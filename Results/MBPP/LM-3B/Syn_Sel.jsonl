{"id": "0_0", "code": "def remove_Occ(s,ch):\n    \"\"\"\n    This function removes the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    \n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if last_occurrence == -1:\n        return s\n    \n    # Remove the first occurrence of the character\n    s = s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the last occurrence of the character\n    s = s[:last_occurrence] + s[last_occurrence + 1:]\n    \n    return s"}
{"id": "1_0", "code": "def sort_matrix(M):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        M (list of lists): A 2D list representing the matrix.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    # Calculate the sum of each row and store it in a list of tuples\n    row_sums = [(sum(row), row) for row in M]\n\n    # Sort the list of tuples based on the sum of each row\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows from the list of tuples\n    sorted_M = [row for _, row in sorted_row_sums]\n\n    return sorted_M"}
{"id": "2_0", "code": "from collections import Counter\nimport re\n\ndef count_common(words):\n    # Convert all words to lower case and remove punctuation\n    cleaned_words = [re.sub(r'[^\\w\\s]', '', word).lower() for word in words]\n    \n    # Count the frequency of each word\n    word_counts = Counter(cleaned_words)\n    \n    # Get the most common words and their counts\n    common_words = word_counts.most_common(10)\n    \n    return common_words"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    \"\"\"\n    This function calculates the volume of a triangular prism.\n\n    Parameters:\n    l (float): The length of the prism.\n    b (float): The base of the prism.\n    h (float): The height of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the base triangle\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        list: A list of strings split at lowercase letters.\n    \"\"\"\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n            current_word += char\n        else:\n            current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "def text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an empty string to store the current sequence\n    current_sequence = \"\"\n    \n    # Iterate over each character in the input string\n    for char in text:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # If the character is a lowercase letter, add it to the current sequence\n            current_sequence += char\n        else:\n            # If the character is not a lowercase letter, check if the current sequence is not empty\n            if current_sequence:\n                # If the current sequence is not empty, add it to the result list\n                result.append(current_sequence)\n                # Reset the current sequence\n                current_sequence = \"\"\n    \n    # After iterating over all characters, check if the current sequence is not empty\n    if current_sequence:\n        # If the current sequence is not empty, add it to the result list\n        result.append(current_sequence)\n    \n    # Return the result list\n    return result"}
{"id": "6_0", "code": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Args:\n        a (float): The length of one side of the square.\n\n    Returns:\n        float: The perimeter of the square.\n    \"\"\"\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = 4 * a\n    return perimeter"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The original string.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters removed.\n    \"\"\"\n    # Convert the second string to a set for efficient lookups\n    dirty_chars = set(second_string)\n    \n    # Use a list comprehension to filter out characters in the first string\n    # that are present in the set of dirty characters\n    filtered_chars = [char for char in string if char not in dirty_chars]\n    \n    # Join the filtered characters back into a string\n    cleaned_string = ''.join(filtered_chars)\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    return len(arraynums) != len(set(arraynums))"}
{"id": "9_0", "code": "def is_woodall(x):\n    \"\"\"\n    Checks if the given number is woodall or not.\n    \n    A woodall number is a number that is the sum of its own digits raised to the power of their respective positions in the number.\n    \n    Parameters:\n    x (int): The number to check.\n    \n    Returns:\n    bool: True if the number is woodall, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_x = str(x)\n    \n    # Initialize a variable to store the sum of the digits raised to their positions\n    total = 0\n    \n    # Iterate over each digit in the number\n    for i, digit in enumerate(str_x):\n        # Add the digit raised to its position to the total\n        total += int(digit) ** (i + 1)\n    \n    # Check if the total is equal to the original number\n    return total == x"}
{"id": "10_0", "code": "def multiples_of_num(m,n):\n    \"\"\"\n    This function generates m number of multiples of n.\n    \n    Parameters:\n    m (int): The number of multiples to generate.\n    n (int): The number for which multiples are to be generated.\n    \n    Returns:\n    list: A list of m number of multiples of n.\n    \"\"\"\n    # Initialize an empty list to store the multiples\n    multiples = []\n    \n    # Loop through the range from 1 to m+1 (to include m)\n    for i in range(1, m+1):\n        # Calculate the multiple of n\n        multiple = n * i\n        # Append the multiple to the list\n        multiples.append(multiple)\n    \n    # Return the list of multiples\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    \"\"\"\n    This function finds the first duplicate element in a given array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first duplicate element if found, otherwise -1.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize max_sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Calculate the sum of the current sublist\n        sublist_sum = sum(sublist)\n        \n        # Update max_sum if the sum of the current sublist is greater\n        max_sum = max(max_sum, sublist_sum)\n    \n    # Return the maximum sum found\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    This function converts a binary number to its decimal equivalent.\n\n    Args:\n        binary (str): A string of binary digits (0s and 1s).\n\n    Returns:\n        int: The decimal equivalent of the given binary number.\n\n    Raises:\n        ValueError: If the input string contains characters other than 0 and 1.\n    \"\"\"\n    # Check if the input string contains only 0s and 1s\n    if not set(binary).issubset({'0', '1'}):\n        raise ValueError(\"Invalid binary number. It should only contain 0s and 1s.\")\n\n    # Initialize the decimal number to 0\n    decimal = 0\n\n    # Iterate over the binary number from right to left\n    for i, bit in enumerate(reversed(binary)):\n        # If the current bit is 1, add 2^i to the decimal number\n        if bit == '1':\n            decimal += 2 ** i\n\n    return decimal"}
{"id": "14_0", "code": "def find_Product(arr,n):\n    # Create a frequency dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize product variable to 1\n    product = 1\n\n    # Iterate through the frequency dictionary\n    for key, value in freq_dict.items():\n        # If the frequency is 1, multiply the product by the element\n        if value == 1:\n            product *= key\n\n    # Return the product\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    \"\"\"\n    This function checks if the given tuple list has all k elements.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to check for.\n\n    Returns:\n        bool: True if the list has all k elements, False otherwise.\n    \"\"\"\n    # Check if the input test_list is a list\n    if not isinstance(test_list, list):\n        raise TypeError(\"Input test_list must be a list.\")\n    \n    # Check if the input K is an integer\n    if not isinstance(K, int):\n        raise TypeError(\"Input K must be an integer.\")\n    \n    # Check if the input K is positive\n    if K <= 0:\n        raise ValueError(\"Input K must be a positive integer.\")\n    \n    # Check if all elements in the test_list are tuples\n    if not all(isinstance(element, tuple) for element in test_list):\n        raise TypeError(\"All elements in the test_list must be tuples.\")\n    \n    # Check if all tuples in the test_list have the same length\n    if not all(len(element) == K for element in test_list):\n        raise ValueError(\"All tuples in the test_list must have the same length.\")\n    \n    # Check if the length of the test_list is equal to the number of tuples\n    if len(test_list) != len(set(tuple(element) for element in test_list)):\n        raise ValueError(\"The length of the test_list must be equal to the number of tuples.\")\n    \n    # If all checks pass, return True\n    return True"}
{"id": "16_0", "code": "def remove(lst):\n    \"\"\"\n    This function removes all digits from a list of strings.\n\n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        list: A list of strings with all digits removed.\n    \"\"\"\n    return [''.join(filter(str.isalpha, s)) for s in lst]"}
{"id": "17_0", "code": "import math\n\ndef binomial_Coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k)\n    \n    Parameters:\n    n (int): The total number of items\n    k (int): The number of items to choose\n    \n    Returns:\n    int: The binomial coefficient (n choose k)\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    return int(result)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    count_dict = {}\n    for i in range(arr_size):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n    for key, value in count_dict.items():\n        if value % 2 != 0:\n            return key\n    return None"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "import heapq\nfrom collections import Counter\n\ndef func(nums, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Count the frequency of each integer\n    freq_count = Counter(flat_list)\n    \n    # Use a heap queue to find the top k integers\n    top_k = heapq.nlargest(k, freq_count.keys(), key=freq_count.get)\n    \n    return top_k"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_prime = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            max_prime = max(max_prime, i)\n    return max_prime"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    \"\"\"\n    This function converts a decimal number to binary number.\n\n    Parameters:\n    N (int): The decimal number to be converted.\n\n    Returns:\n    str: The binary representation of the decimal number.\n\n    Raises:\n    TypeError: If the input is not an integer.\n    ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(N, int):\n        raise TypeError(\"Input must be an integer.\")\n    if N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Convert the decimal number to binary using built-in bin() function\n    binary = bin(N)\n\n    # Remove the '0b' prefix from the binary string\n    binary = binary[2:]\n\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar,N):\n    \"\"\"\n    This function finds the missing number in a sorted array.\n    \n    Parameters:\n    ar (list): A sorted list of integers.\n    N (int): The total number of elements in the array.\n    \n    Returns:\n    int: The missing number in the array.\n    \"\"\"\n    # Check if the array is empty\n    if not ar:\n        return 1\n    \n    # Iterate over the array\n    for i in range(len(ar)):\n        # If the current element is not equal to its index plus one, \n        # it means the missing number is in the range [i+1, ar[i]+1]\n        if ar[i] != i + 1:\n            # Return the missing number\n            return i + 1\n    \n    # If the loop completes without finding a missing number, \n    # it means the missing number is in the range [N, N+1]\n    return N + 1"}
{"id": "24_0", "code": "def find_rect_num(n):\n    \"\"\"\n    This function calculates the n-th rectangular number.\n\n    Args:\n        n (int): The position of the rectangular number to be found.\n\n    Returns:\n        int: The n-th rectangular number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n\n    # Initialize the first rectangular number\n    rect_num = 1\n\n    # Calculate the n-th rectangular number\n    for i in range(1, n + 1):\n        rect_num = rect_num * (i + 1)\n\n    return rect_num"}
{"id": "25_0", "code": "from fractions import Fraction\n\ndef find_Nth_Digit(p, q, N):\n    # Convert the input numbers to fractions\n    frac_p = Fraction(p).limit_denominator()\n    frac_q = Fraction(q).limit_denominator()\n\n    # Calculate the least common multiple (LCM) of the denominators\n    lcm = frac_p.denominator * frac_q.denominator // gcd(frac_p.denominator, frac_q.denominator)\n\n    # Initialize the result\n    result = \"\"\n\n    # Iterate over the range from 0 to N-1\n    for i in range(N):\n        # Calculate the numerator of the current digit\n        numerator = (frac_p.numerator * (lcm // frac_p.denominator)) + (frac_q.numerator * (lcm // frac_q.denominator))\n\n        # Calculate the digit at the current position\n        digit = (numerator // lcm) % 10\n\n        # Append the digit to the result\n        result += str(digit)\n\n    # Return the Nth digit\n    return result[N-1]"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a given mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing a mix of integers and strings.\n\n    Returns:\n        list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the integers and strings separately\n    integers.sort()\n    strings.sort()\n\n    # Combine the sorted integers and strings into a single list\n    sorted_list = integers + strings\n\n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Separate even and odd numbers\n    even_numbers = [num for num in list1 if num % 2 == 0]\n    odd_numbers = [num for num in list1 if num % 2 != 0]\n\n    # Check if there are at least two numbers in each list\n    if len(even_numbers) < 2 or len(odd_numbers) < 2:\n        return \"Not enough numbers to divide\"\n\n    # Calculate the division of the first even and odd numbers\n    first_even = even_numbers[0]\n    first_odd = odd_numbers[0]\n    division = first_even / first_odd\n\n    return division"}
{"id": "28_0", "code": "from collections import Counter\n\ndef rearange_string(S):\n    # Count the frequency of each character in the string\n    char_count = Counter(S)\n    \n    # Sort the characters by their frequency in descending order\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    \n    # Initialize the result string and a temporary string\n    result = ''\n    temp = ''\n    \n    # Iterate over the sorted characters\n    for char, count in sorted_chars:\n        # If the temporary string is not empty and the last character is the same as the current character\n        if temp and temp[-1] == char:\n            # If the result string is not empty and the last character is the same as the current character\n            if result and result[-1] == char:\n                # Return False because two characters that are adjacent to each other are the same\n                return False\n            # If the result string is empty or the last character is different from the current character\n            elif not result or result[-1] != char:\n                # Add the current character to the result string\n                result += char\n            # Add the current character to the temporary string\n            temp += char\n        else:\n            # Add the current character to the result string\n            result += char\n            # Reset the temporary string\n            temp = ''\n    \n    # If the temporary string is not empty, add its characters to the result string\n    if temp:\n        result += temp\n    \n    # Return True if the result string is not empty and all characters are used\n    return result and len(result) == len(S)"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    \"\"\"\n    This function calculates the frequency of each element in a given list of lists.\n    \n    Parameters:\n    nums (list): A list of lists containing elements.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list of lists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq_dict = Counter(flat_list)\n    \n    return dict(freq_dict)"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr,n):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through the array to count the frequency of each element\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n    \n    # Initialize a variable to store the sum of repeated elements\n    sum_repeated = 0\n    \n    # Iterate through the dictionary to find the sum of repeated elements\n    for key, value in freq_dict.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    # Return the sum of repeated elements\n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    \"\"\"\n    This function checks if a word is at the beginning of a given string.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the word is at the beginning of the string, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    text = text.strip()\n    \n    # Split the string into words\n    words = text.split()\n    \n    # Check if the string is not empty\n    if not words:\n        return False\n    \n    # Check if the first word is at the beginning of the string\n    return words[0] == text"}
{"id": "34_0", "code": "import math\n\ndef get_gcd(lst):\n    \"\"\"\n    This function calculates the greatest common divisor (gcd) of all elements in the given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The greatest common divisor of all elements in the list.\n    \"\"\"\n    # Initialize the gcd with the first element of the list\n    result = lst[0]\n    \n    # Iterate over the rest of the list\n    for num in lst[1:]:\n        # Update the gcd using the Euclidean algorithm\n        result = math.gcd(result, num)\n    \n    # Return the final gcd\n    return result"}
{"id": "35_0", "code": "def test_distinct(data):\n    \"\"\"\n    This function checks if all numbers in the input data are distinct.\n\n    Args:\n        data (list): A list of numbers.\n\n    Returns:\n        bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    distinct_set = set(data)\n    \n    # Compare the length of the original list with the length of the set\n    # If they are equal, it means all numbers were distinct\n    return len(data) == len(distinct_set)"}
{"id": "36_0", "code": "import math\n\ndef compute_Last_Digit(A,B):\n    # Calculate the factorial of A and B\n    fact_A = math.factorial(A)\n    fact_B = math.factorial(B)\n    \n    # Calculate the remainder of fact_B divided by fact_A\n    remainder = fact_B % fact_A\n    \n    # Return the last digit of the remainder\n    return remainder % 10\n\n# Test the function\nprint(compute_Last_Digit(5,10))"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Create a mask to set odd bits\n    mask = (1 << n.bit_length()) - 1\n    \n    # Use bitwise OR operation to set odd bits\n    result = n | mask\n    \n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every first or specified element from a given two-dimensional list.\n\n    Args:\n        nums (list): A two-dimensional list of integers.\n        N (int): The position of the element to extract (1-indexed).\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    extracted_elements = []\n    for i, sub_list in enumerate(nums):\n        if i == 0 or N <= len(sub_list):\n            extracted_elements.append(sub_list[0])\n        else:\n            extracted_elements.append(sub_list[N - 1])\n    return extracted_elements"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=len)"}
{"id": "40_0", "code": "def check_equilateral(x,y,z):\n    # Check if all sides are equal\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b,h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n\n    Parameters:\n    str (str): The input string to be checked.\n\n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is not empty\n    if len(str) == 0:\n        return False  # Return False for empty string\n\n    # Get the first and last characters of the string\n    first_char = str[0]\n    last_char = str[-1]\n\n    # Compare the first and last characters\n    return first_char == last_char"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    max_val = max(my_list)\n    min_val = min(my_list)\n    count = [0] * (max_val - min_val + 1)\n    for num in my_list:\n        count[num - min_val] += 1\n    sorted_list = []\n    for i, cnt in enumerate(count):\n        sorted_list.extend([i + min_val] * cnt)\n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a, n, r):\n    \"\"\"\n    Calculate the t-nth term of a geometric series.\n\n    Parameters:\n    a (float): First term of the series\n    n (int): Term number to calculate\n    r (float): Common ratio of the series\n\n    Returns:\n    float: t-nth term of the geometric series\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (r ** (n - 1))"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to easily reverse it\n    str_n = str(n)\n    \n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    \n    # Check if the number is one less than twice its reverse\n    if n == 2 * reversed_n - 1:\n        return True\n    else:\n        return False"}
{"id": "46_0", "code": "def find_Max_Num(arr, n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Join the sorted array into a string\n    max_num_str = ''.join(map(str, arr))\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x,y):\n    \"\"\"\n    This function checks whether two given integers have opposite sign or not.\n    \n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    \n    Returns:\n    bool: True if the integers have opposite sign, False otherwise.\n    \"\"\"\n    # Check if the product of the two integers is negative\n    # If it is, then the integers have opposite sign\n    return x * y < 0"}
{"id": "48_0", "code": "def is_octagonal(n):\n    \"\"\"\n    Checks if a number is an octagonal number.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is an octagonal number, False otherwise.\n    \"\"\"\n    # Calculate the nth octagonal number\n    octagonal_num = (8 * n * (n + 1)) // 2\n    \n    # Check if the number is equal to the calculated octagonal number\n    return n == octagonal_num\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    Calculates the nth octagonal number.\n\n    Args:\n        n (int): The position of the octagonal number to calculate.\n\n    Returns:\n        int: The nth octagonal number.\n    \"\"\"\n    # Calculate the nth octagonal number using the formula\n    return (8 * n * (n + 1)) // 2\n\n# Example usage:\nprint(is_octagonal(1))  # Output: True\nprint(is_octagonal(2))  # Output: False\nprint(nth_octagonal_number(1))  # Output: 1\nprint(nth_octagonal_number(2))  # Output: 6"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    \"\"\"\n    This function calculates the maximum length of the subsequence with difference \n    between adjacent elements for the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The maximum length of the subsequence.\n    \"\"\"\n    # Initialize a list to store the maximum length of subsequence ending at each position\n    max_len = [1] * n\n\n    # Initialize the maximum length of subsequence\n    max_val = 1\n\n    # Iterate over the array\n    for i in range(1, n):\n        # Iterate from the first element to the current element\n        for j in range(i):\n            # If the difference between the current element and the previous element is 1\n            if abs(arr[i] - arr[j]) == 1:\n                # Update the maximum length of subsequence ending at the current position\n                max_len[i] = max(max_len[i], max_len[j] + 1)\n        # Update the maximum length of subsequence\n        max_val = max(max_val, max_len[i])\n\n    # Return the maximum length of subsequence\n    return max_val"}
{"id": "50_0", "code": "def count_Substrings(s,n):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    \"\"\"\n    Returns the smallest number in the list xs.\n\n    Args:\n        xs (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the list is empty.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List is empty\")\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    \"\"\"\n    This function calculates the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        int: The maximum difference between available pairs.\n    \"\"\"\n    # Initialize the maximum difference as negative infinity\n    max_diff = float('-inf')\n\n    # Iterate over each tuple in the list\n    for i in range(len(test_list)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(test_list)):\n            # Calculate the difference between the current pair of tuples\n            diff = abs(test_list[i][0] - test_list[j][0]) + abs(test_list[i][1] - test_list[j][1])\n            # Update the maximum difference if the current difference is greater\n            max_diff = max(max_diff, diff)\n\n    # Return the maximum difference\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_subject_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subject_marks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    \"\"\"\n    This function calculates the sum of all elements in a list using recursion.\n    \n    Args:\n        data_list (list): A list of numbers.\n    \n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    # Base case: If the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: Add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    \"\"\"\n    This function counts the number of positive numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The count of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize the list to store bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1\n\n    # Calculate the first few bell numbers\n    for i in range(1, n + 1):\n        bell[i] = sum(bell[j] for j in range(i))\n\n    return bell[n]"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    # Check if the array is empty\n    if len(A) == 0:\n        return True  # An empty array is considered monotonic\n\n    # Check if the array is monotonic from left to right\n    increasing = decreasing = True\n    for i in range(len(A) - 1):\n        if A[i] > A[i + 1]:\n            increasing = False\n        if A[i] < A[i + 1]:\n            decreasing = False\n\n    # Return True if the array is monotonic in either direction\n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    \"\"\"\n    Checks if list l contains the given sublist s.\n\n    Args:\n        l (list): The list to search in.\n        s (list): The sublist to search for.\n\n    Returns:\n        bool: True if l contains s, False otherwise.\n    \"\"\"\n    # Check if the sublist is empty\n    if not s:\n        return True  # An empty list is a sublist of any list\n\n    # Iterate over the list with a sliding window of the same length as the sublist\n    for i in range(len(l) - len(s) + 1):\n        # Check if the current window matches the sublist\n        if l[i:i+len(s)] == s:\n            return True  # If it matches, return True\n\n    # If no match is found, return False\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    \"\"\"\n    This function checks if all the given tuples have equal length.\n\n    Args:\n        Input (list): A list of tuples.\n        k (int): The length to compare with.\n\n    Returns:\n        bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(Input, list):\n        raise ValueError(\"Input must be a list of tuples\")\n\n    # Check if all elements in the list are tuples\n    if not all(isinstance(x, tuple) for x in Input):\n        raise ValueError(\"All elements in the list must be tuples\")\n\n    # Check if all tuples have the same length\n    return len(set(len(t) for t in Input)) == 1"}
{"id": "60_0", "code": "def comb_sort(nums):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements.\n    \"\"\"\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    \"\"\"\n    Checks if a number can be represented as difference of two squares.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number can be represented as difference of two squares, False otherwise.\n    \"\"\"\n    i = 1\n    while i * i <= n:\n        # Check if n can be represented as difference of two squares\n        if (i * i) - n == (i + 1) * (i + 1):\n            return True\n        i += 1\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define the delimiters\n    delimiters = [\",\", \".\", \"!\", \"?\", \";\", \":\", \"'\", \"\\\"\", \"\\n\", \"\\t\"]\n    \n    # Escape special characters in delimiters\n    escaped_delimiters = [re.escape(d) for d in delimiters]\n    \n    # Join delimiters into a single string\n    delimiter_string = \"\".join(escaped_delimiters)\n    \n    # Use regex to split the text\n    split_text = re.split(delimiter_string, text)\n    \n    # Remove empty strings from the result\n    split_text = [s for s in split_text if s != '']\n    \n    return split_text"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks whether the given colors follow the sequence given in the patterns array.\n\n    Args:\n        colors (list): A list of colors.\n        patterns (list): A list of patterns.\n\n    Returns:\n        bool: True if the colors follow the patterns, False otherwise.\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    \"\"\"\n    This function finds tuples in the given list that have all elements divisible by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The divisor.\n\n    Returns:\n        list: A list of tuples where all elements are divisible by K.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over each tuple in the test list\n    for tup in test_list:\n        # Assume all elements in the tuple are divisible by K\n        all_divisible = True\n\n        # Iterate over each element in the tuple\n        for elem in tup:\n            # If any element is not divisible by K, set the flag to False\n            if elem % K != 0:\n                all_divisible = False\n                break\n\n        # If all elements are divisible by K, add the tuple to the result\n        if all_divisible:\n            result.append(tup)\n\n    # Return the result\n    return result"}
{"id": "65_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # m is the number of rows\n    # n is the number of columns\n    # The number of squares is equal to the number of rows times the number of columns\n    return m * n"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize variables to store the sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each character (digit) in the string\n    for digit in str_n:\n        # Convert the character back into an integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd and add to the corresponding sum\n        if int_digit % 2 == 0:\n            even_sum += int_digit\n        else:\n            odd_sum += int_digit\n    \n    # Calculate the difference between the sum of even and odd digits\n    diff = abs(even_sum - odd_sum)\n    \n    # Return the difference\n    return diff"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(n + 1):\n        # Calculate the number of set bits in i\n        set_bits = bin(i).count('1')\n        # If the number of set bits is odd, increment the count\n        if set_bits % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    \"\"\"\n    This function checks whether the length of the word is odd or not.\n\n    Parameters:\n    s (str): The input word.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(s) % 2 != 0"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    The nth tetrahedral number is the number of ways to choose 4 elements from a set of n elements.\n\n    Args:\n        n (int): The position of the tetrahedral number to calculate.\n\n    Returns:\n        int: The nth tetrahedral number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Calculate the nth tetrahedral number using the formula: n*(n+1)*(n+2)/6\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple with the elements from the input tuples zipped together.\n    \n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n    \n    Returns:\n        tuple: A new tuple with the elements from the input tuples zipped together.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The two tuples must have the same length.\")\n    \n    # Use the built-in zip function to zip the two tuples\n    zipped_tup = zip(test_tup1, test_tup2)\n    \n    # Convert the zipped tuple to a list\n    zipped_list = list(zipped_tup)\n    \n    # Return the zipped list\n    return zipped_list"}
{"id": "71_0", "code": "import math\n\ndef volume_sphere(r):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Args:\n        r (float): The radius of the sphere.\n\n    Returns:\n        float: The volume of the sphere.\n    \"\"\"\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    volume = (4/3) * math.pi * (r ** 3)\n    return volume"}
{"id": "72_0", "code": "def get_Char(strr):\n    \"\"\"\n    This function calculates the character made by adding all the characters of the given string.\n    \n    Parameters:\n    strr (str): The input string.\n    \n    Returns:\n    str: The character made by adding all the characters of the given string.\n    \"\"\"\n    # Initialize a variable to store the sum of ASCII values\n    ascii_sum = 0\n    \n    # Iterate over each character in the string\n    for char in strr:\n        # Add the ASCII value of the character to the sum\n        ascii_sum += ord(char)\n    \n    # Convert the sum to a character using the chr function\n    generated_char = chr(ascii_sum)\n    \n    # Return the generated character\n    return generated_char"}
{"id": "73_0", "code": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is a sequence of numbers that starts with 1, \n    and each subsequent number is the sum of the previous number and the \n    number of 1's in the binary representation of the previous number.\n    \n    Parameters:\n    n (int): The position of the number in the sequence.\n    \n    Returns:\n    int: The n-th number in the Newman-Conway sequence.\n    \"\"\"\n    def count_ones(num):\n        \"\"\"Count the number of 1's in the binary representation of num.\"\"\"\n        return bin(num).count('1')\n    \n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    sequence = [1]\n    for _ in range(n - 1):\n        last_num = sequence[-1]\n        ones = count_ones(last_num)\n        next_num = last_num + ones\n        sequence.append(next_num)\n    \n    return sequence[-1]"}
{"id": "74_0", "code": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    \"\"\"\n    Returns the nth centered hexagonal number.\n\n    A centered hexagonal number is a figurate number that represents a hexagonal shape with a center point.\n    It is calculated as the sum of the first n natural numbers, multiplied by the number of sides of the hexagon (6),\n    and then subtracted by the sum of the first n natural numbers.\n\n    Args:\n        n (int): The position of the centered hexagonal number to find.\n\n    Returns:\n        int: The nth centered hexagonal number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Calculate the sum of the first n natural numbers\n    sum_natural_numbers = n * (n + 1) // 2\n\n    # Calculate the nth centered hexagonal number\n    centered_hexagonal = 6 * sum_natural_numbers - n * (n + 1)\n\n    return centered_hexagonal"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1,dict2, dict3):\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy all key-value pairs from dict1 to merged_dict\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    \n    # Copy all key-value pairs from dict2 to merged_dict\n    for key, value in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    # Copy all key-value pairs from dict3 to merged_dict\n    for key, value in dict3.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    \"\"\"\n    This function calculates the frequency of each element in a given list.\n\n    Args:\n        list1 (list): A list of elements.\n\n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for element in list1:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict"}
{"id": "78_0", "code": "def closest_num(N):\n    \"\"\"\n    This function finds the closest smaller number than N.\n    \n    Parameters:\n    N (int): The input number.\n    \n    Returns:\n    int: The closest smaller number than N.\n    \"\"\"\n    # Initialize the lower and upper bounds\n    low = N - 1\n    high = N\n    \n    # Continue the loop until low and high meet\n    while low >= 0:\n        # Calculate the middle value\n        mid = (low + high) // 2\n        \n        # If mid is smaller than N, update low\n        if mid < N:\n            low = mid\n        # If mid is not smaller than N, update high\n        else:\n            high = mid - 1\n    \n    # After the loop, low will be the closest smaller number than N\n    return low"}
{"id": "79_0", "code": "def len_log(list1):\n    \"\"\"\n    This function finds the length of the longest word in a given list.\n\n    Args:\n        list1 (list): A list of words.\n\n    Returns:\n        int: The length of the longest word in the list.\n    \"\"\"\n    # Check if the list is empty\n    if not list1:\n        return 0\n\n    # Initialize the maximum length to 0\n    max_length = 0\n\n    # Iterate over each word in the list\n    for word in list1:\n        # Calculate the length of the current word\n        length = len(word)\n        \n        # If the length of the current word is greater than the max_length, update max_length\n        if length > max_length:\n            max_length = length\n\n    # Return the maximum length\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    \"\"\"\n    This function checks if a substring is present in a given list of string values.\n\n    Parameters:\n    str1 (list): A list of string values.\n    sub_str (str): The substring to be searched.\n\n    Returns:\n    bool: True if the substring is found, False otherwise.\n    \"\"\"\n    # Iterate over each string in the list\n    for string in str1:\n        # Check if the substring is present in the current string\n        if sub_str in string:\n            # If found, return True\n            return True\n    # If the substring is not found in any string, return False\n    return False"}
{"id": "81_0", "code": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a variable to store the difference between the first and last digits\n    diff = abs(int(str_n[0]) - int(str_n[-1]))\n    \n    # Iterate over the digits in the middle of the number\n    for i in range(1, len(str_n) - 1):\n        # If the difference between the current digit and the next digit is not equal to the difference between the first and last digits, return False\n        if abs(int(str_n[i]) - int(str_n[i + 1])) != diff:\n            return False\n    \n    # If the function hasn't returned False, the number is undulating, so return True\n    return True"}
{"id": "82_0", "code": "def power(a,b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Args:\n        a (float): The base number.\n        b (int): The exponent.\n\n    Returns:\n        float: The result of a to the power b.\n    \"\"\"\n    return a ** b"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    \"\"\"\n    This function takes a list of tuples as input, where each tuple contains a value and its index.\n    It returns the index and minimum value of the tuple with the smallest value.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains a value and its index.\n\n    Returns:\n        tuple: A tuple containing the index and minimum value of the tuple with the smallest value.\n    \"\"\"\n    # Check if the input list is empty\n    if not test_list:\n        return None\n\n    # Initialize the minimum value and its index with the first element of the list\n    min_value = test_list[0][0]\n    min_index = test_list[0][1]\n\n    # Iterate over the list of tuples\n    for value, index in test_list:\n        # Check if the current value is smaller than the minimum value found so far\n        if value < min_value:\n            # Update the minimum value and its index\n            min_value = value\n            min_index = index\n\n    # Return the index and minimum value of the tuple with the smallest value\n    return (min_index, min_value)"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    \"\"\"\n    This function finds the minimum length of a sublist in a given list.\n    \n    Parameters:\n    lst (list): The input list.\n    \n    Returns:\n    int: The minimum length of a sublist.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = float('inf')\n    \n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            min_length = min(min_length, len(sublist))\n    \n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    \"\"\"\n    This function calculates the frequency count of each sublist in a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        dict: A dictionary where keys are sublists and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency count of sublists\n    freq_dict = {}\n\n    # Iterate over each sublist in the given list\n    for sublist in list1:\n        # Convert the sublist to a tuple (because lists are not hashable) and use it as a key\n        # If the key already exists, increment its value; otherwise, set its value to 1\n        freq_dict[tuple(sublist)] = freq_dict.get(tuple(sublist), 0) + 1\n\n    # Return the dictionary containing the frequency count of sublists\n    return freq_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    \"\"\"\n    This function multiplies all the numbers in a list and divides the result by the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of the multiplication and division.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list is empty.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Check if the list is not empty\n    if len(numbers) == 0:\n        raise ValueError(\"List cannot be empty.\")\n\n    # Initialize the product variable to 1\n    product = 1\n\n    # Iterate over each number in the list\n    for num in numbers:\n        # Multiply the product by the current number\n        product *= num\n\n    # Divide the product by the length of the list\n    result = product / len(numbers)\n\n    # Return the result\n    return result"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    \"\"\"\n    This function converts a decimal number to its binary equivalent.\n\n    Args:\n        n (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary representation of the decimal number.\n    \"\"\"\n    return bin(n)[2:]"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    \"\"\"\n    This function finds the kth element in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The position of the element to be found.\n\n    Returns:\n    int: The kth element in the array if it exists, otherwise -1.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k < 1 or k > n:\n        return -1\n    \n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Return the kth element\n    return arr[k - 1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    \"\"\"\n    Convert snake case string to camel case string.\n\n    Args:\n        word (str): The input snake case string.\n\n    Returns:\n        str: The converted camel case string.\n    \"\"\"\n    words = word.split('_')\n    return words[0] + ''.join(word.capitalize() for word in words[1:])"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    m (int): The number of elements to choose.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    # Initialize the result\n    result = 0\n\n    # Calculate the Eulerian number using the formula\n    for i in range(m + 1):\n        # Calculate the binomial coefficient\n        binom_coeff = math.comb(n, i)\n        # Update the result\n        result += binom_coeff * (m - i) ** i\n\n    return result"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    return sorted(input_list, key=lambda x: sorted(x))"}
{"id": "94_0", "code": "def count(lst):\n    \"\"\"\n    This function counts the number of true booleans in a given list.\n\n    Args:\n        lst (list): A list containing boolean values.\n\n    Returns:\n        int: The number of true booleans in the list.\n    \"\"\"\n    return sum(1 for bool_val in lst if bool_val)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    \"\"\"\n    This function adds the given list to the given tuple.\n    \n    Args:\n        test_list (list): The list to be added.\n        test_tup (tuple): The tuple to which the list will be added.\n    \n    Returns:\n        tuple: A new tuple containing the original tuple and the list.\n    \"\"\"\n    # Convert the tuple to a list\n    test_tup_list = list(test_tup)\n    \n    # Add the list to the list\n    test_tup_list.extend(test_list)\n    \n    # Convert the list back to a tuple\n    result = tuple(test_tup_list)\n    \n    return result"}
{"id": "96_0", "code": "def count_Hexadecimal(L,R):\n    \"\"\"\n    This function counts the number of hexadecimal numbers in a given range.\n\n    Parameters:\n    L (int): The lower bound of the range (inclusive).\n    R (int): The upper bound of the range (inclusive).\n\n    Returns:\n    int: The number of hexadecimal numbers in the range [L, R].\n    \"\"\"\n    count = 0\n    for i in range(L, R+1):\n        # Convert the number to hexadecimal and check if it's a hexadecimal number\n        hex_num = hex(i)[2:]  # Remove the '0x' prefix\n        if all(c in '0123456789abcdefABCDEF' for c in hex_num):\n            count += 1\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a min heap to store the elements from the input lists\n    min_heap = []\n    \n    # Push the first element from each list into the heap\n    # We use a tuple to store the value, list index, and element index\n    # This allows us to keep track of which list and element we're currently at\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 0, 0))\n    heapq.heappush(min_heap, (num3[0], 0, 0))\n    \n    # Initialize an empty list to store the merged sorted elements\n    merged_list = []\n    \n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, list_idx, elem_idx = heapq.heappop(min_heap)\n        \n        # Add the popped element to the merged list\n        merged_list.append(val)\n        \n        # If there are more elements in the list we're currently at\n        if elem_idx + 1 < len(num1) and (not merged_list or val > num1[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num1[elem_idx + 1], list_idx, elem_idx + 1))\n        if elem_idx + 1 < len(num2) and (not merged_list or val > num2[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num2[elem_idx + 1], list_idx, elem_idx + 1))\n        if elem_idx + 1 < len(num3) and (not merged_list or val > num3[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num3[elem_idx + 1], list_idx, elem_idx + 1))\n    \n    # Return the merged sorted list\n    return merged_list"}
{"id": "98_0", "code": "def odd_Equivalent(s,n):\n    # Convert the binary string to an integer\n    num = int(s, 2)\n    \n    # Calculate the remainder of the number when divided by 2^n\n    remainder = num % (2 ** n)\n    \n    # Check if the remainder is odd\n    if remainder % 2 != 0:\n        return 1\n    else:\n        return 0"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    \"\"\"\n    This function takes a list of integers and two range values as input.\n    It returns a list of integers that are missing from the given list within the specified range.\n\n    Args:\n        test_list (list): A list of integers.\n        strt_val (int): The start value of the range.\n        stop_val (int): The end value of the range.\n\n    Returns:\n        list: A list of missing integers within the specified range.\n    \"\"\"\n    # Sort the test list in ascending order\n    test_list.sort()\n\n    # Initialize an empty list to store the missing numbers\n    missing_nums = []\n\n    # Iterate over the range from strt_val to stop_val (inclusive)\n    for num in range(strt_val, stop_val + 1):\n        # Check if the number is not in the test list\n        if num not in test_list:\n            # If the number is not in the test list, add it to the missing_nums list\n            missing_nums.append(num)\n\n    # Return the list of missing numbers\n    return missing_nums"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Flatten the nested list\n    flat_list = flatten(nestedlist)\n    \n    # Find common elements with the original list\n    common_elements = set(flat_list) & set(nestedlist)\n    \n    return list(common_elements)"}
{"id": "101_0", "code": "import math\n\ndef perimeter(diameter, height):\n    \"\"\"\n    Calculate the perimeter of a cylinder.\n\n    Parameters:\n    diameter (float): The diameter of the cylinder's base.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The perimeter of the cylinder.\n    \"\"\"\n    # Calculate the radius from the diameter\n    radius = diameter / 2\n    \n    # Calculate the circumference of the base\n    base_circumference = 2 * math.pi * radius\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = 2 * math.pi * radius * height\n    \n    # Calculate the total perimeter\n    total_perimeter = base_circumference + lateral_surface_area\n    \n    return total_perimeter"}
{"id": "102_0", "code": "def check_integer(text):\n    \"\"\"\n    Checks if a given string represents an integer or not.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    text = text.strip()\n    \n    # Check if the string is empty\n    if not text:\n        return False\n    \n    # Check if the string starts with a negative sign\n    if text[0] == '-':\n        # If the string starts with a negative sign, remove it\n        text = text[1:]\n        \n        # Check if the remaining string is empty\n        if not text:\n            return False\n    \n    # Check if the string contains any non-digit characters\n    if not text.isdigit():\n        return False\n    \n    # If all checks pass, the string represents an integer\n    return True"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    \"\"\"\n    Assign frequency to each tuple in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        dict: A dictionary where keys are tuples and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    \"\"\"\n    This function checks whether all dictionaries in a list are empty or not.\n\n    Args:\n        list1 (list): A list of dictionaries.\n\n    Returns:\n        bool: True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Check if all elements in the list are dictionaries\n    if not all(isinstance(item, dict) for item in list1):\n        raise TypeError(\"All elements in the list must be dictionaries\")\n\n    # Check if all dictionaries in the list are empty\n    return all(len(item) == 0 for item in list1)"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    \"\"\"\n    Converts a tuple of positive integers into an integer.\n\n    Args:\n        nums (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The integer equivalent of the tuple.\n\n    Raises:\n        ValueError: If the tuple contains non-positive integers or non-integer values.\n    \"\"\"\n    # Check if all elements in the tuple are integers\n    if not all(isinstance(num, int) for num in nums):\n        raise ValueError(\"The tuple must only contain integers.\")\n\n    # Check if all elements in the tuple are positive\n    if not all(num > 0 for num in nums):\n        raise ValueError(\"The tuple must only contain positive integers.\")\n\n    # Convert the tuple to a string\n    num_str = ''.join(map(str, nums))\n\n    # Convert the string to an integer\n    result = int(num_str)\n\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    \"\"\"\n    This function takes a list as input, identifies all possible convertible elements (i.e., strings that can be converted to float), \n    and converts them to float. The function returns the modified list.\n\n    Parameters:\n    test_list (list): A list containing elements that can be converted to float.\n\n    Returns:\n    list: The input list with all convertible elements converted to float.\n    \"\"\"\n    # Initialize an empty list to store the converted elements\n    converted_list = []\n    \n    # Iterate over each element in the input list\n    for element in test_list:\n        # Check if the element is a string\n        if isinstance(element, str):\n            # Attempt to convert the string to float\n            try:\n                # Append the converted float to the converted list\n                converted_list.append(float(element))\n            except ValueError:\n                # If the conversion fails, append the original string to the converted list\n                converted_list.append(element)\n        else:\n            # If the element is not a string, append it to the converted list as is\n            converted_list.append(element)\n    \n    # Return the modified list\n    return converted_list"}
{"id": "107_0", "code": "def string_to_list(string):\n    \"\"\"\n    Converts a string into a list of characters.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        list: A list of characters from the input string.\n    \"\"\"\n    return list(string)"}
{"id": "108_0", "code": "def search(arr,n):\n    # Initialize the result variable to None\n    res = None\n    \n    # Iterate through the array\n    for i in range(n):\n        # If the current element is not equal to the next element\n        if i < n - 1 and arr[i] != arr[i + 1]:\n            # If the result is not set, set it to the current element\n            if res is None:\n                res = arr[i]\n            # If the result is already set and it's not equal to the current element\n            elif res != arr[i]:\n                # Return the result\n                return res\n    # If the result is still None, it means the single element is at the end of the array\n    if res is None:\n        res = arr[n - 1]\n    # Return the result\n    return res"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    \"\"\"\n    This function finds the maximum product from the pairs of tuples within a given list.\n    \n    Parameters:\n    list1 (list): A list of tuples.\n    \n    Returns:\n    int: The maximum product from the pairs of tuples.\n    \"\"\"\n    \n    # Initialize max_product as negative infinity\n    max_product = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for i in range(len(list1)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = list1[i][0] * list1[j][0]\n            \n            # Update max_product if the current product is greater\n            max_product = max(max_product, product)\n    \n    # Return the maximum product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    for i in range(n - 2):\n        # Initialize two pointers\n        left = i + 1\n        right = n - 1\n        while left < right:\n            # Calculate the current sum\n            current_sum = A[i] + A[left] + A[right]\n            # If the current sum is equal to the given sum, increment the count and move the pointers\n            if current_sum == sum:\n                count[0] += 1\n                left += 1\n                right -= 1\n            # If the current sum is less than the given sum, move the left pointer to the right\n            elif current_sum < sum:\n                left += 1\n            # If the current sum is greater than the given sum, move the right pointer to the left\n            else:\n                right -= 1\n    return count[0]"}
{"id": "111_0", "code": "def smartNumber(n):\n    \"\"\"\n    This function generates the nth smart number.\n    \n    A smart number is a number that is the sum of its proper divisors, excluding the number itself.\n    \n    Parameters:\n    n (int): The position of the smart number to be generated.\n    \n    Returns:\n    int: The nth smart number.\n    \"\"\"\n    smart_numbers = []\n    num = 1\n    while len(smart_numbers) < n:\n        # Calculate the sum of proper divisors of the current number\n        sum_divisors = sum(i for i in range(1, num) if num % i == 0)\n        \n        # Check if the sum of proper divisors is equal to the current number\n        if sum_divisors == num:\n            # If it is, add the number to the list of smart numbers\n            smart_numbers.append(num)\n        \n        # Move on to the next number\n        num += 1\n    \n    # Return the nth smart number\n    return smart_numbers[-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    \"\"\"\n    This function calculates the sum of all amicable numbers from 1 to a specified limit.\n    \n    An amicable pair consists of two numbers so related that the sum of the proper divisors of each is equal to the other number. \n    For example, 220 and 284 are amicable numbers because the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, and 110, \n    and the sum of these divisors is 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284, while the proper divisors of 284 are 1, 2, 4, 71, and 142, \n    and the sum of these divisors is 1 + 2 + 4 + 71 + 142 = 220.\n    \n    Parameters:\n    limit (int): The upper limit for the amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    \n    # Initialize a dictionary to store the sum of proper divisors for each number\n    sum_of_divisors = {}\n    \n    # Iterate over all numbers from 1 to the limit\n    for num in range(1, limit + 1):\n        # Initialize the sum of proper divisors for the current number\n        sum_of_divisors[num] = 0\n        \n        # Iterate over all numbers from 1 to the current number\n        for i in range(1, num):\n            # Check if the current number is a divisor of the number\n            if num % i == 0:\n                # Add the divisor to the sum of proper divisors\n                sum_of_divisors[num] += i\n        \n        # Subtract the current number from the sum of proper divisors (since it's not a proper divisor)\n        sum_of_divisors[num] -= num\n        \n        # Check if the sum of proper divisors is within the limit and is not equal to the current number\n        if sum_of_divisors[num] <= limit and sum_of_divisors[num] != num:\n            # Check if the sum of proper divisors is already in the dictionary\n            if sum_of_divisors[num] in sum_of_divisors:\n                # Return the sum of the amicable numbers\n                return num + sum_of_divisors[num]\n    \n    # If no amicable numbers are found, return 0\n    return 0"}
{"id": "113_0", "code": "import math\n\ndef angle_complex(a,b):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    # Calculate the angle using the atan2 function\n    angle = math.atan2(b, a)\n    \n    # Return the angle\n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\n    max_diff = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if string[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            max_diff = max(max_diff, abs(zeros - ones))\n    return max_diff"}
{"id": "115_0", "code": "def sum(a,b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n\n    return sum(common_divisors)"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    \"\"\"\n    Multiply two integers without using the * operator.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        int: The product of x and y.\n    \"\"\"\n    if y == 0:\n        return 0\n    elif y < 0:\n        return -multiply_int(x, -y)\n    elif x < 0:\n        return -multiply_int(-x, y)\n    else:\n        result = 0\n        while y > 0:\n            result += x\n            y -= 1\n        return result"}
{"id": "117_0", "code": "def long_words(n, string):\n    \"\"\"\n    This function takes a list of words and a number n as input.\n    It returns a list of words that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to be included in the output list.\n    string (str): The input list of words.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the input string into a list of words\n    words = string.split()\n\n    # Initialize an empty list to store the long words\n    long_word_list = []\n\n    # Iterate over each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If the word is long, add it to the long_word_list\n            long_word_list.append(word)\n\n    # Return the list of long words\n    return long_word_list"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the input matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return \"Error: Input matrix is not a square matrix.\"\n\n    # Check if the input matrix is a magic square\n    if not is_magic_square(my_matrix):\n        return \"Error: Input matrix is not a magic square.\"\n\n    # Calculate the magic constant\n    magic_constant = calculate_magic_constant(my_matrix)\n\n    # Print the magic square\n    print(\"Magic Square:\")\n    for row in my_matrix:\n        print(row)\n\n    # Print the magic constant\n    print(\"Magic Constant:\", magic_constant)\n\n\ndef is_magic_square(my_matrix):\n    # Check if the matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Calculate the sum of each row, column, and diagonal\n    row_sums = [sum(row) for row in my_matrix]\n    col_sums = [sum(col) for col in zip(*my_matrix)]\n    diag_sums = [sum(diag) for diag in [my_matrix[i][i] for i in range(len(my_matrix))] + [my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))]]\n\n    # Check if all sums are equal\n    return len(set(row_sums + col_sums + diag_sums)) == 1\n\n\ndef calculate_magic_constant(my_matrix):\n    # Calculate the sum of the first row\n    magic_constant = sum(my_matrix[0])\n\n    # Return the magic constant\n    return magic_constant"}
{"id": "119_0", "code": "from collections import Counter\n\ndef max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum frequency in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum frequency in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Count the frequency of each item in the list\n    freq = Counter(nums)\n\n    # Find the item with maximum frequency\n    max_freq_item = max(freq, key=freq.get)\n\n    return max_freq_item"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    \"\"\"\n    This function converts a tuple into a string.\n    \n    Parameters:\n    tup1 (tuple): The input tuple to be converted.\n    \n    Returns:\n    str: A string representation of the input tuple.\n    \"\"\"\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(num for num in nums if num < 0)"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    \"\"\"\n    This function checks whether the last element of given array is even or odd after performing an operation p times.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The number of operations to be performed.\n    p (int): The number of times the operation is performed.\n\n    Returns:\n    bool: True if the last element is even after p operations, False otherwise.\n    \"\"\"\n    # Check if the array is empty\n    if not arr:\n        return False\n\n    # Check if the number of operations is greater than the number of elements in the array\n    if p > len(arr):\n        raise ValueError(\"Number of operations cannot be greater than the number of elements in the array\")\n\n    # Perform the operation p times\n    for _ in range(p):\n        # If the last element is even, perform the operation\n        if arr[-1] % 2 == 0:\n            arr[-1] = arr[-1] + 1\n        # If the last element is odd, perform the operation\n        else:\n            arr[-1] = arr[-1] + 2\n\n    # Check if the last element is even\n    return arr[-1] % 2 == 0"}
{"id": "124_0", "code": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    The nth hexagonal number is the number of dots that make up the nth hexagonal number.\n    It is calculated using the formula: Hn = 3n^2 - 3n + 1.\n\n    Args:\n        n (int): The position of the hexagonal number to calculate.\n\n    Returns:\n        int: The nth hexagonal number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return 3 * n ** 2 - 3 * n + 1"}
{"id": "125_0", "code": "def cal_electbill(units):\n    \"\"\"\n    Calculate electricity bill based on the number of units consumed.\n\n    Args:\n        units (float): The number of units consumed.\n\n    Returns:\n        float: The calculated electricity bill.\n    \"\"\"\n    # Define the unit rates for electricity in different time periods\n    unit_rates = {\n        'off-peak': 0.05,  # Rs. 0.05 per unit for off-peak hours\n        'peak': 0.10,     # Rs. 0.10 per unit for peak hours\n        'super-peak': 0.15  # Rs. 0.15 per unit for super-peak hours\n    }\n\n    # Define the time periods for each unit rate\n    time_periods = {\n        'off-peak': '6am-10am and 10pm-6am',\n        'peak': '10am-6pm',\n        'super-peak': '6pm-10pm'\n    }\n\n    # Calculate the bill for each unit rate\n    bills = {}\n    for rate, period in unit_rates.items():\n        # Calculate the number of hours in the time period\n        hours = 24 * 4  # Assuming 4 hours in each time period\n        # Calculate the bill for the time period\n        bill = units * rate * hours\n        # Store the bill in the dictionary\n        bills[rate] = bill\n\n    # Calculate the total bill\n    total_bill = sum(bills.values())\n\n    return total_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    \"\"\"\n    This function calculates the ratio of zeroes in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of zeroes in the list.\n\n    Raises:\n        ZeroDivisionError: If the input list is empty.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        raise ZeroDivisionError(\"Cannot calculate ratio of zeroes for an empty list\")\n\n    # Count the number of zeroes in the list\n    zero_count = nums.count(0)\n\n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n\n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a variable to store the sum of powers of 2\n    sum_of_powers = 0\n    \n    # Iterate over each character in the binary representation\n    for char in binary:\n        # If the character is '1', add the corresponding power of 2 to the sum\n        if char == '1':\n            sum_of_powers += 2 ** (binary.index(char) - len(binary) + 1)\n    \n    # Return True if the sum of powers of 2 is equal to the original number, False otherwise\n    return sum_of_powers == n"}
{"id": "128_0", "code": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples that contain only one element.\n\n    Args:\n        test_list (list): A list of tuples\n\n    Returns:\n        list: A list of tuples that contain only one element\n    \"\"\"\n    # Initialize an empty list to store the result\n    singly_elements = []\n\n    # Iterate over each tuple in the input list\n    for tup in test_list:\n        # Check if the tuple has only one element\n        if len(tup) == 1:\n            # If the tuple has only one element, append it to the result list\n            singly_elements.append(tup)\n\n    # Return the list of tuples that contain only one element\n    return singly_elements"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    n = len(nums)\n    for size in range(n, 0, -1):\n        max_idx = nums.index(max(nums[:size]))\n        if max_idx == size - 1:\n            continue\n        if max_idx != 0:\n            if max_idx != size - 1:\n                if max_idx != 0:\n                    nums[:max_idx + 1] = nums[:max_idx + 1][::-1]\n                nums[:size] = nums[:size][::-1]\n            else:\n                nums[:1] = nums[:1][::-1]\n        if size > 1:\n            nums[:size] = nums[:size][::-1]\n    return nums"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(list1)\n    set2 = set(list2)\n    set3 = set(list3)\n\n    # Initialize a counter for the same pairs\n    same_pairs = 0\n\n    # Iterate over the sets to find common elements\n    for elem in set1 & set2 & set3:\n        # For each common element, increment the counter\n        same_pairs += 1\n\n    # Return the count of same pairs\n    return same_pairs"}
{"id": "132_0", "code": "def find_lists(Input):\n    \"\"\"\n    This function takes a tuple as input and returns the number of lists present in the tuple.\n    \n    Args:\n        Input (tuple): A tuple containing lists and/or other elements.\n    \n    Returns:\n        int: The number of lists present in the tuple.\n    \"\"\"\n    count = 0  # Initialize a counter variable to keep track of the number of lists\n    for element in Input:  # Iterate over each element in the tuple\n        if isinstance(element, list):  # Check if the current element is a list\n            count += 1  # If it's a list, increment the counter\n    return count  # Return the total count of lists"}
{"id": "133_0", "code": "def sum_Pairs(arr,n):\n    # Calculate the sum of absolute differences in all pairs of the given array\n    total_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    \"\"\"\n    This function calculates the maximum absolute difference between any two elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Initialize minimum and maximum values with the first element of the array\n    min_val = arr[0]\n    max_val = arr[0]\n\n    # Iterate over the array to find the minimum and maximum values\n    for i in range(1, n):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Calculate the maximum absolute difference\n    max_diff = max_val - min_val\n\n    return max_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    \"\"\"\n    This function calculates the total ASCII value of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total ASCII value of characters in the string.\n    \"\"\"\n    # Initialize a variable to store the total ASCII value\n    total_ascii = 0\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Add the ASCII value of the current character to the total\n        total_ascii += ord(char)\n    \n    # Return the total ASCII value\n    return total_ascii"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Create a 2D array to store the maximum path sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = tri[i][0]\n    for j in range(n):\n        dp[0][j] = tri[0][j]\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m):\n        for j in range(1, n):\n            # Calculate the maximum path sum at the current position\n            # by considering the maximum path sum of the two adjacent cells\n            dp[i][j] = max(tri[i][j] + dp[i-1][j], tri[i][j] + dp[i][j-1])\n    \n    # The maximum total path sum is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    def sum_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    max_sum = 0\n    for i in range(1, N):\n        sum1 = sum_digits(i)\n        sum2 = sum_digits(N - i)\n        total_sum = sum1 + sum2\n        if total_sum > max_sum:\n            max_sum = total_sum\n            best_i = i\n\n    return best_i"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    if n < 3:\n        return n\n\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = 1\n            for k in range(i, j):\n                if abs(arr[i] - arr[k]) == 1 and abs(arr[k] - arr[j]) == 1:\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, dp[i][n-1])\n\n    return max_length"}
{"id": "139_0", "code": "def does_Contain_B(a,b,c):\n    \"\"\"\n    Checks if the given number is present in the infinite sequence.\n    \n    Parameters:\n    a (int): The first number in the sequence.\n    b (int): The second number in the sequence.\n    c (int): The third number in the sequence.\n    \n    Returns:\n    bool: True if the number is present in the sequence, False otherwise.\n    \"\"\"\n    # Calculate the common difference between the numbers\n    common_difference = b - a\n    \n    # Check if the number is present in the sequence\n    if a <= num <= b:\n        return True\n    elif a < num < b:\n        # Calculate the position of the number in the sequence\n        position = (num - a) / common_difference\n        # Check if the position is an integer\n        if position == int(position):\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"id": "140_0", "code": "import math\n\ndef is_coprime(x, y):\n    \"\"\"\n    Checks whether two numbers are co-prime or not.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        bool: True if the numbers are co-prime, False otherwise.\n    \"\"\"\n    # Check if both numbers are integers\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both numbers must be integers.\")\n\n    # Check if both numbers are non-negative\n    if x < 0 or y < 0:\n        raise ValueError(\"Both numbers must be non-negative.\")\n\n    # Calculate the greatest common divisor (GCD) of the two numbers\n    gcd = math.gcd(x, y)\n\n    # If the GCD is 1, the numbers are co-prime\n    return gcd == 1"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) <= 1:\n        return x\n    mid = len(x) // 2\n    left_half = merge_sort(x[:mid])\n    right_half = merge_sort(x[mid:])\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    merged += left[left_index:]\n    merged += right[right_index:]\n    return merged"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculate the vertex of a parabola given its coefficients a, b, and c.\n\n    The parabola is in the form ax^2 + bx + c.\n\n    Parameters:\n    a (float): The coefficient of x^2.\n    b (float): The coefficient of x.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the vertex.\n    \"\"\"\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every specified element from a given two dimensional list.\n\n    Args:\n        nums (list): A two dimensional list containing elements to be extracted.\n        N (int): The number of elements to be extracted.\n\n    Returns:\n        list: A list of extracted elements.\n\n    Raises:\n        ValueError: If N is greater than the total number of elements in the list.\n    \"\"\"\n    # Flatten the two dimensional list into a one dimensional list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Check if N is greater than the total number of elements in the list\n    if N > len(flat_list):\n        raise ValueError(\"N cannot be greater than the total number of elements in the list.\")\n    \n    # Extract every specified element from the flattened list\n    extracted_elements = flat_list[:N]\n    \n    return extracted_elements"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    This function takes an integer as input, toggles all even bits, and returns the result.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The integer with all even bits toggled.\n    \"\"\"\n    # Convert the integer to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in bin_n:\n        # If the bit is even (i.e., '0'), toggle it to '1'\n        if bit == '0':\n            result += '1'\n        # If the bit is odd (i.e., '1'), toggle it to '0'\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    \"\"\"\n    This function takes a tuple of string values as input and returns a tuple of integer values.\n    \n    Parameters:\n    tuple_str (tuple): A tuple of string values.\n    \n    Returns:\n    tuple: A tuple of integer values.\n    \"\"\"\n    return tuple(int(value) for value in tuple_str)"}
{"id": "146_0", "code": "def encode_list(list1):\n    \"\"\"\n    This function takes a list as input and returns a string representing the run-length encoding of the list.\n    \n    Args:\n        list1 (list): A list of characters.\n    \n    Returns:\n        str: A string representing the run-length encoding of the list.\n    \"\"\"\n    if not list1:\n        return \"\"\n    \n    result = \"\"\n    count = 1\n    current_char = list1[0]\n    \n    for char in list1[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            result += str(count) + current_char\n            current_char = char\n            count = 1\n    \n    result += str(count) + current_char\n    return result"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    \"\"\"\n    This function calculates the minimum number of operations required to make all elements in the array equal.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The size of the input list.\n    k (int): The number of operations that can be performed.\n    \n    Returns:\n    int: The minimum number of operations required to make all elements in the array equal.\n    \"\"\"\n    \n    # First, we sort the array in ascending order\n    arr.sort()\n    \n    # We calculate the median of the array, which will be the target value\n    median = arr[n // 2] if n % 2 else (arr[n // 2 - 1] + arr[n // 2]) / 2\n    \n    # We initialize a variable to store the total number of operations\n    total_ops = 0\n    \n    # We iterate over each element in the array\n    for num in arr:\n        # We calculate the absolute difference between the current number and the median\n        # This difference represents the number of operations required to make the current number equal to the median\n        ops = abs(num - median)\n        \n        # We add the number of operations to the total\n        total_ops += ops\n        \n        # If the total number of operations exceeds k, we return -1\n        if total_ops > k:\n            return -1\n    \n    # Finally, we return the total number of operations\n    return total_ops"}
{"id": "148_0", "code": "def month_season(month,days):\n    month_names = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n    days_of_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    month_seasons = {\n        \"January\": \"Winter\",\n        \"February\": \"Winter\",\n        \"March\": \"Spring\",\n        \"April\": \"Spring\",\n        \"May\": \"Spring\",\n        \"June\": \"Summer\",\n        \"July\": \"Summer\",\n        \"August\": \"Summer\",\n        \"September\": \"Autumn\",\n        \"October\": \"Autumn\",\n        \"November\": \"Autumn\",\n        \"December\": \"Winter\"\n    }\n    month_number = month - 1\n    day_number = days - 1\n    day_of_week_number = 0\n    for i in range(day_number):\n        day_of_week_number += 1\n        if day_of_week_number == 7:\n            day_of_week_number = 0\n    day_of_week = days_of_week[day_of_week_number]\n    if month_number < 2 or month_number > 12:\n        print(\"Invalid month\")\n    elif month_number == 2 and days > month_days[month_number - 1]:\n        print(\"Invalid day\")\n    else:\n        print(f\"{month_names[month_number]} {days} {day_of_week}, {month_seasons[month_names[month_number]]}\")"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Calculate the gcd of a and b\n    gcd = gcd_helper(a, b)\n    \n    # If gcd is not 1, there is no solution\n    if gcd != 1:\n        return None\n    \n    # Calculate x and y using the extended Euclidean algorithm\n    x, y = extended_euclidean(a, b, n)\n    \n    return x, y\n\ndef gcd_helper(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef extended_euclidean(a, b, n):\n    if a == 0:\n        return 0, 1\n    else:\n        x, y = extended_euclidean(b % a, a, n)\n        return y - (b // a) * x, x"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    \"\"\"\n    Removes all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The list from which elements will be removed.\n        list2 (list): The list containing elements to be removed.\n\n    Returns:\n        list: The modified list1 with elements from list2 removed.\n    \"\"\"\n    # Convert list2 to a set for efficient lookups\n    set2 = set(list2)\n    \n    # Use a list comprehension to filter out elements from list1\n    # that are present in set2\n    return [element for element in list1 if element not in set2]"}
{"id": "151_0", "code": "def sum_series(n):\n    \"\"\"\n    This function calculates the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n    \n    Parameters:\n    n (int): The starting number of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize the x variable to 2 (since we start from n-2)\n    x = 2\n    \n    # Continue the loop until n-x is less than or equal to 0\n    while n - x >= 0:\n        # Add the current number to the total sum\n        total_sum += n - x\n        \n        # Increment x by 2 (since we are subtracting 2 each time)\n        x += 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "152_0", "code": "import math\n\ndef area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (float): The length of one side of the polygon.\n    l (float): The number of sides of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the number of sides is valid\n    if l < 3:\n        raise ValueError(\"A polygon must have at least 3 sides\")\n\n    # Calculate the area using the formula: (n * s^2) / (4 * tan(/n))\n    area = (l * s**2) / (4 * math.tan(math.pi/l))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    \"\"\"\n    This function checks whether the sum of divisors of two numbers are same or not.\n\n    Args:\n        num1 (int): The first number.\n        num2 (int): The second number.\n\n    Returns:\n        bool: True if the sum of divisors of num1 and num2 are same, False otherwise.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"\n        This function calculates the sum of divisors of a number.\n\n        Args:\n            n (int): The number.\n\n        Returns:\n            int: The sum of divisors of n.\n        \"\"\"\n        sum_divisors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                sum_divisors += i\n        return sum_divisors\n\n    # Calculate the sum of divisors of num1 and num2\n    sum_divisors_num1 = sum_of_divisors(num1)\n    sum_divisors_num2 = sum_of_divisors(num2)\n\n    # Check if the sums are equal\n    return sum_divisors_num1 == sum_divisors_num2"}
{"id": "154_0", "code": "def count_char_position(str1):\n    \"\"\"\n    This function counts characters at the same position in a given string \n    (lower and uppercase characters) as in English alphabet.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their counts.\n    \"\"\"\n    # Initialize an empty dictionary to store character counts\n    char_count = {}\n\n    # Iterate over each character in the input string\n    for char in str1:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Convert the character to lowercase for comparison\n            lower_char = char.lower()\n            # Check if the character is already in the dictionary\n            if lower_char in char_count:\n                # If it is, increment its count\n                char_count[lower_char] += 1\n            else:\n                # If it's not, add it to the dictionary with a count of 1\n                char_count[lower_char] = 1\n\n    # Return the dictionary of character counts\n    return char_count"}
{"id": "155_0", "code": "def find_even_Pair(A,N):\n    count = 0\n    for i in range(N):\n        for j in range(i+1,N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    \"\"\"\n    This function returns the smallest power of 2 that is greater than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The smallest power of 2 that is greater than or equal to n.\n    \"\"\"\n    # Calculate the base-2 logarithm of n\n    log_n = n.bit_length() - 1\n    \n    # Calculate the smallest power of 2 greater than or equal to n\n    next_power = 2 ** log_n\n    \n    return next_power"}
{"id": "157_0", "code": "def frequency(a,x):\n    \"\"\"\n    This function calculates the frequency of a given number in an array.\n\n    Parameters:\n    a (list): The input array.\n    x (int): The number to find the frequency of.\n\n    Returns:\n    int: The frequency of the number in the array.\n    \"\"\"\n    # Initialize a counter variable to store the frequency\n    count = 0\n    \n    # Iterate over each element in the array\n    for num in a:\n        # Check if the current element is equal to the given number\n        if num == x:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the frequency\n    return count"}
{"id": "158_0", "code": "def get_pell(n):\n    \"\"\"\n    Calculate the nth Pell number.\n\n    Args:\n        n (int): The position of the Pell number to calculate.\n\n    Returns:\n        int: The nth Pell number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the first two Pell numbers\n    p_0 = 0\n    p_1 = 1\n\n    # Calculate the nth Pell number\n    for _ in range(2, n + 1):\n        p_0, p_1 = p_1, 2 * p_0 + p_1\n\n    return p_1"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    \"\"\"\n    This function calculates the sum of numbers in a list between the specified range.\n\n    Args:\n        list1 (list): The input list of numbers.\n        m (int): The starting index of the range (inclusive).\n        n (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the list between the specified range.\n\n    Raises:\n        TypeError: If the input list is not a list or if the indices are not integers.\n        IndexError: If the indices are out of range.\n    \"\"\"\n    # Check if the input list is a list\n    if not isinstance(list1, list):\n        raise TypeError(\"Input list must be a list.\")\n\n    # Check if the indices are integers\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"Indices must be integers.\")\n\n    # Check if the indices are within the range of the list\n    if m < 0 or n >= len(list1) or m > n:\n        raise IndexError(\"Indices out of range.\")\n\n    # Calculate the sum of numbers in the list between the specified range\n    total_sum = sum(list1[m:n+1])\n\n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # Define the number of sides of a pentagon\n    n = 5\n    \n    # Calculate the perimeter using the formula: perimeter = n * side_length\n    perimeter = n * a\n    \n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    return s.count('std')"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(char for char in text if char.isalnum())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    \"\"\"\n    This function groups a sequence of key-value pairs into a dictionary of lists.\n    \n    Parameters:\n    l (list): A list of tuples, where each tuple contains a key-value pair.\n    \n    Returns:\n    dict: A dictionary where each key is a unique key from the input list, and its corresponding value is a list of values that belong to that key.\n    \"\"\"\n    result = {}\n    for key, value in l:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result"}
{"id": "164_0", "code": "def is_valid_parenthese(str1):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in str1:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack"}
{"id": "165_0", "code": "def perimeter_triangle(a,b,c):\n    \"\"\"\n    This function calculates the perimeter of a triangle given the lengths of its sides.\n\n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n\n    Returns:\n    float: The perimeter of the triangle.\n    \"\"\"\n    # Check if the sides can form a triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        raise ValueError(\"The sides cannot form a triangle\")\n\n    # Calculate the perimeter\n    perimeter = a + b + c\n\n    return perimeter"}
{"id": "166_0", "code": "import math\n\ndef answer(L, R):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            if lcm(i, j) <= R:\n                return (i, j)\n    return None"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for the given patterns in the text.\n\n    Args:\n        patterns (list): A list of strings to search for.\n        text (str): The text to search in.\n\n    Returns:\n        dict: A dictionary with the patterns as keys and their first occurrence indices as values.\n    \"\"\"\n    result = {}\n    for pattern in patterns:\n        index = text.find(pattern)\n        while index != -1:\n            result[pattern] = index\n            index = text.find(pattern, index + 1)\n    return result"}
{"id": "168_0", "code": "def is_num_keith(x):\n    \"\"\"\n    Checks if the given number is a Keith number.\n\n    A Keith number is a number that can be expressed as the sum of consecutive integers,\n    starting from 1, until the sum is greater than or equal to the number itself.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Keith number, False otherwise.\n    \"\"\"\n    total = 0\n    i = 1\n    while total < x:\n        total += i\n        i += 1\n    return total >= x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Radius of the Earth in kilometers\n    R = 6371.0\n\n    # Convert degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n\n    # Differences in coordinates\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n\n    # Haversine formula\n    a = math.sin(dlat / 2)**2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Distance\n    distance = R * c\n\n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    \"\"\"\n    This function finds the longest common prefix in the given set of strings.\n\n    Parameters:\n    arr (list): A list of strings.\n    n (int): The number of strings in the list.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not arr or n == 0:\n        return \"\"\n\n    # Sort the list of strings\n    arr.sort()\n\n    # Compare the first and last string in the sorted list\n    first_str = arr[0]\n    last_str = arr[n-1]\n\n    # Initialize the common prefix and the index\n    common_prefix = \"\"\n    i = 0\n\n    # Compare characters of the first and last string\n    while i < len(first_str) and i < len(last_str) and first_str[i] == last_str[i]:\n        common_prefix += first_str[i]\n        i += 1\n\n    return common_prefix"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    \"\"\"\n    This function takes a string as input and returns a dictionary containing \n    the count of uppercase, lowercase, special characters and numeric values.\n\n    Args:\n        string (str): The input string to be analyzed.\n\n    Returns:\n        dict: A dictionary containing the count of uppercase, lowercase, special \n        characters and numeric values.\n    \"\"\"\n    # Initialize a dictionary to store the count of each type of character\n    character_count = {\n        \"uppercase\": 0,\n        \"lowercase\": 0,\n        \"special\": 0,\n        \"numeric\": 0\n    }\n\n    # Use regex to find uppercase characters\n    uppercase_count = len(re.findall(r\"[A-Z]\", string))\n    character_count[\"uppercase\"] = uppercase_count\n\n    # Use regex to find lowercase characters\n    lowercase_count = len(re.findall(r\"[a-z]\", string))\n    character_count[\"lowercase\"] = lowercase_count\n\n    # Use regex to find special characters\n    special_count = len(re.findall(r\"[^A-Za-z0-9]\", string))\n    character_count[\"special\"] = special_count\n\n    # Use regex to find numeric values\n    numeric_count = len(re.findall(r\"\\d\", string))\n    character_count[\"numeric\"] = numeric_count\n\n    return character_count"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a hashmap to store the frequency of each element\n    freq_map = {}\n    for num in arr:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n\n    # Initialize count of pairs\n    count = 0\n\n    # Traverse the array\n    for i in range(n):\n        # Check if the number plus k exists in the hashmap\n        if arr[i] + k in freq_map:\n            # If it exists, add the frequency of the number plus k to the count\n            count += freq_map[arr[i] + k]\n\n        # Check if the number minus k exists in the hashmap\n        if arr[i] - k in freq_map:\n            # If it exists, add the frequency of the number minus k to the count\n            # But subtract 1 from the frequency because we have already counted the pair (arr[i] - k, arr[i])\n            count += freq_map[arr[i] - k] - 1\n\n    # Divide the count by 2 because each pair is counted twice\n    count //= 2\n\n    return count"}
{"id": "173_0", "code": "def greater_specificnum(lst, num):\n    \"\"\"\n    This function finds all the values in a list that are greater than a specified number.\n\n    Parameters:\n    lst (list): The input list of numbers.\n    num (int): The specified number.\n\n    Returns:\n    list: A list of numbers greater than the specified number.\n    \"\"\"\n    return [i for i in lst if i > num]"}
{"id": "174_0", "code": "import math\n\ndef parabola_focus(a, b, c):\n    \"\"\"\n    Calculate the focus of a parabola given its equation in the form ax^2 + bx + c = 0.\n\n    Parameters:\n    a (float): The coefficient of the x^2 term.\n    b (float): The coefficient of the x term.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the focus.\n    \"\"\"\n    # Calculate the focal length\n    focal_length = math.sqrt(a / (4 * b**2 - 4 * a * c))\n\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (4 * a)\n\n    # Calculate the y-coordinate of the focus\n    y_focus = c - (b**2) / (4 * a)\n\n    return (x_focus, y_focus)"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    \"\"\"\n    Searches for literals in a given text using regex.\n\n    Args:\n        text (str): The text to search in.\n        patterns (list): A list of literals to search for.\n\n    Returns:\n        dict: A dictionary with the literals found in the text and their positions.\n    \"\"\"\n    result = {}\n    for pattern in patterns:\n        positions = re.finditer(pattern, text)\n        for match in positions:\n            result[pattern] = match.start()\n    return result"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a table to store lengths of longest common subsequence of\n    # substrings. Note that lcs[i][j] contains length of LCS of X[0..i-1]\n    # and Y[0..j-1].\n    lcs = [[0 for w in range(n+1)] for x in range(m+1)]\n\n    # Fill lcs[m][n] in bottom up manner\n    for i in range(m, 0, -1):\n        for j in range(n, 0, -1):\n            if X[i-1] == Y[j-1]:\n                lcs[i][j] = lcs[i-1][j-1] + 1\n            else:\n                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])\n\n    # Following code is used to print LCS\n    index = lcs[m][n]\n\n    # Create a character array to store the lcs string\n    lcs_str = [\"\"] * (index+1)\n    lcs_str[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and\n    # one by one store characters in lcs_str\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X and Y are same, then\n        # current character is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs_str[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and\n        # go in the direction of larger value\n        elif lcs[i-1][j] > lcs[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs_str)"}
{"id": "177_0", "code": "def prod_Square(n):\n    i = 1\n    while i * i <= n:\n        if n % (i * i) == 0:\n            return True\n        i += 1\n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr,n):\n    # Create a set from the array\n    num_set = set(arr)\n    \n    # Initialize the first positive number to 1\n    first_positive = 1\n    \n    # Loop through the set until we find the first missing positive number\n    while first_positive in num_set:\n        first_positive += 1\n    \n    # Return the first missing positive number\n    return first_positive"}
{"id": "179_0", "code": "def count_Intgral_Points(x1,y1,x2,y2):\n    \"\"\"\n    This function counts the number of integral coordinates that lie inside a square.\n    \n    Parameters:\n    x1 (int): The x-coordinate of the lower left corner of the square.\n    y1 (int): The y-coordinate of the lower left corner of the square.\n    x2 (int): The x-coordinate of the upper right corner of the square.\n    y2 (int): The y-coordinate of the upper right corner of the square.\n    \n    Returns:\n    int: The number of integral coordinates that lie inside the square.\n    \"\"\"\n    \n    # Initialize a counter for integral coordinates\n    count = 0\n    \n    # Iterate over all possible x-coordinates\n    for x in range(x1, x2 + 1):\n        # Iterate over all possible y-coordinates\n        for y in range(y1, y2 + 1):\n            # Check if the current coordinate is an integer\n            if isinstance(x, int) and isinstance(y, int):\n                # If it is, increment the counter\n                count += 1\n                \n    # Return the total count of integral coordinates\n    return count"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    monthdays = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in monthdays:\n        if monthdays[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "181_0", "code": "def check_String(str):\n    \"\"\"\n    This function checks whether a given string has at least one letter and one number.\n\n    Parameters:\n    str (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string has at least one letter and one number, False otherwise.\n    \"\"\"\n    # Initialize flags for letter and number\n    has_letter = False\n    has_number = False\n\n    # Iterate over each character in the string\n    for char in str:\n        # Check if the character is a letter\n        if char.isalpha():\n            has_letter = True\n        # Check if the character is a number\n        elif char.isdigit():\n            has_number = True\n\n    # Return True if both letter and number are found, False otherwise\n    return has_letter and has_number"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    \"\"\"\n    This function removes duplicates from a given tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        tuple: A new tuple with duplicates removed.\n    \"\"\"\n    # Convert the tuple to a set to remove duplicates\n    # Since sets are unordered, we convert it back to a tuple\n    # and sort it to maintain the original order\n    return tuple(sorted(set(test_tup)))"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\n    \"\"\"\n    This function converts an octal number to a decimal number.\n\n    Parameters:\n    n (str): The octal number to be converted.\n\n    Returns:\n    int: The decimal equivalent of the input octal number.\n\n    Raises:\n    ValueError: If the input is not a valid octal number.\n    \"\"\"\n\n    # Check if the input is a valid octal number\n    if not set(n).issubset('01234567'):\n        raise ValueError(\"Invalid octal number\")\n\n    # Convert the octal number to decimal using Python's built-in int function\n    decimal = int(n, 8)\n\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    low = 0\n    high = n-1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    \"\"\"\n    This function removes all the tuples with length K from the given list.\n    \n    Parameters:\n    test_list (list): The input list containing tuples.\n    K (int): The length of the tuples to be removed.\n    \n    Returns:\n    list: The modified list with tuples of length K removed.\n    \"\"\"\n    return [t for t in test_list if len(t) != K]"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns the result of exponentiation of the first tuple with the second tuple.\n    \n    Parameters:\n    test_tup1 (tuple): The base tuple\n    test_tup2 (tuple): The exponent tuple\n    \n    Returns:\n    tuple: The result of exponentiation of test_tup1 with test_tup2\n    \"\"\"\n    # Initialize the result tuple with 1\n    result = (1, 1)\n    \n    # Iterate over each element in the exponent tuple\n    for i in test_tup2:\n        # Update the result tuple by multiplying it with the current element in the exponent tuple\n        result = (result[0] * i, result[1] * i)\n    \n    # Return the final result tuple\n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a,b):\n    \"\"\"\n    This function calculates the largest triangle that can be inscribed in an ellipse.\n    \n    Parameters:\n    a (float): The semi-major axis of the ellipse.\n    b (float): The semi-minor axis of the ellipse.\n    \n    Returns:\n    float: The area of the largest triangle that can be inscribed in the ellipse.\n    \"\"\"\n    \n    # Calculate the area of the largest triangle using the formula: A = 2 * a * b * sin(theta)\n    # where theta is the angle between the major and minor axes of the ellipse\n    # We can calculate theta using the formula: theta = 2 * arccos(1 - (b^2 / a^2))\n    theta = 2 * math.acos(1 - (b**2 / a**2))\n    \n    # Calculate the area of the largest triangle\n    area = 2 * a * b * math.sin(theta / 2)\n    \n    return area"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 less than or equal to the given number.\n\n    Parameters:\n    n (int): The given number.\n\n    Returns:\n    int: The highest power of 2 less than or equal to the given number.\n\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep multiplying the power of 2 until it exceeds the given number\n    while power_of_2 <= n:\n        # Multiply the power of 2 by 2\n        power_of_2 *= 2\n    \n    # The highest power of 2 less than or equal to the given number is the previous power of 2\n    return power_of_2 // 2"}
{"id": "189_0", "code": "def position_max(list1):\n    \"\"\"\n    This function finds all index positions of the maximum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the maximum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n\n    return max_indices"}
{"id": "190_0", "code": "def chkList(lst):\n    \"\"\"\n    This function checks whether all elements in a list are the same or not.\n\n    Args:\n        lst (list): A list of elements to be checked.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if len(lst) == 0:\n        return True  # An empty list is considered to have all elements the same\n\n    # Get the first element of the list\n    first_element = lst[0]\n\n    # Iterate over the rest of the list\n    for element in lst[1:]:\n        # If any element is different from the first element, return False\n        if element != first_element:\n            return False\n\n    # If the function hasn't returned False, all elements are the same\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    \"\"\"\n    This function removes even characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with even characters removed.\n    \"\"\"\n    return ''.join([char for char in str1 if int(char) % 2 != 0])"}
{"id": "192_0", "code": "def hamming_Distance(n1,n2):\n    # Convert the integers to binary and remove the '0b' prefix\n    bin_n1 = bin(n1)[2:]\n    bin_n2 = bin(n2)[2:]\n    \n    # Find the maximum length between the two binary strings\n    max_len = max(len(bin_n1), len(bin_n2))\n    \n    # Pad the shorter string with zeros to match the length of the longer string\n    bin_n1 = bin_n1.zfill(max_len)\n    bin_n2 = bin_n2.zfill(max_len)\n    \n    # Initialize a counter for the Hamming distance\n    distance = 0\n    \n    # Iterate over the characters in the binary strings\n    for i in range(max_len):\n        # If the characters at the current position are different, increment the distance\n        if bin_n1[i] != bin_n2[i]:\n            distance += 1\n    \n    # Return the Hamming distance\n    return distance"}
{"id": "193_0", "code": "def count(s,c):\n    \"\"\"\n    This function counts the occurrence of a given character in a string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be searched.\n\n    Returns:\n    int: The number of occurrences of the character in the string.\n    \"\"\"\n    return s.count(c)"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    \"\"\"\n    This function calculates the inversions of tuple elements in the given tuple list.\n    \n    Args:\n        test_tup (list): A list of tuples.\n    \n    Returns:\n        int: The total number of inversions.\n    \"\"\"\n    # Initialize the inversion count to 0\n    inversion_count = 0\n    \n    # Iterate over each tuple in the list\n    for i in range(len(test_tup)):\n        # Iterate over each element in the tuple\n        for j in range(len(test_tup[i])):\n            # Iterate over each element in the remaining tuples\n            for k in range(i + 1, len(test_tup)):\n                # Iterate over each element in the remaining tuples\n                for m in range(len(test_tup[k])):\n                    # Check if the current element is greater than the element in the other tuple\n                    if test_tup[i][j] > test_tup[k][m]:\n                        # Increment the inversion count\n                        inversion_count += 1\n    \n    # Return the total inversion count\n    return inversion_count"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    \"\"\"\n    This function takes a tuple of strings as input, \n    and returns a new tuple where each element is the concatenation of the corresponding elements in the input tuple.\n\n    Args:\n        test_tup (tuple): A tuple of strings.\n\n    Returns:\n        tuple: A new tuple where each element is the concatenation of the corresponding elements in the input tuple.\n    \"\"\"\n    return tuple(str(a) + str(b) for a, b in zip(test_tup, test_tup[1:] + (test_tup[0],)))"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    max_length = 0\n    max_subseq = \"\"\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            elif length == 2:\n                if str[i] == str[j]:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 1\n            else:\n                if str[i] == str[j]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                max_subseq = str[i:j + 1]\n\n    return max_subseq"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    \"\"\"\n    Checks if the given number is a decimal with a precision of 2.\n\n    Args:\n        num (str): The number to check.\n\n    Returns:\n        bool: True if the number is a decimal with a precision of 2, False otherwise.\n    \"\"\"\n    # Define the pattern for a decimal with a precision of 2\n    pattern = r\"^[-+]?[0-9]*\\.?[0-9]{2}$\"\n\n    # Use the fullmatch function to check if the entire string matches the pattern\n    return bool(re.fullmatch(pattern, num))"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    \"\"\"\n    Deletes the smallest element from the given heap and then inserts a new item.\n\n    Args:\n        heap (list): A list representing the heap.\n        a (int): The new item to be inserted into the heap.\n\n    Returns:\n        list: The updated heap after deletion and insertion.\n    \"\"\"\n    # Check if the heap is empty\n    if not heap:\n        return heap\n\n    # Find the smallest element in the heap\n    smallest = min(heap)\n\n    # Remove the smallest element from the heap\n    heap.remove(smallest)\n\n    # Insert the new item into the heap\n    heap.append(a)\n\n    # Heapify the heap to maintain the heap property\n    heapify(heap)\n\n    return heap\n\n\ndef heapify(heap):\n    \"\"\"\n    Maintains the heap property by bubbling down the largest element to its correct position.\n\n    Args:\n        heap (list): A list representing the heap.\n    \"\"\"\n    # Start from the last non-leaf node and perform heapify\n    for i in range(len(heap) // 2 - 1, -1, -1):\n        heapify_node(heap, i)\n\n\ndef heapify_node(heap, i):\n    \"\"\"\n    Recursively heapifies a subtree rooted at index i.\n\n    Args:\n        heap (list): A list representing the heap.\n        i (int): The index of the node to heapify.\n    \"\"\"\n    # Initialize the smallest as the root\n    smallest = i\n\n    # Calculate the left and right child indices\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # Check if the left child exists and is smaller than the root\n    if left < len(heap) and heap[left] < heap[smallest]:\n        smallest = left\n\n    # Check if the right child exists and is smaller than the smallest\n    if right < len(heap) and heap[right] < heap[smallest]:\n        smallest = right\n\n    # If the smallest is not the root, swap them and continue heapifying\n    if smallest != i:\n        heap[i], heap[smallest] = heap[smallest], heap[i]\n        heapify_node(heap, smallest)\n\n\n# Example usage:\nheap = [10, 20, 5, 15, 30]\nprint(\"Original Heap:\", heap)\n\na = 25\nprint(\"After deletion and insertion:\", heap_replace(heap, a))"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    \"\"\"\n    Checks if the given string contains only a-z, a-z, and 0-9 characters.\n\n    Args:\n        string (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains only allowed characters, False otherwise.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, string))"}
{"id": "200_0", "code": "def count_Num(n):\n    \"\"\"\n    This function counts the numbers whose nth and nth bits are set.\n\n    Args:\n        n (int): The position of the bits to check.\n\n    Returns:\n        int: The count of numbers whose nth and nth bits are set.\n    \"\"\"\n    count = 0\n    for i in range(1 << n):  # Iterate over all numbers up to 2^n\n        if (i >> n) & 1:  # Check if the nth bit is set\n            count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fourth power of the first 'n' natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        int: The sum of the fourth power of the first 'n' natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first 'n' natural numbers\n    for i in range(1, n + 1):\n        # Calculate the fourth power of the current number\n        fourth_power = i ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenates two string tuples into a single string.\n\n    Args:\n        test_tup1 (tuple): The first tuple of strings to concatenate.\n        test_tup2 (tuple): The second tuple of strings to concatenate.\n\n    Returns:\n        str: A single string containing all the strings from both input tuples.\n    \"\"\"\n    # Check if both inputs are tuples\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples\")\n\n    # Check if both tuples contain only strings\n    if not all(isinstance(s, str) for s in test_tup1) or not all(isinstance(s, str) for s in test_tup2):\n        raise TypeError(\"Both tuples must contain only strings\")\n\n    # Use the join() method to concatenate the strings in both tuples\n    # The join() method returns a string concatenated with the elements of an iterable\n    # We use the comma join operator (',') to concatenate the strings in each tuple\n    result = ','.join(test_tup1) + ',' + ','.join(test_tup2)\n\n    return result"}
{"id": "203_0", "code": "import math\n\ndef degree_radian(radian):\n    \"\"\"\n    This function converts radians to degrees.\n\n    Parameters:\n    radian (float): The angle in radians.\n\n    Returns:\n    float: The angle in degrees.\n    \"\"\"\n    # Use the math library's rad2deg function to convert radians to degrees\n    # This function returns the angle in degrees\n    degrees = math.degrees(radian)\n    return degrees"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.append(char * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    \"\"\"\n    Checks if list1 is a subset of list2.\n\n    Args:\n        list1 (list): The list to check.\n        list2 (list): The list to check against.\n\n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    # Flatten both lists\n    flat_list1 = flatten_list(list1)\n    flat_list2 = flatten_list(list2)\n\n    # Check if flat_list1 is a subset of flat_list2\n    return is_subset(flat_list1, flat_list2)\n\n\ndef flatten_list(nested_list):\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): The list to flatten.\n\n    Returns:\n        list: The flattened list.\n    \"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n\n\ndef is_subset(list1, list2):\n    \"\"\"\n    Checks if list1 is a subset of list2.\n\n    Args:\n        list1 (list): The list to check.\n        list2 (list): The list to check against.\n\n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    for item in list1:\n        if item not in list2:\n            return False\n    return True"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    \"\"\"\n    This function finds the first repeated character in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The first repeated character if found, otherwise None.\n    \"\"\"\n    # Convert the string to a set to remove duplicates and improve lookup efficiency\n    str_set = set(str)\n    \n    # Iterate over the string to find the first repeated character\n    for char in str:\n        if str.count(char) > 1 and char not in str_set:\n            return char\n    \n    # If no repeated character is found, return None\n    return None"}
{"id": "207_0", "code": "def min_Operations(A,B):\n    \"\"\"\n    This function calculates the minimum number of operations required to make two numbers equal.\n    \n    Parameters:\n    A (int): The first number.\n    B (int): The second number.\n    \n    Returns:\n    int: The minimum number of operations required to make A and B equal.\n    \"\"\"\n    \n    # Calculate the absolute difference between A and B\n    diff = abs(A - B)\n    \n    # If A and B are already equal, return 0\n    if A == B:\n        return 0\n    \n    # If A is greater than B, swap them to make the calculation easier\n    if A > B:\n        A, B = B, A\n    \n    # Calculate the minimum number of operations required to make A equal to B\n    operations = 0\n    while A != B:\n        # If A is greater than B, subtract B from A\n        if A > B:\n            A -= B\n        # If A is less than B, add B to A\n        else:\n            A += B\n        # Increment the operations counter\n        operations += 1\n    \n    # Return the minimum number of operations required\n    return operations"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    \"\"\"\n    This function takes a tuple and an integer K as input, \n    and returns the minimum and maximum K elements in the tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n        K (int): The number of elements to extract.\n\n    Returns:\n        tuple: A tuple containing the minimum and maximum K elements.\n    \"\"\"\n    # Check if K is greater than the length of the tuple\n    if K > len(test_tup):\n        raise ValueError(\"K cannot be greater than the length of the tuple\")\n\n    # Sort the tuple in ascending order\n    sorted_tup = sorted(test_tup)\n\n    # Extract the minimum and maximum K elements\n    min_k = sorted_tup[:K]\n    max_k = sorted_tup[-K:]\n\n    # Return the minimum and maximum K elements\n    return min_k, max_k"}
{"id": "209_0", "code": "def replace_max_specialchar(text,n):\n    \"\"\"\n    Replaces maximum n occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        text (str): The input string.\n        n (int): The maximum number of replacements.\n\n    Returns:\n        str: The modified string with maximum n occurrences of spaces, commas, or dots replaced with a colon.\n    \"\"\"\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Initialize a counter to track the number of replacements\n    count = 0\n    \n    # Initialize an empty string to store the modified text\n    modified_text = ''\n    \n    # Iterate over each character in the input text\n    for char in text:\n        # Check if the character is a special character\n        if char in special_chars:\n            # If the count is less than n, replace the character with a colon\n            if count < n:\n                modified_text += ':'\n                count += 1\n            # If the count is equal to n, keep the character as it is\n            else:\n                modified_text += char\n        # If the character is not a special character, keep it as it is\n        else:\n            modified_text += char\n    \n    # Return the modified text\n    return modified_text"}
{"id": "210_0", "code": "def first_even(nums):\n    \"\"\"\n    This function finds the first even number in a given list of numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first even number in the list. If no even number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    \"\"\"\n    This function checks if all elements in a given tuple have the same data type.\n\n    Args:\n        test_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    # Get the data type of the first element in the tuple\n    first_type = type(test_tuple[0])\n    \n    # Iterate over the rest of the elements in the tuple\n    for element in test_tuple[1:]:\n        # If the data type of the current element is different from the first type, return False\n        if type(element) != first_type:\n            return False\n    \n    # If the function hasn't returned False, it means all elements have the same data type, so return True\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    \"\"\"\n    Checks if the given element is a majority element in the sorted array.\n\n    Args:\n        arr (list): The input sorted array.\n        n (int): The size of the array.\n        x (int): The element to check.\n\n    Returns:\n        bool: True if the element is a majority element, False otherwise.\n    \"\"\"\n    # Initialize two pointers, one at the start and one at the end of the array\n    left, right = 0, n - 1\n    \n    # Continue the loop until the two pointers meet\n    while left < right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the target element, move the right pointer\n        if arr[mid] == x:\n            right = mid\n        # If the middle element is greater than the target element, move the right pointer\n        elif arr[mid] > x:\n            right = mid - 1\n        # If the middle element is less than the target element, move the left pointer\n        else:\n            left = mid + 1\n    \n    # After the loop, the left and right pointers should be pointing to the same element\n    # If the element at the left pointer is equal to the target element, return True\n    # Otherwise, return False\n    return arr[left] == x"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    \"\"\"\n    This function counts the number of set bits in a given integer n.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The number of set bits in n.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    \"\"\"\n    This function finds the minimum element in a sorted and rotated array.\n    \n    Parameters:\n    arr (list): The input array.\n    low (int): The low index of the current search range.\n    high (int): The high index of the current search range.\n    \n    Returns:\n    int: The minimum element in the array.\n    \"\"\"\n    \n    # If the array is not rotated, the minimum element is the first element\n    if high < low:\n        return arr[low]\n    \n    # If the array is rotated, find the middle element\n    mid = (low + high) // 2\n    \n    # If the middle element is greater than the next element, the minimum element is in the right half\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return find_Min(arr, mid + 1, high)\n    \n    # If the middle element is less than the previous element, the minimum element is in the left half\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return find_Min(arr, low, mid - 1)\n    \n    # If the middle element is greater than the first element, the minimum element is in the right half\n    if arr[mid] > arr[low]:\n        return find_Min(arr, low, mid)\n    \n    # If the middle element is less than the first element, the minimum element is in the left half\n    return find_Min(arr, mid + 1, high)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    \"\"\"\n    This function removes characters with odd index values from a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The modified string with characters at odd index values removed.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    \"\"\"\n    This function returns the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    # Check if a is the smallest\n    if a <= b and a <= c:\n        return a\n    # Check if b is the smallest\n    elif b <= a and b <= c:\n        return b\n    # If c is the smallest, return c\n    else:\n        return c"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):\n    # Convert the given numbers to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    bin_l = bin(l)[2:]\n    bin_r = bin(r)[2:]\n\n    # Calculate the length of the binary representation of n\n    n_len = len(bin_n)\n\n    # Pad the binary representation of l and r with leading zeros to match the length of n\n    bin_l = bin_l.zfill(n_len)\n    bin_r = bin_r.zfill(n_len)\n\n    # Check if all bits are set in the given range\n    for i in range(n_len):\n        if bin_l[i] == '0' or bin_r[i] == '0':\n            return False\n\n    return True"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    \"\"\"\n    Re-arranges the elements of the given array so that all negative elements appear before positive ones.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the array.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    # Initialize two lists, one for negative numbers and one for positive numbers\n    negative = []\n    positive = []\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current number is negative, add it to the negative list\n        if arr[i] < 0:\n            negative.append(arr[i])\n        # If the current number is positive, add it to the positive list\n        else:\n            positive.append(arr[i])\n\n    # Combine the two lists to get the final rearranged array\n    rearranged_arr = negative + positive\n\n    # Return the rearranged array\n    return rearranged_arr"}
{"id": "219_0", "code": "def replace_blank(str1,char):\n    return str1.replace(\" \", char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    \"\"\"\n    This function calculates the maximum sum in a right triangle of numbers.\n\n    Parameters:\n    tri (list): A list of numbers representing the sides of the right triangle.\n    n (int): The number of rows in the triangle.\n\n    Returns:\n    int: The maximum sum in the triangle.\n    \"\"\"\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Calculate the sum of the current row\n        row_sum = sum(tri[i*2:i*2+3])\n        \n        # Update the maximum sum if the current row sum is greater\n        max_sum = max(max_sum, row_sum)\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "221_0", "code": "def larg_nnum(list1,n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n\n    Args:\n        list1 (list): The dataset to select from.\n        n (int): The number of largest items to return.\n\n    Returns:\n        list: A list of the n largest items from the dataset.\n    \"\"\"\n    # Check if n is greater than the length of the list\n    if n > len(list1):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n\n    # Return the n largest items\n    return sorted_list[:n]"}
{"id": "222_0", "code": "import math\n\ndef lateralsuface_cylinder(r,h):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Parameters:\n    r (float): radius of the cylinder\n    h (float): height of the cylinder\n\n    Returns:\n    float: lateral surface area of the cylinder\n    \"\"\"\n    # Calculate the lateral surface area using the formula 2rh\n    lateral_surface_area = 2 * math.pi * r * h\n    \n    return lateral_surface_area"}
{"id": "223_0", "code": "def volume_cube(length):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Args:\n        length (float): The length of the cube.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return length ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all even bits set.\n    \"\"\"\n    # Create a mask to set even bits\n    mask = ((1 << n.bit_length()) - 1) & ~((1 << n.bit_length()) - 1)\n    \n    # Use bitwise AND operation to set even bits\n    result = n & mask\n    \n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Calculate the area of the large equilateral triangle\n    area_large = (N * N * N) / (4 * 3 * math.sqrt(3) / 4)\n    \n    # Calculate the area of the small equilateral triangle\n    area_small = (K * K * K) / (4 * 3 * math.sqrt(3) / 4)\n    \n    # Calculate the maximum number of small triangles that can fit in the large triangle\n    max_triangles = area_large / area_small\n    \n    # Return the maximum number of triangles as an integer\n    return int(max_triangles)"}
{"id": "226_0", "code": "from collections import defaultdict\n\ndef check_occurences(test_list):\n    # Create a dictionary to store the count of each record\n    record_count = defaultdict(int)\n    \n    # Iterate over each tuple in the test list\n    for record in test_list:\n        # Increment the count of the current record\n        record_count[record] += 1\n    \n    # Create a dictionary to store the count of each record at each time\n    time_record_count = defaultdict(dict)\n    \n    # Iterate over each record and its count\n    for record, count in record_count.items():\n        # Iterate over each time\n        for time in test_list:\n            # If the record is at the current time, increment its count\n            if record == time:\n                time_record_count[record][time] = time_record_count[record].get(time, 0) + 1\n    \n    # Find the records that occur at the same time\n    same_time_records = {}\n    for record, time_counts in time_record_count.items():\n        # If a record occurs at the same time more than once, add it to the dictionary\n        if len(time_counts.values()) > 1:\n            same_time_records[record] = list(time_counts.keys())\n    \n    # Return the records that occur at the same time\n    return same_time_records"}
{"id": "227_0", "code": "def number_of_substrings(s):\n    \"\"\"\n    This function calculates the number of non-empty substrings of a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of non-empty substrings.\n    \"\"\"\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            # Check if the substring is not empty\n            if s[i:j] != \"\":\n                count += 1\n    return count"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m,n):\n    \"\"\"\n    This function calculates the number of possible sequences of length n \n    such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.\n\n    Args:\n        m (int): The upper limit of the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n    # Initialize a list to store the number of sequences for each length up to n\n    sequences = [0] * (n + 1)\n    \n    # There is only one way to have a sequence of length 1, which is to have the first element be 1\n    sequences[1] = 1\n    \n    # For each length from 2 to n\n    for i in range(2, n + 1):\n        # Initialize the number of sequences for the current length to 0\n        sequences[i] = 0\n        # For each possible value of the previous element\n        for j in range(1, m // 2 + 1):\n            # If the current element is less than or equal to m and the previous element is less than or equal to twice of the current element\n            if j <= m // 2 and j * 2 <= m:\n                # Add the number of sequences for the previous length to the current number of sequences\n                sequences[i] += sequences[i - 1]\n    \n    # Return the total number of sequences for the given length\n    return sequences[n]"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    \"\"\"\n    This function replaces the last element of the first list with the second list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1] = list2\n    # Return the modified list\n    return list1"}
{"id": "230_0", "code": "def array_3d(m,n,o):\n    return [[[('*') for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_charac(str1):\n    \"\"\"\n    This function counts the total number of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    # Initialize a variable to store the count of characters\n    char_count = 0\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Increment the character count by 1 for each character\n        char_count += 1\n    \n    # Return the total character count\n    return char_count"}
{"id": "232_0", "code": "from collections import Counter\n\ndef sort_on_occurence(lst):\n    \"\"\"\n    Sorts the given list based on the occurrence of first element of tuples.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        list: The sorted list of tuples.\n    \"\"\"\n    # Count the occurrence of each first element\n    count = Counter(t[0] for t in lst)\n\n    # Sort the list based on the count\n    sorted_lst = sorted(lst, key=lambda x: (-count[x[0]], x))\n\n    return sorted_lst"}
{"id": "233_0", "code": "import math\n\ndef next_Perfect_Square(N):\n    # Calculate the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # If N is already a perfect square, return N\n    if sqrt_N == int(sqrt_N):\n        return N\n    \n    # Calculate the next perfect square\n    next_square = math.ceil(sqrt_N) ** 2\n    \n    return next_square"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Create a 2D array to store the maximum sum of bi-tonic sub-sequence\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of the 2D array\n    for i in range(n):\n        dp[i][i] = arr[i]\n    \n    # Fill the 2D array in a bottom-up manner\n    for length in range(1, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = max(arr[i] + dp[i + 1][j], arr[j] + dp[i][j - 1])\n    \n    # Return the maximum sum of bi-tonic sub-sequence\n    return dp[0][n - 1]"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    \"\"\"\n    Compute the square root of a number using the Babylonian method.\n\n    Args:\n        number (float): The number to compute the square root of.\n\n    Returns:\n        float: The square root of the input number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n\n    # Initial guess for the square root\n    guess = number / 2.0\n\n    # Maximum number of iterations\n    max_iterations = 1000\n\n    # Tolerance for convergence\n    tolerance = 0.00001\n\n    for _ in range(max_iterations):\n        # Calculate the next guess using the Babylonian method formula\n        next_guess = (guess + number / guess) / 2.0\n\n        # Check for convergence\n        if abs(guess - next_guess) < tolerance:\n            return next_guess\n\n        # Update the guess for the next iteration\n        guess = next_guess\n\n    # If the maximum number of iterations is reached without convergence, raise an error\n    raise RuntimeError(\"Failed to compute square root after {} iterations.\".format(max_iterations))"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store the lengths of the longest palindromic subsequences\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # All substrings of length 1 are palindromes\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for substring of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Check for lengths greater than 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            # If the first and last characters are the same, then\n            # the length of the longest palindromic subsequence is\n            # 2 plus the length of the longest palindromic subsequence\n            # of the substring without the first and last characters\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                # If the first and last characters are different, then\n                # the length of the longest palindromic subsequence is\n                # the maximum of the lengths of the longest palindromic\n                # subsequences of the substrings without the first or\n                # the last character\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # The longest palindromic subsequence is stored in dp[0][n - 1]\n    return dp[0][n - 1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1.\n\n    The harmonic sum of n-1 is the sum of the reciprocals of the first n-1 positive integers.\n\n    Args:\n        n (int): The number of terms in the harmonic sum.\n\n    Returns:\n        float: The harmonic sum of n-1.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the sum to 0\n    harmonic_sum = 0\n\n    # Calculate the harmonic sum\n    for i in range(1, n):\n        harmonic_sum += 1 / i\n\n    return harmonic_sum"}
{"id": "238_0", "code": "def intersection_array(array_nums1,array_nums2):\n    return list(filter(lambda x: x in array_nums2, array_nums1))"}
{"id": "239_0", "code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        x: The element to be searched.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(x)"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element of a list.\n\n    Args:\n        lst (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The modified list with the element inserted before each element.\n    \"\"\"\n    return [element] + lst + [element]"}
{"id": "241_0", "code": "import cmath\n\ndef convert(numbers):\n    \"\"\"\n    This function takes a complex number as input and returns its polar coordinates.\n\n    Parameters:\n    numbers (complex): A complex number.\n\n    Returns:\n    tuple: A tuple containing the magnitude (r) and angle (theta) of the complex number in polar coordinates.\n    \"\"\"\n    # Calculate the magnitude (r) of the complex number\n    r = abs(numbers)\n    \n    # Calculate the angle (theta) of the complex number in radians\n    theta = cmath.phase(numbers)\n    \n    # Return the magnitude and angle as a tuple\n    return (r, theta)"}
{"id": "242_0", "code": "def count_integer(list1):\n    \"\"\"\n    This function takes a list of integers as input and returns the count of integers in the list.\n\n    Args:\n        list1 (list): A list of integers.\n\n    Returns:\n        int: The count of integers in the list.\n    \"\"\"\n    # Initialize a counter variable to 0\n    count = 0\n    \n    # Iterate over each element in the list\n    for num in list1:\n        # Check if the element is an integer\n        if isinstance(num, int):\n            # If the element is an integer, increment the counter\n            count += 1\n    \n    # Return the count of integers\n    return count"}
{"id": "243_0", "code": "def words_ae(text):\n    \"\"\"\n    This function finds all words starting with 'a' or 'e' in a given string.\n\n    Parameters:\n    text (str): The input string to search for words starting with 'a' or 'e'.\n\n    Returns:\n    list: A list of words starting with 'a' or 'e'.\n    \"\"\"\n    # Split the input string into words\n    words = text.split()\n\n    # Initialize an empty list to store the words starting with 'a' or 'e'\n    result = []\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word starts with 'a' or 'e'\n        if word[0].lower() in ['a', 'e']:\n            # If the word starts with 'a' or 'e', add it to the result list\n            result.append(word)\n\n    # Return the list of words starting with 'a' or 'e'\n    return result"}
{"id": "244_0", "code": "import itertools\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Generate all combinations with repetitions of n colours from l colours.\n\n    Parameters:\n    l (list): List of colours.\n    n (int): Number of colours to choose.\n\n    Returns:\n    list: List of all combinations with repetitions.\n    \"\"\"\n    # Use itertools.product to generate all combinations with repetitions\n    combinations = list(itertools.product(l, repeat=n))\n    return combinations"}
{"id": "245_0", "code": "def count_primes_nums(n):\n    \"\"\"\n    This function counts the number of prime numbers less than a given non-negative number.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Create a boolean array, prime, of size n+1\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False\n    \n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n    \n    # Count all prime numbers in the boolean array\n    count = sum(prime)\n    \n    return count"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    \"\"\"\n    This function swaps the values of two numbers.\n    \n    Args:\n        a (int): The first number.\n        b (int): The second number.\n    \n    Returns:\n        tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    # Swap the values of a and b\n    a, b = b, a  # This line swaps the values of a and b\n    \n    # Return the swapped numbers as a tuple\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    return len(list(filter(lambda x: x % 2 != 0, array_nums)))"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns the maximum possible sum of elements from both tuples.\n    \n    Parameters:\n    test_tup1 (tuple): The first tuple of elements.\n    test_tup2 (tuple): The second tuple of elements.\n    \n    Returns:\n    int: The maximum possible sum of elements from both tuples.\n    \"\"\"\n    \n    # Initialize variables to store the maximum sum and the current sum\n    max_sum = 0\n    current_sum = 0\n    \n    # Initialize variables to store the maximum element and the current element\n    max_element = float('-inf')\n    current_element = float('-inf')\n    \n    # Iterate over the elements in both tuples\n    for i in range(max(len(test_tup1), len(test_tup2))):\n        # If the current index is within the bounds of both tuples\n        if i < len(test_tup1) and i < len(test_tup2):\n            # Update the current sum and the current element\n            current_sum += max(test_tup1[i], test_tup2[i])\n            current_element = max(test_tup1[i], test_tup2[i])\n        # If the current index is within the bounds of the first tuple\n        elif i < len(test_tup1):\n            # Update the current sum and the current element\n            current_sum += test_tup1[i]\n            current_element = test_tup1[i]\n        # If the current index is within the bounds of the second tuple\n        else:\n            # Update the current sum and the current element\n            current_sum += test_tup2[i]\n            current_element = test_tup2[i]\n        \n        # Update the maximum sum and the maximum element\n        max_sum = max(max_sum, current_sum)\n        max_element = max(max_element, current_element)\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "249_0", "code": "def newman_prime(n):\n    \"\"\"\n    Returns the nth Newman-Shanks-Williams prime number.\n    \n    Parameters:\n    n (int): The position of the prime number to find.\n    \n    Returns:\n    int: The nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def next_prime(num):\n        \"\"\"Find the next prime number after num.\"\"\"\n        num += 1\n        while not is_prime(num):\n            num += 1\n        return num\n\n    def newman_shanks_williams(num):\n        \"\"\"Generate the Newman-Shanks-Williams sequence.\"\"\"\n        sequence = [2]\n        for i in range(1, num):\n            next_num = next_prime(sequence[-1])\n            while not is_prime(next_num):\n                next_num = next_prime(next_num)\n            sequence.append(next_num)\n        return sequence\n\n    # Generate the sequence up to the nth prime\n    sequence = newman_shanks_williams(n)\n    return sequence[-1]"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function performs mathematical division operation across the given tuples.\n    \n    Args:\n        test_tup1 (tuple): The dividend tuple.\n        test_tup2 (tuple): The divisor tuple.\n    \n    Returns:\n        list: A list of division results.\n    \"\"\"\n    # Check if the tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Tuples must have the same length for division operation.\")\n    \n    # Initialize an empty list to store the division results\n    division_results = []\n    \n    # Iterate over the tuples\n    for i in range(len(test_tup1)):\n        # Perform division operation and append the result to the list\n        division_results.append(test_tup1[i] / test_tup2[i])\n    \n    # Return the list of division results\n    return division_results"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    \"\"\"\n    This function splits a given list into two parts where the length of the first part of the list is given.\n\n    Args:\n        list1 (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing the first part of the list and the second part of the list.\n    \"\"\"\n    # Check if the length of the list is less than or equal to the given length\n    if len(list1) <= L:\n        # If true, return the list as it is and an empty list\n        return list1, []\n    else:\n        # If false, return the first part of the list and the second part of the list\n        return list1[:L], list1[L:]"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into one.\n\n    Args:\n        d1 (dict): The first dictionary to merge.\n        d2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from both input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy all key-value pairs from the first dictionary to the merged dictionary\n    for key, value in d1.items():\n        merged_dict[key] = value\n    \n    # Iterate over the key-value pairs of the second dictionary\n    for key, value in d2.items():\n        # If the key is already present in the merged dictionary, update its value\n        if key in merged_dict:\n            merged_dict[key] = value\n        # If the key is not present in the merged dictionary, add it\n        else:\n            merged_dict[key] = value\n    \n    # Return the merged dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    \"\"\"\n    Calculate a dog's age in dog years.\n\n    Args:\n        h_age (int): Human age.\n\n    Returns:\n        int: Dog age in dog years.\n    \"\"\"\n    # Dog years are calculated based on the human age\n    # 1 human year is equivalent to 7 dog years for the first 2 years\n    # 1 human year is equivalent to 5 dog years for each subsequent year\n    if h_age <= 2:\n        return h_age * 7\n    else:\n        return (h_age - 2) * 5 + 2 * 7"}
{"id": "254_0", "code": "def list_split(S, step):\n    \"\"\"\n    Splits a list into sublists of size 'step' each.\n\n    Args:\n        S (list): The input list to be split.\n        step (int): The size of each sublist.\n\n    Returns:\n        list: A list of sublists of size 'step' each.\n    \"\"\"\n    return [S[i:i + step] for i in range(0, len(S), step)]"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): The length of the side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # Calculate the lateral surface area using the formula 4 * l^2\n    lateral_surface_area = 4 * (l ** 2)\n    return lateral_surface_area"}
{"id": "256_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to consider.\n\n    Returns:\n        int: The sum of squares of first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n odd natural numbers\n    for i in range(1, n+1):\n        # Calculate the square of the current odd number\n        square = (2*i - 1) ** 2\n        \n        # Add the square to the total sum\n        total_sum += square\n    \n    # Return the total sum\n    return total_sum"}
{"id": "257_0", "code": "def find_star_num(n):\n    \"\"\"\n    This function calculates the nth star number.\n    \n    The first star number is 1, the second star number is 6, the third star number is 11, and so on.\n    The formula to calculate the nth star number is: 5n(n+1)//2\n    \n    Parameters:\n    n (int): The position of the star number to be found.\n    \n    Returns:\n    int: The nth star number.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Calculate the nth star number using the formula\n    star_num = 5 * n * (n + 1) // 2\n    \n    return star_num"}
{"id": "258_0", "code": "def ascii_value(k):\n    \"\"\"\n    This function calculates the ASCII value of a given character.\n\n    Parameters:\n    k (str): The character for which the ASCII value is to be calculated.\n\n    Returns:\n    int: The ASCII value of the character.\n\n    Raises:\n    TypeError: If the input is not a string.\n    ValueError: If the input string is empty.\n    \"\"\"\n\n    # Check if the input is a string\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Check if the input string is not empty\n    if len(k) == 0:\n        raise ValueError(\"Input string cannot be empty.\")\n\n    # Calculate the ASCII value of the character\n    ascii_val = ord(k)\n\n    return ascii_val"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr,n):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The sum of even numbers at even positions.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the array using the index and value\n    for i, num in enumerate(arr):\n        # Check if the index is even and the number is even\n        if i % 2 == 0 and num % 2 == 0:\n            # Add the number to the total sum\n            total_sum += num\n    \n    # Return the total sum\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fifth power of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of the fifth power of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the fifth power of the current even number\n        power = i ** 5\n        \n        # Add the fifth power to the total sum\n        total_sum += power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples \n    where the last element of each tuple is extracted and stored in a new list.\n\n    Args:\n        test_list (list): A list of tuples containing records.\n\n    Returns:\n        list: A list of tuples where the last element of each tuple is extracted.\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_list = []\n\n    # Iterate over each tuple in the input list\n    for record in test_list:\n        # Extract the last element of the tuple and append it to the extracted list\n        extracted_list.append(record[-1])\n\n    # Return the extracted list\n    return extracted_list"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function subtracts the contents of one tuple with corresponding index of other tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the difference between corresponding elements of test_tup1 and test_tup2.\n\n    Raises:\n        ValueError: If the lengths of test_tup1 and test_tup2 are not equal.\n    \"\"\"\n    # Check if the lengths of the tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The lengths of the tuples must be equal.\")\n\n    # Use zip to iterate over the tuples in parallel\n    # Use a list comprehension to create a new list with the differences\n    differences = [x - y for x, y in zip(test_tup1, test_tup2)]\n\n    # Convert the list to a tuple and return it\n    return tuple(differences)"}
{"id": "263_0", "code": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of even index binomial coefficients up to n.\n    \n    Parameters:\n    n (int): The number of terms to consider in the binomial expansion.\n    \n    Returns:\n    int: The sum of even index binomial coefficients.\n    \"\"\"\n    # Initialize the sum of even index binomial coefficients\n    even_sum = 0\n    \n    # Iterate over the range from 0 to n (inclusive)\n    for i in range(n + 1):\n        # Calculate the binomial coefficient using the math.comb function\n        binomial_coeff = math.comb(i, i % 2)\n        \n        # If the index is even, add the binomial coefficient to the sum\n        if i % 2 == 0:\n            even_sum += binomial_coeff\n    \n    # Return the sum of even index binomial coefficients\n    return even_sum"}
{"id": "264_0", "code": "def get_Position(a,n,m):\n    \"\"\"\n    This function finds the position of the last removed element from the given array.\n    \n    Parameters:\n    a (list): The input array.\n    n (int): The number of elements removed.\n    m (int): The size of the array.\n    \n    Returns:\n    int: The position of the last removed element.\n    \"\"\"\n    # Calculate the position of the last removed element\n    position = n - 1\n    \n    # Check if the position is within the array bounds\n    if position < 0 or position >= m:\n        return -1\n    \n    # Return the position\n    return position"}
{"id": "265_0", "code": "import math\n\ndef volume_cylinder(r,h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Calculate the volume using the formula V = rh\n    volume = math.pi * (r ** 2) * h\n    return volume"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    \"\"\"\n    This function filters a dictionary based on values.\n\n    Parameters:\n    dict (dict): The dictionary to be filtered.\n    n (int): The value to filter the dictionary by.\n\n    Returns:\n    dict: A new dictionary containing only the key-value pairs where the value equals n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value == n}"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    \"\"\"\n    This function takes a tuple as input and returns the count of elements before the first occurrence of the record.\n    \n    Parameters:\n    test_tup (tuple): The input tuple.\n    \n    Returns:\n    int: The count of elements before the first occurrence of the record.\n    \"\"\"\n    # Initialize a counter variable to keep track of the count of elements before the record\n    count = 0\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # Increment the counter for each element\n        count += 1\n        \n        # Check if the current element is the record\n        if element == test_tup[-1]:\n            # If the record is found, break the loop\n            break\n    \n    # Return the count of elements before the record\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n    # Check if n is a decagonal number\n    return n == (3 * n * (n - 1) + 1) // 2"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    pos = 0\n    while pos < len(dlist):\n        if dlist[pos] == item:\n            return pos\n        else:\n            pos = pos + 1\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    \"\"\"\n    This function checks if all elements in a given list are unique.\n\n    Args:\n        test_list (list): A list of elements to be checked.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x: x - y for x, y in zip(nums1, nums2)))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq_dict = {}\n    \n    # Iterate over each digit in the number\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, freq in freq_dict.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if freq > int(digit):\n            return False\n    \n    # If no digit's frequency is greater than the digit itself, return True\n    return True"}
{"id": "273_0", "code": "def check_element(lst, element):\n    \"\"\"\n    Checks if all elements in the list are equal to the given element.\n\n    Args:\n        lst (list): The list to be checked.\n        element (str): The element to be compared with.\n\n    Returns:\n        bool: True if all elements are equal to the given element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    \"\"\"\n    This function checks if the input string contains 'a' followed by two to three 'b'.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Check if the length of the string is at least 3\n    if len(text) < 3:\n        return False\n    \n    # Check if the string starts with 'a'\n    if text[0] != 'a':\n        return False\n    \n    # Initialize a counter for 'b'\n    b_count = 0\n    \n    # Iterate over the string starting from the second character\n    for char in text[1:]:\n        # If the character is 'b', increment the counter\n        if char == 'b':\n            b_count += 1\n        # If the character is not 'b', reset the counter\n        else:\n            b_count = 0\n    \n    # Check if the counter is between 2 and 3 (inclusive)\n    return 2 <= b_count <= 3"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the total length of the repeated array\n    total_length = n * k\n    \n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Initialize the window start index\n    window_start = 0\n    \n    # Traverse the array\n    for window_end in range(total_length):\n        # Add the current element to the current sum\n        current_sum += a[window_end % n]\n        \n        # If the window size is greater than n, remove the first element\n        if window_end >= n - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= a[window_start]\n            window_start += 1\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "276_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of squares of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the square of the current even number\n        square = i ** 2\n        \n        # Add the square to the total sum\n        total_sum += square\n    \n    # Return the total sum\n    return total_sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    \"\"\"\n    This function counts the number of elements in the array that have a modular inverse under the given prime number P equal to itself.\n\n    Parameters:\n    arr (list): The input array.\n    N (int): The size of the array.\n    P (int): The given prime number.\n\n    Returns:\n    int: The count of elements having modular inverse under P equal to itself.\n    \"\"\"\n    count = 0  # Initialize a counter to store the count of elements with modular inverse equal to itself\n    for num in arr:  # Iterate over each element in the array\n        if pow(num, P-2, P) == 1:  # Check if the modular inverse of num under P is equal to itself\n            count += 1  # If true, increment the counter\n    return count  # Return the count of elements with modular inverse equal to itself"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Initialize a counter for odd days\n    odd_count = 0\n\n    # Loop through each month of the year\n    for month in range(1, 13):\n        # Determine the number of days in the month\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            days_in_month = 31\n        elif month == 2:\n            # February has 28 days in non-leap years\n            days_in_month = 28\n        else:\n            # April, June, September, and November have 30 days\n            days_in_month = 30\n\n        # Check if the month is odd\n        if month % 2 != 0:\n            # If the month is odd, add the number of days in the month to the odd count\n            odd_count += days_in_month\n        else:\n            # If the month is even, add half the number of days in the month to the odd count\n            odd_count += days_in_month // 2\n\n    # Return the total number of odd days\n    return odd_count"}
{"id": "279_0", "code": "def max_length(lists):\n    \"\"\"\n    This function finds the list of lists with maximum length.\n\n    Args:\n        lists (list): A list of lists.\n\n    Returns:\n        list: The list of lists with maximum length.\n    \"\"\"\n    if not lists:\n        return []\n\n    max_len = max(len(sublist) for sublist in lists)\n    return [sublist for sublist in lists if len(sublist) == max_len]"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    # Base case: If there are no posts or only one post, there is only one way to paint the fence\n    if n <= 1:\n        return 1\n    \n    # Base case: If there are two posts, there are k * k ways to paint the fence\n    if n == 2:\n        return k * k\n    \n    # Initialize a list to store the number of ways to paint the fence for each post\n    ways = [0] * n\n    ways[0] = k\n    ways[1] = k * k\n    \n    # For each post from the third post onwards\n    for i in range(2, n):\n        # The number of ways to paint the fence for the current post is the sum of the number of ways to paint the fence for the previous two posts\n        # with the same color and the number of ways to paint the fence for the previous two posts with different colors\n        ways[i] = (ways[i-1] + ways[i-2]) * (k - 1)\n    \n    # The number of ways to paint the fence for the last post is the sum of the number of ways to paint the fence for the last two posts\n    # with the same color and the number of ways to paint the fence for the last two posts with different colors\n    ways[n-1] = (ways[n-2] + ways[n-3]) * (k - 1)\n    \n    # Return the number of ways to paint the fence for the last post\n    return ways[-1]"}
{"id": "281_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the quotient of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The quotient of n and m.\n    \n    Raises:\n    ZeroDivisionError: If m is zero.\n    \"\"\"\n    if m == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return n // m"}
{"id": "282_0", "code": "import math\n\ndef otherside_rightangle(w,h):\n    # Calculate the length of the third side using the Pythagorean theorem\n    c = math.sqrt(w**2 + h**2)\n    return c"}
{"id": "283_0", "code": "def max_val(listval):\n    \"\"\"\n    This function finds the maximum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The maximum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"Input list is empty\")\n\n    max_val = listval[0]\n    for val in listval:\n        if val > max_val:\n            max_val = val\n\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    \"\"\"\n    Returns the sum of all divisors of a number.\n\n    Args:\n        number (int): The number for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of all divisors of the number.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize the sum of divisors to 0\n    sum_divisors = 0\n\n    # Iterate over all numbers from 1 to the input number\n    for i in range(1, number + 1):\n        # Check if the current number is a divisor of the input number\n        if number % i == 0:\n            # If it is, add it to the sum of divisors\n            sum_divisors += i\n\n    return sum_divisors"}
{"id": "285_0", "code": "def get_Inv_Count(arr,n):\n    inv_count = 0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if arr[i] > arr[j]:\n                inv_count = inv_count + 1\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    \"\"\"\n    This function takes a nested list as input and returns a flattened list.\n    \n    Args:\n        list1 (list): A nested list structure.\n    \n    Returns:\n        list: A flattened list structure.\n    \"\"\"\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    \"\"\"\n    This function finds the nested list elements which are present in another list.\n\n    Args:\n        l1 (list): The list to search for elements.\n        l2 (list): The list to search in.\n\n    Returns:\n        list: A list of elements that are present in both l1 and l2.\n    \"\"\"\n    # Flatten both lists\n    flat_l1 = flatten(l1)\n    flat_l2 = flatten(l2)\n\n    # Convert the flattened lists to sets\n    set_l1 = set(flat_l1)\n    set_l2 = set(flat_l2)\n\n    # Find the intersection of the two sets\n    intersection = set_l1.intersection(set_l2)\n\n    # Convert the intersection back to a list\n    result = list(intersection)\n\n    return result\n\n\ndef flatten(lst):\n    \"\"\"\n    This function flattens a nested list.\n\n    Args:\n        lst (list): The list to flatten.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    flat_list = []\n    for element in lst:\n        if isinstance(element, list):\n            flat_list.extend(flatten(element))\n        else:\n            flat_list.append(element)\n    return flat_list"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    \"\"\"\n    This function calculates the maximum aggregate from the list of tuples.\n    \n    Parameters:\n    stdata (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    int: The maximum aggregate from the list of tuples.\n    \"\"\"\n    # Initialize the maximum aggregate as negative infinity\n    max_agg = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for tup in stdata:\n        # Calculate the aggregate for the current tuple\n        agg = tup[0] + tup[1]\n        \n        # Update the maximum aggregate if the current aggregate is greater\n        if agg > max_agg:\n            max_agg = agg\n    \n    # Return the maximum aggregate\n    return max_agg"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    \"\"\"\n    This function calculates the count of all binary sequences of length 2n \n    such that sum of first n bits is same as sum of last n bits.\n\n    Args:\n    n (int): The number of bits in the binary sequence.\n\n    Returns:\n    int: The count of all binary sequences of length 2n that satisfy the condition.\n    \"\"\"\n    # Initialize count to 0\n    count = 0\n    \n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the number to binary and remove the '0b' prefix\n        bin_seq = bin(i)[2:].zfill(2*n)\n        \n        # Check if the sum of first n bits is equal to the sum of last n bits\n        if sum(int(bit) for bit in bin_seq[:n]) == sum(int(bit) for bit in bin_seq[n:]):\n            # If the condition is satisfied, increment the count\n            count += 1\n    \n    # Return the count\n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n        d (dict): The dictionary to calculate the depth of.\n\n    Returns:\n        int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        return 0  # Base case: if d is not a dictionary, return 0\n\n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            # Recursively calculate the depth of the sub-dictionary\n            depth = dict_depth(value) + 1\n            max_depth = max(max_depth, depth)\n\n    return max_depth"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Find the index of the first '1' in the binary representation\n    msb_index = binary.find('1')\n    \n    # If no '1' is found, return -1\n    if msb_index == -1:\n        return -1\n    \n    # Return the index of the most significant bit plus one\n    return msb_index + 1"}
{"id": "292_0", "code": "def solve(a,n):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left_half = merge_sort(arr[:mid])\n        right_half = merge_sort(arr[mid:])\n        return merge(left_half, right_half)\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged += left[left_index:]\n        merged += right[right_index:]\n        return merged\n\n    def count_inversions(arr):\n        if len(arr) <= 1:\n            return 0, arr\n        mid = len(arr) // 2\n        left_inversions, left = count_inversions(arr[:mid])\n        right_inversions, right = count_inversions(arr[mid:])\n        merged = merge(left, right)\n        return left_inversions + right_inversions, merged\n\n    left_inversions, _ = count_inversions(a)\n    _, right_inversions = count_inversions(a[::-1])\n    return left_inversions == right_inversions"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    \"\"\"\n    This function finds the element at a given index after a number of rotations.\n    \n    Parameters:\n    arr (list): The input list of elements.\n    ranges (list): A list of ranges of elements in the array.\n    rotations (int): The number of rotations.\n    index (int): The index of the element to be found.\n    \n    Returns:\n    The element at the given index after the number of rotations.\n    \"\"\"\n    \n    # Calculate the effective index after rotations\n    effective_index = (index + rotations) % len(arr)\n    \n    # Check if the effective index is within the range of the array\n    if effective_index < ranges[0]:\n        return arr[effective_index]\n    elif effective_index > ranges[1]:\n        return arr[effective_index]\n    else:\n        # If the effective index is within the range, return the element at the effective index\n        return arr[effective_index]"}
{"id": "294_0", "code": "def start_withp(words):\n    \"\"\"\n    This function takes a list of words as input and returns a list of tuples.\n    Each tuple contains two words from the list that start with the letter 'p'.\n    If no such pairs are found, it returns an empty list.\n    \"\"\"\n    # Filter the list to include only words starting with 'p'\n    p_words = [word for word in words if word.startswith('p')]\n    \n    # Initialize an empty list to store the matching pairs\n    pairs = []\n    \n    # Iterate over the list of 'p' words\n    for i in range(len(p_words)):\n        # For each word, iterate over the remaining words in the list\n        for j in range(i + 1, len(p_words)):\n            # If both words start with 'p', add them as a pair to the list\n            if p_words[i].startswith('p') and p_words[j].startswith('p'):\n                pairs.append((p_words[i], p_words[j]))\n    \n    # Return the list of pairs\n    return pairs"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Create a table to store the maximum sum of increasing subsequence\n    # till ith index and including kth element after i\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    \n    # Initialize the first row and column of the table\n    for i in range(n):\n        dp[i][0] = a[i]\n    for j in range(1, k):\n        dp[0][j] = float('-inf')\n    \n    # Fill the table in bottom-up manner\n    for i in range(1, n):\n        for j in range(1, k):\n            # If current element is greater than previous element\n            if a[i] > a[i-1]:\n                dp[i][j] = max(dp[i-1][j-1] + a[i], dp[i-1][j])\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    # The maximum sum of increasing subsequence is stored in the last cell of the table\n    return dp[n-1][k-1]"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\n    \"\"\"\n    This function takes a tuple and two integers as input, \n    and returns the mth element of the nth colon of the tuple.\n\n    Args:\n        tuplex (tuple): The input tuple.\n        m (int): The index of the element to be returned.\n        n (int): The index of the colon to be returned.\n\n    Returns:\n        The mth element of the nth colon of the tuple.\n    \"\"\"\n    # Check if the tuple is empty\n    if not tuplex:\n        return None\n\n    # Calculate the length of the tuple\n    tuplex_len = len(tuplex)\n\n    # Check if the indices are valid\n    if m < 1 or m > tuplex_len or n < 1 or n > tuplex_len:\n        return None\n\n    # Calculate the index of the element to be returned\n    index = (m - 1) * tuplex_len + n\n\n    # Check if the index is within the bounds of the tuple\n    if index < 0 or index >= tuplex_len:\n        return None\n\n    # Return the element at the calculated index\n    return tuplex[index]"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    \"\"\"\n    This function finds the specified number of largest products from two given lists.\n\n    Parameters:\n    nums1 (list): The first list of numbers.\n    nums2 (list): The second list of numbers.\n    N (int): The number of largest products to find.\n\n    Returns:\n    list: A list of the N largest products from the two input lists.\n    \"\"\"\n    # Combine the two lists into one\n    combined = nums1 + nums2\n    \n    # Sort the combined list in descending order\n    combined.sort(reverse=True)\n    \n    # Return the N largest products\n    return combined[:N]"}
{"id": "298_0", "code": "def maximum(a,b):\n    \"\"\"\n    This function returns the maximum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of a and b.\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    \"\"\"\n    This function converts a given string into a tuple.\n    \n    Parameters:\n    str1 (str): The input string to be converted into a tuple.\n    \n    Returns:\n    tuple: A tuple containing the input string.\n    \"\"\"\n    # Remove leading and trailing whitespaces from the input string\n    str1 = str1.strip()\n    \n    # Convert the string into a tuple\n    str_tuple = tuple(str1)\n    \n    # Return the tuple\n    return str_tuple"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    \"\"\"\n    This function sets the left most unset bit in the binary representation of the input number n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with the left most unset bit set.\n    \"\"\"\n    # Calculate the left most unset bit\n    left_most_unset_bit = n & -n\n    \n    # Return the number with the left most unset bit set\n    return n | left_most_unset_bit"}
{"id": "301_0", "code": "import math\n\ndef volume_cone(r,h):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    r (float): radius of the cone's base\n    h (float): height of the cone\n\n    Returns:\n    float: volume of the cone\n    \"\"\"\n    # Calculate the volume using the formula (1/3)rh\n    volume = (1/3) * math.pi * (r**2) * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize a list to store the maximum sum at each position\n    max_sum = [0] * (n + 1)\n    \n    # Initialize the maximum sum for the first row\n    max_sum[0] = grid[0][0]\n    \n    # Initialize the maximum sum for the first column\n    max_sum[1] = grid[0][1]\n    \n    # Calculate the maximum sum for each position\n    for i in range(2, n + 1):\n        max_sum[i] = grid[0][i] + max(max_sum[i - 2], max_sum[i - 3])\n        \n    # Calculate the maximum sum for the second row\n    for i in range(1, n + 1):\n        max_sum[i + n] = grid[1][i] + max(max_sum[i + 1], max_sum[i + 2])\n        \n    # Return the maximum sum\n    return max(max_sum)"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    \"\"\"\n    This function finds the first maximum length of even word in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The length of the first even word. If no even word is found, returns -1.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n\n    # Initialize max_len to -1\n    max_len = -1\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word is even\n        if len(word) % 2 == 0:\n            # If the word is even and its length is greater than max_len, update max_len\n            if len(word) > max_len:\n                max_len = len(word)\n\n    # Return max_len\n    return max_len"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    \"\"\"\n    Find the index of the last occurrence of a given number in a sorted array.\n\n    Args:\n        A (list): A sorted list of integers.\n        x (int): The target number to find.\n\n    Returns:\n        int: The index of the last occurrence of x in A. If x is not found, returns -1.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] < x:\n            left = mid + 1\n        elif A[mid] > x:\n            right = mid - 1\n        else:\n            # If A[mid] is equal to x, we need to check if it's the last occurrence\n            # We can do this by checking if A[mid + 1] is not equal to x\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            right = mid - 1\n    return -1"}
{"id": "306_0", "code": "def modified_encode(alist):\n    \"\"\"\n    This function takes a list of integers as input and returns a string representing the modified run-length encoding.\n    \n    Parameters:\n    alist (list): A list of integers.\n    \n    Returns:\n    str: A string representing the modified run-length encoding.\n    \"\"\"\n    if not alist:\n        return \"\"\n    \n    result = \"\"\n    count = 1\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            result += str(count) + alist[i - 1] + \" \"\n            count = 1\n    result += str(count) + alist[-1] + \" \"\n    return result.strip()"}
{"id": "307_0", "code": "def max_volume(s):\n    \"\"\"\n    This function calculates the maximum volume of a cuboid with a given sum of sides.\n    \n    Parameters:\n    s (int): The sum of the sides of the cuboid.\n    \n    Returns:\n    int: The maximum volume of the cuboid.\n    \"\"\"\n    # Initialize the maximum volume to 0\n    max_vol = 0\n    \n    # Iterate over all possible lengths\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible widths\n        for width in range(length, (s - length) // 2 + 1):\n            # Calculate the height\n            height = s - length - width\n            # Check if the height is greater than 0\n            if height > 0:\n                # Calculate the volume\n                vol = length * width * height\n                # Update the maximum volume if necessary\n                max_vol = max(max_vol, vol)\n    \n    # Return the maximum volume\n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    \"\"\"\n    This function finds all five characters long words in the given text.\n\n    Args:\n        text (str): The input string to search for words.\n\n    Returns:\n        list: A list of all five characters long words found in the text.\n    \"\"\"\n    # Define the pattern to match five characters long words\n    pattern = r'\\b\\w{5}\\b'\n\n    # Use re.findall to find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n\n    # Return the list of matches\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    \"\"\"\n    Calculate the difference between the squared sum of first n natural numbers \n    and the sum of squared first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        int: The difference between the two sums.\n    \"\"\"\n    # Calculate the sum of first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of squared first n natural numbers\n    sum_squared_n = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum_n = sum_n ** 2\n    \n    # Calculate the difference between the two sums\n    difference = squared_sum_n - sum_squared_n\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    \"\"\"\n    This function finds the demlo number for the given number.\n    \n    Parameters:\n    s (int): The input number.\n    \n    Returns:\n    int: The demlo number of the input number.\n    \"\"\"\n    # Define a dictionary to store the demlo numbers\n    demlo_numbers = {\n        1: 1,\n        2: 2,\n        3: 4,\n        4: 8,\n        5: 16,\n        6: 32,\n        7: 64,\n        8: 128,\n        9: 256,\n        10: 512,\n        11: 1024,\n        12: 2048,\n        13: 4096,\n        14: 8192,\n        15: 16384,\n        16: 32768,\n        17: 65536,\n        18: 131072,\n        19: 262144,\n        20: 524288,\n        21: 1048576,\n        22: 2097152,\n        23: 4194304,\n        24: 8388608,\n        25: 16777216,\n        26: 33554432,\n        27: 67108864,\n        28: 134217728,\n        29: 268435456,\n        30: 536870912,\n        31: 1073741824,\n        32: 2147483648,\n        33: 4294967296,\n        34: 8589934592,\n        35: 17179869184,\n        36: 34359738368,\n        37: 68719476736,\n        38: 137438953472,\n        39: 274877906944,\n        40: 549755813888,\n        41: 1099511627776,\n        42: 2199023255552,\n        43: 4398046511104,\n        44: 8796093022208,\n        45: 17592186044416,\n        46: 35184372088832,\n        47: 70368744177664,\n        48: 140737488355328,\n        49: 281474976710656,\n        50: 562949953421312,\n        51: 1125899906842624,\n        52: 2251799813685248,\n        53: 4503599627370496,\n        54: 9007199254740992,\n        55: 18014398509481984,\n        56: 36028797018963968,\n        57: 72057594037927936,\n        58: 144115188075855872,\n        59: 288230376151711744,\n        60: 576460752303423488,\n        61: 1152921504606846976,\n        62: 2305843009213693952,\n        63: 4611686018427387904,\n        64: 9223372036854775808,\n    }\n    \n    # Check if the input number is in the dictionary\n    if s in demlo_numbers:\n        # Return the demlo number\n        return demlo_numbers[s]\n    else:\n        # Return a message if the input number is not in the dictionary\n        return \"Demlo number not found for the given number.\""}
{"id": "311_0", "code": "def position_min(list1):\n    \"\"\"\n    This function finds all index positions of the minimum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the minimum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    # Find the minimum value in the list\n    min_val = min(list1)\n\n    # Find all index positions of the minimum value\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n\n    return min_indices"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    \"\"\"\n    Re-arranges the given array in alternating positive and negative items.\n\n    Args:\n        arr (list): The input array.\n        n (int): The number of elements to consider.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    # Separate positive and negative numbers\n    positive = [x for x in arr if x >= 0]\n    negative = [x for x in arr if x < 0]\n\n    # Initialize the result array\n    result = []\n\n    # Alternate between positive and negative numbers\n    for i in range(min(n, len(positive))):\n        result.append(positive[i])\n        result.append(negative[i])\n\n    # If there are remaining positive numbers, append them to the result\n    if len(positive) > n:\n        result.extend(positive[n:])\n\n    # If there are remaining negative numbers, append them to the result\n    if len(negative) > n:\n        result.extend(negative[:n])\n\n    return result"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    \"\"\"\n    This function calculates the sum of alternate chains of tuples.\n    \n    Parameters:\n    test_tuple (tuple): A tuple of tuples.\n    \n    Returns:\n    int: The sum of alternate chains of tuples.\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Initialize the index to 0\n    index = 0\n    \n    # Loop through the tuples in the test tuple\n    while index < len(test_tuple):\n        # Add the current tuple to the sum\n        total_sum += test_tuple[index]\n        \n        # Move to the next tuple, skipping the next one\n        index += 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    \"\"\"\n    This function calculates the minimum number of squares whose sum is equal to a given number.\n    \n    Args:\n    n (int): The given number.\n    \n    Returns:\n    int: The minimum number of squares.\n    \"\"\"\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    dp = [float('inf')] * (n + 1)\n    \n    # The minimum number of squares for 0 is 0\n    dp[0] = 0\n    \n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Initialize the minimum number of squares for the current number to infinity\n        min_squares = float('inf')\n        \n        # Iterate over each square number from 1 to the current number\n        j = 1\n        while j * j <= i:\n            # Update the minimum number of squares for the current number\n            min_squares = min(min_squares, dp[i - j * j] + 1)\n            j += 1\n        \n        # Update the minimum number of squares for the current number in the dp list\n        dp[i] = min_squares\n    \n    # Return the minimum number of squares for the given number\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    \n    # Iterate over each string in the test list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # Convert the word to lowercase to ignore case sensitivity\n            word = word.lower()\n            \n            # If the word is already in the dictionary, increment its frequency\n            if word in word_freq:\n                word_freq[word] += 1\n            # If the word is not in the dictionary, add it with a frequency of 1\n            else:\n                word_freq[word] = 1\n                \n    # Find the word with the maximum frequency\n    most_common_word = max(word_freq, key=word_freq.get)\n    \n    # Return the word with the most occurrences\n    return most_common_word"}
{"id": "316_0", "code": "def check_isosceles(x,y,z):\n    # Check if any two sides are equal\n    if x == y or y == z or x == z:\n        # If two sides are equal, check if the third side is equal to the other two\n        if x == y == z:\n            print(\"The triangle is equilateral.\")\n        else:\n            print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is scalene.\")"}
{"id": "317_0", "code": "def rotate_left(list1, m, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the left direction.\n\n    Args:\n        list1 (list): The input list to be rotated.\n        m (int): The number of items to rotate to the left.\n        n (int): The number of items to rotate to the right.\n\n    Returns:\n        list: The rotated list.\n    \"\"\"\n    # Calculate the effective rotation steps\n    effective_rotation_steps = m - n\n    \n    # If the effective rotation steps is negative, add the length of the list to make it positive\n    if effective_rotation_steps < 0:\n        effective_rotation_steps += len(list1)\n    \n    # Rotate the list to the left by slicing and concatenating\n    rotated_list = list1[effective_rotation_steps:] + list1[:effective_rotation_steps]\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    \"\"\"\n    This function counts the number of negative numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The count of negative numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num < 0)"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    \"\"\"\n    This function finds all three, four, five characters long words in the given string.\n    \n    Parameters:\n    text (str): The input string to search for words.\n    \n    Returns:\n    list: A list of words that are three, four, or five characters long.\n    \"\"\"\n    \n    # Define the pattern for words of length 3, 4, or 5\n    pattern = r'\\b\\w{3,5}\\b'\n    \n    # Use the findall function to find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n    \n    # Return the list of matches\n    return matches"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    \"\"\"\n    This function counts the number of unset bits in a given integer.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The number of unset bits in the input integer.\n    \"\"\"\n    # Initialize a counter for unset bits\n    unset_bits = 0\n    \n    # Loop through each bit in the binary representation of n\n    while n:\n        # Use bitwise AND operation with 1 to check if the least significant bit is 0\n        # If it is 0, increment the counter\n        unset_bits += n & 1\n        \n        # Right shift n by 1 to move to the next bit\n        n >>= 1\n    \n    # Return the total count of unset bits\n    return unset_bits"}
{"id": "321_0", "code": "def char_frequency(str1):\n    \"\"\"\n    This function calculates the frequency of each character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store character frequencies\n    freq_dict = {}\n\n    # Iterate over each character in the input string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in freq_dict:\n            freq_dict[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[char] = 1\n\n    # Return the dictionary containing character frequencies\n    return freq_dict"}
{"id": "322_0", "code": "def Sort(sub_li):\n    return sorted(sub_li, key=lambda x: x[1])"}
{"id": "323_0", "code": "def check_Validity(a,b,c):\n    # Check if the sides can form a triangle\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "324_0", "code": "def ap_sum(a,n,d):\n    \"\"\"\n    This function calculates the sum of an arithmetic progression.\n\n    Parameters:\n    a (float): The first term of the arithmetic progression.\n    n (int): The number of terms in the arithmetic progression.\n    d (float): The common difference of the arithmetic progression.\n\n    Returns:\n    float: The sum of the arithmetic progression.\n    \"\"\"\n    # Calculate the sum using the formula for the sum of an arithmetic progression\n    total = (n/2) * (2*a + (n-1)*d)\n    return total"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    monthdays = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname1 in monthdays:\n        if monthdays[monthname1] == 28:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    # Regular expression pattern to match a word at the end of a string with optional punctuation\n    pattern = r'\\b\\w+\\b(?=[\\s.,!?;:])'\n    # Use the re.search function to search for the pattern in the text\n    match = re.search(pattern, text)\n    # If a match is found, return the matched word\n    if match:\n        return match.group()\n    # If no match is found, return None\n    else:\n        return None"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i] == s[j - 1]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x,y):\n    \"\"\"\n    This function finds the maximum occurring divisor in the interval [x, y].\n    \n    Parameters:\n    x (int): The start of the interval.\n    y (int): The end of the interval.\n    \n    Returns:\n    int: The maximum occurring divisor in the interval [x, y].\n    \"\"\"\n    \n    # Initialize an empty dictionary to store the frequency of each divisor\n    divisor_freq = {}\n    \n    # Iterate over the interval [x, y]\n    for i in range(x, y+1):\n        # Iterate from 1 to the square root of i\n        for j in range(1, int(i**0.5) + 1):\n            # Check if j is a divisor of i\n            if i % j == 0:\n                # If j is a divisor, increment its frequency in the dictionary\n                if j in divisor_freq:\n                    divisor_freq[j] += 1\n                else:\n                    divisor_freq[j] = 1\n                \n                # Also, increment the frequency of its corresponding divisor\n                if i // j in divisor_freq:\n                    divisor_freq[i // j] += 1\n                else:\n                    divisor_freq[i // j] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(divisor_freq.values())\n    \n    # Find the maximum occurring divisor\n    max_divisor = [k for k, v in divisor_freq.items() if v == max_freq]\n    \n    # Return the maximum occurring divisor\n    return max(max_divisor)"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    \"\"\"\n    This function calculates the sum of the three smallest positive numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of the three smallest positive numbers.\n\n    Raises:\n        ValueError: If the list is empty or contains no positive numbers.\n    \"\"\"\n    # Filter out non-positive numbers and sort the list\n    positive_nums = sorted([num for num in lst if num > 0])\n    \n    # Check if there are at least three positive numbers\n    if len(positive_nums) < 3:\n        raise ValueError(\"The list must contain at least three positive numbers.\")\n    \n    # Return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    \"\"\"\n    This function takes a set as input and returns a list of ordered tuples.\n    \n    Parameters:\n    s (set): The input set to be converted into ordered tuples.\n    \n    Returns:\n    list: A list of ordered tuples.\n    \"\"\"\n    return list(s)"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    \"\"\"\n    This function finds the smallest range that includes at-least one element from each of the given arrays.\n    \n    Parameters:\n    lists (list): A list of lists, where each sublist contains integers.\n    \n    Returns:\n    tuple: A tuple containing the start and end of the smallest range.\n    \"\"\"\n    \n    # First, we find the minimum and maximum values in each list\n    min_values = [min(lst) for lst in lists]\n    max_values = [max(lst) for lst in lists]\n    \n    # Then, we find the minimum and maximum values across all lists\n    min_all = min(min_values)\n    max_all = max(max_values)\n    \n    # The smallest range that includes at-least one element from each of the given arrays\n    # is the range from the minimum value to the maximum value across all lists\n    return (min_all, max_all)"}
{"id": "332_0", "code": "def dig_let(s):\n    \"\"\"\n    Calculate the number of digits and letters in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    tuple: A tuple containing the number of digits and letters in the string.\n    \"\"\"\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n,m):\n    count = 0\n    for i in range(n,m):\n        if i % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    \"\"\"\n    This function calculates the difference between two consecutive numbers in a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of differences between consecutive numbers.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"Input list must have at least two elements.\")\n\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]"}
{"id": "335_0", "code": "def zigzag(n, k):\n    # Initialize a list to store the zigzag sequence\n    zigzag_sequence = []\n    \n    # Calculate the number of full cycles\n    full_cycles = n // k\n    \n    # Calculate the remaining elements\n    remaining_elements = n % k\n    \n    # Generate the full cycles\n    for i in range(full_cycles):\n        # Calculate the start and end indices for the current cycle\n        start = i * k\n        end = (i + 1) * k\n        \n        # Generate the current cycle\n        cycle = list(range(start, end))\n        \n        # Add the current cycle to the zigzag sequence\n        zigzag_sequence.extend(cycle)\n    \n    # Generate the remaining elements\n    remaining_cycle = list(range(full_cycles * k, n))\n    \n    # Add the remaining elements to the zigzag sequence\n    zigzag_sequence.extend(remaining_cycle)\n    \n    # Return the zigzag sequence\n    return zigzag_sequence"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # m is the number of rows\n    # n is the number of columns\n    # The number of squares is the product of the number of rows and the number of columns\n    return m * n"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a 2D array to store the number of ways to get prefix sums\n    dp = [[0 for _ in range(M + 1)] for _ in range(M + 1)]\n    \n    # Base case: there is one way to get a prefix sum of 0 (by not using any numbers)\n    dp[0][0] = 1\n    \n    # For each number from 1 to M\n    for i in range(1, M + 1):\n        # For each possible prefix sum from 0 to i\n        for j in range(i + 1):\n            # For each possible value of the current number\n            for k in range(1, i + 1):\n                # If the current number is less than or equal to the current prefix sum\n                if k <= j:\n                    # Add the number of ways to get the prefix sum without the current number\n                    # to the number of ways to get the prefix sum with the current number\n                    dp[j][i] += dp[j - k][i - k]\n    \n    # The number of ways to get a prefix sum of M is stored in dp[M][M]\n    return dp[M][M]"}
{"id": "338_0", "code": "def check(string):\n    \"\"\"\n    This function checks whether the given string is a binary string or not.\n    \n    A binary string is a string that contains only '0's and '1's.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string is a binary string, False otherwise.\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Check if the string contains only '0's and '1's\n    if set(string).issubset({'0', '1'}):\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Create a dictionary to store the frequency of each character in the string\n    char_frequency = {}\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Initialize the minimum length and the character to be removed\n    min_length = float('inf')\n    remove_char = None\n\n    # Iterate over each character and its frequency\n    for char, freq in char_frequency.items():\n        # Calculate the length of the string if the current character is removed\n        new_length = len(s) - freq\n        # Update the minimum length and the character to be removed if necessary\n        if new_length < min_length:\n            min_length = new_length\n            remove_char = char\n\n    # Return the minimum length and the character to be removed\n    return min_length, remove_char"}
{"id": "340_0", "code": "from collections import Counter\n\ndef first_Element(arr,n,k):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = Counter(arr)\n    \n    # Iterate through the array to find the first element occurring k times\n    for i in range(n):\n        if freq_dict[arr[i]] == k:\n            return arr[i]\n    return None"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Convert the string to a set, which automatically removes duplicates\n    unique_chars = set(str)\n    \n    # Check if the length of the set is equal to the length of the original string\n    if len(unique_chars) == len(str):\n        return True\n    else:\n        return False"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    \"\"\"\n    Removes the nth column from a given nested list.\n\n    Args:\n        list1 (list): The input nested list.\n        n (int): The column index to be removed.\n\n    Returns:\n        list: The modified nested list with the specified column removed.\n    \"\"\"\n    # Check if the input list is empty\n    if not list1:\n        return list1\n\n    # Check if the column index is within the valid range\n    if n < 0 or n >= len(list1[0]):\n        raise ValueError(\"Invalid column index\")\n\n    # Use list comprehension to create a new list with the specified column removed\n    return [row[:n] + row[n+1:] for row in list1]"}
{"id": "343_0", "code": "def tn_ap(a,n,d):\n    \"\"\"\n    This function calculates the t-nth term of an arithmetic progression.\n    \n    Parameters:\n    a (int): The first term of the arithmetic progression.\n    n (int): The term number to be calculated.\n    d (int): The common difference of the arithmetic progression.\n    \n    Returns:\n    int: The t-nth term of the arithmetic progression.\n    \"\"\"\n    # Calculate the t-nth term using the formula: a + (n-1)*d\n    t_n = a + (n-1)*d\n    return t_n"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    \"\"\"\n    Calculate the number of rectangles in a circle of radius r.\n\n    The number of rectangles is calculated by dividing the circle into 4 equal quadrants,\n    and then counting the number of rectangles in each quadrant.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    int: The number of rectangles in the circle.\n    \"\"\"\n    # Calculate the area of the circle\n    circle_area = math.pi * radius ** 2\n    \n    # Calculate the area of each rectangle\n    rectangle_area = radius ** 2\n    \n    # Calculate the number of rectangles in the circle\n    # by dividing the circle area by the rectangle area\n    num_rectangles = circle_area / rectangle_area\n    \n    # Since each rectangle is counted 4 times (once for each quadrant),\n    # we divide the total number of rectangles by 4\n    num_rectangles /= 4\n    \n    # Return the total number of rectangles\n    return int(num_rectangles)"}
{"id": "345_0", "code": "def find_angle(a,b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    c = 180 - a - b\n    return c"}
{"id": "346_0", "code": "def find_max(test_list):\n    \"\"\"\n    This function finds the maximum element of all the given tuple records.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        int: The maximum element found in the tuple records.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"Input list is empty\")\n\n    max_element = test_list[0][0]\n    for record in test_list:\n        if record[0] > max_element:\n            max_element = record[0]\n\n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    \"\"\"\n    This function calculates the modulo division of two lists.\n    \n    Args:\n        nums1 (list): The dividend list.\n        nums2 (list): The divisor list.\n    \n    Returns:\n        list: A list of the results of the modulo division.\n    \"\"\"\n    return list(map(lambda x, y: (x - y * (x // y)) % y, nums1, nums2))"}
{"id": "348_0", "code": "import math\n\ndef Check_Solution(a,b,c):\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if d < 0:\n        return \"This equation has no real solutions.\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(d)) / (2*a)\n    root2 = (-b - math.sqrt(d)) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return \"One root is twice the other.\"\n    else:\n        return \"No root is twice the other.\""}
{"id": "349_0", "code": "def get_carol(n):\n    \"\"\"\n    Returns the nth carol number.\n\n    The carol numbers are generated based on the following rules:\n    - The first carol number is 1.\n    - The second carol number is 2.\n    - The third carol number is 3.\n    - The fourth carol number is 4.\n    - The fifth carol number is 5.\n    - The sixth carol number is 6.\n    - The seventh carol number is 7.\n    - The eighth carol number is 8.\n    - The ninth carol number is 9.\n    - The tenth carol number is 10.\n    - The eleventh carol number is 11.\n    - The twelfth carol number is 12.\n    - The thirteenth carol number is 13.\n    - The fourteenth carol number is 14.\n    - The fifteenth carol number is 15.\n    - The sixteenth carol number is 16.\n    - The seventeenth carol number is 17.\n    - The eighteenth carol number is 18.\n    - The nineteenth carol number is 19.\n    - The twentieth carol number is 20.\n    - The twenty-first carol number is 21.\n    - The twenty-second carol number is 22.\n    - The twenty-third carol number is 23.\n    - The twenty-fourth carol number is 24.\n    - The twenty-fifth carol number is 25.\n    - The twenty-sixth carol number is 26.\n    - The twenty-seventh carol number is 27.\n    - The twenty-eighth carol number is 28.\n    - The twenty-ninth carol number is 29.\n    - The thirtieth carol number is 30.\n    - The thirty-first carol number is 31.\n    - The thirty-second carol number is 32.\n    - The thirty-third carol number is 33.\n    - The thirty-fourth carol number is 34.\n    - The thirty-fifth carol number is 35.\n    - The thirty-sixth carol number is 36.\n    - The thirty-seventh carol number is 37.\n    - The thirty-eighth carol number is 38.\n    - The thirty-ninth carol number is 39.\n    - The fortieth carol number is 40.\n    - The forty-first carol number is 41.\n    - The forty-second carol number is 42.\n    - The forty-third carol number is 43.\n    - The forty-fourth carol number is 44.\n    - The forty-fifth carol number is 45.\n    - The forty-sixth carol number is 46.\n    - The forty-seventh carol number is 47.\n    - The forty-eighth carol number is 48.\n    - The forty-ninth carol number is 49.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fiftieth carol number is 50.\n    - The fift"}
{"id": "350_0", "code": "def remove_empty(list1):\n    \"\"\"\n    Removes empty lists from a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        list: The input list with empty lists removed.\n    \"\"\"\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum occurrences in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum occurrences.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the number with maximum count\n    max_count = max(count_dict.values())\n    max_num = [num for num, count in count_dict.items() if count == max_count]\n\n    # Return the first number with maximum count\n    return max_num[0]"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    \"\"\"\n    This function adds K elements to each element in the tuple.\n\n    Args:\n        test_list (tuple): The input tuple.\n        K (int): The number of elements to add.\n\n    Returns:\n        list: A list of tuples, where each tuple contains the original element and the element with K added.\n    \"\"\"\n    result = []\n    for element in test_list:\n        new_element = element + K\n        result.append((element, new_element))\n    return result"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(str):\n    \"\"\"\n    This function calculates the minimum number of flips required to make a binary string a sequence of alternate characters.\n    \n    Parameters:\n    str (str): The input binary string.\n    \n    Returns:\n    int: The minimum number of flips required.\n    \"\"\"\n    flips = 0\n    prev_char = None\n    for char in str:\n        if char == '1':\n            if prev_char == '1':\n                flips += 1\n        else:\n            if prev_char == '1':\n                flips += 1\n        prev_char = char\n    return flips"}
{"id": "354_0", "code": "def count_Digit(n):\n    return len(str(abs(n)))"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    \"\"\"\n    This function calculates the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        list_nums (list): A list of integers.\n\n    Returns:\n        int: The largest product of the pair of adjacent elements.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(list_nums) < 2:\n        raise ValueError(\"The input list must have at least two elements.\")\n\n    max_product = float('-inf')  # Initialize max_product as negative infinity\n\n    for i in range(len(list_nums) - 1):  # Iterate over the list, excluding the last element\n        product = list_nums[i] * list_nums[i + 1]  # Calculate the product of the current pair of adjacent elements\n        if product > max_product:  # Check if the current product is greater than the max_product\n            max_product = product  # Update max_product if the current product is greater\n\n    return max_product"}
{"id": "356_0", "code": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_tree_balanced(root):\n    def check_balance(node):\n        if node is None:\n            return (True, 0)\n        left_balanced, left_height = check_balance(node.left)\n        if not left_balanced:\n            return (False, 0)\n        right_balanced, right_height = check_balance(node.right)\n        if not right_balanced:\n            return (False, 0)\n        if abs(left_height - right_height) > 1:\n            return (False, 0)\n        return (True, max(left_height, right_height) + 1)\n\n    return check_balance(root)[0]"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    \"\"\"\n    Repeat the given tuple n times.\n\n    Args:\n        test_tup (tuple): The tuple to be repeated.\n        N (int): The number of times to repeat the tuple.\n\n    Returns:\n        list: A list of tuples, where each tuple is a repetition of the input tuple.\n    \"\"\"\n    return [test_tup] * N"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l,w,h):\n    # Calculate the lateral surface area of the cuboid\n    lateral_surface_area = 2 * (l * w + l * h + w * h)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    \"\"\"\n    Sorts a tuple by its float element.\n\n    Args:\n        price (tuple): A tuple containing float elements.\n\n    Returns:\n        tuple: A sorted tuple of float elements.\n    \"\"\"\n    return tuple(sorted(price, key=lambda x: float(x)))"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    \"\"\"\n    This function finds the smallest missing element in a sorted array.\n    \n    Parameters:\n    A (list): The input sorted array.\n    left_element (int): The left boundary of the search range.\n    right_element (int): The right boundary of the search range.\n    \n    Returns:\n    int: The smallest missing element in the array.\n    \"\"\"\n    \n    # Initialize the left and right pointers\n    left = left_element\n    right = right_element\n    \n    # Continue the search until the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the middle index, it means the middle element is the smallest missing element\n        if A[mid] == mid + left_element:\n            return mid + left_element\n        \n        # If the middle element is greater than the middle index, it means the smallest missing element is in the left half\n        elif A[mid] > mid + left_element:\n            right = mid - 1\n        \n        # If the middle element is less than the middle index, it means the smallest missing element is in the right half\n        else:\n            left = mid + 1\n    \n    # If the loop ends, it means the smallest missing element is the next integer after the right element\n    return right_element + 1"}
{"id": "361_0", "code": "import heapq\n\ndef heap_ascending(nums):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements in ascending order.\n    \"\"\"\n    # Create a min heap from the input list\n    heapq.heapify(nums)\n\n    # Initialize an empty list to store the sorted elements\n    sorted_nums = []\n\n    # While the heap is not empty, pop the smallest element and add it to the sorted list\n    while nums:\n        sorted_nums.append(heapq.heappop(nums))\n\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(length, width, height):\n    \"\"\"\n    Calculate the volume of a cuboid.\n\n    Args:\n        length (float): The length of the cuboid.\n        width (float): The width of the cuboid.\n        height (float): The height of the cuboid.\n\n    Returns:\n        float: The volume of the cuboid.\n    \"\"\"\n    # Calculate the volume using the formula: volume = length * width * height\n    volume = length * width * height\n    return volume"}
{"id": "363_0", "code": "def permute_string(str):\n    \"\"\"\n    This function generates all permutations of a given string including duplicates.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        None\n    \"\"\"\n    # Base case: if the string is empty or has only one character, return it\n    if len(str) <= 1:\n        print(str)\n    else:\n        # Choose each character in the string as the first character of the permutation\n        for i in range(len(str)):\n            # Remove the chosen character from the string\n            remaining_str = str[:i] + str[i+1:]\n            # Recursively generate permutations of the remaining string\n            permute_string(remaining_str)\n\n# Example usage:\npermute_string(\"abc\")"}
{"id": "364_0", "code": "def round_num(n,m):\n    \"\"\"\n    Rounds the given number to the nearest multiple of a specific number.\n\n    Args:\n        n (float): The number to be rounded.\n        m (int): The multiple to round to.\n\n    Returns:\n        float: The rounded number.\n    \"\"\"\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is less than half of m, round down\n    if remainder < m / 2:\n        return n - remainder\n    # If the remainder is greater than or equal to half of m, round up\n    else:\n        return n + (m - remainder)"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with unique elements and custom values\n    new_tup = []\n    for element, count in count_dict.items():\n        if count == 1:\n            new_tup.append(element)\n        else:\n            new_tup.append((element, \"REPLICA\"))\n\n    return tuple(new_tup)"}
{"id": "366_0", "code": "def remove_Char(s,c):\n    \"\"\"\n    Removes all occurrences of a character in a given string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be removed.\n\n    Returns:\n    str: The string with all occurrences of the character removed.\n    \"\"\"\n    return s.replace(c, '')"}
{"id": "367_0", "code": "def move_first(test_list):\n    \"\"\"\n    Shifts the last element to the first position in the given list.\n\n    Args:\n        test_list (list): The input list.\n\n    Returns:\n        list: The modified list with the last element shifted to the first position.\n    \"\"\"\n    if len(test_list) == 0:\n        return test_list\n    else:\n        return [test_list[-1]] + test_list[:-1]"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    This function calculates the surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: surface area of the cuboid\n    \"\"\"\n    # Calculate the surface area of the cuboid\n    surface_area = 2 * (l * w + l * h + w * h)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum, colnum):\n    \"\"\"\n    Generate a two-dimensional array with the specified number of rows and columns.\n\n    Args:\n        rownum (int): The number of rows in the array.\n        colnum (int): The number of columns in the array.\n\n    Returns:\n        list: A two-dimensional list (array) with the specified number of rows and columns.\n    \"\"\"\n    # Initialize an empty list to store the rows of the array\n    array = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Initialize an empty list to store the columns of the current row\n        row = []\n        \n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append a default value (e.g., 0) to the current row\n            row.append(0)\n        \n        # Append the current row to the array\n        array.append(row)\n    \n    # Return the generated array\n    return array"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists by a given index of the inner list.\n\n    Args:\n        list_data (list): A list of lists to be sorted.\n        index_no (int): The index of the inner list to sort by.\n\n    Returns:\n        list: The sorted list of lists.\n    \"\"\"\n    return sorted(list_data, key=lambda x: x[index_no])"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    \"\"\"\n    This function calculates the number of rotations in a circularly sorted array.\n\n    Args:\n        A (list): A list of integers representing the circularly sorted array.\n\n    Returns:\n        int: The number of rotations in the array.\n    \"\"\"\n    n = len(A)\n    low, high = 0, n - 1\n\n    # Perform binary search\n    while low < high:\n        mid = (low + high) // 2\n        if A[mid] > A[high]:\n            # If the middle element is greater than the last element, \n            # the rotation point must be in the right half\n            low = mid + 1\n        else:\n            # If the middle element is not greater than the last element, \n            # the rotation point must be in the left half\n            high = mid\n\n    # At this point, low and high are the same, which is the rotation point\n    return low"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    This function takes an integer as input, toggles all odd bits and returns the result.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The integer with all odd bits toggled.\n    \"\"\"\n    # Initialize result as 0\n    result = 0\n    \n    # Iterate over each bit in the input number\n    for i in range(32):  # Assuming 32-bit integer\n        # Check if the current bit is odd\n        if (n >> i) & 1:\n            # If the bit is odd, toggle it by XORing with 1\n            result |= 1 << i\n        else:\n            # If the bit is even, keep it as it is\n            pass\n    \n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the smallest value in the array\n    smallest = min(arr)\n\n    # Count the frequency of the smallest value\n    count = arr.count(smallest)\n\n    return count"}
{"id": "374_0", "code": "def get_perrin(n):\n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    elif n == 3:\n        return 2\n\n    # Recursive case\n    else:\n        return get_perrin(n-1) + get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    \"\"\"\n    This function calculates the minimum number of swaps required to balance the brackets in a given string.\n    \n    Parameters:\n    s (str): The input string containing brackets.\n    \n    Returns:\n    int: The minimum number of swaps required to balance the brackets.\n    \"\"\"\n    # Initialize variables to store the count of opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Initialize a variable to store the minimum number of swaps\n    min_swaps = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is an opening bracket, increment the open_count\n        if char == '(':\n            open_count += 1\n        # If the character is a closing bracket, increment the close_count\n        elif char == ')':\n            close_count += 1\n            # If the close_count is greater than the open_count, it means there is an extra closing bracket\n            if close_count > open_count:\n                # Increment the min_swaps by the difference between close_count and open_count\n                min_swaps += close_count - open_count\n                # Reset the close_count to 0\n                close_count = 0\n            # If the close_count is not greater than the open_count, it means we have a balanced pair of brackets\n            else:\n                # Decrement the close_count\n                close_count -= 1\n    \n    # Return the minimum number of swaps\n    return min_swaps"}
{"id": "376_0", "code": "def even_or_odd(N):\n    \"\"\"\n    This function checks whether a given hexadecimal number is even or odd.\n\n    Parameters:\n    N (str): A hexadecimal number as a string.\n\n    Returns:\n    str: 'even' if the number is even, 'odd' if the number is odd.\n    \"\"\"\n    # Convert the hexadecimal number to decimal\n    decimal_N = int(N, 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal_N % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'"}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function calculates the highest power of 2 that is less than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep doubling the power of 2 until it exceeds n\n    while power_of_2 <= n:\n        # Double the power of 2\n        power_of_2 *= 2\n    \n    # The highest power of 2 that is less than or equal to n is the previous power of 2\n    return power_of_2 // 2"}
{"id": "378_0", "code": "def find_lucas(n):\n    \"\"\"\n    This function calculates the nth Lucas number.\n    \n    Args:\n        n (int): The position of the Lucas number to be calculated.\n    \n    Returns:\n        int: The nth Lucas number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input should be a positive integer.\")\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b"}
{"id": "379_0", "code": "def add_string(lst, string):\n    \"\"\"\n    Inserts a given string at the beginning of all items in a list.\n\n    Args:\n        lst (list): The input list.\n        string (str): The string to be inserted.\n\n    Returns:\n        list: The modified list with the string inserted at the beginning of each item.\n    \"\"\"\n    return [string + item for item in lst]"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a nested dictionary.\n    \n    Args:\n        l1 (list): The first list to be converted.\n        l2 (list): The second list to be converted.\n        l3 (list): The third list to be converted.\n    \n    Returns:\n        dict: A nested dictionary with the input lists as keys.\n    \"\"\"\n    # Initialize an empty dictionary to store the result\n    result = {}\n    \n    # Iterate over the first list\n    for i, val in enumerate(l1):\n        # Create a new dictionary for each value in the first list\n        result[val] = {}\n        \n        # Iterate over the second list\n        for j, val2 in enumerate(l2):\n            # Create a new dictionary for each value in the second list\n            result[val][val2] = {}\n            \n            # Iterate over the third list\n            for k, val3 in enumerate(l3):\n                # Add the value from the third list to the current dictionary\n                result[val][val2][val3] = val * val2 * val3\n    \n    # Return the resulting dictionary\n    return result"}
{"id": "381_0", "code": "def get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 1:\n            return x\n        max_sum = 0\n        for i in [2, 3, 4, 5]:\n            if x % i == 0:\n                max_sum = max(max_sum, f(x // i) + f(i))\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    \"\"\"\n    This function checks if the given tuple is distinct or not.\n    \n    Args:\n        test_tup (tuple): The tuple to be checked for distinctness.\n    \n    Returns:\n        bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set\n    set_tup = set(test_tup)\n    \n    # Compare the length of the original tuple and the set\n    # If they are equal, it means all elements are distinct\n    return len(test_tup) == len(set_tup)"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    \"\"\"\n    This function finds the first non-repeating character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The first non-repeating character in the string. If no such character exists, returns None.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over the string to count the frequency of each character\n    for char in str1:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Iterate over the string again to find the first non-repeating character\n    for char in str1:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    \"\"\"\n    This function checks whether the given string starts and ends with the same character or not.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string starts and ends with the same character, False otherwise.\n    \"\"\"\n    \n    # Compile a regex pattern that matches the start and end of the string with the same character\n    pattern = re.compile(r'^([a-zA-Z])\\1$')\n    \n    # Use the pattern to match the string\n    match = pattern.match(string)\n    \n    # If the string matches the pattern, return True; otherwise, return False\n    return match is not None"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    \"\"\"\n    This function calculates the median of three numbers.\n\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    c (float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n    \"\"\"\n    # First, we need to sort the three numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Then, we find the middle number(s)\n    middle_index = len(numbers) // 2\n    \n    # If the length of the numbers list is odd, the median is the middle number\n    if len(numbers) % 2 != 0:\n        median = numbers[middle_index]\n    # If the length of the numbers list is even, the median is the average of the two middle numbers\n    else:\n        median = (numbers[middle_index - 1] + numbers[middle_index]) / 2\n    \n    return median"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    \"\"\"\n    This function calculates the sum of digits of each number in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of sums of digits of each number in the input list.\n    \"\"\"\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the bitwise XOR operation across the given tuples.\n    \n    Args:\n        test_tup1 (tuple): The first tuple to perform the XOR operation on.\n        test_tup2 (tuple): The second tuple to perform the XOR operation on.\n    \n    Returns:\n        tuple: A new tuple containing the result of the XOR operation between the two input tuples.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the input tuples\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        # Perform the bitwise XOR operation on the current elements\n        xor_result = elem1 ^ elem2\n        \n        # Append the result to the list\n        result.append(xor_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "389_0", "code": "from collections import Counter\n\ndef extract_freq(test_list):\n    # Convert the list to a set to remove duplicates and convert each element to a tuple\n    unique_tuples = set(tuple(sorted(x)) for x in test_list)\n    \n    # Use the Counter class to count the frequency of each unique tuple\n    freq_dict = Counter(unique_tuples)\n    \n    # Return the frequency dictionary\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise addition of tuple elements in the given two nested tuples.\n\n    Args:\n        test_tup1 (tuple): The first nested tuple.\n        test_tup2 (tuple): The second nested tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise addition of the elements in the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the input tuples\n    for i in range(len(test_tup1)):\n        # Check if the current elements are tuples themselves\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function for the nested tuples\n            nested_result = add_nested_tuples(test_tup1[i], test_tup2[i])\n            # Append the result to the main result list\n            result.append(nested_result)\n        else:\n            # Check if the current elements are numbers\n            if isinstance(test_tup1[i], (int, float)) and isinstance(test_tup2[i], (int, float)):\n                # Perform the addition and append the result to the list\n                result.append(test_tup1[i] + test_tup2[i])\n            else:\n                # If the elements are not numbers, raise a ValueError\n                raise ValueError(\"All elements in the input tuples must be numbers\")\n\n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    Args:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The prime number.\n\n    Returns:\n    int: The value of ncr%p.\n    \"\"\"\n    # Initialize the result\n    res = 1\n    \n    # Calculate the binomial coefficient\n    for i in range(r):\n        res = (res * (n - i)) % p\n        res = (res * pow(i + 1, p - 2, p)) % p\n    \n    return res"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    \"\"\"\n    Checks if a given URL is valid or not using regex.\n\n    Args:\n        str (str): The URL to be checked.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"\n    # Regular expression pattern for a valid URL\n    pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    # Check if the URL matches the pattern\n    return bool(pattern.match(str))"}
{"id": "393_0", "code": "def minimum(a,b):\n    \"\"\"\n    This function calculates the minimum of two numbers.\n\n    Args:\n        a (float): The first number.\n        b (float): The second number.\n\n    Returns:\n        float: The minimum of a and b.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be searched.\n        tuple1 (tuple): The tuple to be searched in.\n\n    Returns:\n        bool: True if the element exists, False otherwise.\n    \"\"\"\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    \"\"\"\n    This function calculates the parity of a given number.\n    \n    Parameters:\n    x (int): The number to find the parity of.\n    \n    Returns:\n    str: The parity of the number ('Even' or 'Odd').\n    \"\"\"\n    if x % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Find the first pair of digits from the right that are in increasing order\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            break\n    else:\n        # If no such pair is found, the number is already the biggest possible\n        return n\n    \n    # Find the smallest digit to the right of the pair that is greater than the first digit of the pair\n    for j in range(len(digits) - 1, i, -1):\n        if digits[j] > digits[i]:\n            break\n    \n    # Swap the two digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the pair in increasing order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number and return it\n    return int(''.join(map(str, digits)))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    \"\"\"\n    Returns the k smallest pairs of elements from two sorted arrays.\n\n    Args:\n    nums1 (list): The first sorted array.\n    nums2 (list): The second sorted array.\n    k (int): The number of pairs to return.\n\n    Returns:\n    list: A list of tuples, where each tuple contains a pair of elements from the input arrays.\n    \"\"\"\n    # Initialize the result list\n    result = []\n    \n    # Initialize the indices for both arrays\n    i, j = 0, 0\n    \n    # Loop until we have found k pairs or we have exhausted both arrays\n    while len(result) < k and i < len(nums1) and j < len(nums2):\n        # Calculate the sum of the current elements in both arrays\n        sum_ij = nums1[i] + nums2[j]\n        \n        # Add the pair to the result list\n        result.append((sum_ij, nums1[i], nums2[j]))\n        \n        # Move to the next element in the array with the smaller sum\n        if sum_ij < nums1[i] + nums2[j + 1]:\n            j += 1\n        else:\n            i += 1\n    \n    # Return the k smallest pairs\n    return [pair[1:] for pair in result[:k]]"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    \"\"\"\n    This function finds the minimum product from the pairs of tuples within a given list.\n    \n    Parameters:\n    list1 (list): A list of tuples.\n    \n    Returns:\n    int: The minimum product from the pairs of tuples.\n    \"\"\"\n    \n    # Initialize the minimum product as infinity\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for i in range(len(list1)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = list1[i][0] * list1[j][0]\n            \n            # Update the minimum product if the current product is smaller\n            min_product = min(min_product, product)\n    \n    # Return the minimum product\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    \"\"\"\n    This function finds the minimum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The minimum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"Input list is empty\")\n    return min(listval)"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    \"\"\"\n    Convert a snake case string to camel case string.\n\n    Args:\n        word (str): The input snake case string.\n\n    Returns:\n        str: The converted camel case string.\n    \"\"\"\n    # Split the word into words by underscore\n    words = re.split('_+', word)\n    \n    # Capitalize the first letter of each word except the first word\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words into a single string\n    camel_case = ''.join(words)\n    \n    return camel_case"}
{"id": "401_0", "code": "def remove_odd(l):\n    \"\"\"\n    This function removes all odd numbers from a given list.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A new list containing only the even numbers from the original list.\n    \"\"\"\n    return [i for i in l if i % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    \"\"\"\n    This function extracts the nth element from a given list of tuples.\n\n    Args:\n        list1 (list): A list of tuples.\n        n (int): The position of the element to be extracted.\n\n    Returns:\n        The nth element from the list of tuples. If n is out of range, returns None.\n    \"\"\"\n    # Check if n is within the valid range\n    if n < 1 or n > len(list1):\n        return None\n    \n    # Extract the nth element\n    nth_element = list1[n - 1]\n    \n    return nth_element"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    \"\"\"\n    This function checks if two lists are overlapping or not.\n    \n    Args:\n        list1 (list): The first list to check.\n        list2 (list): The second list to check.\n    \n    Returns:\n        bool: True if the lists are overlapping, False otherwise.\n    \"\"\"\n    # Check if the second list is a subset of the first list\n    return set(list2).issubset(set(list1))"}
{"id": "404_0", "code": "def max_Product(arr):\n    \"\"\"\n    This function finds the pair with the highest product in a given array of integers.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The highest product of a pair of integers in the array.\n    \"\"\"\n    \n    # First, we sort the array in ascending order\n    arr.sort()\n    \n    # The highest product can be either the product of the two largest numbers or the product of the two smallest numbers\n    # We calculate both possibilities\n    highest_product = max(arr[-1] * arr[-2], arr[0] * arr[1])\n    \n    return highest_product"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than 3, return n\n    if n < 3:\n        return n\n\n    # Recursive case: try dividing n into three parts\n    max_sum = float('-inf')\n    for i in range(1, n // 3 + 1):\n        # Calculate the sum of the three parts\n        sum1 = i\n        sum2 = n - i - 1\n        sum3 = n - i - sum2\n        # Recursively find the maximum sum for each part\n        sum1 += breakSum(sum1)\n        sum2 += breakSum(sum2)\n        sum3 += breakSum(sum3)\n        # Update the maximum sum\n        max_sum = max(max_sum, sum1 + sum2 + sum3)\n\n    return max_sum"}
{"id": "406_0", "code": "def group_tuples(Input):\n    \"\"\"\n    This function takes a list of tuples as input and returns a dictionary where the keys are the common first elements of the tuples and the values are lists of tuples that have that common first element.\n\n    Args:\n        Input (list): A list of tuples.\n\n    Returns:\n        dict: A dictionary where the keys are the common first elements of the tuples and the values are lists of tuples that have that common first element.\n    \"\"\"\n    result = {}\n    for tup in Input:\n        first_element = tup[0]\n        if first_element in result:\n            result[first_element].append(tup)\n        else:\n            result[first_element] = [tup]\n    return result"}
{"id": "407_0", "code": "def Find_Max(lst):\n    \"\"\"\n    This function finds the sublist having maximum length in a given list.\n    \n    Parameters:\n    lst (list): The input list containing sublists.\n    \n    Returns:\n    list: The sublist with maximum length.\n    \"\"\"\n    # Initialize max_length and max_sublist variables\n    max_length = 0\n    max_sublist = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Check if the length of the current sublist is greater than max_length\n        if len(sublist) > max_length:\n            # Update max_length and max_sublist\n            max_length = len(sublist)\n            max_sublist = sublist\n    \n    # Return the sublist with maximum length\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    # Initialize sum variable to zero\n    total_sum = 0\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Round the number to two decimal places\n        rounded_num = round(num, 2)\n        \n        # Add the rounded number to the total sum\n        total_sum += rounded_num\n    \n    # Calculate the product of the total sum and the length of the list\n    product = total_sum * len(list1)\n    \n    # Print the product\n    print(product)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    \"\"\"\n    This function calculates the cube sum of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The cube sum of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    cube_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the cube of the current number\n        cube = i ** 3\n        # Add the cube to the sum\n        cube_sum += cube\n    \n    # Return the cube sum\n    return cube_sum"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    \"\"\"\n    Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        test_tup (tuple): The input tuple to be concatenated.\n\n    Returns:\n        str: A string containing the concatenated elements of the tuple.\n    \"\"\"\n    delimiter = ', '  # Define the delimiter\n    concatenated_str = delimiter.join(map(str, test_tup))  # Convert elements to string and join them with the delimiter\n    return concatenated_str"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to consider.\n    \n    Returns:\n    float: The average of cubes of first n natural numbers.\n    \"\"\"\n    # Initialize sum variable to store the sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing the sum by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    \"\"\"\n    This function calculates the maximum gold that can be obtained from a 2D grid of gold mines.\n    \n    Parameters:\n    gold (list): A 2D list representing the grid of gold mines.\n    m (int): The number of rows in the grid.\n    n (int): The number of columns in the grid.\n    \n    Returns:\n    int: The maximum gold that can be obtained.\n    \"\"\"\n    \n    # Create a 2D list to store the maximum gold that can be obtained at each position\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp table\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill in the rest of the dp table\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum gold that can be obtained at this position is the maximum of the gold above it, to its left, and to its top-left, plus the gold at this position\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be obtained is stored in the bottom-right corner of the dp table\n    return dp[m-1][n-1]"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    \"\"\"\n    This function takes a tuple of strings as input and returns a tuple of the rear index element of each string.\n\n    Args:\n        test_tuple (tuple): A tuple of strings.\n\n    Returns:\n        tuple: A tuple of the rear index element of each string.\n    \"\"\"\n    return tuple(string[-1] for string in test_tuple)"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    \"\"\"\n    This function counts the number of sublists containing a particular element in a given list.\n\n    Args:\n        list1 (list): The input list.\n        x (any): The element to be searched.\n\n    Returns:\n        int: The number of sublists containing the element x.\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Define the regex pattern\n    pattern = r\"(\\d{4})-(\\d{2})-(\\d{2})\"\n    # Use the regex pattern to extract the year, month and day\n    year, month, day = re.match(pattern, dt).groups()\n    # Convert the month and day to two digits\n    month = month.zfill(2)\n    day = day.zfill(2)\n    # Return the date in dd-mm-yyyy format\n    return f\"{day}-{month}-{year}\""}
{"id": "417_0", "code": "def shell_sort(my_list):\n    \"\"\"\n    Sorts the given list using shell sort algorithm.\n\n    Args:\n        my_list (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(my_list) // 2\n\n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Iterate over the list starting from the gap size\n        for i in range(gap, len(my_list)):\n            # Store the current element\n            temp = my_list[i]\n            # Initialize the index for the previous gap\n            j = i\n            # Shift the previous elements to the right until a smaller element is found\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            # Place the current element at its correct position\n            my_list[j] = temp\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n\n    # Return the sorted list\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a list of tuples.\n    Each tuple in the list contains an element from the first tuple and an element from the second tuple.\n    \n    Parameters:\n    test_tup1 (tuple): The first tuple.\n    test_tup2 (tuple): The second tuple.\n    \n    Returns:\n    list: A list of tuples, where each tuple contains an element from the first tuple and an element from the second tuple.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    # Use the zip function to create an iterator of tuples, where the first item in each tuple is from the first tuple and the second item is from the second tuple\n    zipped = zip(test_tup1, test_tup2)\n    \n    # Convert the iterator to a list of tuples\n    result = list(zipped)\n    \n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    \"\"\"\n    This function calculates the directrix of a parabola given its coefficients a, b, and c.\n    \n    Parameters:\n    a (float): The coefficient of x^2 in the parabola equation.\n    b (float): The coefficient of x in the parabola equation.\n    c (float): The constant term in the parabola equation.\n    \n    Returns:\n    float: The equation of the directrix of the parabola in the form y = mx + b.\n    \"\"\"\n    \n    # Calculate the focal parameter p\n    p = (b**2) / (4 * a)\n    \n    # Calculate the directrix equation\n    directrix = f\"y = -1/{a}x - {p/a}\"\n    \n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2)) > 0"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    \"\"\"\n    Calculate the median of a trapezium.\n\n    Parameters:\n    base1 (float): The length of the first base of the trapezium.\n    base2 (float): The length of the second base of the trapezium.\n    height (float): The height of the trapezium.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n\n    # Calculate the height of the trapezium\n    trapezium_height = (2 * area) / (base1 + base2)\n\n    # Calculate the median of the trapezium\n    median = 0.5 * (base1 + base2) + trapezium_height\n\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    \"\"\"\n    This function checks if the given number is greater than all elements in the array.\n\n    Parameters:\n    arr (list): A list of numbers\n    number (int): The number to be checked\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise\n    \"\"\"\n    # Check if the input array is empty\n    if not arr:\n        return True  # If the array is empty, the number is greater than all elements\n\n    # Iterate over each element in the array\n    for element in arr:\n        # If the number is not greater than any element, return False\n        if number <= element:\n            return False\n\n    # If the function hasn't returned False, the number is greater than all elements\n    return True"}
{"id": "423_0", "code": "import re\n\ndef text_match_one(text):\n    \"\"\"\n    This function matches a string that has an 'a' followed by one or more 'b's.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^a[b]+$'\n    return bool(re.match(pattern, text))"}
{"id": "424_0", "code": "def last_Digit(n):\n    \"\"\"\n    This function calculates the last digit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The last digit of the input number.\n    \"\"\"\n    # Calculate the remainder of n when divided by 10\n    # This will give us the last digit of the number\n    last_digit = n % 10\n    \n    # Return the last digit\n    return last_digit"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for i in list1:\n        if i < 0:\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    \"\"\"\n    This function removes all odd-indexed characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all odd-indexed characters removed.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(str1) if index % 2 == 0])"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    \"\"\"\n    This function counts the number of bidirectional tuple pairs in a given list.\n    \n    Args:\n        test_list (list): A list of tuples.\n    \n    Returns:\n        int: The number of bidirectional tuple pairs.\n    \"\"\"\n    # Initialize a variable to store the count of bidirectional tuple pairs\n    count = 0\n    \n    # Iterate over each tuple in the list\n    for i in range(len(test_list)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(test_list)):\n            # Check if the current tuple is a subset of the other tuple\n            if set(test_list[i]).issubset(set(test_list[j])) and set(test_list[j]).issubset(set(test_list[i])):\n                # If the current tuple is a subset of the other tuple, increment the count\n                count += 1\n    \n    # Return the count of bidirectional tuple pairs\n    return count"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    \"\"\"\n    This function takes a list of integers as input and returns a single integer.\n    The integers in the list are concatenated to form a single integer.\n    \n    Parameters:\n    L (list): A list of integers.\n    \n    Returns:\n    int: A single integer formed by concatenating the integers in the list.\n    \"\"\"\n    # Convert each integer in the list to a string\n    str_L = [str(i) for i in L]\n    \n    # Concatenate the strings in the list\n    concatenated_str = ''.join(str_L)\n    \n    # Convert the concatenated string back to an integer\n    result = int(concatenated_str)\n    \n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    This function finds all adverbs and their positions in a given sentence.\n\n    Args:\n        text (str): The input sentence.\n\n    Returns:\n        dict: A dictionary where keys are adverbs and values are their positions.\n    \"\"\"\n    # Define a list of adverbs\n    adverbs = ['very', 'well', 'well', 'really', 'so', 'just', 'already', 'just', 'really', 'already']\n\n    # Initialize an empty dictionary to store adverb positions\n    adverb_positions = {}\n\n    # Split the text into words\n    words = text.split()\n\n    # Iterate over each word in the text\n    for i, word in enumerate(words):\n        # Check if the word is an adverb\n        if word.lower() in adverbs:\n            # If the word is an adverb, add it to the dictionary with its position\n            adverb_positions[word] = i\n\n    # Return the dictionary of adverb positions\n    return adverb_positions\n\n# Example usage:\ntext = \"I am going to the store very quickly and I will buy some milk already.\"\nprint(find_adverb_position(text))"}
{"id": "430_0", "code": "def surfacearea_cube(length):\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Args:\n        length (float): The length of the cube.\n\n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    # Calculate the surface area of the cube\n    surface_area = 6 * (length ** 2)\n    return surface_area"}
{"id": "431_0", "code": "def positive_count(nums):\n    \"\"\"\n    This function calculates the ratio of positive numbers in a given list of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of positive numbers in the list.\n\n    Raises:\n        ZeroDivisionError: If the list is empty.\n    \"\"\"\n    # Count the total number of positive numbers in the list\n    positive_count = sum(1 for num in nums if num > 0)\n    \n    # Calculate the ratio of positive numbers\n    if len(nums) == 0:\n        raise ZeroDivisionError(\"Cannot calculate ratio for an empty list\")\n    else:\n        ratio = positive_count / len(nums)\n    \n    return ratio"}
{"id": "432_0", "code": "def largest_neg(list1):\n    \"\"\"\n    This function finds the largest negative number from the given list.\n\n    Args:\n        list1 (list): A list of integers.\n\n    Returns:\n        int: The largest negative number in the list. If no negative number is found, returns None.\n    \"\"\"\n    # Initialize max_neg to negative infinity\n    max_neg = float('-inf')\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Check if the number is negative and greater than max_neg\n        if num < 0 and num > max_neg:\n            # Update max_neg\n            max_neg = num\n    \n    # If max_neg is still negative infinity, return None\n    if max_neg == float('-inf'):\n        return None\n    else:\n        # Return the largest negative number\n        return max_neg"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    \"\"\"\n    This function trims each tuple in the given list by K elements from the beginning and end.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to trim from the beginning and end of each tuple.\n\n    Returns:\n        list: A list of trimmed tuples.\n    \"\"\"\n    trimmed_list = []\n    for tup in test_list:\n        # Trim the tuple by K elements from the beginning\n        trimmed_tup = tup[K:]\n        # Trim the tuple by K elements from the end\n        trimmed_tup = trimmed_tup[:-K]\n        trimmed_list.append(trimmed_tup)\n    return trimmed_list"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise multiplication.\n\n    Raises:\n        ValueError: If the lengths of the two tuples are not equal.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The lengths of the two tuples must be equal.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function counts the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list to search for.\n\n    Returns:\n    dict: A dictionary where the keys are the elements of the list and the values are their occurrences in the tuple.\n    \"\"\"\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n\n    # Iterate over each element in the list\n    for elem in lst:\n        # Initialize a counter for the current element\n        count = 0\n        # Iterate over each element in the tuple\n        for tup_elem in tup:\n            # If the current element in the tuple is equal to the current element in the list, increment the counter\n            if tup_elem == elem:\n                count += 1\n        # Store the count in the dictionary\n        occurrences[elem] = count\n\n    # Return the dictionary of occurrences\n    return occurrences"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth number.\n\n    Args:\n    n (int): The number of Perrin numbers to sum.\n\n    Returns:\n    int: The sum of the first n Perrin numbers.\n    \"\"\"\n    # Initialize the first three Perrin numbers\n    p1, p2, p3 = 0, 1, 2\n    \n    # Initialize the sum of Perrin numbers\n    total_sum = p1 + p2 + p3\n    \n    # Calculate the sum of the remaining Perrin numbers\n    for _ in range(3, n):\n        # Calculate the next Perrin number\n        p1, p2, p3 = p2, p3, p1 + p2 + p3\n        \n        # Add the new Perrin number to the total sum\n        total_sum += p3\n    \n    return total_sum"}
{"id": "438_0", "code": "def check_Triangle(x1,y1,x2,y2,x3,y3):\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n    b = ((x3 - x2)**2 + (y3 - y2)**2)**0.5\n    c = ((x1 - x3)**2 + (y1 - y3)**2)**0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "439_0", "code": "def extract_string(str, length):\n    \"\"\"\n    Extract specified size of strings from a given list of string values.\n\n    Args:\n        str (list): A list of string values.\n        length (int): The desired length of the extracted strings.\n\n    Returns:\n        list: A list of extracted strings of specified length.\n    \"\"\"\n    extracted_strings = []\n    for s in str:\n        if len(s) >= length:\n            extracted_strings.append(s[:length])\n    return extracted_strings"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    \"\"\"\n    This function removes all whitespaces from the given string using regex.\n\n    Args:\n        text1 (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    # Use regex to replace all whitespaces with an empty string\n    text_without_whitespaces = re.sub(r'\\s', '', text1)\n    return text_without_whitespaces"}
{"id": "441_0", "code": "def loss_amount(actual_cost,sale_amount):\n    if actual_cost > sale_amount:\n        loss = actual_cost - sale_amount\n        return loss\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n    \n    Parameters:\n    n (int): The number for which the sum of even factors is to be calculated.\n    \n    Returns:\n    int: The sum of even factors of the given number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    sum_even_factors = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if i is an even factor\n            if i % 2 == 0:\n                # Add i to the sum of even factors\n                sum_even_factors += i\n    \n    # Return the sum of even factors\n    return sum_even_factors"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    \"\"\"\n    This function matches a word containing 'z' in the given text.\n\n    Args:\n        text (str): The input text to search for words containing 'z'.\n\n    Returns:\n        list: A list of words containing 'z' from the input text.\n    \"\"\"\n    # Split the input text into words\n    words = text.split()\n\n    # Initialize an empty list to store the matching words\n    matching_words = []\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word contains 'z'\n        if 'z' in word.lower():\n            # If the word contains 'z', add it to the list of matching words\n            matching_words.append(word)\n\n    # Return the list of matching words\n    return matching_words"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    month_days = {\n        1: 31,\n        2: 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    if monthnum2 in month_days:\n        if month_days[monthnum2] == 31:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month number\""}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    \"\"\"\n    This function takes a list of strings as input, reverses each string in the list, \n    and returns the resulting list of reversed strings.\n\n    Args:\n        stringlist (list): A list of strings to be reversed.\n\n    Returns:\n        list: A list of reversed strings.\n    \"\"\"\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in stringlist:\n        # Reverse the current string using slicing and append it to the reversed list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    \"\"\"\n    This function finds the sublist with the minimum length in a given list of lists.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The sublist with the minimum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    min_len = min(len(sublist) for sublist in lst)\n    min_sublist = next(sublist for sublist in lst if len(sublist) == min_len)\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(l, b):\n    \"\"\"\n    This function calculates the area of a rectangle.\n\n    Parameters:\n    l (float): The length of the rectangle.\n    b (float): The breadth of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    area = l * b\n    return area"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    \"\"\"\n    This function removes uppercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string.\n    \n    Returns:\n    str: The string with uppercase substrings removed.\n    \"\"\"\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    str2 = re.sub(r'[A-Z]+', '', str1)\n    return str2"}
{"id": "449_0", "code": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    \"\"\"\n    This function counts the number of upper case characters in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The number of upper case characters in the string.\n    \"\"\"\n    return sum(1 for char in str if char.isupper())"}
{"id": "451_0", "code": "import itertools\n\ndef combinations_list(list1):\n    # Generate all possible combinations of the elements of the list\n    all_combinations = list(itertools.chain(*itertools.combinations(list1, r) for r in range(1, len(list1) + 1)))\n    \n    return all_combinations"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    \"\"\"\n    This function finds the maximum product subarray of the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum product of a subarray.\n\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    \"\"\"\n    This function checks if all values in a dictionary are the same.\n\n    Parameters:\n    dict (dict): The dictionary to be checked.\n    n (int): The expected value.\n\n    Returns:\n    bool: True if all values are the same, False otherwise.\n    \"\"\"\n    # Get the values from the dictionary\n    values = list(dict.values())\n    \n    # Check if the length of the values list is 1\n    # If it is, then all values are the same\n    if len(values) == 1:\n        return True\n    else:\n        # If the length is not 1, check if all values are equal to the first value\n        return all(value == values[0] for value in values)"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    \"\"\"\n    Drops empty items from a given dictionary.\n\n    Args:\n        dict1 (dict): The dictionary to process.\n\n    Returns:\n        dict: The dictionary with empty items dropped.\n    \"\"\"\n    return {key: value for key, value in dict1.items() if value}"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    \"\"\"\n    This function finds the peak element in the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    \n    Returns:\n    int: The index of the peak element in the array.\n    \"\"\"\n    \n    # Initialize the low and high pointers\n    low = 0\n    high = n - 1\n    \n    # Continue the loop until low and high pointers meet\n    while low < high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is smaller than the next element, \n        # then the peak element must be on the right side\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        # If the middle element is greater than the next element, \n        # then the peak element must be on the left side\n        else:\n            high = mid\n    \n    # At this point, low and high pointers are pointing to the same index, \n    # which is the index of the peak element\n    return low"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    \"\"\"\n    This function converts a decimal number to octal number.\n    \n    Parameters:\n    deciNum (int): The decimal number to be converted.\n    \n    Returns:\n    str: The octal representation of the decimal number.\n    \"\"\"\n    # Use built-in function oct() to convert decimal to octal\n    octalNum = oct(deciNum)\n    \n    # Remove the '0o' prefix added by the oct() function\n    octalNum = octalNum[2:]\n    \n    return octalNum"}
{"id": "457_0", "code": "def max_product(arr, n):\n    # Initialize a list to store the maximum product ending at each position\n    max_product_ending_here = [0]*n\n    # Initialize a list to store the maximum product of the entire array\n    max_product_entire_array = [0]*n\n    # Initialize the maximum product ending at the first position as the first element of the array\n    max_product_ending_here[0] = arr[0]\n    # Initialize the maximum product of the entire array as the first element of the array\n    max_product_entire_array[0] = arr[0]\n    # Iterate over the array starting from the second position\n    for i in range(1, n):\n        # Initialize the maximum product ending at the current position as negative infinity\n        max_product_ending_here[i] = float('-inf')\n        # Iterate over the previous positions\n        for j in range(i):\n            # If the current element is greater than the product of the previous element and the maximum product ending at the previous position\n            if arr[i] > arr[j] * max_product_ending_here[j]:\n                # Update the maximum product ending at the current position\n                max_product_ending_here[i] = max(max_product_ending_here[i], arr[i] * max_product_ending_here[j])\n        # Update the maximum product of the entire array\n        max_product_entire_array[i] = max(max_product_ending_here[i], max_product_entire_array[i-1] * arr[i])\n    # Return the maximum product of the entire array\n    return max_product_entire_array[-1]"}
{"id": "458_0", "code": "def max_profit(price, k):\n    \"\"\"\n    This function calculates the maximum possible profit from buying and selling a stock at most k times.\n\n    Parameters:\n    price (list): A list of stock prices for each day.\n    k (int): The maximum number of transactions allowed.\n\n    Returns:\n    int: The maximum possible profit.\n    \"\"\"\n    if not price or k == 0:\n        return 0\n\n    n = len(price)\n    if k >= n // 2:\n        return sum(max(0, b - a) for a, b in zip(price, price[1:]))\n\n    # Initialize a 2D array to store the maximum profit for each subproblem\n    dp = [[0] * n for _ in range(k + 1)]\n\n    # Iterate over each transaction\n    for i in range(1, k + 1):\n        # Initialize the maximum profit for the current transaction\n        max_profit_for_current_transaction = -price[0]\n        # Iterate over each day\n        for j in range(1, n):\n            # Update the maximum profit for the current transaction\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_profit_for_current_transaction)\n            # Update the maximum profit for the current transaction if we sell on the current day\n            max_profit_for_current_transaction = max(max_profit_for_current_transaction, dp[i - 1][j] - price[j])\n\n    # Return the maximum profit for the last transaction\n    return dp[k][n - 1]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    \"\"\"\n    This function calculates the pairwise addition of the elements of the given tuples.\n\n    Args:\n        test_tup (tuple): A tuple containing multiple tuples.\n\n    Returns:\n        list: A list of sums of each pair of elements from the input tuples.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            # Calculate the sum of the current pair of elements\n            pair_sum = sum(test_tup[i]) + sum(test_tup[j])\n            # Append the sum to the result list\n            result.append(pair_sum)\n    return result"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    \"\"\"\n    This function calculates the remainder of the product of all elements in the array\n    divided by the given number n.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    lens (int): The length of the array.\n    n (int): The divisor.\n\n    Returns:\n    int: The remainder of the product of all elements in the array divided by n.\n    \"\"\"\n    # Initialize the product variable to 1\n    product = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current element with the product\n        product *= arr[i]\n    \n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    \n    # Return the remainder\n    return remainder"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    # Sort the list in ascending order\n    l.sort()\n    \n    # Initialize a variable to store the previous number\n    prev_num = l[0]\n    \n    # Iterate over the list starting from the second number\n    for num in l[1:]:\n        # If the difference between the current number and the previous number is not 1, return False\n        if num - prev_num != 1:\n            return False\n        # Update the previous number\n        prev_num = num\n    \n    # If the function hasn't returned False, it means the list contains consecutive numbers, so return True\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert the tuples to sets\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the intersection back to a tuple\n    result = tuple(intersection)\n\n    return result"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    \"\"\"\n    Replaces all occurrences of a character in a string with a new character.\n\n    Args:\n        str1 (str): The original string.\n        ch (str): The character to be replaced.\n        newch (str): The new character to replace with.\n\n    Returns:\n        str: The modified string with all occurrences of 'ch' replaced with 'newch'.\n    \"\"\"\n    return str1.replace(ch,newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    \"\"\"\n    Sorts a dictionary by its values in descending order.\n\n    Args:\n        dict1 (dict): The dictionary to be sorted.\n\n    Returns:\n        dict: A new dictionary sorted by its values in descending order.\n    \"\"\"\n    # Use the sorted function to sort the dictionary items by their values\n    sorted_items = sorted(dict1.items(), key=lambda item: item[1], reverse=True)\n    \n    # Use dictionary comprehension to create a new dictionary with the sorted items\n    sorted_dict = {k: v for k, v in sorted_items}\n    \n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    \"\"\"\n    This function calculates the sum of the largest and smallest value in a given array.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of the largest and smallest value in the array.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    return nums[0] + nums[-1]"}
{"id": "466_0", "code": "def is_lower(string):\n    \"\"\"\n    This function converts the given string to lower case.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return string.lower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str1)):\n        if str1[i].isupper():\n            result += str1[i]\n        elif str1[i].islower():\n            if i > 0 and str1[i-1].isupper():\n                result += str1[i]\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    # Convert the number to a string to easily access individual digits\n    str_n = str(n)\n    \n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If negative, return the first digit (which is the negative sign)\n        return int(str_n[0])\n    else:\n        # If positive, return the first digit\n        return int(str_n[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    \"\"\"\n    This function finds the maximum occurring character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The maximum occurring character in the string.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n\n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n\n    # Find the character with the maximum frequency\n    max_char = max(char_frequency, key=char_frequency.get)\n\n    # Return the maximum occurring character\n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Create a table to store results of subproblems\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n\n    # Initialize the first row and column\n    dp[0][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                # Choose the maximum of including and excluding the current element\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The answer is stored in the last cell of the table\n    return dp[n][sum]"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    \"\"\"\n    This function finds sequences of one upper case letter followed by lower case letters in the given string.\n\n    Parameters:\n    text (str): The input string to search for the pattern.\n\n    Returns:\n    list: A list of tuples, where each tuple contains the start and end indices of a match.\n    \"\"\"\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return [(m.start(), m.end()) for m in matches]"}
{"id": "472_0", "code": "import math\n\ndef first_Factorial_Divisible_Number(x):\n    \"\"\"\n    This function finds the first natural number whose factorial is divisible by x.\n    \n    Parameters:\n    x (int): The number by which the factorial should be divisible.\n    \n    Returns:\n    int: The first natural number whose factorial is divisible by x.\n    \"\"\"\n    \n    # Initialize the number to 1\n    num = 1\n    \n    # Loop until we find a number whose factorial is divisible by x\n    while True:\n        # Calculate the factorial of the current number\n        factorial = math.factorial(num)\n        \n        # Check if the factorial is divisible by x\n        if factorial % x == 0:\n            # If it is, return the number\n            return num\n        \n        # If not, increment the number and try again\n        num += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    \"\"\"\n    This function removes the matching tuples from the given two tuples.\n    \n    Args:\n        test_list1 (list): The first tuple.\n        test_list2 (list): The second tuple.\n    \n    Returns:\n        tuple: A tuple containing the two modified lists.\n    \"\"\"\n    # Convert the tuples to lists\n    list1 = list(test_list1)\n    list2 = list(test_list2)\n    \n    # Find the intersection of the two lists\n    intersection = set(list1) & set(list2)\n    \n    # Remove the intersection from the first list\n    list1 = [item for item in list1 if item not in intersection]\n    \n    # Remove the intersection from the second list\n    list2 = [item for item in list2 if item not in intersection]\n    \n    # Convert the lists back to tuples\n    list1 = tuple(list1)\n    list2 = tuple(list2)\n    \n    # Return the modified lists as a tuple\n    return list1, list2"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = float('-inf')\n    for num in A:\n        if is_palindrome(num):\n            max_palindrome = max(max_palindrome, num)\n    return max_palindrome"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Compute the binomial probability for the given number.\n\n    Parameters:\n    n (int): The number of trials.\n    k (int): The number of successes.\n    p (float): The probability of success.\n\n    Returns:\n    float: The binomial probability.\n    \"\"\"\n    # Check if inputs are valid\n    if not isinstance(n, int) or not isinstance(k, int) or not isinstance(p, (int, float)):\n        raise ValueError(\"Inputs must be integers or floats.\")\n    if n < 0 or k < 0 or p < 0 or p > 1:\n        raise ValueError(\"Inputs must be non-negative and p must be between 0 and 1.\")\n\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n\n    # Calculate the probability of success\n    probability_of_success = p ** k\n\n    # Calculate the probability of failure\n    probability_of_failure = (1 - p) ** (n - k)\n\n    # Calculate the binomial probability\n    binomial_probability = binomial_coefficient * probability_of_success * probability_of_failure\n\n    return binomial_probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    return sorted(tup, key=lambda x: x[-1])"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The area of the pentagon.\n    \"\"\"\n    # Calculate the area using the formula: (n * s^2) / (4 * tan(/n))\n    # where n is the number of sides (5 for a pentagon) and s is the side length\n    area = (5 * a**2) / (4 * math.tan(math.pi/5))\n    return area"}
{"id": "478_0", "code": "def frequency_Of_Largest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the maximum value in the array\n    max_val = max(arr)\n\n    # Count the frequency of the maximum value\n    count = arr.count(max_val)\n\n    # Return the frequency of the maximum value\n    return count"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples where each tuple contains a pair of elements that are symmetric.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples where each tuple contains a pair of symmetric elements.\n    \"\"\"\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j] and test_list[i] not in symmetric_pairs:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a, n, r):\n    \"\"\"\n    Calculate the sum of a geometric progression series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The number of terms in the series.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The sum of the geometric progression series.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    \"\"\"\n    Searches for an item in a sorted list using binary search.\n\n    Args:\n        item_list (list): A sorted list of items.\n        item: The item to search for.\n\n    Returns:\n        int: The index of the item if found, -1 otherwise.\n    \"\"\"\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1"}
{"id": "482_0", "code": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    # Calculate the center of the hexagon\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the angle between each vertex\n    angle = 2 * math.pi / 6\n\n    # Initialize the list of coordinates\n    coordinates = []\n\n    # Calculate the coordinates of each vertex\n    for i in range(6):\n        # Calculate the x and y coordinates of the current vertex\n        x = center_x + radius * math.cos(i * angle)\n        y = center_y + radius * math.sin(i * angle)\n\n        # Add the coordinates to the list\n        coordinates.append((x, y))\n\n    return coordinates"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    \"\"\"\n    This function converts a given binary tuple to an integer.\n\n    Args:\n        test_tup (tuple): A tuple of binary digits (0s and 1s)\n\n    Returns:\n        int: The integer equivalent of the given binary tuple\n\n    Raises:\n        ValueError: If the input tuple contains non-binary digits\n    \"\"\"\n    # Check if all elements in the tuple are binary digits\n    if not all(digit in '01' for digit in test_tup):\n        raise ValueError(\"Input tuple contains non-binary digits\")\n\n    # Convert the binary tuple to a string\n    binary_str = ''.join(test_tup)\n\n    # Convert the binary string to an integer\n    integer = int(binary_str, 2)\n\n    return integer"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase substrings are to be removed.\n    \n    Returns:\n    str: The modified string with all lowercase substrings removed.\n    \"\"\"\n    # Use regex to replace all lowercase substrings with an empty string\n    # The pattern '[a-z]+' matches one or more lowercase letters\n    # The re.sub function replaces all occurrences of the pattern in the string with the replacement string\n    return re.sub('[a-z]+', '', str1)"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    This function finds the smallest integers from a given list of numbers using heap queue algorithm.\n\n    Args:\n        nums (list): A list of integers.\n        n (int): The number of smallest integers to find.\n\n    Returns:\n        list: A list of the n smallest integers from the input list.\n    \"\"\"\n    # Create a min heap and push the first n elements into the heap\n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n    \n    # Initialize an empty list to store the smallest integers\n    smallest_integers = []\n    \n    # Loop until the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap and add it to the list\n        smallest_integers.append(heapq.heappop(min_heap))\n        \n        # If the heap size is less than n, push the next element into the heap\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, nums[n])\n    \n    # Return the list of smallest integers\n    return smallest_integers"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r,h):\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    \n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two positive integers.\n\n    Args:\n        x (int): The first positive integer.\n        y (int): The second positive integer.\n\n    Returns:\n        int: The GCD of x and y.\n\n    Raises:\n        ValueError: If either x or y is not a positive integer.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both inputs must be integers.\")\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both inputs must be positive integers.\")\n\n    # Use the Euclidean algorithm to find the GCD\n    while y:\n        x, y = y, x % y\n\n    return x"}
{"id": "488_0", "code": "import math\n\ndef diameter_circle(r):\n    \"\"\"\n    Calculate the diameter of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The diameter of the circle.\n    \"\"\"\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    \"\"\"\n    Concatenates all elements of the given list into a string.\n\n    Args:\n        lst (list): A list of strings to be concatenated.\n\n    Returns:\n        str: A string containing all elements of the input list.\n    \"\"\"\n    return ''.join(lst)"}
{"id": "490_0", "code": "def num_comm_div(x,y):\n    \"\"\"\n    This function finds the common divisor between two numbers in a given pair.\n    \n    Parameters:\n    x (int): The first number in the pair.\n    y (int): The second number in the pair.\n    \n    Returns:\n    int: The greatest common divisor of x and y.\n    \"\"\"\n    # Calculate the greatest common divisor using the Euclidean algorithm\n    def gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n    \n    # Find the common divisor\n    common_divisor = gcd(x, y)\n    \n    return common_divisor"}
{"id": "491_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the remainder of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The remainder of n divided by m.\n    \"\"\"\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list where each number is the sum of consecutive numbers in the input list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of integers where each number is the sum of consecutive numbers in the input list.\n    \"\"\"\n    if not nums:\n        return []\n\n    result = []\n    current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum += num\n        result.append(current_sum)\n\n    return result"}
{"id": "493_0", "code": "def sum_Of_Series(n):\n    \"\"\"\n    This function calculates the cube sum of the first n natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to be summed.\n    \n    Returns:\n    int: The cube sum of the first n natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the total sum\n        total_sum += i ** 3\n    \n    # Return the total sum\n    return total_sum"}
{"id": "494_0", "code": "def re_order(A):\n    \"\"\"\n    This function reorders the given array such that all zeroes are moved to the end.\n    \n    Parameters:\n    A (list): The input array.\n    \n    Returns:\n    list: The reordered array with zeroes at the end.\n    \"\"\"\n    # Initialize two pointers, one at the beginning and one at the end of the array\n    left = 0\n    right = 0\n    \n    # Traverse the array from left to right\n    while right < len(A):\n        # If the current element is not zero, swap it with the element at the left pointer\n        if A[right] != 0:\n            A[left], A[right] = A[right], A[left]\n            # Move the left pointer to the right\n            left += 1\n        # Move the right pointer to the right\n        right += 1\n    \n    # Return the reordered array\n    return A"}
{"id": "495_0", "code": "import math\n\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient of given p(n, k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    float: The permutation coefficient p(n, k).\n    \"\"\"\n    # Check if k is greater than n\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n\n    # Calculate the permutation coefficient using the formula n! / (n-k)!\n    coefficient = math.factorial(n) / math.factorial(n - k)\n    return coefficient"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    \"\"\"\n    This function removes specific words from a given list.\n\n    Parameters:\n    list1 (list): The original list of words.\n    removewords (list): The list of words to be removed.\n\n    Returns:\n    list: The updated list with the specified words removed.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    updated_list = list1.copy()\n    \n    # Iterate over each word to be removed\n    for word in removewords:\n        # Check if the word exists in the updated list\n        if word in updated_list:\n            # Remove the word from the updated list\n            updated_list.remove(word)\n    \n    # Return the updated list\n    return updated_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    \"\"\"\n    This function checks if the common elements between two given lists are in the same order or not.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        bool: True if the common elements are in the same order, False otherwise.\n    \"\"\"\n    # Initialize two pointers, one for each list\n    i, j = 0, 0\n    # Iterate through both lists\n    while i < len(l1) and j < len(l2):\n        # If the current elements are equal, move both pointers\n        if l1[i] == l2[j]:\n            i += 1\n            j += 1\n        # If the current element in l1 is smaller, move the pointer in l1\n        elif l1[i] < l2[j]:\n            i += 1\n        # If the current element in l2 is smaller, move the pointer in l2\n        else:\n            j += 1\n    # If one of the lists is exhausted, the common elements are in the same order\n    return i == len(l1) or j == len(l2)"}
{"id": "498_0", "code": "def average_Odd(n):\n    \"\"\"\n    This function calculates the average of odd numbers till a given odd number.\n\n    Args:\n        n (int): The given odd number.\n\n    Returns:\n        float: The average of odd numbers till the given odd number.\n    \"\"\"\n    # Initialize sum and count variables to zero\n    total_sum = 0\n    count = 0\n\n    # Loop through all odd numbers till the given odd number\n    for i in range(1, n + 1):\n        # Check if the current number is odd\n        if i % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += i\n            # Increment the count of odd numbers\n            count += 1\n\n    # Check if there are any odd numbers\n    if count == 0:\n        # If no odd numbers, return 0\n        return 0\n    else:\n        # Calculate and return the average of odd numbers\n        return total_sum / count"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * arr[i - 1]\n        if dp[i] >= k:\n            dp[i] = k\n    for i in range(n, 0, -1):\n        dp[i] += dp[i - 1]\n    return dp[0]"}

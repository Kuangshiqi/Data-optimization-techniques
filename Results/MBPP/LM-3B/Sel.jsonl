{"id": "0_0", "code": "def remove_Occ(s,ch):\n    s = list(s)\n    first_occ = s.index(ch)\n    last_occ = len(s) - 1 - s[::-1].index(ch)\n    s[first_occ:last_occ+1] = []\n    return ''.join(s)"}
{"id": "1_0", "code": "def sort_matrix(M):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        M (list of lists): A 2D list representing the matrix.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    # Calculate the sum of each row and store it in a list of tuples\n    row_sums = [(sum(row), row) for row in M]\n\n    # Sort the list of tuples based on the sum of each row\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows from the list of tuples\n    sorted_M = [row for _, row in sorted_row_sums]\n\n    return sorted_M"}
{"id": "2_0", "code": "from collections import Counter\nimport re\n\ndef count_common(words):\n    # Convert all words to lower case and remove punctuation\n    cleaned_words = [re.sub(r'[^\\w\\s]', '', word).lower() for word in words]\n    \n    # Count the frequency of each word\n    word_counts = Counter(cleaned_words)\n    \n    # Get the most common words and their counts\n    common_words = word_counts.most_common(10)\n    \n    return common_words"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    \"\"\"\n    This function calculates the volume of a triangular prism.\n\n    Parameters:\n    l (float): The length of the prism.\n    b (float): The base of the prism.\n    h (float): The height of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the base triangle\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        list: A list of strings split at lowercase letters.\n    \"\"\"\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n            current_word += char\n        else:\n            current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "def text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an empty string to store the current sequence\n    current_sequence = \"\"\n    \n    # Iterate over each character in the input string\n    for char in text:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # If the character is a lowercase letter, add it to the current sequence\n            current_sequence += char\n        else:\n            # If the character is not a lowercase letter, check if the current sequence is not empty\n            if current_sequence:\n                # If the current sequence is not empty, add it to the result list\n                result.append(current_sequence)\n                # Reset the current sequence\n                current_sequence = \"\"\n    \n    # After iterating over all characters, check if the current sequence is not empty\n    if current_sequence:\n        # If the current sequence is not empty, add it to the result list\n        result.append(current_sequence)\n    \n    # Return the result list\n    return result"}
{"id": "6_0", "code": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Args:\n        a (float): The length of one side of the square.\n\n    Returns:\n        float: The perimeter of the square.\n    \"\"\"\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = 4 * a\n    return perimeter"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The original string.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters removed.\n    \"\"\"\n    # Convert the second string to a set for efficient lookups\n    dirty_chars = set(second_string)\n    \n    # Use a list comprehension to filter out characters in the first string\n    # that are present in the set of dirty characters\n    filtered_chars = [char for char in string if char not in dirty_chars]\n    \n    # Join the filtered characters back into a string\n    cleaned_string = ''.join(filtered_chars)\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    return len(arraynums) != len(set(arraynums))"}
{"id": "9_0", "code": "def is_woodall(x):\n    \"\"\"\n    Checks if the given number is woodall or not.\n    \n    A woodall number is a number that is the sum of its own digits raised to the power of their respective positions in the number.\n    \n    Parameters:\n    x (int): The number to check.\n    \n    Returns:\n    bool: True if the number is woodall, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_x = str(x)\n    \n    # Initialize a variable to store the sum of the digits raised to the power of their positions\n    woodall_sum = 0\n    \n    # Iterate over each digit in the number\n    for i, digit in enumerate(str_x):\n        # Add the digit raised to the power of its position to the sum\n        woodall_sum += int(digit) ** (i + 1)\n    \n    # Check if the sum is equal to the original number\n    return woodall_sum == x"}
{"id": "10_0", "code": "def multiples_of_num(m,n):\n    \"\"\"\n    This function generates m number of multiples of n.\n    \n    Parameters:\n    m (int): The number of multiples to generate.\n    n (int): The number for which multiples are to be generated.\n    \n    Returns:\n    list: A list of m number of multiples of n.\n    \"\"\"\n    # Initialize an empty list to store the multiples\n    multiples = []\n    \n    # Loop through the range from 1 to m+1 (to include m)\n    for i in range(1, m+1):\n        # Calculate the multiple of n\n        multiple = n * i\n        # Append the multiple to the list\n        multiples.append(multiple)\n    \n    # Return the list of multiples\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    \"\"\"\n    This function finds the first duplicate element in a given array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first duplicate element if found, otherwise -1.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize max_sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Calculate the sum of the current sublist\n        sublist_sum = sum(sublist)\n        \n        # Update max_sum if the sum of the current sublist is greater\n        max_sum = max(max_sum, sublist_sum)\n    \n    # Return the maximum sum found\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    This function converts a binary number to its decimal equivalent.\n\n    Args:\n        binary (str): A string of binary digits (0s and 1s).\n\n    Returns:\n        int: The decimal equivalent of the given binary number.\n\n    Raises:\n        ValueError: If the input string contains characters other than 0 and 1.\n    \"\"\"\n    # Check if the input string contains only 0s and 1s\n    if not set(binary).issubset({'0', '1'}):\n        raise ValueError(\"Invalid binary number. It should only contain 0s and 1s.\")\n\n    # Initialize the decimal number to 0\n    decimal = 0\n\n    # Iterate over the binary number from right to left\n    for i, bit in enumerate(reversed(binary)):\n        # If the current bit is 1, add 2^i to the decimal number\n        if bit == '1':\n            decimal += 2 ** i\n\n    return decimal"}
{"id": "14_0", "code": "def find_Product(arr,n):\n    # Create a frequency dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize product variable to 1\n    product = 1\n\n    # Iterate through the frequency dictionary\n    for key, value in freq_dict.items():\n        # If the frequency of an element is 1, multiply the product by that element\n        if value == 1:\n            product *= key\n\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    \"\"\"\n    This function checks if the given tuple list has all k elements.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to check for.\n\n    Returns:\n        bool: True if the list has all k elements, False otherwise.\n    \"\"\"\n    # Check if the input test_list is a list\n    if not isinstance(test_list, list):\n        raise TypeError(\"Input test_list must be a list.\")\n    \n    # Check if the input K is an integer\n    if not isinstance(K, int):\n        raise TypeError(\"Input K must be an integer.\")\n    \n    # Check if the input K is positive\n    if K <= 0:\n        raise ValueError(\"Input K must be a positive integer.\")\n    \n    # Check if all elements in the test_list are tuples\n    if not all(isinstance(element, tuple) for element in test_list):\n        raise TypeError(\"All elements in the test_list must be tuples.\")\n    \n    # Check if all tuples in the test_list have the same length\n    if not all(len(element) == K for element in test_list):\n        raise ValueError(\"All tuples in the test_list must have the same length.\")\n    \n    # Check if all tuples in the test_list have the same elements\n    if not all(set(element) == set(test_list[0]) for element in test_list):\n        raise ValueError(\"All tuples in the test_list must have the same elements.\")\n    \n    # If all checks pass, return True\n    return True"}
{"id": "16_0", "code": "def remove(lst):\n    \"\"\"\n    This function removes all digits from a list of strings.\n\n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A list of strings with all digits removed.\n    \"\"\"\n    return [''.join(filter(str.isalpha, s)) for s in lst]"}
{"id": "17_0", "code": "import math\n\ndef binomial_Coeff(n,k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k)\n    \n    Parameters:\n    n (int): The total number of items\n    k (int): The number of items to choose\n    \n    Returns:\n    int: The binomial coefficient (n choose k)\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    return int(result)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    count_dict = {}\n    for i in range(arr_size):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n    for key, value in count_dict.items():\n        if value % 2 != 0:\n            return key\n    return None"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "import heapq\nfrom collections import Counter\n\ndef func(nums, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Count the frequency of each integer\n    freq_count = Counter(flat_list)\n    \n    # Use a heap queue to find the top k integers\n    top_k = heapq.nlargest(k, freq_count.keys(), key=freq_count.get)\n    \n    return top_k"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_factor = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            max_factor = max(max_factor, i)\n    return max_factor"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    \"\"\"\n    This function converts a decimal number to binary number.\n\n    Parameters:\n    N (int): The decimal number to be converted.\n\n    Returns:\n    str: The binary representation of the decimal number.\n\n    Raises:\n    TypeError: If the input is not an integer.\n    ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(N, int):\n        raise TypeError(\"Input must be an integer.\")\n    if N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Convert the decimal number to binary using built-in function bin()\n    binary = bin(N)\n\n    # Remove the '0b' prefix from the binary string\n    binary = binary[2:]\n\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar,N):\n    \"\"\"\n    This function finds the missing number in a sorted array of size N.\n    \n    Parameters:\n    ar (list): A sorted list of integers.\n    N (int): The size of the list.\n    \n    Returns:\n    int: The missing number in the list.\n    \"\"\"\n    # Iterate through the array\n    for i in range(N-1):\n        # Check if the difference between the current element and the next element is greater than 1\n        if ar[i+1] - ar[i] > 1:\n            # If the difference is greater than 1, then the missing number is the current element plus 1\n            return ar[i] + 1\n    # If no missing number is found, return None\n    return None"}
{"id": "24_0", "code": "def find_rect_num(n):\n    \"\"\"\n    This function calculates the n-th rectangular number.\n    \n    Parameters:\n    n (int): The position of the rectangular number to be found.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    # Initialize the first rectangular number\n    rect_num = 1\n    \n    # Initialize the counter for the number of rectangles\n    count = 1\n    \n    # Initialize the current number\n    curr_num = 1\n    \n    # Loop until we find the n-th rectangular number\n    while count < n:\n        # Increment the current number\n        curr_num += 1\n        \n        # Calculate the next rectangular number\n        rect_num = curr_num * curr_num\n        \n        # Increment the counter\n        count += 1\n    \n    # Return the n-th rectangular number\n    return rect_num"}
{"id": "25_0", "code": "from fractions import Fraction\n\ndef find_Nth_Digit(p, q, N):\n    # Convert the input numbers to fractions\n    frac_p = Fraction(p).limit_denominator()\n    frac_q = Fraction(q).limit_denominator()\n\n    # Calculate the greatest common divisor of the denominators\n    gcd = frac_p.denominator * frac_q.denominator // gcd_helper(frac_p.denominator, frac_q.denominator)\n\n    # Calculate the least common multiple of the denominators\n    lcm = frac_p.denominator * frac_q.denominator // gcd\n\n    # Calculate the numerator of the fraction\n    numerator = frac_p.numerator * frac_q.denominator + frac_q.numerator * frac_p.denominator\n\n    # Calculate the nth digit\n    digit = (numerator // lcm) % 10\n\n    return digit"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a given mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing a mix of integers and strings.\n\n    Returns:\n        list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort both lists\n    integers.sort()\n    strings.sort()\n\n    # Combine the sorted lists, with integers first\n    sorted_list = integers + strings\n\n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Separate even and odd numbers\n    even_numbers = [num for num in list1 if num % 2 == 0]\n    odd_numbers = [num for num in list1 if num % 2 != 0]\n\n    # Check if there are at least two numbers in each list\n    if len(even_numbers) < 2 or len(odd_numbers) < 2:\n        return \"Not enough numbers in the list to perform division.\"\n\n    # Perform division\n    even_division = even_numbers[0] / even_numbers[1]\n    odd_division = odd_numbers[0] / odd_numbers[1]\n\n    return even_division, odd_division"}
{"id": "28_0", "code": "from collections import Counter\n\ndef rearange_string(S):\n    # Count the frequency of each character in the string\n    char_count = Counter(S)\n    \n    # Sort the characters by their frequency in descending order\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    \n    # Initialize the result string and the last character\n    result = ''\n    last_char = None\n    \n    # Iterate over the sorted characters\n    for char, count in sorted_chars:\n        # If the last character is the same as the current character, \n        # we need to add more characters to the result string\n        if last_char == char:\n            # If the count of the current character is 1, \n            # we cannot rearrange the string\n            if count == 1:\n                return False\n            # Otherwise, add the current character to the result string\n            # and decrement the count\n            else:\n                result += char\n                count -= 1\n        # Add the current character to the result string\n        result += char * count\n        # Update the last character\n        last_char = char\n    \n    # If the length of the result string is equal to the length of the input string, \n    # we can rearrange the string\n    return len(result) == len(S)"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    \"\"\"\n    This function calculates the frequency of each element in a given list of lists.\n    \n    Parameters:\n    nums (list): A list of lists containing elements.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list of lists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq_dict = Counter(flat_list)\n    \n    return dict(freq_dict)"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr,n):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over the array to count the frequency of each element\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n    \n    # Initialize a variable to store the sum of repeated elements\n    sum_repeated = 0\n    \n    # Iterate over the dictionary to find the sum of repeated elements\n    for key, value in freq_dict.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    # Return the sum of repeated elements\n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    \"\"\"\n    This function checks if a word is at the beginning of a given string.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the word is at the beginning of the string, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    text = text.strip()\n    \n    # Split the string into words\n    words = text.split()\n    \n    # Check if the string is not empty\n    if not words:\n        return False\n    \n    # Return True if the first word is not empty, False otherwise\n    return words[0]"}
{"id": "34_0", "code": "import math\n\ndef get_gcd(lst):\n    \"\"\"\n    This function calculates the greatest common divisor (GCD) of all elements in the given list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The GCD of all elements in the list.\n    \"\"\"\n    \n    # Check if the list is empty\n    if not lst:\n        return None\n    \n    # Initialize the GCD with the first element of the list\n    gcd = lst[0]\n    \n    # Iterate over the rest of the list\n    for num in lst[1:]:\n        # Update the GCD using the Euclidean algorithm\n        gcd = math.gcd(gcd, num)\n    \n    # Return the final GCD\n    return gcd"}
{"id": "35_0", "code": "def test_distinct(data):\n    return len(data) == len(set(data))"}
{"id": "36_0", "code": "import math\n\ndef compute_Last_Digit(A,B):\n    # Calculate the factorial of A and B\n    fact_A = math.factorial(A)\n    fact_B = math.factorial(B)\n\n    # Calculate the last digit of fact_A and fact_B\n    last_digit_A = fact_A % 10\n    last_digit_B = fact_B % 10\n\n    # Return the last digit of fact_A when divided by fact_B\n    return (last_digit_A * pow(last_digit_B, -1, 10)) % 10"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result variable to store the final result\n    result = 0\n    \n    # Iterate over each bit in the given number\n    for i in range(n.bit_length()):\n        # Check if the current bit is odd\n        if (n >> i) & 1:\n            # If the bit is odd, set it to 1 in the result\n            result |= 1 << i\n    \n    # Return the result\n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every first or specified element from a given two-dimensional list.\n\n    Args:\n        nums (list): A two-dimensional list of integers.\n        N (int): The position of the element to extract (1-indexed).\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    extracted_elements = []\n    for i in range(len(nums)):\n        if i == 0 or N <= len(nums[i]):\n            extracted_elements.append(nums[i][0])\n    return extracted_elements"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=len)"}
{"id": "40_0", "code": "def check_equilateral(x,y,z):\n    # Check if the triangle is equilateral\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b,h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    \"\"\"\n    Checks whether the first and last characters of a given string are equal.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is not empty\n    if len(str) == 0:\n        return False\n    \n    # Get the first and last characters of the string\n    first_char = str[0]\n    last_char = str[-1]\n    \n    # Compare the first and last characters\n    return first_char == last_char"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    max_val = max(my_list)\n    min_val = min(my_list)\n    count = [0] * (max_val - min_val + 1)\n    for num in my_list:\n        count[num - min_val] += 1\n    sorted_list = []\n    for i, cnt in enumerate(count):\n        sorted_list.extend([i + min_val] * cnt)\n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a, n, r):\n    \"\"\"\n    Calculate the t-nth term of a geometric series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The term number to calculate.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (r ** (n - 1))"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to easily reverse it\n    str_n = str(n)\n    \n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    \n    # Check if the number is one less than twice its reverse\n    if n == 2 * reversed_n - 1:\n        return True\n    else:\n        return False"}
{"id": "46_0", "code": "def find_Max_Num(arr,n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Join the sorted array into a string\n    max_num_str = ''.join(map(str, arr))\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x,y):\n  \"\"\"\n  This function checks whether two given integers have opposite sign or not.\n  \n  Parameters:\n  x (int): The first integer.\n  y (int): The second integer.\n  \n  Returns:\n  bool: True if the integers have opposite sign, False otherwise.\n  \"\"\"\n  # Check if the signs of the two integers are different\n  # If the signs are different, the integers have opposite sign\n  return (x < 0) != (y < 0)"}
{"id": "48_0", "code": "def is_octagonal(n):\n    \"\"\"\n    Checks if a number is an octagonal number.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is octagonal, False otherwise.\n    \"\"\"\n    # Calculate the nth octagonal number\n    oct_num = (8 * n * (n + 1)) // 2\n    \n    # Check if the number is equal to the calculated octagonal number\n    return n == oct_num\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    Calculates the nth octagonal number.\n\n    Args:\n        n (int): The position of the octagonal number to calculate.\n\n    Returns:\n        int: The nth octagonal number.\n    \"\"\"\n    # Calculate the nth octagonal number using the formula\n    return (8 * n * (n + 1)) // 2\n\n# Example usage:\nprint(is_octagonal(1))  # Output: True\nprint(is_octagonal(2))  # Output: False\nprint(nth_octagonal_number(1))  # Output: 1\nprint(nth_octagonal_number(2))  # Output: 6"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    # Initialize variables to store the maximum length and the current length\n    max_len = 1\n    curr_len = 1\n\n    # Iterate through the array from the second element to the end\n    for i in range(1, n):\n        # If the difference between the current element and the previous one is positive\n        if arr[i] - arr[i - 1] > 0:\n            # Increase the current length by 1\n            curr_len += 1\n        else:\n            # Update the maximum length if the current length is greater\n            max_len = max(max_len, curr_len)\n            # Reset the current length to 1\n            curr_len = 1\n\n    # Update the maximum length one last time\n    max_len = max(max_len, curr_len)\n\n    # Return the maximum length\n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s,n):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1,len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    \"\"\"\n    This function calculates the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        int: The maximum difference between available pairs.\n\n    Raises:\n        ValueError: If the input list is empty or contains less than two tuples.\n    \"\"\"\n    if len(test_list) < 2:\n        raise ValueError(\"Input list must contain at least two tuples.\")\n\n    # Initialize the maximum difference as negative infinity\n    max_diff = float('-inf')\n\n    # Iterate over each tuple in the list\n    for i in range(len(test_list)):\n        # Iterate over each tuple that comes after the current tuple\n        for j in range(i + 1, len(test_list)):\n            # Calculate the difference between the current pair of tuples\n            diff = abs(test_list[i][0] - test_list[j][0]) + abs(test_list[i][1] - test_list[j][1])\n            # Update the maximum difference if the current difference is larger\n            max_diff = max(max_diff, diff)\n\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_subject_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subject_marks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    \"\"\"\n    This function calculates the sum of all elements in a list using recursion.\n\n    Args:\n        data_list (list): A list of numbers.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    # Base case: If the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: Add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    \"\"\"\n    This function counts the number of positive numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The count of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize the list to store bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1\n\n    # Calculate the first few bell numbers\n    for i in range(1, n + 1):\n        bell[i] = sum(bell[j] for j in range(i))\n\n    return bell[n]"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    # Check if the array is empty\n    if len(A) == 0:\n        return True  # An empty array is considered monotonic\n\n    # Check if the array is monotonic from left to right\n    increasing = all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n\n    # Check if the array is monotonic from right to left\n    decreasing = all(A[i] >= A[i + 1] for i in range(len(A) - 1))\n\n    # Return True if the array is monotonic in either direction\n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    \"\"\"\n    Checks if list l contains the given sublist s.\n\n    Args:\n        l (list): The list to search in.\n        s (list): The sublist to search for.\n\n    Returns:\n        bool: True if l contains s, False otherwise.\n    \"\"\"\n    # Check if the sublist is empty\n    if not s:\n        return True  # An empty sublist is a sublist of any list\n\n    # Check if the sublist is longer than the list\n    if len(s) > len(l):\n        return False  # A sublist longer than the list cannot be a sublist\n\n    # Iterate over the list with a sliding window of the same size as the sublist\n    for i in range(len(l) - len(s) + 1):\n        # Check if the current window matches the sublist\n        if l[i:i+len(s)] == s:\n            return True  # If a match is found, return True\n\n    # If no match is found after iterating over the entire list, return False\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    \"\"\"\n    This function checks if all the given tuples have equal length.\n\n    Args:\n        Input (list): A list of tuples.\n        k (int): The length to compare with.\n\n    Returns:\n        bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    # Check if Input is a list\n    if not isinstance(Input, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n\n    # Check if all elements in Input are tuples\n    if not all(isinstance(x, tuple) for x in Input):\n        raise TypeError(\"All elements in Input must be tuples.\")\n\n    # Check if k is an integer\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n\n    # Check if k is positive\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer.\")\n\n    # Check if all tuples in Input have equal length\n    return len(set(len(t) for t in Input)) == 1"}
{"id": "60_0", "code": "def comb_sort(nums):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n    nums (list): A list of elements to be sorted.\n\n    Returns:\n    list: A sorted list of elements.\n    \"\"\"\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    i = 1\n    while i * i <= n:\n        if (n - i * i) % 2 == 0:\n            return True\n        i += 1\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define the delimiters\n    delimiters = [\",\", \".\", \"!\", \"?\", \";\", \":\", \"'\", \"\\\"\", \"\\t\", \"\\n\"]\n    \n    # Escape special characters in delimiters\n    escaped_delimiters = [re.escape(delimiter) for delimiter in delimiters]\n    \n    # Join the escaped delimiters into a single string\n    delimiter_string = \"\".join(escaped_delimiters)\n    \n    # Use regex to split the text\n    split_text = re.split(delimiter_string, text)\n    \n    # Remove empty strings from the result\n    split_text = [item for item in split_text if item != '']\n    \n    return split_text"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks whether the given colors follow the sequence given in the patterns array.\n\n    Args:\n        colors (list): A list of colors.\n        patterns (list): A list of patterns.\n\n    Returns:\n        bool: True if the colors follow the patterns, False otherwise.\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    \"\"\"\n    This function finds tuples in the given list that have all elements divisible by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The divisor.\n\n    Returns:\n        list: A list of tuples where all elements are divisible by K.\n    \"\"\"\n    return [t for t in test_list if all(i % K == 0 for i in t)]"}
{"id": "65_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # The number of squares is equal to the number of rows times the number of columns\n    # minus the number of squares on the edges and corners\n    # We use the formula: (m-1)*(n-1) to calculate the number of squares on the edges and corners\n    # We subtract this from the total number of squares to get the final answer\n    return (m-1)*(n-1)"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize variables to store the sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each character (digit) in the string\n    for digit in str_n:\n        # Convert the character back into an integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd\n        if int_digit % 2 == 0:\n            # If even, add to even_sum\n            even_sum += int_digit\n        else:\n            # If odd, add to odd_sum\n            odd_sum += int_digit\n    \n    # Calculate the difference between the sums of even and odd digits\n    diff = abs(even_sum - odd_sum)\n    \n    # Return the difference\n    return diff"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(n + 1):\n        # Calculate the number of set bits in i\n        set_bits = bin(i).count('1')\n        # If the number of set bits is odd, increment the count\n        if set_bits % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    \"\"\"\n    This function checks whether the length of the word is odd or not.\n\n    Parameters:\n    s (str): The input word.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(s) % 2 != 0"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    The nth tetrahedral number is the number of ways to choose 4 elements from a set of n elements.\n\n    Args:\n        n (int): The position of the tetrahedral number to calculate.\n\n    Returns:\n        int: The nth tetrahedral number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # The formula for the nth tetrahedral number is n*(n+1)*(n+2)/6\n    # We use the math library to calculate the factorial\n    import math\n    return n*(n+1)*(n+2)//6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple containing the zipped elements.\n    \n    Args:\n        test_tup1 (tuple): The first tuple to be zipped.\n        test_tup2 (tuple): The second tuple to be zipped.\n    \n    Returns:\n        tuple: A new tuple containing the zipped elements of test_tup1 and test_tup2.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Use the built-in zip function to create a new tuple containing the zipped elements\n    zipped_tup = tuple(zip(test_tup1, test_tup2))\n    \n    return zipped_tup"}
{"id": "71_0", "code": "import math\n\ndef volume_sphere(r):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    volume = (4/3) * math.pi * (r ** 3)\n    return volume"}
{"id": "72_0", "code": "def get_Char(strr):\n    \"\"\"\n    This function calculates the character made by adding all the characters of the given string.\n    \n    Parameters:\n    strr (str): The input string.\n    \n    Returns:\n    str: The character made by adding all the characters of the given string.\n    \"\"\"\n    # Initialize a variable to store the sum of ASCII values\n    ascii_sum = 0\n    \n    # Iterate over each character in the string\n    for char in strr:\n        # Add the ASCII value of the character to the sum\n        ascii_sum += ord(char)\n    \n    # Convert the sum to a character using the chr function\n    generated_char = chr(ascii_sum)\n    \n    # Return the generated character\n    return generated_char"}
{"id": "73_0", "code": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as:\n    1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n    \n    This sequence is formed by adding the two preceding numbers to get the next number.\n    \n    Parameters:\n    n (int): The position of the number in the sequence.\n    \n    Returns:\n    int: The n-th number in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    \n    return b"}
{"id": "74_0", "code": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    Args:\n        n (int): The position of the centered hexagonal number to calculate.\n\n    Returns:\n        int: The nth centered hexagonal number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # The formula for the nth centered hexagonal number is given by:\n    # (3n^2 - n) / 2\n    return (3 * n ** 2 - n) // 2"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1,dict2, dict3):\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy all key-value pairs from dict1 to merged_dict\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    \n    # Copy all key-value pairs from dict2 to merged_dict\n    for key, value in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    # Copy all key-value pairs from dict3 to merged_dict\n    for key, value in dict3.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    # Create an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for element in list1:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    # Return the dictionary with the frequency of each element\n    return freq_dict"}
{"id": "78_0", "code": "def closest_num(N):\n    \"\"\"\n    This function finds the closest smaller number than N.\n\n    Args:\n        N (int): The input number.\n\n    Returns:\n        int: The closest smaller number than N.\n    \"\"\"\n    # Initialize the lower and upper bounds\n    low = N - 1\n    high = N\n\n    # Perform binary search\n    while low < high:\n        mid = (low + high) // 2\n        # If mid is smaller than N, update low\n        if mid < N:\n            low = mid + 1\n        # If mid is not smaller than N, update high\n        else:\n            high = mid\n\n    # At this point, low is the closest smaller number than N\n    return low"}
{"id": "79_0", "code": "def len_log(list1):\n    \"\"\"\n    This function finds the length of the longest word in a given list.\n\n    Args:\n        list1 (list): A list of words.\n\n    Returns:\n        int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate over each word in the list\n    for word in list1:\n        # Calculate the length of the current word\n        length = len(word)\n        \n        # If the length of the current word is greater than the max_length, update max_length\n        if length > max_length:\n            max_length = length\n    \n    # Return the maximum length found\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    \"\"\"\n    Checks if a substring is present in a given list of string values.\n\n    Args:\n        str1 (list): A list of string values.\n        sub_str (str): The substring to be searched.\n\n    Returns:\n        bool: True if the substring is found, False otherwise.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False"}
{"id": "81_0", "code": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a variable to store the difference between the first and last digit\n    diff = abs(int(str_n[0]) - int(str_n[-1]))\n    \n    # Iterate over the digits in the middle of the number\n    for i in range(1, len(str_n) - 1):\n        # Calculate the difference between the current digit and the digit two positions ahead\n        curr_diff = abs(int(str_n[i]) - int(str_n[i+2]))\n        \n        # If the difference is not equal to the initial difference, the number is not undulating\n        if curr_diff != diff:\n            return False\n    \n    # If the function hasn't returned False, the number is undulating\n    return True"}
{"id": "82_0", "code": "def power(a,b):\n    return a ** b"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    \"\"\"\n    This function takes a list of tuples as input, where each tuple contains an index and a value.\n    It returns the index and value of the minimum value record.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains an index and a value.\n\n    Returns:\n        tuple: A tuple containing the index and value of the minimum value record.\n    \"\"\"\n    # Check if the input list is empty\n    if not test_list:\n        return None\n\n    # Initialize the minimum value and its index with the first element of the list\n    min_value = test_list[0][1]\n    min_index = test_list[0][0]\n\n    # Iterate over the list of tuples\n    for index, value in test_list:\n        # Check if the current value is less than the minimum value found so far\n        if value < min_value:\n            # Update the minimum value and its index\n            min_value = value\n            min_index = index\n\n    # Return the index and value of the minimum value record\n    return (min_index, min_value)"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    \"\"\"\n    This function finds the minimum length of a sublist in a given list.\n    \n    Parameters:\n    lst (list): The input list.\n    \n    Returns:\n    int: The minimum length of a sublist.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = float('inf')\n    \n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            min_length = min(min_length, len(sublist))\n    \n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    \"\"\"\n    This function calculates the frequency count of each sublist in a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        dict: A dictionary where keys are sublists and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    for sublist in list1:\n        # Convert the sublist to a tuple to make it hashable\n        sublist_tuple = tuple(sublist)\n        # If the sublist is already in the dictionary, increment its count\n        if sublist_tuple in frequency_dict:\n            frequency_dict[sublist_tuple] += 1\n        # If the sublist is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[sublist_tuple] = 1\n    return frequency_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    \"\"\"\n    This function multiplies all the numbers in a list and divides the result by the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of the multiplication and division.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list is empty.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Check if the list is not empty\n    if len(numbers) == 0:\n        raise ValueError(\"List cannot be empty.\")\n\n    # Initialize the product variable to 1\n    product = 1\n\n    # Iterate over each number in the list\n    for num in numbers:\n        # Multiply the product by the current number\n        product *= num\n\n    # Divide the product by the length of the list\n    result = product / len(numbers)\n\n    # Return the result\n    return result"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    \"\"\"\n    This function converts a decimal number to its binary equivalent.\n\n    Args:\n        n (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary equivalent of the given decimal number.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Convert the decimal number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    \"\"\"\n    This function finds the kth element in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The position of the element to be found.\n\n    Returns:\n    int: The kth element in the array. If k is larger than the array size, returns None.\n    \"\"\"\n    if k < 1 or k > n:\n        return None\n    return arr[k - 1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    \"\"\"\n    Converts a snake case string to camel case string.\n\n    Args:\n        word (str): The input snake case string.\n\n    Returns:\n        str: The converted camel case string.\n    \"\"\"\n    words = word.split('_')\n    return words[0] + ''.join(word.capitalize() for word in words[1:])"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m) using the formula:\n    a(n, m) = (m-1)! / ((n-1)! * (m-n)!)\n\n    Args:\n        n (int): The number of elements in the sequence.\n        m (int): The number of elements to choose.\n\n    Returns:\n        int: The Eulerian number a(n, m).\n    \"\"\"\n    def factorial(x):\n        \"\"\"Calculate the factorial of a number.\"\"\"\n        result = 1\n        for i in range(1, x + 1):\n            result *= i\n        return result\n\n    # Calculate the numerator (m-1)!\n    numerator = factorial(m - 1)\n\n    # Calculate the denominator ((n-1)! * (m-n)!)\n    denominator = factorial(n - 1) * factorial(m - n)\n\n    # Return the result\n    return numerator // denominator"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    return sorted(input_list, key=lambda x: [sublist.sort() for sublist in x])"}
{"id": "94_0", "code": "def count(lst):\n    \"\"\"\n    This function counts the number of true booleans in a given list.\n\n    Args:\n        lst (list): A list containing boolean values.\n\n    Returns:\n        int: The number of true booleans in the list.\n    \"\"\"\n    return sum(1 for bool_val in lst if bool_val)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    \"\"\"\n    This function adds the given list to the given tuple.\n    \n    Args:\n        test_list (list): The list to be added to the tuple.\n        test_tup (tuple): The tuple to which the list will be added.\n    \n    Returns:\n        tuple: A new tuple containing the original tuple and the added list.\n    \"\"\"\n    # Convert the tuple to a list to make it mutable\n    test_tup_list = list(test_tup)\n    \n    # Add the list to the list\n    test_tup_list.extend(test_list)\n    \n    # Convert the list back to a tuple\n    result = tuple(test_tup_list)\n    \n    return result"}
{"id": "96_0", "code": "def count_Hexadecimal(L,R):\n    \"\"\"\n    This function counts the number of hexadecimal numbers in a given range.\n    \n    Parameters:\n    L (int): The lower bound of the range (inclusive).\n    R (int): The upper bound of the range (inclusive).\n    \n    Returns:\n    int: The number of hexadecimal numbers in the range [L, R].\n    \"\"\"\n    count = 0\n    for i in range(L, R + 1):\n        # Convert the number to hexadecimal and check if it's a hexadecimal number\n        if all(c in '0123456789abcdefABCDEF' for c in hex(i)[2:]):\n            count += 1\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a min heap to store the elements\n    min_heap = []\n    \n    # Push the first element of each list into the heap\n    # along with its list index and element index\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 0, 0))\n    heapq.heappush(min_heap, (num3[0], 0, 0))\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, list_idx, elem_idx = heapq.heappop(min_heap)\n        \n        # Add the popped element to the result\n        result.append(val)\n        \n        # If there are more elements in the list\n        if elem_idx + 1 < len(num1) and (not result or val > num1[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num1[elem_idx + 1], list_idx, elem_idx + 1))\n        if elem_idx + 1 < len(num2) and (not result or val > num2[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num2[elem_idx + 1], list_idx, elem_idx + 1))\n        if elem_idx + 1 < len(num3) and (not result or val > num3[elem_idx + 1]):\n            # Push the next element from the list into the heap\n            heapq.heappush(min_heap, (num3[elem_idx + 1], list_idx, elem_idx + 1))\n    \n    # Return the result\n    return result"}
{"id": "98_0", "code": "def odd_Equivalent(s,n):\n    # Convert the binary string to an integer\n    num = int(s, 2)\n    \n    # Calculate the number of rotations\n    num_rotated = (num << n) | (num >> (len(s) - n))\n    \n    # Check if the rotated number has an odd value\n    if num_rotated % 2 != 0:\n        return 1\n    else:\n        return 0"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    \"\"\"\n    This function takes a list of integers and two range values as input.\n    It returns a list of integers that are missing from the given list within the specified range.\n\n    Args:\n        test_list (list): A list of integers.\n        strt_val (int): The start value of the range.\n        stop_val (int): The end value of the range.\n\n    Returns:\n        list: A list of missing integers within the specified range.\n    \"\"\"\n    # Convert the input list to a set for efficient lookups\n    test_set = set(test_list)\n    \n    # Initialize an empty list to store the missing values\n    missing_values = []\n    \n    # Iterate over the range from strt_val to stop_val (inclusive)\n    for i in range(strt_val, stop_val + 1):\n        # Check if the current value is not in the test set\n        if i not in test_set:\n            # If it's not in the test set, add it to the missing values list\n            missing_values.append(i)\n    \n    # Return the list of missing values\n    return missing_values"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Flatten the nested list\n    flat_list = flatten(nestedlist)\n    \n    # Find common elements with the first sublist\n    common = set(flat_list).intersection(set(flat_list[0]))\n    \n    return list(common)"}
{"id": "101_0", "code": "import math\n\ndef perimeter(diameter, height):\n    \"\"\"\n    Calculate the perimeter of a cylinder.\n\n    Parameters:\n    diameter (float): The diameter of the cylinder's base.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The perimeter of the cylinder.\n    \"\"\"\n    radius = diameter / 2\n    circumference = 2 * math.pi * radius\n    lateral_surface_area = 2 * math.pi * radius * height\n    total_perimeter = circumference + lateral_surface_area\n    return total_perimeter"}
{"id": "102_0", "code": "def check_integer(text):\n    \"\"\"\n    Checks if a given string represents an integer.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    \"\"\"\n    Assigns frequency to each tuple in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        dict: A dictionary where keys are tuples and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    \"\"\"\n    This function checks whether all dictionaries in a list are empty or not.\n\n    Args:\n        list1 (list): A list of dictionaries.\n\n    Returns:\n        bool: True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Check if all elements in the list are dictionaries\n    if not all(isinstance(item, dict) for item in list1):\n        raise TypeError(\"All elements in the list must be dictionaries\")\n\n    # Check if all dictionaries in the list are empty\n    return all(len(item) == 0 for item in list1)"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    \"\"\"\n    Converts a tuple of positive integers into an integer.\n\n    Args:\n        nums (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The integer representation of the tuple.\n\n    Raises:\n        ValueError: If the tuple contains non-positive integers or non-integer values.\n    \"\"\"\n    # Check if all elements in the tuple are integers\n    if not all(isinstance(num, int) for num in nums):\n        raise ValueError(\"The tuple must only contain integers.\")\n\n    # Check if all elements in the tuple are positive\n    if not all(num > 0 for num in nums):\n        raise ValueError(\"The tuple must only contain positive integers.\")\n\n    # Convert the tuple to a string\n    num_str = ''.join(map(str, nums))\n\n    # Convert the string to an integer\n    result = int(num_str)\n\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    \"\"\"\n    This function takes a list as input, identifies all possible convertible elements (i.e., strings that can be converted to float), \n    and converts them to float. The function returns the modified list.\n\n    Parameters:\n    test_list (list): A list containing elements that can be converted to float.\n\n    Returns:\n    list: The input list with all convertible elements converted to float.\n    \"\"\"\n    # Initialize an empty list to store the converted elements\n    converted_list = []\n\n    # Iterate over each element in the input list\n    for element in test_list:\n        # Check if the element is a string\n        if isinstance(element, str):\n            # Try to convert the string to float\n            try:\n                # Append the converted float to the converted list\n                converted_list.append(float(element))\n            except ValueError:\n                # If the string cannot be converted to float, append the original string to the converted list\n                converted_list.append(element)\n        else:\n            # If the element is not a string, append it to the converted list as is\n            converted_list.append(element)\n\n    # Return the modified list\n    return converted_list"}
{"id": "107_0", "code": "def string_to_list(string):\n    \"\"\"\n    Converts a string into a list of characters.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        list: A list of characters from the input string.\n    \"\"\"\n    return list(string)"}
{"id": "108_0", "code": "def search(arr,n):\n    # Initialize two pointers, one at the start and one at the end of the array\n    left = 0\n    right = n - 1\n\n    # Continue the search until the two pointers meet\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n\n        # If the middle element is a single element, return it\n        if arr[mid] == arr[mid + 1]:\n            return arr[mid]\n\n        # If the middle element is not a single element, move the pointers\n        if arr[mid] == arr[mid - 1]:\n            left = mid + 1\n        else:\n            # If the middle element is greater than the next element, move the right pointer\n            if arr[mid] > arr[mid + 1]:\n                right = mid - 1\n            else:\n                # If the middle element is less than the next element, move the left pointer\n                left = mid + 1\n\n    # If no single element is found, return None\n    return None"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    \"\"\"\n    This function finds the maximum product from the pairs of tuples within a given list.\n    \n    Parameters:\n    list1 (list): A list of tuples.\n    \n    Returns:\n    int: The maximum product from the pairs of tuples.\n    \"\"\"\n    \n    # Initialize max_product as negative infinity\n    max_product = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for i in range(len(list1)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = list1[i][0] * list1[j][0]\n            \n            # Update max_product if the current product is greater\n            if product > max_product:\n                max_product = product\n                \n    # Return the maximum product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    for i in range(n-2):\n        # Initialize two pointers\n        left = i + 1\n        right = n - 1\n        while left < right:\n            # Calculate the sum of the current triplet\n            current_sum = A[i] + A[left] + A[right]\n            # If the sum is equal to the given sum, increment the count and move the pointers\n            if current_sum == sum:\n                count[0] += 1\n                left += 1\n                right -= 1\n            # If the sum is less than the given sum, move the left pointer to increase the sum\n            elif current_sum < sum:\n                left += 1\n            # If the sum is greater than the given sum, move the right pointer to decrease the sum\n            else:\n                right -= 1\n    return count[0]"}
{"id": "111_0", "code": "def smartNumber(n):\n    \"\"\"\n    This function generates the nth smart number.\n    \n    A smart number is a number that is the sum of its proper divisors, excluding the number itself.\n    \n    Parameters:\n    n (int): The position of the smart number to be generated.\n    \n    Returns:\n    int: The nth smart number.\n    \"\"\"\n    smart_numbers = []\n    num = 1\n    while len(smart_numbers) < n:\n        # Calculate the sum of proper divisors\n        sum_divisors = sum(i for i in range(1, num) if num % i == 0)\n        \n        # Check if the sum of divisors is equal to the number\n        if sum_divisors == num:\n            smart_numbers.append(num)\n        \n        num += 1\n    \n    # Return the nth smart number\n    return smart_numbers[-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    \"\"\"\n    This function calculates the sum of all amicable numbers from 1 to a specified limit.\n    \n    An amicable pair consists of two numbers so related that the sum of the proper divisors of each is equal to the other number. \n    For example, 220 and 284 are amicable numbers because the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110, \n    and the sum of these divisors is 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284, while the proper divisors of 284 are 1, 2, 4, 71 and 142, \n    and the sum of these divisors is 1 + 2 + 4 + 71 + 142 = 220.\n    \n    Parameters:\n    limit (int): The upper limit for the amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    \n    # Initialize a dictionary to store the sum of proper divisors for each number\n    divisor_sums = {}\n    \n    # Iterate over all numbers from 1 to the limit\n    for num in range(1, limit + 1):\n        # Initialize the sum of proper divisors for the current number\n        sum_of_divisors = 0\n        \n        # Iterate over all numbers from 1 to the current number\n        for i in range(1, num):\n            # Check if the current number is a divisor of the number\n            if num % i == 0:\n                # Add the divisor to the sum\n                sum_of_divisors += i\n        \n        # Store the sum of proper divisors in the dictionary\n        divisor_sums[num] = sum_of_divisors\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate over all numbers from 1 to the limit\n    for num in range(1, limit + 1):\n        # Check if the number has a corresponding amicable number\n        if num in divisor_sums and divisor_sums[num] in divisor_sums and divisor_sums[num] != num:\n            # Add the amicable numbers to the sum\n            amicable_sum += num + divisor_sums[num]\n    \n    # Return the sum of amicable numbers\n    return amicable_sum"}
{"id": "113_0", "code": "import math\n\ndef angle_complex(a,b):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    # Calculate the angle using the atan2 function\n    angle = math.atan2(b, a)\n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\n    max_diff = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if string[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            max_diff = max(max_diff, abs(zeros - ones))\n    return max_diff"}
{"id": "115_0", "code": "def sum(a,b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n\n    return sum(common_divisors)"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    \"\"\"\n    Multiply two integers without using the * operator.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        int: The product of x and y.\n    \"\"\"\n    if y == 0:\n        return 0\n    result = 0\n    is_negative = False\n    if (x < 0) ^ (y < 0):\n        is_negative = True\n    x = abs(x)\n    y = abs(y)\n    while y != 0:\n        if y & 1:\n            result += x\n        y >>= 1\n        x <<= 1\n    if is_negative:\n        result = -result\n    return result"}
{"id": "117_0", "code": "def long_words(n, string):\n    \"\"\"\n    This function takes a list of words and a number n as input.\n    It returns a list of words that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to be included in the output list.\n    string (str): A string containing a list of words separated by spaces.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the input string into a list of words\n    words = string.split()\n\n    # Initialize an empty list to store the long words\n    long_word_list = []\n\n    # Iterate over each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If the word is long, add it to the long_word_list\n            long_word_list.append(word)\n\n    # Return the list of long words\n    return long_word_list"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the input matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return \"Error: Input matrix is not a square matrix.\"\n\n    # Check if the input matrix is a magic square\n    if not is_magic_square(my_matrix):\n        return \"Error: Input matrix is not a magic square.\"\n\n    # Calculate the sum of the first row\n    sum_first_row = sum(my_matrix[0])\n\n    # Calculate the sum of the first column\n    sum_first_column = sum([my_matrix[i][0] for i in range(len(my_matrix))])\n\n    # Calculate the sum of the main diagonal\n    sum_main_diagonal = sum([my_matrix[i][i] for i in range(len(my_matrix))])\n\n    # Calculate the sum of the anti-diagonal\n    sum_anti_diagonal = sum([my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))])\n\n    # Check if the sums are equal\n    if sum_first_row == sum_first_column == sum_main_diagonal == sum_anti_diagonal:\n        return \"The magic square is valid.\"\n    else:\n        return \"The magic square is not valid.\""}
{"id": "119_0", "code": "from collections import Counter\n\ndef max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum frequency in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum frequency.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Count the frequency of each item in the list\n    freq = Counter(nums)\n\n    # Find the item with maximum frequency\n    max_freq_item = max(freq, key=freq.get)\n\n    return max_freq_item"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    \"\"\"\n    This function converts a tuple into a string.\n    \n    Parameters:\n    tup1 (tuple): The input tuple to be converted.\n    \n    Returns:\n    str: A string representation of the input tuple.\n    \"\"\"\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(num for num in nums if num < 0)"}
{"id": "123_0", "code": "def check_last(arr,n,p):\n    # Perform operation p times\n    for _ in range(p):\n        arr = arr[:-1]\n    \n    # Check if the last element is even or odd\n    if arr[-1] % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "124_0", "code": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    Args:\n        n (int): The position of the hexagonal number to calculate.\n\n    Returns:\n        int: The nth hexagonal number.\n\n    Raises:\n        ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # The formula for the nth hexagonal number is given by: \n    # Hn = n * (2n - 1)\n    # We use this formula to calculate the nth hexagonal number.\n    return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    \"\"\"\n    Calculate electricity bill based on the number of units consumed.\n\n    Args:\n        units (float): The number of units consumed.\n\n    Returns:\n        float: The calculated electricity bill.\n    \"\"\"\n    # Electricity tariff rates in Rs per unit\n    tariff_rate = 2.0  # Rs per unit\n\n    # Base rate for first 100 units\n    base_rate = 100 * tariff_rate\n\n    # Additional rate for units above 100\n    additional_rate = (units - 100) * tariff_rate\n\n    # Calculate the total bill\n    total_bill = base_rate + additional_rate\n\n    return total_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    \"\"\"\n    This function calculates the ratio of zeroes in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of zeroes in the list.\n\n    Raises:\n        ZeroDivisionError: If the input list is empty.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        raise ZeroDivisionError(\"Cannot calculate ratio of zeroes for an empty list\")\n\n    # Count the number of zeroes in the list\n    zero_count = nums.count(0)\n\n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n\n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a variable to store the sum of powers of 2\n    sum_of_powers = 0\n    \n    # Iterate over each character in the binary representation\n    for char in binary:\n        # If the character is '1', add the corresponding power of 2 to the sum\n        if char == '1':\n            sum_of_powers += 2 ** (binary.index(char) - len(binary) + 1)\n    \n    # Return True if the sum of powers is equal to the original number, False otherwise\n    return sum_of_powers == n"}
{"id": "128_0", "code": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    # Use the math library to calculate the circumference\n    # The formula for the circumference of a circle is 2 * pi * r\n    circumference = 2 * math.pi * r\n    return circumference"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples that contain only one element.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples that contain only one element.\n    \"\"\"\n    return [t for t in test_list if len(t) == 1]"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    \"\"\"\n    Sorts a list of elements using pancake sort algorithm.\n\n    Args:\n        nums (list): A list of integers to be sorted.\n\n    Returns:\n        list: A sorted list of integers.\n    \"\"\"\n    # Create a copy of the input list to avoid modifying it in-place\n    nums_copy = nums.copy()\n\n    # Iterate over the list from the end to the beginning\n    for n in range(len(nums_copy) - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_idx = nums_copy.index(max(nums_copy[:n + 1]))\n\n        # If the maximum element is not at the beginning of the unsorted part, flip it to the top\n        if max_idx != n:\n            # Flip the maximum element to the top\n            nums_copy[:max_idx + 1] = reversed(nums_copy[:max_idx + 1])\n\n            # Flip the maximum element to the bottom\n            nums_copy[:n + 1] = reversed(nums_copy[:n + 1])\n\n    return nums_copy"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(list1)\n    set2 = set(list2)\n    set3 = set(list3)\n\n    # Initialize a counter for the same pairs\n    same_pairs = 0\n\n    # Iterate over the elements in the first set\n    for elem in set1:\n        # Check if the element is also in the second and third sets\n        if elem in set2 and elem in set3:\n            # If it is, increment the counter\n            same_pairs += 1\n\n    # Return the count of same pairs\n    return same_pairs"}
{"id": "132_0", "code": "def find_lists(Input):\n    \"\"\"\n    This function takes a tuple as input and returns the number of lists present in the tuple.\n\n    Args:\n        Input (tuple): A tuple containing lists.\n\n    Returns:\n        int: The number of lists present in the tuple.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr,n):\n    # Calculate the sum of absolute differences in all pairs of the given array\n    total_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr,n):\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # The maximum difference will be between the last and first elements\n    # If the array has only one element, return 0\n    if n == 1:\n        return 0\n    else:\n        return arr[n-1] - arr[0]"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    \"\"\"\n    This function calculates the total ASCII value of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total ASCII value of characters in the string.\n    \"\"\"\n    total_ascii = sum(ord(char) for char in str1)\n    return total_ascii"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Create a 2D array to store the maximum path sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = tri[i][0]\n    for j in range(n):\n        dp[0][j] = tri[0][j]\n    \n    # Fill up the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum path sum at position (i, j) is the maximum of the path sum\n            # from the top, left, and top-left, plus the value at position (i, j)\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + tri[i][j]\n    \n    # The maximum total path sum is stored in the bottom-right corner of the dp array\n    return dp[m-1][n-1]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    def sum_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    max_sum = 0\n    for i in range(1, N):\n        sum1 = sum_digits(i)\n        sum2 = sum_digits(N - i)\n        total_sum = sum1 + sum2\n        if total_sum > max_sum:\n            max_sum = total_sum\n            best_i = i\n\n    return best_i"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    if n < 3:\n        return n\n\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = 1\n            for k in range(i, j):\n                if abs(arr[i] - arr[k]) == 1 and abs(arr[k] - arr[j]) == 1:\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, dp[i][n-1])\n\n    return max_length"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    \"\"\"\n    Checks if the number 'a' is present in the infinite sequence generated by the recurrence relation:\n    b = b * b + c\n    a = a * a + c\n\n    Args:\n        a (int): The number to check for presence in the sequence.\n        b (int): The first term of the sequence.\n        c (int): The constant term in the recurrence relation.\n\n    Returns:\n        bool: True if 'a' is present in the sequence, False otherwise.\n    \"\"\"\n    # Initialize the sequence with the first term 'b'\n    sequence = [b]\n\n    # Generate the sequence until we find 'a' or it exceeds the limit\n    while True:\n        # Calculate the next term in the sequence\n        next_term = sequence[-1] * sequence[-1] + c\n\n        # If the next term is equal to 'a', return True\n        if next_term == a:\n            return True\n\n        # If the next term exceeds the limit, return False\n        if next_term > 1000000:  # arbitrary limit, adjust as needed\n            return False\n\n        # Add the next term to the sequence\n        sequence.append(next_term)\n\n# Example usage:\nprint(does_Contain_B(13, 3, 0))  # True\nprint(does_Contain_B(10, 3, 0))  # False"}
{"id": "140_0", "code": "import math\n\ndef is_coprime(x, y):\n    \"\"\"\n    Checks whether two numbers are co-prime or not.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        bool: True if the numbers are co-prime, False otherwise.\n    \"\"\"\n    # Check if both numbers are integers\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both numbers must be integers.\")\n\n    # Check if both numbers are non-negative\n    if x < 0 or y < 0:\n        raise ValueError(\"Both numbers must be non-negative.\")\n\n    # Check if both numbers are zero\n    if x == 0 and y == 0:\n        return True\n\n    # Calculate the greatest common divisor (GCD) of the two numbers\n    gcd = math.gcd(x, y)\n\n    # Check if the GCD is 1\n    return gcd == 1"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) <= 1:\n        return x\n    mid = len(x) // 2\n    left_half = merge_sort(x[:mid])\n    right_half = merge_sort(x[mid:])\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    merged += left[left_index:]\n    merged += right[right_index:]\n    return merged"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculate the vertex of a parabola given its coefficients a, b, and c.\n\n    The parabola is in the form ax^2 + bx + c.\n\n    Parameters:\n    a (float): The coefficient of x^2.\n    b (float): The coefficient of x.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the vertex.\n    \"\"\"\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    # Return the vertex as a tuple\n    return (x_vertex, y_vertex)"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every specified element from a given two dimensional list.\n\n    Args:\n        nums (list): A two dimensional list of integers.\n        N (int): The index of the element to be extracted.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    extracted_elements = []\n    for row in nums:\n        if N < len(row):\n            extracted_elements.append(row[N])\n    return extracted_elements"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    This function takes an integer as input, toggles all even bits, and returns the result.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The integer with all even bits toggled.\n    \"\"\"\n    # Convert the integer to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in bin_n:\n        # If the bit is even (i.e., '0'), toggle it to '1'\n        if bit == '0':\n            result += '1'\n        # If the bit is odd (i.e., '1'), toggle it to '0'\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    \"\"\"\n    This function takes a tuple of string values as input and returns a tuple of integer values.\n    \n    Parameters:\n    tuple_str (tuple): A tuple of string values.\n    \n    Returns:\n    tuple: A tuple of integer values.\n    \"\"\"\n    return tuple(int(value) for value in tuple_str)"}
{"id": "146_0", "code": "def encode_list(list1):\n    \"\"\"\n    This function takes a list as input and returns a string representing the run-length encoding of the input list.\n    \n    Args:\n        list1 (list): A list of characters.\n    \n    Returns:\n        str: A string representing the run-length encoding of the input list.\n    \"\"\"\n    if not list1:\n        return \"\"\n    \n    result = \"\"\n    count = 1\n    current_char = list1[0]\n    \n    for char in list1[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            result += str(count) + current_char\n            current_char = char\n            count = 1\n    \n    result += str(count) + current_char\n    return result"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    \"\"\"\n    This function calculates the minimum number of operations required to make all elements in the array equal.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The size of the input list.\n    k (int): The number of operations allowed.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    \n    # First, we need to find the median of the array. This is because the median is the value that minimizes the sum of absolute differences with all other values in the array.\n    arr.sort()\n    \n    # If the array is empty, we return 0 because no operations are needed.\n    if n == 0:\n        return 0\n    \n    # If the array has only one element, we return 0 because no operations are needed.\n    if n == 1:\n        return 0\n    \n    # We calculate the median of the array. If the array has an odd length, the median is the middle element. If the array has an even length, the median is the average of the two middle elements.\n    median = arr[n // 2] if n % 2 != 0 else (arr[n // 2 - 1] + arr[n // 2]) / 2\n    \n    # We initialize a variable to store the total number of operations.\n    total_ops = 0\n    \n    # We iterate over the array and calculate the absolute difference between each element and the median. We add this difference to the total number of operations.\n    for num in arr:\n        total_ops += abs(num - median)\n    \n    # We return the total number of operations. However, we need to consider the constraint that we can only perform k operations. So, we return the minimum of the total number of operations and k.\n    return min(total_ops, k)"}
{"id": "148_0", "code": "def month_season(month,days):\n    if month == 12:\n        if days >= 25:\n            print(\"Winter\")\n        else:\n            print(\"Autumn\")\n    elif month == 1:\n        if days >= 1:\n            print(\"Winter\")\n        else:\n            print(\"Spring\")\n    elif month == 2:\n        if days >= 28:\n            print(\"Winter\")\n        else:\n            print(\"Spring\")\n    elif month == 3:\n        if days >= 1:\n            print(\"Spring\")\n        else:\n            print(\"Autumn\")\n    elif month == 4:\n        if days >= 30:\n            print(\"Spring\")\n        else:\n            print(\"Summer\")\n    elif month == 5:\n        if days >= 1:\n            print(\"Summer\")\n        else:\n            print(\"Autumn\")\n    elif month == 6:\n        if days >= 30:\n            print(\"Summer\")\n        else:\n            print(\"Winter\")\n    elif month == 7:\n        if days >= 1:\n            print(\"Autumn\")\n        else:\n            print(\"Spring\")\n    elif month == 8:\n        if days >= 31:\n            print(\"Autumn\")\n        else:\n            print(\"Winter\")\n    elif month == 9:\n        if days >= 1:\n            print(\"Winter\")\n        else:\n            print(\"Spring\")\n    elif month == 10:\n        if days >= 30:\n            print(\"Winter\")\n        else:\n            print(\"Autumn\")\n    elif month == 11:\n        if days >= 1:\n            print(\"Autumn\")\n        else:\n            print(\"Summer\")\n    elif month == 0:\n        if days >= 31:\n            print(\"Summer\")\n        else:\n            print(\"Winter\")\n    else:\n        print(\"Invalid month\")"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Calculate the gcd of a and b\n    gcd = gcd_helper(a, b)\n    \n    # If gcd is not 1, there is no solution\n    if gcd != 1:\n        return None\n    \n    # Calculate x and y using the extended Euclidean algorithm\n    x, y = extended_euclidean(a, b, n)\n    \n    return x, y\n\ndef gcd_helper(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef extended_euclidean(a, b, n):\n    if b == 0:\n        return 1, 0\n    else:\n        x, y = extended_euclidean(b, a % b, n)\n        return y, x - (n // b) * y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    \"\"\"\n    Removes all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The list from which elements will be removed.\n        list2 (list): The list containing elements to be removed.\n\n    Returns:\n        list: The modified list1 with elements from list2 removed.\n    \"\"\"\n    # Convert list2 to a set for efficient lookups\n    set2 = set(list2)\n    \n    # Use a list comprehension to filter out elements from list1 that are in set2\n    return [element for element in list1 if element not in set2]"}
{"id": "151_0", "code": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n    \n    Parameters:\n    n (int): The starting number of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize the x variable to 2 (since we start from n-2)\n    x = 2\n    \n    # Continue the loop until n-x is less than or equal to 0\n    while n - x >= 0:\n        # Add the current number to the sum\n        total_sum += n - x\n        \n        # Increment x by 2 (since we are subtracting 2 each time)\n        x += 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "152_0", "code": "import math\n\ndef area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (float): The length of one side of the polygon.\n    l (float): The number of sides of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the number of sides is valid\n    if l < 3:\n        raise ValueError(\"A polygon must have at least 3 sides\")\n\n    # Calculate the area using the formula: (n * s^2) / (4 * tan(/n))\n    area = (l * s**2) / (4 * math.tan(math.pi/l))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    \"\"\"\n    This function checks whether the sum of divisors of two numbers are same or not.\n    \n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n    \n    Returns:\n    bool: True if the sum of divisors of num1 and num2 are same, False otherwise.\n    \"\"\"\n    \n    # Function to calculate the sum of divisors of a number\n    def sum_of_divisors(n):\n        sum_divisors = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                sum_divisors += i\n        return sum_divisors\n    \n    # Calculate the sum of divisors for both numbers\n    sum_divisors_num1 = sum_of_divisors(num1)\n    sum_divisors_num2 = sum_of_divisors(num2)\n    \n    # Check if the sums are equal\n    return sum_divisors_num1 == sum_divisors_num2"}
{"id": "154_0", "code": "def count_char_position(str1):\n    \"\"\"\n    This function counts the characters at the same position in a given string \n    (lower and uppercase characters) as in English alphabet.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are the characters and values are their counts.\n    \"\"\"\n    # Initialize an empty dictionary to store the character counts\n    char_count = {}\n\n    # Iterate over the string\n    for i in range(len(str1)):\n        # Check if the character is an alphabet\n        if str1[i].isalpha():\n            # Convert the character to lowercase for comparison\n            char = str1[i].lower()\n            # Check if the character is already in the dictionary\n            if char in char_count:\n                # If it is, increment its count\n                char_count[char] += 1\n            else:\n                # If it's not, add it to the dictionary with a count of 1\n                char_count[char] = 1\n\n    # Return the dictionary\n    return char_count"}
{"id": "155_0", "code": "def find_even_Pair(A,N):\n    count = 0\n    for i in range(N):\n        for j in range(i+1,N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count"}
{"id": "156_0", "code": "import math\n\ndef next_Power_Of_2(n):\n    \"\"\"\n    This function returns the smallest power of 2 that is greater than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The smallest power of 2 that is greater than or equal to n.\n    \"\"\"\n    # Calculate the base-2 logarithm of n\n    log_n = math.log2(n)\n    \n    # If n is a power of 2, return n\n    if log_n == int(log_n):\n        return n\n    \n    # Calculate the smallest power of 2 greater than or equal to n\n    next_power = 2 ** math.ceil(log_n)\n    \n    return next_power"}
{"id": "157_0", "code": "def frequency(a,x):\n    \"\"\"\n    This function calculates the frequency of a given number in an array.\n\n    Parameters:\n    a (list): The input array.\n    x (int): The number to find the frequency of.\n\n    Returns:\n    int: The frequency of the number in the array.\n    \"\"\"\n    # Initialize a counter variable to store the frequency\n    count = 0\n    \n    # Iterate over each element in the array\n    for num in a:\n        # Check if the current element is equal to the given number\n        if num == x:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the frequency\n    return count"}
{"id": "158_0", "code": "import math\n\ndef get_pell(n):\n    \"\"\"\n    Calculate the nth Pell number.\n\n    Args:\n        n (int): The position of the Pell number to calculate.\n\n    Returns:\n        int: The nth Pell number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the first two Pell numbers\n    p_0 = 0\n    p_1 = 1\n\n    # Calculate the nth Pell number\n    for _ in range(2, n + 1):\n        p_0, p_1 = p_1, 2 * p_0 + p_1\n\n    return p_1"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    \"\"\"\n    This function calculates the sum of numbers in a list between the specified range.\n\n    Args:\n        list1 (list): The input list of numbers.\n        m (int): The starting index of the range (inclusive).\n        n (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the list between the specified range.\n\n    Raises:\n        TypeError: If the input list is not a list or if the indices are not integers.\n        IndexError: If the indices are out of range.\n    \"\"\"\n    # Check if the input list is a list and the indices are integers\n    if not isinstance(list1, list) or not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"Input list must be a list and indices must be integers.\")\n\n    # Check if the indices are within the range of the list\n    if m < 0 or n >= len(list1) or m > n:\n        raise IndexError(\"Indices out of range.\")\n\n    # Calculate the sum of numbers in the list between the specified range\n    total_sum = sum(list1[m:n+1])\n\n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # Define the number of sides of a pentagon\n    n = 5\n    \n    # Calculate the perimeter using the formula: perimeter = n * side_length\n    perimeter = n * a\n    \n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    return s.count('std')"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(char for char in text if char.isalnum())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    \"\"\"\n    This function groups a sequence of key-value pairs into a dictionary of lists.\n    \n    Parameters:\n    l (list): A list of tuples, where each tuple contains a key-value pair.\n    \n    Returns:\n    dict: A dictionary where each key is a unique key from the input list, and its corresponding value is a list of values associated with that key.\n    \"\"\"\n    result = {}\n    for key, value in l:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result"}
{"id": "164_0", "code": "def is_valid_parenthese(str1):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in str1:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack"}
{"id": "165_0", "code": "def perimeter_triangle(a,b,c):\n    \"\"\"\n    This function calculates the perimeter of a triangle given the lengths of its sides.\n\n    Args:\n        a (float): The length of the first side of the triangle.\n        b (float): The length of the second side of the triangle.\n        c (float): The length of the third side of the triangle.\n\n    Returns:\n        float: The perimeter of the triangle.\n\n    Raises:\n        ValueError: If the sum of the lengths of any two sides is not greater than the length of the third side.\n    \"\"\"\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        raise ValueError(\"The given sides cannot form a triangle.\")\n\n    # Calculate the perimeter\n    perimeter = a + b + c\n\n    return perimeter"}
{"id": "166_0", "code": "import math\n\ndef answer(L, R):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            if lcm(i, j) <= R:\n                return (i, j)\n    return None"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for the given patterns in the text.\n\n    Args:\n        patterns (list): A list of literals to search for.\n        text (str): The text to search in.\n\n    Returns:\n        dict: A dictionary with the patterns as keys and their first occurrence indices as values.\n    \"\"\"\n    result = {}\n    for pattern in patterns:\n        index = text.find(pattern)\n        while index != -1:\n            result[pattern] = index\n            index = text.find(pattern, index + 1)\n    return result"}
{"id": "168_0", "code": "def is_num_keith(x):\n    \"\"\"\n    Checks if a given number is a Keith number.\n\n    A Keith number is a number that can be expressed as the sum of consecutive integers,\n    starting from 1, until the sum is greater than or equal to the number.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Keith number, False otherwise.\n    \"\"\"\n    total = 0\n    i = 1\n    while total < x:\n        total += i\n        i += 1\n    return total == x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Radius of the Earth in kilometers\n    R = 6371.0\n\n    # Convert degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n\n    # Differences in coordinates\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n\n    # Haversine formula\n    a = math.sin(dlat / 2)**2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Distance\n    distance = R * c\n\n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    if not arr:\n        return \"\"\n    prefix = arr[0]\n    for i in range(1, n):\n        while not arr[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    \"\"\"\n    This function takes a string as input and returns a dictionary containing \n    the count of uppercase, lowercase, special characters and numeric values.\n\n    Parameters:\n    string (str): The input string to be analyzed.\n\n    Returns:\n    dict: A dictionary containing the count of uppercase, lowercase, special characters and numeric values.\n    \"\"\"\n\n    # Initialize a dictionary to store the count of each type of character\n    character_count = {\n        'uppercase': 0,\n        'lowercase': 0,\n        'special': 0,\n        'numeric': 0\n    }\n\n    # Use regex to find uppercase characters\n    uppercase_count = len(re.findall(r'[A-Z]', string))\n    character_count['uppercase'] = uppercase_count\n\n    # Use regex to find lowercase characters\n    lowercase_count = len(re.findall(r'[a-z]', string))\n    character_count['lowercase'] = lowercase_count\n\n    # Use regex to find special characters\n    special_count = len(re.findall(r'[^A-Za-z0-9]', string))\n    character_count['special'] = special_count\n\n    # Use regex to find numeric values\n    numeric_count = len(re.findall(r'\\d', string))\n    character_count['numeric'] = numeric_count\n\n    return character_count"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a hashmap to store the frequency of each element\n    freq_map = {}\n    for num in arr:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n\n    # Initialize count of pairs\n    count = 0\n\n    # Traverse the array\n    for i in range(n):\n        # Check if the element plus k exists in the hashmap\n        if arr[i] + k in freq_map:\n            # Add the product of their frequencies to the count\n            count += freq_map[arr[i]] * freq_map[arr[i] + k]\n\n        # Check if the element minus k exists in the hashmap\n        if arr[i] - k in freq_map:\n            # Add the product of their frequencies to the count\n            count += freq_map[arr[i]] * freq_map[arr[i] - k]\n\n    # Divide by 2 to avoid counting each pair twice\n    return count // 2"}
{"id": "173_0", "code": "def greater_specificnum(lst, num):\n    \"\"\"\n    This function finds all the values in a list that are greater than a specified number.\n\n    Args:\n        lst (list): A list of numbers.\n        num (int): The specified number.\n\n    Returns:\n        list: A list of numbers greater than the specified number.\n    \"\"\"\n    return [i for i in lst if i > num]"}
{"id": "174_0", "code": "import math\n\ndef parabola_focus(a, b, c):\n    \"\"\"\n    Calculate the focus of a parabola given its equation in the form ax^2 + bx + c = 0.\n\n    Parameters:\n    a (float): The coefficient of the x^2 term.\n    b (float): The coefficient of the x term.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the focus.\n    \"\"\"\n    # Calculate the focal length (p)\n    p = (a * b**2 - 3 * c) / (3 * a**2)\n\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n\n    # Calculate the y-coordinate of the focus\n    y_focus = p\n\n    return x_focus, y_focus"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    \"\"\"\n    Searches for the given patterns in the text.\n\n    Args:\n        text (str): The text to search in.\n        patterns (list of str): The patterns to search for.\n\n    Returns:\n        list of bool: A list of boolean values indicating whether each pattern was found in the text.\n    \"\"\"\n    results = []\n    for pattern in patterns:\n        results.append(bool(re.search(pattern, text)))\n    return results"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a table to store lengths of longest common subsequence of\n    # substrings. Note that lcs[i][j] contains length of LCS of X[0..i-1]\n    # and Y[0..j-1].\n    lcs = [[0 for w in range(n+1)] for x in range(m+1)]\n\n    # Fill lcs[m][n] in bottom up manner\n    for i in range(m, 0, -1):\n        for j in range(n, 0, -1):\n            if X[i-1] == Y[j-1]:\n                lcs[i][j] = lcs[i-1][j-1] + 1\n            else:\n                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])\n\n    # Following code is used to print LCS\n    index = lcs[m][n]\n\n    # Create a character array to store the lcs string\n    lcs_str = [\"\"] * (index+1)\n    lcs_str[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and\n    # one by one store characters in lcs_str\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X and Y are same, then\n        # current character is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs_str[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and\n        # go in the direction of larger value\n        elif lcs[i-1][j] > lcs[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs_str)"}
{"id": "177_0", "code": "def prod_Square(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            if (n // i) % i == 0:\n                return True\n            else:\n                return False\n        i += 1\n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr,n):\n    # Create a set from the array\n    s = set(arr)\n    \n    # Initialize the first missing positive number as 1\n    missing = 1\n    \n    # Loop through the set\n    while missing in s:\n        missing += 1\n    \n    # Return the first missing positive number\n    return missing"}
{"id": "179_0", "code": "def count_Intgral_Points(x1,y1,x2,y2):\n    # Calculate the side length of the square\n    side_length = abs(x2 - x1)\n    \n    # Initialize a counter for integral coordinates\n    count = 0\n    \n    # Iterate over all possible x-coordinates\n    for x in range(x1, x2 + 1):\n        # Iterate over all possible y-coordinates\n        for y in range(y1, y2 + 1):\n            # Check if the current coordinate is an integer\n            if x == int(x) and y == int(y):\n                # Increment the counter if the coordinate is an integer\n                count += 1\n                \n    # Return the total count of integral coordinates\n    return count"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    monthdays = {\n        \"January\": 31, \"February\": 28, \"March\": 31, \"April\": 30, \"May\": 31, \"June\": 30,\n        \"July\": 31, \"August\": 31, \"September\": 30, \"October\": 31, \"November\": 30, \"December\": 31\n    }\n    if monthname3 in monthdays:\n        if monthdays[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "181_0", "code": "def check_String(str):\n    # Check if the string has at least one letter and one number\n    if (any(char.isalpha() for char in str) and any(char.isdigit() for char in str)):\n        return True\n    else:\n        return False"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    \"\"\"\n    This function removes duplicates from a given tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        tuple: A new tuple with duplicates removed.\n    \"\"\"\n    # Convert the tuple to a set to remove duplicates\n    # Since sets are unordered, we convert it back to a tuple\n    # and sort it to maintain the original order\n    return tuple(sorted(set(test_tup)))"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\n    \"\"\"\n    This function converts an octal number to a decimal number.\n\n    Parameters:\n    n (str): The octal number to be converted.\n\n    Returns:\n    int: The decimal equivalent of the input octal number.\n\n    Raises:\n    ValueError: If the input is not a valid octal number.\n    \"\"\"\n\n    # Check if the input is a valid octal number\n    if not set(n).issubset('01234567'):\n        raise ValueError(\"Invalid octal number\")\n\n    # Convert the octal number to decimal using Python's built-in int function\n    decimal = int(n, 8)\n\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    low = 0\n    high = n-1\n    while low <= high:\n        mid = (low+high)//2\n        if arr[mid] == x:\n            return mid+1\n        elif arr[mid] < x:\n            low = mid+1\n        else:\n            high = mid-1\n    return -1"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    return [item for item in test_list if len(item) != K]"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns the result of the exponentiation of the first tuple element with the second tuple element.\n\n    Args:\n        test_tup1 (tuple): The first tuple containing the base number.\n        test_tup2 (tuple): The second tuple containing the exponent.\n\n    Returns:\n        float: The result of the exponentiation.\n\n    Raises:\n        TypeError: If either of the input tuples contains non-numeric values.\n    \"\"\"\n    # Check if both tuples contain only numeric values\n    if not all(isinstance(x, (int, float)) for x in test_tup1) or not all(isinstance(x, (int, float)) for x in test_tup2):\n        raise TypeError(\"Both tuples must contain only numeric values.\")\n\n    # Extract the base and exponent from the tuples\n    base = test_tup1[0]\n    exponent = test_tup2[0]\n\n    # Perform the exponentiation using the ** operator\n    result = base ** exponent\n\n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a,b):\n    \"\"\"\n    This function calculates the largest triangle that can be inscribed in an ellipse.\n    \n    Parameters:\n    a (float): The semi-major axis of the ellipse.\n    b (float): The semi-minor axis of the ellipse.\n    \n    Returns:\n    float: The area of the largest triangle that can be inscribed in the ellipse.\n    \"\"\"\n    \n    # Calculate the area of the largest triangle using the formula: A = 2 * a * b * sin(theta)\n    # where theta is the angle between the major and minor axes of the ellipse\n    # We can find theta using the formula: theta = 2 * arccos(1 - (b^2/a^2))\n    theta = 2 * math.acos(1 - (b**2/a**2))\n    \n    # Calculate the area of the largest triangle\n    area = 2 * a * b * math.sin(theta/2)\n    \n    return area"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 less than or equal to the given number.\n\n    Parameters:\n    n (int): The given number.\n\n    Returns:\n    int: The highest power of 2 less than or equal to the given number.\n\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep doubling the power of 2 until it exceeds the given number\n    while power_of_2 <= n:\n        power_of_2 *= 2\n    \n    # The highest power of 2 less than or equal to the given number is the previous power of 2\n    return power_of_2 // 2"}
{"id": "189_0", "code": "def position_max(list1):\n    \"\"\"\n    This function finds all index positions of the maximum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the maximum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n\n    return max_indices"}
{"id": "190_0", "code": "def chkList(lst):\n    \"\"\"\n    This function checks whether the elements in a list are same or not.\n\n    Args:\n        lst (list): A list of elements to be checked.\n\n    Returns:\n        bool: True if all elements are same, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if len(lst) == 0:\n        return True  # An empty list is considered to have all elements same\n\n    # Get the first element of the list\n    first_element = lst[0]\n\n    # Iterate over the rest of the list\n    for element in lst[1:]:\n        # If any element is different from the first element, return False\n        if element != first_element:\n            return False\n\n    # If the function hasn't returned False, all elements are same\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    return ''.join([char for char in str1 if int(char) % 2 != 0])"}
{"id": "192_0", "code": "def hamming_Distance(n1,n2):\n    # Convert the integers to binary and remove the '0b' prefix\n    bin_n1 = bin(n1)[2:]\n    bin_n2 = bin(n2)[2:]\n    \n    # Find the maximum length between the two binary strings\n    max_len = max(len(bin_n1), len(bin_n2))\n    \n    # Pad the shorter string with leading zeros\n    bin_n1 = bin_n1.zfill(max_len)\n    bin_n2 = bin_n2.zfill(max_len)\n    \n    # Initialize a counter for the Hamming distance\n    distance = 0\n    \n    # Iterate over the characters in the binary strings\n    for i in range(max_len):\n        # If the characters at the current position are different, increment the distance\n        if bin_n1[i] != bin_n2[i]:\n            distance += 1\n    \n    # Return the Hamming distance\n    return distance"}
{"id": "193_0", "code": "def count(s,c):\n    \"\"\"\n    This function counts the occurrence of a given character in a string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be counted.\n\n    Returns:\n    int: The number of occurrences of the character in the string.\n    \"\"\"\n    return s.count(c)"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    \"\"\"\n    This function calculates the inversions of tuple elements in the given tuple list.\n    \n    Args:\n        test_tup (list): A list of tuples.\n    \n    Returns:\n        list: A list of tuples with inversions calculated.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the given list\n    for tup in test_tup:\n        # Initialize a counter to count the inversions\n        inversion_count = 0\n        \n        # Iterate over each element in the tuple\n        for i in range(len(tup)):\n            # Iterate over each element in the remaining part of the tuple\n            for j in range(i + 1, len(tup)):\n                # If the current element is greater than the compared element, it's an inversion\n                if tup[i] > tup[j]:\n                    inversion_count += 1\n        \n        # Append the inversion count to the result list\n        result.append((tup, inversion_count))\n    \n    # Return the result list\n    return result"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    \"\"\"\n    This function takes a tuple of strings as input, \n    and returns a new tuple with the adjacent elements concatenated.\n    \n    Args:\n        test_tup (tuple): A tuple of strings.\n    \n    Returns:\n        tuple: A new tuple with the adjacent elements concatenated.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        # Concatenate adjacent elements\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    max_length = 0\n    max_subseq = \"\"\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            elif length == 2:\n                if str[i] == str[j]:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 1\n            else:\n                if str[i] == str[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                max_subseq = str[i:j + 1]\n\n    return max_subseq, max_length"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    \"\"\"\n    Checks if the given number is a decimal with a precision of 2.\n    \n    Args:\n        num (str): The input number to be checked.\n    \n    Returns:\n        bool: True if the number is a decimal with a precision of 2, False otherwise.\n    \"\"\"\n    # Define the pattern for a decimal with a precision of 2\n    pattern = r'^-?\\d+(\\.\\d{2})?$'\n    \n    # Use the fullmatch function to check if the entire string matches the pattern\n    if re.fullmatch(pattern, num):\n        return True\n    else:\n        return False"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    \"\"\"\n    Deletes the smallest element from the heap and inserts a new item.\n\n    Args:\n        heap (list): A list representing the heap.\n        a (int): The new item to be inserted.\n\n    Returns:\n        list: The updated heap after deletion and insertion.\n    \"\"\"\n    # Check if the heap is empty\n    if not heap:\n        return heap\n\n    # Find the smallest element in the heap\n    smallest = min(heap)\n\n    # Remove the smallest element from the heap\n    heap.remove(smallest)\n\n    # Insert the new item into the heap\n    heap.append(a)\n\n    # Heapify the heap to maintain the heap property\n    heapify(heap)\n\n    return heap\n\n\ndef heapify(heap):\n    \"\"\"\n    Maintains the heap property by bubbling up or down the heap.\n\n    Args:\n        heap (list): A list representing the heap.\n    \"\"\"\n    # Start from the last non-leaf node and work backwards\n    for i in range(len(heap) // 2 - 1, -1, -1):\n        # Heapify the subtree rooted at index i\n        heapify_subtree(heap, i)\n\n\ndef heapify_subtree(heap, i):\n    \"\"\"\n    Recursively heapifies the subtree rooted at index i.\n\n    Args:\n        heap (list): A list representing the heap.\n        i (int): The index of the root of the subtree.\n    \"\"\"\n    # Initialize the smallest as the root\n    smallest = i\n\n    # Calculate the left and right child indices\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # Check if the left child exists and is smaller than the root\n    if left < len(heap) and heap[left] < heap[smallest]:\n        smallest = left\n\n    # Check if the right child exists and is smaller than the smallest\n    if right < len(heap) and heap[right] < heap[smallest]:\n        smallest = right\n\n    # If the smallest is not the root, swap them and continue heapifying\n    if smallest != i:\n        heap[i], heap[smallest] = heap[smallest], heap[i]\n        heapify_subtree(heap, smallest)"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    \"\"\"\n    Checks if the given string contains only a-z, a-z, and 0-9 characters.\n\n    Args:\n        string (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains only allowed characters, False otherwise.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, string))"}
{"id": "200_0", "code": "def count_Num(n):\n    count = 0\n    for i in range(n):\n        # calculate the ith bit position\n        bit_position = i + 1\n        # calculate the ith bit value\n        bit_value = (1 << bit_position) & i\n        # check if the ith bit is set\n        if bit_value != 0:\n            count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fourth power of the first 'n' natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to be considered.\n    \n    Returns:\n    int: The sum of the fourth power of the first 'n' natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first 'n' natural numbers\n    for i in range(1, n + 1):\n        # Calculate the fourth power of the current number\n        fourth_power = i ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenates two string tuples into a single string.\n\n    Args:\n        test_tup1 (tuple): The first tuple of strings to concatenate.\n        test_tup2 (tuple): The second tuple of strings to concatenate.\n\n    Returns:\n        str: A single string containing all the strings from both input tuples.\n    \"\"\"\n    # Check if both inputs are tuples\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples\")\n\n    # Check if both tuples contain only strings\n    if not all(isinstance(s, str) for s in test_tup1) or not all(isinstance(s, str) for s in test_tup2):\n        raise TypeError(\"Both tuples must contain only strings\")\n\n    # Use the join() method to concatenate the strings in both tuples\n    # The join() method returns a string concatenated with the elements of an iterable\n    # We use the comma join operator (',') to concatenate the strings in each tuple\n    result = ','.join(test_tup1) + ',' + ','.join(test_tup2)\n\n    return result"}
{"id": "203_0", "code": "import math\n\ndef degree_radian(radian):\n    \"\"\"\n    This function converts radians to degrees.\n\n    Args:\n        radian (float): The angle in radians.\n\n    Returns:\n        float: The angle in degrees.\n    \"\"\"\n    # Use the math library's rad2deg function to convert radians to degrees\n    degree = math.degrees(radian)\n    return degree"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.append(char * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    \"\"\"\n    This function checks if list1 is a subset of list2.\n    \n    Args:\n        list1 (list): The list to be checked.\n        list2 (list): The list against which the check is performed.\n    \n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    # Flatten both lists\n    flat_list1 = flatten_list(list1)\n    flat_list2 = flatten_list(list2)\n    \n    # Check if all elements of flat_list1 are in flat_list2\n    return all(element in flat_list2 for element in flat_list1)\n\n\ndef flatten_list(nested_list):\n    \"\"\"\n    This function flattens a nested list into a one-dimensional list.\n    \n    Args:\n        nested_list (list): The list to be flattened.\n    \n    Returns:\n        list: The flattened list.\n    \"\"\"\n    flat_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            flat_list.append(element)\n    return flat_list"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    \"\"\"\n    This function finds the first repeated character in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The first repeated character if found, otherwise None.\n    \"\"\"\n    # Convert the string to a set to remove duplicates and preserve order\n    str_set = set()\n    for char in str:\n        if char in str_set:\n            # If the character is already in the set, return it\n            return char\n        str_set.add(char)\n    # If no repeated character is found, return None\n    return None"}
{"id": "207_0", "code": "def min_Operations(A,B):\n    # Calculate the absolute difference between A and B\n    diff = abs(A - B)\n    \n    # If A and B are already equal, no operations are needed\n    if A == B:\n        return 0\n    \n    # If A is greater than B, we need to reduce A to B\n    if A > B:\n        # Calculate the number of times we need to subtract 1 from A\n        operations = (A - B) // 2\n        # Add 1 to account for the last subtraction\n        operations += 1\n        return operations\n    \n    # If B is greater than A, we need to increase A to B\n    else:\n        # Calculate the number of times we need to add 1 to A\n        operations = (B - A) // 2\n        # Add 1 to account for the last addition\n        operations += 1\n        return operations"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    \"\"\"\n    This function takes a tuple and an integer K as input, \n    and returns the minimum and maximum K elements in the tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n        K (int): The number of elements to extract.\n\n    Returns:\n        tuple: A tuple containing the minimum and maximum K elements.\n    \"\"\"\n    # Check if K is greater than the length of the tuple\n    if K > len(test_tup):\n        raise ValueError(\"K cannot be greater than the length of the tuple\")\n\n    # Sort the tuple in ascending order\n    sorted_tup = sorted(test_tup)\n\n    # Extract the minimum and maximum K elements\n    min_k = sorted_tup[:K]\n    max_k = sorted_tup[-K:]\n\n    # Return the minimum and maximum K elements\n    return min_k, max_k"}
{"id": "209_0", "code": "def replace_max_specialchar(text,n):\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Initialize a counter to track the number of replacements made\n    replacements = 0\n    \n    # Initialize an empty list to store the characters of the modified text\n    modified_text = []\n    \n    # Iterate over each character in the input text\n    for char in text:\n        # Check if the character is a special character\n        if char in special_chars:\n            # If the number of replacements is less than n, replace the character with a colon\n            if replacements < n:\n                modified_text.append(':')\n                replacements += 1\n            # If the number of replacements is equal to n, append the character as is\n            else:\n                modified_text.append(char)\n        # If the character is not a special character, append it to the modified text as is\n        else:\n            modified_text.append(char)\n    \n    # Join the characters in the modified text list into a string\n    modified_text = ''.join(modified_text)\n    \n    # Return the modified text\n    return modified_text"}
{"id": "210_0", "code": "def first_even(nums):\n    \"\"\"\n    This function finds the first even number in a given list of numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first even number in the list. If no even number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    \"\"\"\n    This function checks if all elements in a tuple have the same data type.\n\n    Args:\n        test_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    # Get the data type of the first element in the tuple\n    first_type = type(test_tuple[0])\n    \n    # Iterate over the rest of the elements in the tuple\n    for element in test_tuple[1:]:\n        # If the data type of the current element is different from the first type, return False\n        if type(element) != first_type:\n            return False\n    \n    # If the function hasn't returned False, it means all elements have the same data type, so return True\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    \"\"\"\n    Checks if the given element is a majority element in the sorted array.\n\n    Args:\n        arr (list): A sorted list of integers.\n        n (int): The size of the array.\n        x (int): The element to check.\n\n    Returns:\n        bool: True if the element is a majority element, False otherwise.\n    \"\"\"\n    # Initialize two pointers, one at the start and one at the end of the array\n    left, right = 0, n - 1\n    \n    # Continue the loop until the two pointers meet\n    while left < right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the target, we need to check its neighbors\n        if arr[mid] == x:\n            # Check the left neighbor\n            if mid > 0 and arr[mid - 1] != x:\n                # If the left neighbor is not equal to the target, we can conclude that the target is a majority element\n                return True\n            # Check the right neighbor\n            elif mid < n - 1 and arr[mid + 1] != x:\n                # If the right neighbor is not equal to the target, we can conclude that the target is a majority element\n                return True\n            # If both neighbors are equal to the target, we need to continue the search\n            else:\n                left = mid + 1\n        # If the middle element is less than the target, we need to search in the right half\n        elif arr[mid] < x:\n            left = mid + 1\n        # If the middle element is greater than the target, we need to search in the left half\n        else:\n            right = mid - 1\n    \n    # If the loop ends and the target is not found, it's not a majority element\n    return False"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    \"\"\"\n    This function counts the number of set bits in a given integer.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The number of set bits in the input integer.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    \"\"\"\n    This function finds the minimum element in a sorted and rotated array.\n\n    Args:\n        arr (list): The input array.\n        low (int): The low index of the current search range.\n        high (int): The high index of the current search range.\n\n    Returns:\n        int: The minimum element in the array.\n    \"\"\"\n    # If the array is not rotated, the minimum element is the first element\n    if high < low:\n        return arr[low]\n\n    # If the array is rotated, find the middle element\n    mid = (low + high) // 2\n\n    # If the middle element is greater than the next element, the minimum element is in the right half\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return find_Min(arr, mid + 1, high)\n\n    # If the middle element is less than the previous element, the minimum element is in the left half\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return find_Min(arr, low, mid - 1)\n\n    # If the middle element is greater than the first element, the minimum element is in the right half\n    if arr[mid] > arr[low]:\n        return find_Min(arr, low, mid)\n\n    # If the middle element is less than the first element, the minimum element is in the left half\n    return find_Min(arr, mid + 1, high)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    \"\"\"\n    This function removes characters with odd index values from a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The modified string with characters at odd index values removed.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    \"\"\"\n    This function returns the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):\n    # Convert the given numbers to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    bin_l = bin(l)[2:]\n    bin_r = bin(r)[2:]\n\n    # Calculate the length of the binary representation of n\n    n_len = len(bin_n)\n\n    # Pad the binary representation of l and r with leading zeros to match the length of n\n    bin_l = bin_l.zfill(n_len)\n    bin_r = bin_r.zfill(n_len)\n\n    # Check if all bits are set in the given range\n    for i in range(n_len):\n        if bin_l[i] == '0' or bin_r[i] == '0':\n            return False\n\n    return True"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    \"\"\"\n    Re-arranges the elements of the given array so that all negative elements appear before positive ones.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the array.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    # Initialize two lists, one for negative numbers and one for positive numbers\n    negative = []\n    positive = []\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is negative, add it to the negative list\n        if arr[i] < 0:\n            negative.append(arr[i])\n        # If the current element is positive, add it to the positive list\n        else:\n            positive.append(arr[i])\n\n    # Combine the two lists to get the final rearranged array\n    rearranged_arr = negative + positive\n\n    # Return the rearranged array\n    return rearranged_arr"}
{"id": "219_0", "code": "def replace_blank(str1,char):\n    return str1.replace(\" \", char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    \"\"\"\n    This function calculates the maximum sum in a right triangle of numbers.\n\n    Parameters:\n    tri (list): A list of numbers representing the triangle.\n    n (int): The number of rows in the triangle.\n\n    Returns:\n    int: The maximum sum in the triangle.\n    \"\"\"\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Iterate over each column in the triangle\n        for j in range(i, n):\n            # Calculate the sum of the current row and column\n            row_sum = sum(tri[i])\n            col_sum = sum(tri[j])\n            # Update the maximum sum if the current sum is greater\n            max_sum = max(max_sum, row_sum, col_sum)\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "221_0", "code": "def larg_nnum(list1,n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n\n    Args:\n        list1 (list): The dataset.\n        n (int): The number of largest items to return.\n\n    Returns:\n        list: The n largest items from the dataset.\n    \"\"\"\n    # Check if n is greater than the length of the list\n    if n > len(list1):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n\n    # Return the n largest items\n    return sorted_list[:n]"}
{"id": "222_0", "code": "import math\n\ndef lateralsuface_cylinder(r,h):\n    # Calculate the lateral surface area of the cylinder\n    lateral_surface_area = 2 * math.pi * r * h\n    \n    return lateral_surface_area"}
{"id": "223_0", "code": "def volume_cube(length):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Args:\n        length (float): The length of the cube's edge.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return length ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all even bits set.\n    \"\"\"\n    # Initialize result variable to store the result\n    result = 0\n    \n    # Iterate over each bit in the binary representation of n\n    for i in range(32):  # Assuming 32-bit integer\n        # Check if the current bit is even\n        if (n >> i) & 1 == 0:\n            # If the bit is even, set it to 1 in the result\n            result |= 1 << i\n    \n    # Return the result\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Calculate the number of triangles that can be formed in each row\n    row_triangles = K // N\n    \n    # Calculate the number of triangles that can be formed in each column\n    col_triangles = K // N\n    \n    # Calculate the number of triangles that can be formed in the main diagonal\n    main_diagonal_triangles = min(row_triangles, col_triangles)\n    \n    # Calculate the number of triangles that can be formed in the anti-diagonal\n    anti_diagonal_triangles = min(row_triangles, col_triangles)\n    \n    # Calculate the total number of triangles\n    total_triangles = row_triangles * col_triangles + 2 * main_diagonal_triangles + 2 * anti_diagonal_triangles\n    \n    return total_triangles"}
{"id": "226_0", "code": "from collections import defaultdict\n\ndef check_occurences(test_list):\n    # Create a dictionary to store the count of each record\n    record_count = defaultdict(int)\n    \n    # Create a dictionary to store the count of each time\n    time_count = defaultdict(int)\n    \n    # Iterate over each tuple in the test list\n    for record, time in test_list:\n        # Increment the count of the record\n        record_count[record] += 1\n        \n        # Increment the count of the time\n        time_count[time] += 1\n    \n    # Initialize a variable to store the maximum count of a record\n    max_record_count = 0\n    \n    # Iterate over each record and its count\n    for record, count in record_count.items():\n        # Update the maximum count of a record\n        max_record_count = max(max_record_count, count)\n    \n    # Initialize a variable to store the maximum count of a time\n    max_time_count = 0\n    \n    # Iterate over each time and its count\n    for time, count in time_count.items():\n        # Update the maximum count of a time\n        max_time_count = max(max_time_count, count)\n    \n    # Initialize a variable to store the maximum count of a record that occurs at the same time\n    max_similar_count = 0\n    \n    # Iterate over each record and its count\n    for record, count in record_count.items():\n        # Check if the count of the record is equal to the maximum count of a time\n        if count == max_time_count:\n            # Update the maximum count of a record that occurs at the same time\n            max_similar_count = max(max_similar_count, count)\n    \n    # Return the maximum count of a record that occurs at the same time\n    return max_similar_count"}
{"id": "227_0", "code": "def number_of_substrings(s):\n    \"\"\"\n    This function calculates the number of non-empty substrings of a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of non-empty substrings.\n    \"\"\"\n    n = len(s)\n    count = 0\n    \n    # Iterate over the string\n    for i in range(n):\n        # Iterate over the remaining characters\n        for j in range(i + 1, n + 1):\n            # Check if the substring is not empty\n            if s[i:j] != '':\n                # Increment the count\n                count += 1\n                \n    return count"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m,n):\n    if n == 1:\n        return m\n    else:\n        total = 0\n        for i in range(1, m+1):\n            total += get_total_number_of_sequences(i, n-1)\n        return total"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    \"\"\"\n    This function replaces the last element of the first list with the second list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1] = list2\n    # Return the modified list\n    return list1"}
{"id": "230_0", "code": "def array_3d(m,n,o):\n    return [[[('*') for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_charac(str1):\n    \"\"\"\n    This function counts the total number of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    # Initialize a variable to store the count of characters\n    char_count = 0\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Increment the character count by 1 for each character\n        char_count += 1\n    \n    # Return the total character count\n    return char_count"}
{"id": "232_0", "code": "from collections import Counter\n\ndef sort_on_occurence(lst):\n    \"\"\"\n    Sorts the given list based on the occurrence of first element of tuples.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        list: The sorted list of tuples.\n    \"\"\"\n    # Count the occurrence of each first element\n    count = Counter(t[0] for t in lst)\n\n    # Sort the list based on the count\n    sorted_lst = sorted(lst, key=lambda x: (-count[x[0]], x))\n\n    return sorted_lst"}
{"id": "233_0", "code": "import math\n\ndef next_Perfect_Square(N):\n    # Calculate the square root of the given number\n    sqrt_N = math.sqrt(N)\n    \n    # If the square root is an integer, then N is a perfect square\n    if sqrt_N == int(sqrt_N):\n        # Return the next perfect square by adding 1 to the square root\n        return int(sqrt_N + 1) ** 2\n    else:\n        # If N is not a perfect square, return the next perfect square\n        # by rounding up the square root and squaring it\n        return math.ceil(sqrt_N) ** 2"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Initialize a list to store the maximum sum of bi-tonic sub-sequence\n    max_sum = [0]*n\n    \n    # Initialize a list to store the maximum sum of bi-tonic sub-sequence ending at each position\n    max_ending_here = [0]*n\n    \n    # Initialize the maximum sum of bi-tonic sub-sequence\n    max_so_far = 0\n    \n    # Initialize the maximum sum of bi-tonic sub-sequence ending at the first position\n    max_ending_here[0] = arr[0]\n    \n    # Calculate the maximum sum of bi-tonic sub-sequence\n    for i in range(1, n):\n        # If the current element is greater than the previous element, update the maximum sum\n        if arr[i] > arr[i-1]:\n            max_ending_here[i] = max_ending_here[i-1] + arr[i]\n        else:\n            max_ending_here[i] = arr[i]\n        \n        # Update the maximum sum of bi-tonic sub-sequence\n        max_sum[i] = max(max_sum[i-1], max_ending_here[i])\n        \n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        max_so_far = max(max_so_far, max_sum[i])\n    \n    # Return the maximum sum of bi-tonic sub-sequence\n    return max_so_far"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    \"\"\"\n    Compute the square root of a number using the Babylonian method.\n\n    Args:\n        number (float): The number to compute the square root of.\n\n    Returns:\n        float: The square root of the input number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n\n    # Initial guess for the square root\n    guess = number / 2.0\n\n    # Maximum number of iterations\n    max_iterations = 1000\n\n    # Tolerance for convergence\n    tolerance = 1e-10\n\n    for _ in range(max_iterations):\n        # Calculate the next guess using the Babylonian method formula\n        next_guess = (guess + number / guess) / 2.0\n\n        # Check for convergence\n        if abs(guess - next_guess) < tolerance:\n            return next_guess\n\n        # Update the guess for the next iteration\n        guess = next_guess\n\n    # If the maximum number of iterations is reached without convergence, raise an error\n    raise RuntimeError(\"Failed to converge after {} iterations.\".format(max_iterations))"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store the lengths of the longest palindromic subsequences\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # All substrings of length 1 are palindromes\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for substring of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Check for lengths greater than 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # Find the longest palindromic subsequence\n    max_length = 0\n    start = 0\n    for i in range(n):\n        for j in range(i, n):\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                start = i\n                end = j\n    \n    # Return the longest palindromic subsequence\n    return str[start:end + 1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1.\n\n    The harmonic sum of n-1 is the sum of the reciprocals of the first n-1 positive integers.\n\n    Args:\n        n (int): The number of terms in the harmonic sum.\n\n    Returns:\n        float: The harmonic sum of n-1.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the sum to 0\n    total = 0\n\n    # Calculate the harmonic sum\n    for i in range(1, n):\n        total += 1 / i\n\n    return total"}
{"id": "238_0", "code": "def intersection_array(array_nums1,array_nums2):\n    return list(filter(lambda x: x in array_nums2, array_nums1))"}
{"id": "239_0", "code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        x (any): The element to search for.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(x)"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element of a list.\n\n    Args:\n        lst (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The modified list with the element inserted before each element.\n    \"\"\"\n    return [element] + lst + [element]"}
{"id": "241_0", "code": "import cmath\n\ndef convert(numbers):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n\n    Args:\n        numbers (complex): A complex number.\n\n    Returns:\n        tuple: A tuple containing the magnitude (r) and angle (theta) in radians.\n    \"\"\"\n    # Calculate the magnitude (r) using the abs() function\n    r = abs(numbers)\n    \n    # Calculate the angle (theta) using the cmath.phase() function\n    theta = cmath.phase(numbers)\n    \n    # Return the magnitude and angle as a tuple\n    return (r, theta)"}
{"id": "242_0", "code": "def count_integer(list1):\n    \"\"\"\n    This function takes a list of integers as input and returns the count of integers in the list.\n\n    Args:\n        list1 (list): A list of integers.\n\n    Returns:\n        int: The count of integers in the list.\n    \"\"\"\n    # Initialize a counter variable to store the count of integers\n    count = 0\n    \n    # Iterate over each element in the list\n    for num in list1:\n        # Check if the element is an integer\n        if isinstance(num, int):\n            # If the element is an integer, increment the counter\n            count += 1\n    \n    # Return the count of integers\n    return count"}
{"id": "243_0", "code": "def words_ae(text):\n    \"\"\"\n    This function finds all words starting with 'a' or 'e' in a given string.\n\n    Parameters:\n    text (str): The input string to search for words.\n\n    Returns:\n    list: A list of words starting with 'a' or 'e'.\n    \"\"\"\n    # Split the input string into words\n    words = text.split()\n\n    # Use list comprehension to filter words starting with 'a' or 'e'\n    result = [word for word in words if word.lower().startswith(('a', 'e'))]\n\n    return result"}
{"id": "244_0", "code": "import itertools\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Generate all combinations with repetitions of n colours from l colours.\n\n    Parameters:\n    l (list): List of colours.\n    n (int): Number of colours to choose.\n\n    Returns:\n    list: List of all combinations with repetitions.\n    \"\"\"\n    return list(itertools.combinations_with_replacement(l, n))"}
{"id": "245_0", "code": "def count_primes_nums(n):\n    \"\"\"\n    This function counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        int: The number of prime numbers less than n.\n\n    Raises:\n        ValueError: If n is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize a boolean array, prime, of size n+1\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n\n    # Count all prime numbers in the range [2, n]\n    count = sum(prime)\n\n    return count"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    \"\"\"\n    This function swaps two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    # Swap the numbers using tuple packing and unpacking\n    return b, a"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    return len(list(filter(lambda x: x % 2 != 0, array_nums)))"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Unpack the tuples into separate variables\n    tup1_first, tup1_second, tup1_third = test_tup1\n    tup2_first, tup2_second, tup2_third = test_tup2\n\n    # Compare the first elements of the tuples\n    if tup1_first > tup2_first:\n        # If the first element of the first tuple is greater, return the first tuple\n        return test_tup1\n    elif tup1_first < tup2_first:\n        # If the first element of the second tuple is greater, return the second tuple\n        return test_tup2\n    else:\n        # If the first elements are equal, compare the second elements\n        if tup1_second > tup2_second:\n            # If the second element of the first tuple is greater, return the first tuple\n            return test_tup1\n        elif tup1_second < tup2_second:\n            # If the second element of the second tuple is greater, return the second tuple\n            return test_tup2\n        else:\n            # If the second elements are equal, compare the third elements\n            if tup1_third > tup2_third:\n                # If the third element of the first tuple is greater, return the first tuple\n                return test_tup1\n            elif tup1_third < tup2_third:\n                # If the third element of the second tuple is greater, return the second tuple\n                return test_tup2\n            else:\n                # If all elements are equal, return the first tuple\n                return test_tup1"}
{"id": "249_0", "code": "def newman_prime(n):\n    \"\"\"\n    Returns the nth Newman-Shanks-Williams prime number.\n\n    Parameters:\n    n (int): The position of the prime number to find.\n\n    Returns:\n    int: The nth Newman-Shanks-Williams prime number.\n\n    Raises:\n    ValueError: If n is less than 1.\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n\n    # Initialize the first few Newman-Shanks-Williams primes\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    # If n is less than or equal to the number of primes we have, return the nth prime\n    if n <= len(primes):\n        return primes[n - 1]\n\n    # Otherwise, we need to generate more primes\n    else:\n        # Initialize the current prime and the current number to check\n        current_prime = primes[-1]\n        current_num = current_prime + 1\n\n        # Keep generating new primes until we find the nth one\n        while True:\n            # Check if the current number is prime\n            if is_prime(current_num):\n                # If it is, add it to the list of primes and check if it's the nth prime\n                primes.append(current_num)\n                if len(primes) == n:\n                    return current_num\n            # If it's not prime, increment the current number and try again\n            current_num += 1\n\n\ndef is_prime(num):\n    \"\"\"\n    Checks if a number is prime.\n\n    Parameters:\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n\n    if num < 2:\n        return False\n\n    # Check if the number is divisible by any number up to its square root\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n\n    return True"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input, performs mathematical division operation \n    on corresponding elements, and returns the result as a list of tuples.\n    \n    Args:\n        test_tup1 (tuple): The first tuple containing numbers to be divided.\n        test_tup2 (tuple): The second tuple containing numbers to divide by.\n    \n    Returns:\n        list: A list of tuples containing the results of the division operations.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Check if the divisor is zero to avoid ZeroDivisionError\n        if test_tup2[i] == 0:\n            raise ZeroDivisionError(f\"Cannot divide by zero at index {i}.\")\n        \n        # Perform the division operation and append the result to the list\n        result.append((test_tup1[i] / test_tup2[i], i))\n    \n    # Return the list of results\n    return result"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    \"\"\"\n    This function splits a given list into two parts where the length of the first part of the list is given.\n\n    Args:\n        list1 (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing the first part of the list and the second part of the list.\n    \"\"\"\n    # Check if the length of the list is less than or equal to the given length\n    if len(list1) <= L:\n        # If true, return the list as it is and an empty list\n        return list1, []\n    else:\n        # If false, return the first part of the list and the second part of the list\n        return list1[:L], list1[L:]"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into one.\n\n    Args:\n        d1 (dict): The first dictionary to merge.\n        d2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from both input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy all key-value pairs from the first dictionary into the merged dictionary\n    for key, value in d1.items():\n        merged_dict[key] = value\n    \n    # Iterate over the key-value pairs of the second dictionary\n    for key, value in d2.items():\n        # If the key is already present in the merged dictionary, update its value\n        if key in merged_dict:\n            merged_dict[key] = value\n        # If the key is not present in the merged dictionary, add it\n        else:\n            merged_dict[key] = value\n    \n    # Return the merged dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Args:\n        h_age (int): Human age\n\n    Returns:\n        int: Dog's age in dog's years\n    \"\"\"\n    # Assuming a dog's age is 1 human year for the first 2 years\n    if h_age <= 2:\n        return h_age * 10\n    # Assuming a dog's age is 1 human year for every 7 human years for the next 15 years\n    elif h_age <= 17:\n        return 2 + (h_age - 2) * 7\n    # Assuming a dog's age is 1 human year for every 10 human years for the next 25 years\n    elif h_age <= 32:\n        return 2 + 15 + (h_age - 17) * 10\n    # Assuming a dog's age is 1 human year for every 12 human years for the rest of the dog's life\n    else:\n        return 2 + 15 + 8 + (h_age - 32) * 12"}
{"id": "254_0", "code": "def list_split(S, step):\n    \"\"\"\n    Splits a list into sublists of size 'step' each.\n\n    Args:\n        S (list): The input list to be split.\n        step (int): The size of each sublist.\n\n    Returns:\n        list: A list of sublists of size 'step' each.\n    \"\"\"\n    return [S[i:i + step] for i in range(0, len(S), step)]"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): The length of the side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # Calculate the lateral surface area using the formula 4 * l^2\n    lateral_surface_area = 4 * (l ** 2)\n    return lateral_surface_area"}
{"id": "256_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to consider.\n\n    Returns:\n        int: The sum of squares of first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n odd natural numbers\n    for i in range(1, n+1):\n        # Calculate the square of the current odd number\n        square = (2*i - 1) ** 2\n        \n        # Add the square to the total sum\n        total_sum += square\n    \n    # Return the total sum\n    return total_sum"}
{"id": "257_0", "code": "def find_star_num(n):\n    \"\"\"\n    This function calculates the nth star number.\n    \n    The star numbers are generated based on the formula: \n    (n * (n + 1)) / 2\n    \n    Parameters:\n    n (int): The position of the star number to be found.\n    \n    Returns:\n    int: The nth star number.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    return (n * (n + 1)) // 2"}
{"id": "258_0", "code": "def ascii_value(k):\n    \"\"\"\n    This function calculates the ASCII value of a given character.\n\n    Parameters:\n    k (str): The character for which the ASCII value is to be calculated.\n\n    Returns:\n    int: The ASCII value of the character.\n\n    Raises:\n    TypeError: If the input is not a string.\n    ValueError: If the input string is empty.\n    \"\"\"\n\n    # Check if the input is a string\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Check if the input string is not empty\n    if len(k) == 0:\n        raise ValueError(\"Input string cannot be empty.\")\n\n    # Calculate the ASCII value of the character\n    ascii_val = ord(k)\n\n    return ascii_val"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr,n):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in a given array.\n\n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The size of the input list.\n\n    Returns:\n    int: The sum of even numbers at even positions.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the array using the index and value\n    for i, num in enumerate(arr):\n        # Check if the index is even and the number is even\n        if i % 2 == 0 and num % 2 == 0:\n            # Add the number to the total sum\n            total_sum += num\n    \n    # Return the total sum\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fifth power of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of the fifth power of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the fifth power of the current even number\n        power = i ** 5\n        \n        # Add the fifth power to the total sum\n        total_sum += power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples \n    where the last element of each tuple is extracted and stored in a new list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples where the last element of each tuple is extracted.\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_list = []\n\n    # Iterate over each tuple in the input list\n    for record in test_list:\n        # Extract the last element of the tuple and append it to the extracted list\n        extracted_list.append(record[-1])\n\n    # Return the extracted list\n    return extracted_list"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function subtracts the contents of one tuple with corresponding index of other tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the result of subtraction.\n\n    Raises:\n        ValueError: If the lengths of the two tuples are not equal.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The lengths of the two tuples must be equal.\")\n\n    # Use zip to iterate over the two tuples in parallel\n    # Use a list comprehension to subtract the corresponding elements\n    result = [x - y for x, y in zip(test_tup1, test_tup2)]\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "263_0", "code": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of even index binomial coefficients up to the nth term.\n\n    Parameters:\n    n (int): The number of terms to consider.\n\n    Returns:\n    int: The sum of even index binomial coefficients.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through each term from 0 to n\n    for i in range(n + 1):\n        # Calculate the binomial coefficient using the math.comb function\n        binomial_coefficient = math.comb(i, i)\n        \n        # Check if the index is even\n        if i % 2 == 0:\n            # Add the binomial coefficient to the total sum\n            total_sum += binomial_coefficient\n    \n    # Return the total sum\n    return total_sum"}
{"id": "264_0", "code": "def get_Position(a,n,m):\n    # Calculate the sum of the first n elements\n    sum_first_n = sum(a[:n])\n    \n    # Calculate the sum of the first m elements\n    sum_first_m = sum(a[:m])\n    \n    # Calculate the sum of the first (n-m) elements\n    sum_first_nm = sum(a[:n-m])\n    \n    # Calculate the position of the last removed element\n    position = (sum_first_n - sum_first_m + sum_first_nm) / (n - m)\n    \n    return position"}
{"id": "265_0", "code": "import math\n\ndef volume_cylinder(r,h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): radius of the cylinder\n    h (float): height of the cylinder\n\n    Returns:\n    float: volume of the cylinder\n    \"\"\"\n    # Calculate the volume of the cylinder using the formula V = rh\n    volume = math.pi * (r ** 2) * h\n    return volume"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    \"\"\"\n    This function filters a dictionary based on values.\n    \n    Parameters:\n    dict (dict): The dictionary to be filtered.\n    n (int): The value to filter by.\n    \n    Returns:\n    dict: A new dictionary with the filtered values.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value == n}"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    \"\"\"\n    This function takes a tuple as input and returns the count of elements that occur before the record in the tuple.\n    \n    Parameters:\n    test_tup (tuple): The input tuple.\n    \n    Returns:\n    int: The count of elements that occur before the record in the tuple.\n    \"\"\"\n    # Initialize a counter variable to keep track of the count of elements before the record\n    count = 0\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # If the element is not the record, increment the counter\n        if element != test_tup[-1]:\n            count += 1\n    \n    # Return the count of elements before the record\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n    # Check if n is a decagonal number\n    return n == (3*n**2 - 3*n + 1) // 2"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    pos = 0\n    while pos < len(dlist):\n        if dlist[pos] == item:\n            return pos\n        else:\n            pos = pos + 1\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    \"\"\"\n    This function checks if all elements in a given list are unique or not.\n\n    Args:\n        test_list (list): The input list to be checked.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x: x[0] - x[1], zip(nums1, nums2)))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq_dict = {}\n    \n    # Iterate over each digit in the number\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, freq in freq_dict.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if freq > int(digit):\n            return False\n    \n    # If no digit's frequency is greater than the digit itself, return True\n    return True"}
{"id": "273_0", "code": "def check_element(lst, element):\n    \"\"\"\n    This function checks if all elements in a list are equal to a given string.\n\n    Args:\n        lst (list): The list to be checked.\n        element (str): The string to be compared with the list elements.\n\n    Returns:\n        bool: True if all elements in the list are equal to the given string, False otherwise.\n    \"\"\"\n    # Check if the input is a list and the element is a string\n    if not isinstance(lst, list) or not isinstance(element, str):\n        raise TypeError(\"Input must be a list and the element must be a string.\")\n\n    # Check if the list is empty\n    if len(lst) == 0:\n        return True  # An empty list is considered equal to the given string\n\n    # Check if the first element of the list is equal to the given string\n    if lst[0] != element:\n        return False  # If the first element is not equal, the list is not equal to the given string\n\n    # Check if all elements in the list are equal to the given string\n    for i in range(1, len(lst)):\n        if lst[i] != element:\n            return False  # If any element is not equal, the list is not equal to the given string\n\n    return True  # If all elements are equal, the list is equal to the given string"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    \"\"\"\n    This function checks if the input string contains 'a' followed by two to three 'b's.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string contains 'a' followed by two to three 'b's, False otherwise.\n    \"\"\"\n    # Check if the length of the string is at least 3\n    if len(text) < 3:\n        return False\n    \n    # Check if the string starts with 'a'\n    if text[0] != 'a':\n        return False\n    \n    # Initialize a counter for 'b's\n    b_count = 0\n    \n    # Iterate over the string starting from the second character\n    for char in text[1:]:\n        # If the character is 'b', increment the counter\n        if char == 'b':\n            b_count += 1\n        # If the character is not 'b', reset the counter\n        else:\n            b_count = 0\n        \n        # If the counter exceeds 3, return False\n        if b_count > 3:\n            return False\n    \n    # If the function hasn't returned False, return True\n    return True"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the total length of the repeated array\n    total_length = n * k\n    \n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Initialize the window start index\n    window_start = 0\n    \n    # Traverse the array\n    for window_end in range(total_length):\n        # Add the current element to the current sum\n        current_sum += a[window_end % n]\n        \n        # If the window size is greater than n, remove the first element\n        if window_end >= n - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= a[window_start]\n            window_start += 1\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "276_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of squares of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the square of the current number and add it to the total sum\n        total_sum += i ** 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    \"\"\"\n    This function counts the number of elements in the array 'arr' that have a modular inverse under the given prime number 'P' equal to itself.\n\n    Parameters:\n    arr (list): The input list of integers.\n    N (int): The size of the input list.\n    P (int): The given prime number.\n\n    Returns:\n    int: The count of elements in the array 'arr' that have a modular inverse under the given prime number 'P' equal to itself.\n    \"\"\"\n    count = 0  # Initialize a counter variable to store the count of elements with modular inverse equal to itself.\n    \n    # Iterate over each element in the input array 'arr'.\n    for num in arr:\n        # Check if the number is relatively prime to the given prime number 'P'.\n        if gcd(num, P) == 1:\n            # If the number is relatively prime, check if its modular inverse under 'P' is equal to itself.\n            if pow(num, P-2, P) == num:\n                # If the modular inverse is equal to itself, increment the counter.\n                count += 1\n                \n    # Return the count of elements with modular inverse equal to itself.\n    return count\n\n\n# Define a helper function to calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\ndef gcd(a, b):\n    \"\"\"\n    This function calculates the greatest common divisor (GCD) of two numbers 'a' and 'b' using the Euclidean algorithm.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The greatest common divisor of 'a' and 'b'.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 6]\nN = len(arr)\nP = 7\nprint(modular_inverse(arr, N, P))"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Initialize a counter for odd days\n    odd_count = 0\n\n    # Iterate over each month in the year\n    for month in range(1, N + 1):\n        # Check if the month is February\n        if month == 2:\n            # February has 28 days in non-leap years and 29 days in leap years\n            if (N % 4 == 0 and N % 100 != 0) or N % 400 == 0:\n                # If the year is a leap year, February has 29 days\n                days_in_month = 29\n            else:\n                # If the year is not a leap year, February has 28 days\n                days_in_month = 28\n        # Check if the month is April, June, September, or November\n        elif month in [4, 6, 9, 11]:\n            # These months have 30 days\n            days_in_month = 30\n        # Check if the month is January, March, May, July, August, October, or December\n        else:\n            # These months have 31 days\n            days_in_month = 31\n\n        # Calculate the number of odd days in the month\n        odd_count += days_in_month % 2\n\n    # Return the total number of odd days in the year\n    return odd_count"}
{"id": "279_0", "code": "def max_length(lists):\n    \"\"\"\n    This function finds the list of lists with maximum length.\n\n    Args:\n        lists (list): A list of lists.\n\n    Returns:\n        list: The list of lists with maximum length.\n    \"\"\"\n    if not lists:  # Check if the input list is empty\n        return []\n\n    max_len = max(len(sublist) for sublist in lists)  # Find the maximum length\n    return [sublist for sublist in lists if len(sublist) == max_len]  # Return the list of lists with maximum length"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    # Base case: If there are no posts or only one post, there is only one way to paint the fence.\n    if n == 0 or n == 1:\n        return 1\n    \n    # Base case: If there are two posts, there are k * k ways to paint the fence.\n    if n == 2:\n        return k * k\n    \n    # Initialize a list to store the number of ways to paint the fence for each post.\n    ways = [0] * n\n    ways[0] = 1\n    ways[1] = k * k\n    \n    # For each post from the third post onwards, calculate the number of ways to paint the fence.\n    for i in range(2, n):\n        # For each color, calculate the number of ways to paint the fence by considering the previous two posts.\n        for j in range(k):\n            # If the current post is not adjacent to a post with the same color, add the number of ways to paint the fence for the previous two posts.\n            if j != ways[i-1] % k:\n                ways[i] += ways[i-1]\n            # If the current post is adjacent to a post with the same color, add the number of ways to paint the fence for the previous post.\n            if j != ways[i-2] % k:\n                ways[i] += ways[i-2]\n    \n    # Return the number of ways to paint the fence for the last post.\n    return ways[-1]"}
{"id": "281_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the quotient of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The quotient of n and m.\n    \n    Raises:\n    ZeroDivisionError: If m is zero.\n    \"\"\"\n    if m == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero.\")\n    return n // m"}
{"id": "282_0", "code": "import math\n\ndef otherside_rightangle(w,h):\n    # Calculate the length of the third side using the Pythagorean theorem\n    c = math.sqrt(w**2 + h**2)\n    return c"}
{"id": "283_0", "code": "def max_val(listval):\n    \"\"\"\n    This function finds the maximum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The maximum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not listval:\n        raise ValueError(\"Input list is empty\")\n\n    # Initialize max_val with the first element of the list\n    max_val = listval[0]\n\n    # Iterate over the list starting from the second element\n    for val in listval[1:]:\n        # Check if the current value is greater than max_val\n        if val > max_val:\n            # Update max_val if the current value is greater\n            max_val = val\n\n    # Return the maximum value found\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    \"\"\"\n    Returns the sum of all divisors of a number.\n\n    Args:\n        number (int): The number for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of all divisors of the number.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize the sum of divisors to 0\n    sum_divisors = 0\n\n    # Iterate over all numbers from 1 to the input number\n    for i in range(1, number + 1):\n        # Check if the current number is a divisor of the input number\n        if number % i == 0:\n            # If it is, add it to the sum of divisors\n            sum_divisors += i\n\n    return sum_divisors"}
{"id": "285_0", "code": "def get_Inv_Count(arr,n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    \"\"\"\n    This function takes a nested list as input and returns a flattened list.\n    \n    Args:\n        list1 (list): A nested list structure.\n    \n    Returns:\n        list: A flattened list.\n    \"\"\"\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    \"\"\"\n    This function finds the nested list elements which are present in another list.\n    \n    Parameters:\n    l1 (list): The list in which we need to find the intersection.\n    l2 (list): The list in which we need to find the intersection.\n    \n    Returns:\n    list: A list of elements that are present in both l1 and l2.\n    \"\"\"\n    \n    # Initialize an empty list to store the intersection\n    intersection = []\n    \n    # Iterate over each element in l1\n    for element in l1:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # If the element is a list, recursively call the function on it and l2\n            intersection.extend(intersection_nested_lists(element, l2))\n        # Check if the element is present in l2\n        elif element in l2:\n            # If the element is present in l2, add it to the intersection list\n            intersection.append(element)\n    \n    # Return the intersection list\n    return intersection"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    \"\"\"\n    This function calculates the maximum aggregate from the list of tuples.\n    \n    Parameters:\n    stdata (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    int: The maximum aggregate value.\n    \"\"\"\n    # Initialize the maximum aggregate value to negative infinity\n    max_agg = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for tup in stdata:\n        # Calculate the aggregate value for the current tuple\n        agg = tup[0] + tup[1]\n        \n        # Update the maximum aggregate value if the current aggregate is greater\n        if agg > max_agg:\n            max_agg = agg\n    \n    # Return the maximum aggregate value\n    return max_agg"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    \"\"\"\n    This function calculates the count of all binary sequences of length 2n \n    such that sum of first n bits is same as sum of last n bits.\n\n    Args:\n        n (int): The length of the binary sequence.\n\n    Returns:\n        int: The count of all binary sequences of length 2n.\n    \"\"\"\n    # Initialize count variable to store the count of valid sequences\n    count = 0\n    \n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the current number to binary and remove the '0b' prefix\n        bin_seq = bin(i)[2:].zfill(2*n)\n        \n        # Calculate the sum of first n bits and last n bits\n        sum_first_n = sum(int(bit) for bit in bin_seq[:n])\n        sum_last_n = sum(int(bit) for bit in bin_seq[n:])\n        \n        # Check if the sums are equal\n        if sum_first_n == sum_last_n:\n            # If they are equal, increment the count\n            count += 1\n    \n    # Return the count of valid sequences\n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n        d (dict): The dictionary to calculate the depth of.\n\n    Returns:\n        int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        return 0  # Base case: if d is not a dictionary, return 0\n\n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            # Recursively calculate the depth of the sub-dictionary\n            depth = dict_depth(value) + 1\n            max_depth = max(max_depth, depth)\n\n    return max_depth"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    # Convert the integer to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize the most significant bit number to 0\n    msb_number = 0\n    \n    # Iterate over the binary string from right to left\n    for i in range(len(binary) - 1, -1, -1):\n        # If the current bit is 1, it's the most significant bit\n        if binary[i] == '1':\n            # Update the most significant bit number\n            msb_number = i\n            # Break the loop since we've found the most significant bit\n            break\n    \n    # Return the most significant bit number\n    return msb_number"}
{"id": "292_0", "code": "def solve(a,n):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left_half = merge_sort(arr[:mid])\n        right_half = merge_sort(arr[mid:])\n        return merge(left_half, right_half)\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        return merged\n\n    def count_inversions(arr):\n        if len(arr) <= 1:\n            return 0, arr\n        mid = len(arr) // 2\n        left_inversions, left = count_inversions(arr[:mid])\n        right_inversions, right = count_inversions(arr[mid:])\n        merged = merge(left, right)\n        return left_inversions + right_inversions, merged\n\n    left_inversions, _ = count_inversions(a)\n    _, right_inversions = count_inversions(a[::-1])\n    return left_inversions == right_inversions"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    \"\"\"\n    This function finds the element at a given index after a number of rotations.\n    \n    Parameters:\n    arr (list): The input list of elements.\n    ranges (list): A list of ranges of elements in the array.\n    rotations (int): The number of rotations.\n    index (int): The index at which to find the element.\n    \n    Returns:\n    The element at the given index after the number of rotations.\n    \"\"\"\n    \n    # Calculate the effective index after rotations\n    effective_index = (index + rotations) % len(arr)\n    \n    # Check if the effective index is within the range of the array\n    if effective_index < 0 or effective_index >= len(arr):\n        raise ValueError(\"Effective index is out of range\")\n    \n    # Find the element at the effective index\n    element = arr[effective_index]\n    \n    # Check if the element is within the range of the array\n    if element < ranges[0] or element > ranges[1]:\n        raise ValueError(\"Element is out of range\")\n    \n    return element"}
{"id": "294_0", "code": "def start_withp(words):\n    \"\"\"\n    This function takes a list of words as input and returns a list of tuples.\n    Each tuple contains two words from the list that start with the letter 'p'.\n    If no such pairs are found, it returns an empty list.\n\n    Args:\n        words (list): A list of words\n\n    Returns:\n        list: A list of tuples containing pairs of words that start with 'p'\n    \"\"\"\n    # Filter the list to include only words that start with 'p'\n    p_words = [word for word in words if word.lower().startswith('p')]\n\n    # Initialize an empty list to store the pairs of words\n    pairs = []\n\n    # Iterate over the list of words\n    for i in range(len(p_words)):\n        # For each word, iterate over the remaining words in the list\n        for j in range(i + 1, len(p_words)):\n            # If both words start with 'p', add them as a pair to the list\n            if p_words[i].lower().startswith('p') and p_words[j].lower().startswith('p'):\n                pairs.append((p_words[i], p_words[j]))\n\n    # Return the list of pairs\n    return pairs"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Create a table to store the maximum sum of increasing subsequence\n    dp = [[0 for _ in range(n)] for _ in range(index + 1)]\n    \n    # Initialize the first row and column of the table\n    for i in range(index + 1):\n        dp[i][0] = a[i]\n    \n    # Fill the table in a bottom-up manner\n    for i in range(1, index + 1):\n        for j in range(1, n):\n            # If the current element is greater than the previous element, \n            # update the maximum sum of increasing subsequence\n            if a[i] > a[i - 1]:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] + a[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Find the maximum sum of increasing subsequence including the kth element\n    max_sum = 0\n    for i in range(index + 1, k + 1):\n        max_sum = max(max_sum, dp[i][k] + dp[i - 1][k - 1])\n    \n    return max_sum"}
{"id": "296_0", "code": "def colon_tuplex(tuplex, m, n):\n    \"\"\"\n    This function returns the mth element of the nth tuple in the given tuplex.\n\n    Parameters:\n    tuplex (list): A list of tuples\n    m (int): The index of the tuple to be returned\n    n (int): The index of the element to be returned\n\n    Returns:\n    The mth element of the nth tuple in the tuplex\n    \"\"\"\n    # Check if the input is valid\n    if m < 1 or n < 1 or m > len(tuplex) or n > len(tuplex[m-1]):\n        raise ValueError(\"Invalid input\")\n\n    # Return the mth element of the nth tuple\n    return tuplex[m-1][n-1]"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    # Combine the two lists into one\n    combined = nums1 + nums2\n    \n    # Sort the combined list in descending order\n    combined.sort(reverse=True)\n    \n    # Return the N largest products\n    return combined[:N]"}
{"id": "298_0", "code": "def maximum(a,b):\n    \"\"\"\n    This function returns the maximum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of the two numbers.\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    \"\"\"\n    This function converts a given string into a tuple.\n    \n    Parameters:\n    str1 (str): The input string to be converted into a tuple.\n    \n    Returns:\n    tuple: A tuple containing the input string.\n    \"\"\"\n    return (str1,)"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    \"\"\"\n    This function sets the left most unset bit in the binary representation of the input number n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with the left most unset bit set.\n    \"\"\"\n    # Calculate the left most unset bit using bitwise AND and left shift operators\n    left_most_unset_bit = n & -n\n    \n    # Return the number with the left most unset bit set\n    return n | left_most_unset_bit"}
{"id": "301_0", "code": "import math\n\ndef volume_cone(r,h):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    r (float): The radius of the cone's base.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    # Calculate the volume using the formula (1/3)rh\n    volume = (1/3) * math.pi * (r**2) * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize a list to store the maximum sum at each column\n    max_sum = [0] * n\n    \n    # Initialize the maximum sum for the first column\n    max_sum[0] = grid[0][0]\n    \n    # Calculate the maximum sum for each column\n    for i in range(1, n):\n        # The maximum sum for the current column is the maximum of the sum of the current cell and the maximum sum of the previous column,\n        # and the maximum sum of the column before the previous column\n        max_sum[i] = max(grid[i][0] + max_sum[i-1], grid[i][0] + max_sum[i-2])\n    \n    # Return the maximum sum of the last column\n    return max_sum[-1]"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    \"\"\"\n    This function finds the first maximum length of even word in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The length of the first even word. If no even word is found, returns -1.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n\n    # Initialize the maximum length of even word to -1\n    max_len = -1\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word is even\n        if len(word) % 2 == 0:\n            # If the word is even and its length is greater than the current max_len, update max_len\n            if len(word) > max_len:\n                max_len = len(word)\n\n    # Return the maximum length of even word\n    return max_len"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    \"\"\"\n    Find the index of the last occurrence of a given number in a sorted array.\n\n    Args:\n        A (list): A sorted list of integers.\n        x (int): The target number to find.\n\n    Returns:\n        int: The index of the last occurrence of x in A. If x is not found, returns -1.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] < x:\n            left = mid + 1\n        elif A[mid] > x:\n            right = mid - 1\n        else:\n            # If A[mid] is equal to x, we need to check if it's the last occurrence\n            # We can do this by checking the next element\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            right = mid - 1\n    return -1"}
{"id": "306_0", "code": "def modified_encode(alist):\n    \"\"\"\n    This function takes a list of integers as input and returns a string representing the modified run-length encoding.\n    \n    Parameters:\n    alist (list): A list of integers.\n    \n    Returns:\n    str: A string representing the modified run-length encoding.\n    \"\"\"\n    if not alist:\n        return \"\"\n    \n    result = \"\"\n    count = 1\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            result += str(count) + alist[i - 1] + \" \"\n            count = 1\n    result += str(count) + alist[-1] + \" \"\n    return result.strip()"}
{"id": "307_0", "code": "def max_volume(s):\n    \"\"\"\n    This function calculates the maximum volume of a cuboid with a given sum of sides.\n\n    Parameters:\n    s (int): The sum of the sides of the cuboid.\n\n    Returns:\n    int: The maximum volume of the cuboid.\n\n    \"\"\"\n    # Initialize the maximum volume\n    max_vol = 0\n\n    # Iterate over all possible lengths\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible widths\n        for width in range(length, (s - length) // 2 + 1):\n            # Calculate the height\n            height = s - length - width\n            # Check if the cuboid can be formed\n            if length * width * height == s:\n                # Update the maximum volume\n                max_vol = max(max_vol, length * width * height)\n\n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    \"\"\"\n    This function finds all five characters long words in the given text.\n\n    Args:\n        text (str): The input string to search for words.\n\n    Returns:\n        list: A list of all five characters long words found in the text.\n    \"\"\"\n    # Use regex to find all words that are exactly 5 characters long\n    pattern = r'\\b\\w{5}\\b'\n    words = re.findall(pattern, text)\n    return words"}
{"id": "309_0", "code": "def sum_difference(n):\n    \"\"\"\n    Calculate the difference between the squared sum of first n natural numbers \n    and the sum of squared first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        int: The difference between the two sums.\n    \"\"\"\n    # Calculate the sum of first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of squared first n natural numbers\n    sum_squared_n = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum_n = sum_n ** 2\n    \n    # Calculate the difference between the two sums\n    difference = squared_sum_n - sum_squared_n\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    \"\"\"\n    This function finds the demlo number for the given number.\n    \n    Parameters:\n    s (int): The input number.\n    \n    Returns:\n    int: The demlo number for the given number.\n    \"\"\"\n    # Define a dictionary to store the demlo numbers\n    demlo_dict = {\n        1: 1,\n        2: 2,\n        3: 4,\n        4: 8,\n        5: 16,\n        6: 32,\n        7: 64,\n        8: 128,\n        9: 256,\n        10: 512,\n        11: 1024,\n        12: 2048,\n        13: 4096,\n        14: 8192,\n        15: 16384,\n        16: 32768,\n        17: 65536,\n        18: 131072,\n        19: 262144,\n        20: 524288,\n        21: 1048576,\n        22: 2097152,\n        23: 4194304,\n        24: 8388608,\n        25: 16777216,\n        26: 33554432,\n        27: 67108864,\n        28: 134217728,\n        29: 268435456,\n        30: 536870912,\n        31: 1073741824,\n        32: 2147483648,\n        33: 4294967296,\n        34: 8589934592,\n        35: 17179869184,\n        36: 34359738368,\n        37: 68719476736,\n        38: 137438953472,\n        39: 274877906944,\n        40: 549755813888,\n        41: 1099511627776,\n        42: 2199023255552,\n        43: 4398046511104,\n        44: 8796093022208,\n        45: 17592186044416,\n        46: 35184372088832,\n        47: 70368744177664,\n        48: 140737488355328,\n        49: 281474976710656,\n        50: 562949953421312,\n        51: 1125899906842624,\n        52: 2251799813685248,\n        53: 4503599627370496,\n        54: 9007199254740992,\n        55: 18014398509481984,\n        56: 36028797018963968,\n        57: 72057594037927936,\n        58: 144115188075855872,\n        59: 288230376151711744,\n        60: 576460752303423488,\n        61: 1152921504606846976,\n        62: 2305843009213693952,\n        63: 4611686018427387904,\n        64: 9223372036854775808\n    }\n    \n    # Check if the input number is in the dictionary\n    if s in demlo_dict:\n        # Return the demlo number for the given number\n        return demlo_dict[s]\n    else:\n        # Return a message if the input number is not in the dictionary\n        return \"Demlo number not found for the given number.\""}
{"id": "311_0", "code": "def position_min(list1):\n    \"\"\"\n    This function finds all index positions of the minimum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the minimum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    # Find the minimum value in the list\n    min_val = min(list1)\n\n    # Find all index positions of the minimum value\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n\n    return min_indices"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    \"\"\"\n    Re-arranges the given array in alternating positive and negative items.\n\n    Args:\n        arr (list): The input list of integers.\n        n (int): The number of elements to consider for the re-arrangement.\n\n    Returns:\n        list: The re-arranged list with alternating positive and negative items.\n    \"\"\"\n    # Separate positive and negative numbers\n    positive = [x for x in arr if x >= 0]\n    negative = [x for x in arr if x < 0]\n\n    # Initialize the result list\n    result = []\n\n    # Alternate between positive and negative numbers\n    for i in range(min(n, len(positive))):\n        result.append(positive[i])\n        result.append(negative[i])\n\n    # If there are remaining positive numbers, append them to the result\n    if len(positive) > n:\n        result.extend(positive[n:])\n\n    # If there are remaining negative numbers, append them to the result\n    if len(negative) > n:\n        result.extend(negative[n:])\n\n    return result"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    \"\"\"\n    This function calculates the sum of alternate chains of tuples.\n    \n    Args:\n        test_tuple (tuple): A tuple containing tuples as elements.\n    \n    Returns:\n        int: The sum of alternate chains of tuples.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize a flag to track whether we are in an alternate chain\n    in_chain = False\n    \n    # Iterate over each element in the test tuple\n    for element in test_tuple:\n        # If the element is a tuple and we are not in an alternate chain\n        if isinstance(element, tuple) and not in_chain:\n            # Add the sum of the element's tuple to the total sum\n            total_sum += sum(element)\n            # Set the flag to True to indicate we are in an alternate chain\n            in_chain = True\n        # If the element is a tuple and we are in an alternate chain\n        elif isinstance(element, tuple) and in_chain:\n            # Add the sum of the element's tuple to the total sum\n            total_sum += sum(element)\n            # Set the flag to False to indicate we are not in an alternate chain\n            in_chain = False\n    \n    # Return the total sum\n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    \"\"\"\n    This function calculates the minimum number of squares whose sum is equal to a given number.\n    \n    Parameters:\n    n (int): The given number.\n    \n    Returns:\n    int: The minimum number of squares.\n    \"\"\"\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    dp = [float('inf')] * (n + 1)\n    \n    # The minimum number of squares for 0 is 0\n    dp[0] = 0\n    \n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Initialize the minimum number of squares for the current number to infinity\n        min_squares = float('inf')\n        \n        # Iterate over each square number from 1 to the current number\n        j = 1\n        while j * j <= i:\n            # Update the minimum number of squares for the current number\n            min_squares = min(min_squares, dp[i - j * j] + 1)\n            j += 1\n        \n        # Update the minimum number of squares for the current number in the dp list\n        dp[i] = min_squares\n    \n    # Return the minimum number of squares for the given number\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    \n    # Iterate over each string in the test list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # Convert the word to lowercase and remove punctuation\n            word = word.lower()\n            word = ''.join(e for e in word if e.isalnum())\n            \n            # Increment the frequency of the word in the dictionary\n            if word in word_freq:\n                word_freq[word] += 1\n            else:\n                word_freq[word] = 1\n                \n    # Find the word with the most occurrences\n    most_common_word = max(word_freq, key=word_freq.get)\n    \n    return most_common_word"}
{"id": "316_0", "code": "def check_isosceles(x,y,z):\n    # Check if the triangle is valid\n    if x + y > z and x + z > y and y + z > x:\n        # Check if two sides are equal\n        if x == y or x == z or y == z:\n            print(\"The triangle is isosceles.\")\n        else:\n            print(\"The triangle is not isosceles.\")\n    else:\n        print(\"The triangle is not valid.\")"}
{"id": "317_0", "code": "def rotate_left(list1, m, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the left direction.\n\n    Args:\n        list1 (list): The input list to be rotated.\n        m (int): The number of items to rotate to the left.\n        n (int): The number of items to rotate to the right.\n\n    Returns:\n        list: The rotated list.\n    \"\"\"\n    # Calculate the effective rotation steps\n    effective_steps = m - n\n    \n    # If the effective steps is negative, add the length of the list to make it positive\n    if effective_steps < 0:\n        effective_steps += len(list1)\n    \n    # Rotate the list to the left by slicing\n    rotated_list = list1[effective_steps:] + list1[:effective_steps]\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    \"\"\"\n    This function counts the number of negative numbers in a given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The number of negative numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num < 0)"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Define the pattern for three, four, five characters long words\n    pattern = r'\\b\\w{3,5}\\b'\n\n    # Find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n\n    return matches"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    \"\"\"\n    This function counts the number of unset bits in a given integer.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The number of unset bits in the input integer.\n    \"\"\"\n    # Initialize a counter for unset bits\n    unset_bits = 0\n    \n    # Loop through each bit in the binary representation of n\n    while n:\n        # Use the bitwise AND operator (&) with 1 to check if the least significant bit is 0\n        # If the result is 0, it means the least significant bit is 0 (unset)\n        if n & 1 == 0:\n            # Increment the counter for unset bits\n            unset_bits += 1\n        \n        # Right shift the number by 1 bit to move to the next bit\n        n >>= 1\n    \n    # Return the total count of unset bits\n    return unset_bits"}
{"id": "321_0", "code": "def char_frequency(str1):\n    \"\"\"\n    This function calculates the frequency of each character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store character frequencies\n    freq_dict = {}\n\n    # Iterate over each character in the input string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in freq_dict:\n            freq_dict[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[char] = 1\n\n    # Return the dictionary containing character frequencies\n    return freq_dict"}
{"id": "322_0", "code": "def Sort(sub_li):\n    return sorted(sub_li, key=lambda x: x[1])"}
{"id": "323_0", "code": "def check_Validity(a,b,c):\n    # Check if the sides can form a triangle\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "324_0", "code": "def ap_sum(a,n,d):\n    \"\"\"\n    This function calculates the sum of an arithmetic progression.\n    \n    Parameters:\n    a (float): The first term of the arithmetic progression.\n    n (int): The number of terms in the arithmetic progression.\n    d (float): The common difference of the arithmetic progression.\n    \n    Returns:\n    float: The sum of the arithmetic progression.\n    \"\"\"\n    # Calculate the sum of the arithmetic progression using the formula: n/2 * (2a + (n-1)d)\n    sum_ap = (n/2) * (2*a + (n-1)*d)\n    return sum_ap"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    monthdays = {\n        \"January\": 31, \"February\": 28, \"March\": 31, \"April\": 30, \"May\": 31, \"June\": 30,\n        \"July\": 31, \"August\": 31, \"September\": 30, \"October\": 31, \"November\": 30, \"December\": 31\n    }\n    if monthname1 in monthdays:\n        if monthdays[monthname1] == 28:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    # Regular expression pattern to match a word at the end of a string with optional punctuation\n    pattern = r'\\b\\w+\\b(?=[\\s.,!?]*$)'\n    # Use the re.search function to search for the pattern in the text\n    match = re.search(pattern, text)\n    # Return True if a match is found, False otherwise\n    return match is not None"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i] == s[j - 1]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x,y):\n    \"\"\"\n    This function finds the maximum occurring divisor in the interval [x, y].\n    \n    Parameters:\n    x (int): The start of the interval.\n    y (int): The end of the interval.\n    \n    Returns:\n    int: The maximum occurring divisor in the interval [x, y].\n    \"\"\"\n    \n    # Initialize an empty dictionary to store the frequency of each divisor\n    divisor_freq = {}\n    \n    # Iterate over the interval [x, y]\n    for i in range(x, y+1):\n        # Iterate from 1 to the square root of i\n        for j in range(1, int(i**0.5) + 1):\n            # Check if j is a divisor of i\n            if i % j == 0:\n                # If j is a divisor, increment its frequency in the dictionary\n                if j in divisor_freq:\n                    divisor_freq[j] += 1\n                else:\n                    divisor_freq[j] = 1\n                \n                # If i//j is not equal to j, it's also a divisor, so increment its frequency\n                if i // j != j:\n                    if i // j in divisor_freq:\n                        divisor_freq[i // j] += 1\n                    else:\n                        divisor_freq[i // j] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(divisor_freq.values())\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [divisor for divisor, freq in divisor_freq.items() if freq == max_freq]\n    \n    # Return the maximum occurring divisor\n    return max(max_divisors)"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    \"\"\"\n    This function calculates the sum of the three smallest positive numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of the three smallest positive numbers.\n\n    Raises:\n        ValueError: If the list is empty or contains no positive numbers.\n    \"\"\"\n    # Filter out non-positive numbers and sort the list\n    positive_nums = sorted([num for num in lst if num > 0])\n    \n    # Check if there are at least three positive numbers\n    if len(positive_nums) < 3:\n        raise ValueError(\"The list must contain at least three positive numbers.\")\n    \n    # Return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    \"\"\"\n    This function takes a set as input and returns a list of ordered tuples.\n    \n    Parameters:\n    s (set): The input set to be converted into ordered tuples.\n    \n    Returns:\n    list: A list of ordered tuples.\n    \"\"\"\n    return list(s)"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    if not lists:\n        return None\n\n    # Sort all lists\n    lists = [sorted(lst) for lst in lists]\n\n    # Initialize variables\n    min_range = float('inf')\n    left = 0\n    right = 0\n\n    # Iterate over the lists\n    while right < len(lists[0]):\n        # Find the smallest element in the current range\n        min_val = min([lst[left] for lst in lists])\n\n        # Update the minimum range\n        min_range = min(min_range, right - left + 1)\n\n        # Move the right pointer\n        for i in range(len(lists)):\n            if lists[i][right] > min_val:\n                break\n        else:\n            right += 1\n\n        # Move the left pointer\n        for i in range(len(lists)):\n            if lists[i][left] > min_val:\n                break\n        else:\n            left += 1\n\n    return min_range"}
{"id": "332_0", "code": "def dig_let(s):\n    \"\"\"\n    Calculate the number of digits and letters in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    tuple: A tuple containing the number of digits and letters in the string.\n    \"\"\"\n    # Initialize counters for digits and letters\n    digits = 0\n    letters = 0\n\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digits += 1\n        # Check if the character is a letter\n        elif char.isalpha():\n            letters += 1\n\n    # Return the counts as a tuple\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n,m):\n    count = 0\n    for i in range(n,m):\n        if i % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    \"\"\"\n    This function calculates the difference between two consecutive numbers in a given list.\n    \n    Args:\n        nums (list): A list of numbers.\n    \n    Returns:\n        list: A list of differences between consecutive numbers.\n    \"\"\"\n    # Check if the list has less than two elements\n    if len(nums) < 2:\n        return []\n    \n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate over the list of numbers from the second number to the last\n    for i in range(1, len(nums)):\n        # Calculate the difference between the current number and the previous number\n        diff = nums[i] - nums[i - 1]\n        # Append the difference to the list of differences\n        differences.append(diff)\n    \n    # Return the list of differences\n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    # Calculate the number of rows\n    rows = n // k\n    # Calculate the number of columns\n    cols = k - (n % k)\n    # Initialize the result list\n    result = []\n    # Initialize the index\n    index = 0\n    # Loop through each row\n    for i in range(rows):\n        # Loop through each column\n        for j in range(cols):\n            # Calculate the value of e(n, k)\n            e_value = (i * k + j + 1) ** 2\n            # Append the value to the result list\n            result.append(e_value)\n            # Increment the index\n            index += 1\n    # Return the result list\n    return result"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # The number of squares is equal to the number of rows times the number of columns\n    # minus the number of squares on the border\n    # The number of squares on the border is equal to the number of rows plus the number of columns minus 2\n    # minus the number of squares on the border of the top-left and top-right corners\n    # The number of squares on the border of the top-left and top-right corners is equal to the number of rows plus the number of columns minus 2\n    # minus 1\n    return (m*n) - ((m+1)*(n+1)-2)"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a 2D array to store the number of ways to get each prefix sum\n    dp = [[0] * (M + 1) for _ in range(M + 1)]\n    \n    # Base case: there is one way to get a prefix sum of 0 (by not using any numbers)\n    dp[0][0] = 1\n    \n    # For each number from 1 to M\n    for i in range(1, M + 1):\n        # For each possible prefix sum from 0 to i\n        for j in range(i + 1):\n            # For each possible value of the current number\n            for k in range(1, i + 1):\n                # If the current number is less than or equal to the current prefix sum\n                if k <= j:\n                    # Add the number of ways to get the current prefix sum minus the current number\n                    # to the number of ways to get the current prefix sum\n                    dp[j][i] += dp[j - k][i - k]\n    \n    # The number of ways to get a prefix sum of M is stored in dp[M][M]\n    return dp[M][M]"}
{"id": "338_0", "code": "def check(string):\n    \"\"\"\n    This function checks whether the given string is a binary string or not.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string is a binary string, False otherwise.\n    \"\"\"\n    # Check if the string contains only '0' and '1'\n    if set(string).issubset({'0', '1'}):\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Initialize the minimum length and the character to remove\n    min_length = float('inf')\n    char_to_remove = None\n\n    # Iterate over each character and its frequency\n    for char, freq in char_frequency.items():\n        # If the frequency is more than 1, we can remove this character to minimize the length\n        if freq > 1:\n            # Calculate the length if we remove this character\n            new_length = len(s) - freq\n            # Update the minimum length and the character to remove\n            if new_length < min_length:\n                min_length = new_length\n                char_to_remove = char\n\n    # If no character can be removed, return the original string\n    if min_length == float('inf'):\n        return s\n    # Otherwise, return the string with the character to remove\n    else:\n        return s.replace(char_to_remove, '')"}
{"id": "340_0", "code": "from collections import Counter\n\ndef first_Element(arr,n,k):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = Counter(arr)\n    \n    # Iterate through the array to find the first element occurring k times\n    for i in range(n):\n        if freq_dict[arr[i]] == k:\n            return arr[i]\n    return None"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Convert the string into a set\n    unique_chars = set(str)\n    \n    # Check if the length of the set is equal to the length of the string\n    if len(unique_chars) == len(str):\n        return True\n    else:\n        return False"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    \"\"\"\n    Removes the nth column from a given nested list.\n\n    Args:\n        list1 (list): The input nested list.\n        n (int): The index of the column to be removed.\n\n    Returns:\n        list: The modified nested list with the specified column removed.\n    \"\"\"\n    # Check if the input list is empty\n    if not list1:\n        return list1\n\n    # Check if the nth column exists\n    if n < len(list1[0]):\n        # Use list comprehension to create a new list without the nth column\n        return [row[:n] + row[n+1:] for row in list1]\n    else:\n        # If the nth column does not exist, return the original list\n        return list1"}
{"id": "343_0", "code": "def tn_ap(a,n,d):\n    \"\"\"\n    This function calculates the t-nth term of an arithmetic progression.\n    \n    Parameters:\n    a (int): The first term of the arithmetic progression.\n    n (int): The term number to be calculated.\n    d (int): The common difference of the arithmetic progression.\n    \n    Returns:\n    int: The t-nth term of the arithmetic progression.\n    \"\"\"\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Check if d is an integer\n    if not isinstance(d, int):\n        raise ValueError(\"d must be an integer\")\n    \n    # Calculate the t-nth term using the formula: a + (n-1)*d\n    t_n = a + (n-1)*d\n    \n    return t_n"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    \"\"\"\n    Calculate the number of rectangles that can fit inside a circle of radius r.\n\n    Args:\n        radius (float): The radius of the circle.\n\n    Returns:\n        int: The number of rectangles that can fit inside the circle.\n    \"\"\"\n    # Calculate the area of the circle\n    circle_area = math.pi * radius ** 2\n    \n    # Calculate the area of a rectangle\n    rectangle_area = radius * radius\n    \n    # Calculate the maximum number of rectangles that can fit in the circle\n    # by dividing the area of the circle by the area of a rectangle\n    num_rectangles = circle_area / rectangle_area\n    \n    # Since we can't have a fraction of a rectangle, we use the floor function\n    # to round down to the nearest whole number\n    num_rectangles = math.floor(num_rectangles)\n    \n    return num_rectangles"}
{"id": "345_0", "code": "def find_angle(a,b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    c = 180 - a - b\n    return c"}
{"id": "346_0", "code": "def find_max(test_list):\n    \"\"\"\n    This function finds the maximum element of all the given tuple records.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        The maximum element of all the given tuple records.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"Input list is empty\")\n\n    max_element = test_list[0]\n    for record in test_list:\n        if max_element < record[0]:\n            max_element = record[0]\n\n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    \"\"\"\n    This function calculates the modulo division of two lists.\n    \n    Parameters:\n    nums1 (list): The dividend list.\n    nums2 (list): The divisor list.\n    \n    Returns:\n    list: A list of the results of the modulo division.\n    \"\"\"\n    return list(map(lambda x, y: x % y, nums1, nums2))"}
{"id": "348_0", "code": "import math\n\ndef Check_Solution(a,b,c):\n    # Calculate the discriminant\n    D = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if D < 0:\n        return \"No real solutions\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(D)) / (2*a)\n    root2 = (-b - math.sqrt(D)) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return \"One root is twice the other\"\n    else:\n        return \"No root is twice the other\""}
{"id": "349_0", "code": "def get_carol(n):\n    \"\"\"\n    Returns the nth carol number.\n\n    The carol numbers are generated based on the following rules:\n    - The first carol number is 1.\n    - Each subsequent carol number is the sum of the two preceding carol numbers.\n    - The carol numbers are generated in a circular manner, i.e., when the sum exceeds 31, it wraps around to 1.\n\n    Args:\n        n (int): The position of the carol number to be generated.\n\n    Returns:\n        int: The nth carol number.\n    \"\"\"\n    # Initialize the first two carol numbers\n    a, b = 1, 1\n\n    # Generate the carol numbers up to the nth number\n    for _ in range(2, n + 1):\n        # Calculate the next carol number as the sum of the previous two, modulo 31\n        a, b = b, (a + b) % 31\n\n    # Return the nth carol number\n    return b"}
{"id": "350_0", "code": "def remove_empty(list1):\n    \"\"\"\n    This function removes empty lists from a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        list: A list of lists with empty lists removed.\n    \"\"\"\n    # Use list comprehension to filter out empty lists\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum occurrences in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum occurrences.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the number with maximum count\n    max_count = max(count_dict.values())\n    max_num = [num for num, count in count_dict.items() if count == max_count]\n\n    # Return the first number with maximum count\n    return max_num[0]"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    \"\"\"\n    This function adds K elements to each element in the tuple.\n\n    Args:\n        test_list (tuple): A tuple containing elements to be modified.\n        K (int): The number of elements to add to each element in the tuple.\n\n    Returns:\n        list: A list of tuples, where each tuple contains the modified elements.\n    \"\"\"\n    # Initialize an empty list to store the modified elements\n    modified_list = []\n    \n    # Iterate over each element in the tuple\n    for element in test_list:\n        # Add K elements to the current element and store it in a new tuple\n        new_element = (element,) + (K,) * K\n        # Append the new tuple to the modified list\n        modified_list.append(new_element)\n    \n    # Return the modified list\n    return modified_list"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(str):\n    \"\"\"\n    This function calculates the minimum number of flips required to make a binary string a sequence of alternate characters.\n    \n    Parameters:\n    str (str): The input binary string.\n    \n    Returns:\n    int: The minimum number of flips required.\n    \"\"\"\n    flips = 0\n    prev_char = None\n    for char in str:\n        if char == '1' and prev_char == '1':\n            flips += 1\n        elif char == '0' and prev_char == '0':\n            flips += 1\n        prev_char = char\n    return flips"}
{"id": "354_0", "code": "def count_Digit(n):\n    return len(str(abs(n)))"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    \"\"\"\n    This function calculates the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        list_nums (list): A list of integers.\n\n    Returns:\n        int: The largest product of the pair of adjacent elements.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(list_nums) < 2:\n        raise ValueError(\"Input list must have at least two elements.\")\n\n    max_product = float('-inf')  # Initialize max_product as negative infinity\n\n    # Iterate over the list of numbers, considering each number and the next one\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        # Update max_product if the current product is larger\n        if product > max_product:\n            max_product = product\n\n    return max_product"}
{"id": "356_0", "code": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_tree_balanced(root):\n    def check_balance(node):\n        if node is None:\n            return (True, 0)\n        left_balanced, left_height = check_balance(node.left)\n        right_balanced, right_height = check_balance(node.right)\n        if not left_balanced or not right_balanced:\n            return (False, 0)\n        return (abs(left_height - right_height) <= 1, max(left_height, right_height) + 1)\n\n    return check_balance(root)[0]"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    \"\"\"\n    Repeat the given tuple n times.\n\n    Args:\n        test_tup (tuple): The tuple to be repeated.\n        N (int): The number of times to repeat the tuple.\n\n    Returns:\n        list: A list of tuples, where each tuple is a repetition of the input tuple.\n    \"\"\"\n    return [test_tup] * N"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l,w,h):\n    # Calculate the lateral surface area of the cuboid\n    lateral_surface_area = 2 * (l * h + w * h + l * w)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    \"\"\"\n    Sorts a tuple by its float element.\n\n    Args:\n        price (tuple): A tuple containing float elements.\n\n    Returns:\n        tuple: A sorted tuple of float elements.\n    \"\"\"\n    return tuple(sorted(price, key=lambda x: float(x)))"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    \"\"\"\n    This function finds the smallest missing element in a sorted array.\n    \n    Parameters:\n    A (list): The input sorted array.\n    left_element (int): The left boundary of the search range.\n    right_element (int): The right boundary of the search range.\n    \n    Returns:\n    int: The smallest missing element in the array.\n    \"\"\"\n    \n    # Initialize the left and right pointers\n    left = left_element\n    right = right_element\n    \n    # Continue the search until the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the middle index, it means the middle element is the smallest missing element\n        if A[mid] == mid + left_element:\n            return mid + left_element\n        \n        # If the middle element is greater than the middle index, it means the smallest missing element is in the left half\n        elif A[mid] > mid + left_element:\n            right = mid - 1\n        \n        # If the middle element is less than the middle index, it means the smallest missing element is in the right half\n        else:\n            left = mid + 1\n    \n    # If the loop ends, it means the smallest missing element is the left element plus the left boundary\n    return left_element + left"}
{"id": "361_0", "code": "import heapq\n\ndef heap_ascending(nums):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements in ascending order.\n    \"\"\"\n    # Create a min heap from the input list\n    heapq.heapify(nums)\n\n    # Initialize an empty list to store the sorted elements\n    sorted_nums = []\n\n    # While the heap is not empty, pop the smallest element and add it to the sorted list\n    while nums:\n        sorted_nums.append(heapq.heappop(nums))\n\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(length, width, height):\n    \"\"\"\n    Calculate the volume of a cuboid.\n\n    Args:\n        length (float): The length of the cuboid.\n        width (float): The width of the cuboid.\n        height (float): The height of the cuboid.\n\n    Returns:\n        float: The volume of the cuboid.\n    \"\"\"\n    return length * width * height"}
{"id": "363_0", "code": "def permute_string(str):\n    def backtrack(start, end):\n        if start == end:\n            print(str)\n        for i in range(start, end):\n            str = str[:i] + str[i+1:] + str[i]\n            backtrack(i+1, end)\n\n    backtrack(0, len(str))\n\n# Test the function\npermute_string(\"abc\")"}
{"id": "364_0", "code": "def round_num(n,m):\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is less than half of m, round down\n    if remainder < m/2:\n        return n - remainder\n    # If the remainder is greater than or equal to half of m, round up\n    else:\n        return n + (m - remainder)"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with unique elements and their count\n    unique_tup = []\n    for element, count in count_dict.items():\n        if count == 1:\n            unique_tup.append(element)\n        else:\n            unique_tup.append((element, count))\n\n    # Replace duplicates with a custom value\n    custom_value = \"REPLICA\"\n    for i in range(len(unique_tup)):\n        if unique_tup[i][1] > 1:\n            unique_tup[i] = (unique_tup[i][0], custom_value)\n\n    # Return the new tuple\n    return tuple(unique_tup)"}
{"id": "366_0", "code": "def remove_Char(s,c):\n    \"\"\"\n    Removes all occurrences of a character in a given string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be removed.\n\n    Returns:\n    str: The string with all occurrences of the character removed.\n    \"\"\"\n    return s.replace(c, '')"}
{"id": "367_0", "code": "def move_first(test_list):\n    \"\"\"\n    This function takes a list as input and returns a new list with the last element shifted to the first position.\n\n    Args:\n        test_list (list): The input list.\n\n    Returns:\n        list: A new list with the last element shifted to the first position.\n    \"\"\"\n    # Check if the list is not empty\n    if test_list:\n        # Use list slicing to get the last element and the rest of the list\n        last_element = test_list[-1]\n        rest_of_list = test_list[:-1]\n        # Combine the last element and the rest of the list to get the new list\n        new_list = [last_element] + rest_of_list\n        return new_list\n    else:\n        # If the list is empty, return the original list\n        return test_list"}
{"id": "368_0", "code": "def surfacearea_cuboid(l,w,h):\n    # Calculate the surface area of the cuboid\n    # The formula for the surface area of a cuboid is 2lw + 2lh + 2wh\n    surface_area = 2 * (l * w + l * h + w * h)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum, colnum):\n    \"\"\"\n    Generate a two-dimensional array with the specified number of rows and columns.\n\n    Args:\n        rownum (int): The number of rows in the array.\n        colnum (int): The number of columns in the array.\n\n    Returns:\n        list: A two-dimensional list (array) with the specified number of rows and columns.\n    \"\"\"\n    # Initialize an empty list to store the rows\n    array = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Initialize an empty list to store the columns in the current row\n        row = []\n        \n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append a default value (e.g., 0) to the current row\n            row.append(0)\n        \n        # Append the current row to the array\n        array.append(row)\n    \n    # Return the generated array\n    return array"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists based on a given index of the inner list.\n\n    Args:\n        list_data (list): A list of lists to be sorted.\n        index_no (int): The index of the inner list to sort by.\n\n    Returns:\n        list: The sorted list of lists.\n    \"\"\"\n    return sorted(list_data, key=lambda x: x[index_no])"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    n = len(A)\n    low = 0\n    high = n - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == A[0]:\n            return mid\n        if A[0] < A[mid]:\n            if A[mid] < A[n - 1]:\n                return mid\n            high = mid - 1\n        else:\n            if A[mid] > A[0]:\n                return n - mid\n            low = mid + 1\n    return -1"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    This function takes an integer as input, toggles all odd bits, and returns the result.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The integer with all odd bits toggled.\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    \n    # Iterate over each bit in the input number\n    for i in range(32):  # Assuming 32-bit integer\n        # Check if the current bit is odd\n        if (n >> i) & 1:\n            # If the bit is odd, toggle it by using the XOR operator\n            result |= 1 << i\n        else:\n            # If the bit is even, just copy it to the result\n            result |= 1 << i\n    \n    # Return the result\n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the smallest value in the array\n    smallest = min(arr)\n\n    # Count the frequency of the smallest value\n    count = arr.count(smallest)\n\n    return count"}
{"id": "374_0", "code": "def get_perrin(n):\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n\n    # Recursive case\n    else:\n        return get_perrin(n-1) + get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    \"\"\"\n    This function calculates the minimum number of swaps required to balance the brackets in a given string.\n    \n    Parameters:\n    s (str): The input string containing brackets.\n    \n    Returns:\n    int: The minimum number of swaps required to balance the brackets.\n    \"\"\"\n    # Initialize variables to store the count of opening and closing brackets\n    open_brackets = 0\n    close_brackets = 0\n    \n    # Initialize a variable to store the minimum number of swaps required\n    min_swaps = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is an opening bracket, increment the count of opening brackets\n        if char == '(':\n            open_brackets += 1\n        # If the character is a closing bracket, increment the count of closing brackets\n        elif char == ')':\n            close_brackets += 1\n            # If the count of closing brackets is greater than the count of opening brackets, increment the minimum number of swaps required\n            if close_brackets > open_brackets:\n                min_swaps += 1\n                # Decrement the count of closing brackets by 2 to account for the extra closing bracket\n                close_brackets -= 1\n    \n    # Return the minimum number of swaps required\n    return min_swaps"}
{"id": "376_0", "code": "def even_or_odd(N):\n    # Convert the hexadecimal number to decimal\n    decimal_N = int(N, 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal_N % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function calculates the highest power of 2 that is less than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep doubling the power of 2 until it exceeds n\n    while power_of_2 <= n:\n        # Double the power of 2\n        power_of_2 *= 2\n    \n    # The highest power of 2 that is less than or equal to n is the previous power of 2\n    return power_of_2 // 2"}
{"id": "378_0", "code": "def find_lucas(n):\n    \"\"\"\n    This function calculates the nth Lucas number.\n    \n    Parameters:\n    n (int): The position of the Lucas number to be calculated.\n    \n    Returns:\n    int: The nth Lucas number.\n    \"\"\"\n    # Base cases\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    \n    # Initialize variables\n    a, b = 2, 1\n    \n    # Calculate the nth Lucas number\n    for _ in range(2, n):\n        a, b = b, a + b\n    \n    return b"}
{"id": "379_0", "code": "def add_string(lst, string):\n    \"\"\"\n    Inserts a given string at the beginning of all items in a list.\n\n    Args:\n        lst (list): The input list.\n        string (str): The string to be inserted.\n\n    Returns:\n        list: The modified list with the string inserted at the beginning of each item.\n    \"\"\"\n    return [string + item for item in lst]"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a nested dictionary.\n    \n    Args:\n        l1 (list): The first list to be converted.\n        l2 (list): The second list to be converted.\n        l3 (list): The third list to be converted.\n    \n    Returns:\n        dict: A nested dictionary with the input lists as keys.\n    \"\"\"\n    # Initialize an empty dictionary to store the result\n    result = {}\n    \n    # Iterate over the input lists\n    for i in range(len(l1)):\n        # Create a new dictionary for each iteration\n        new_dict = {}\n        \n        # Add the first list as a key to the new dictionary\n        new_dict['list1'] = l1[i]\n        \n        # Add the second list as a key to the new dictionary\n        new_dict['list2'] = l2[i]\n        \n        # Add the third list as a key to the new dictionary\n        new_dict['list3'] = l3[i]\n        \n        # Add the new dictionary to the result dictionary\n        result[f'list{i+1}'] = new_dict\n    \n    # Return the result dictionary\n    return result"}
{"id": "381_0", "code": "def get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 1:\n            return x\n        max_sum = 0\n        for i in [2, 3, 4, 5]:\n            if x % i == 0:\n                max_sum = max(max_sum, f(x // i) + f(i))\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    \"\"\"\n    This function checks if the given tuple is distinct or not.\n    \n    Args:\n        test_tup (tuple): The tuple to be checked for distinctness.\n    \n    Returns:\n        bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set\n    set_tup = set(test_tup)\n    \n    # Compare the length of the original tuple with the length of the set\n    # If they are equal, it means the tuple contains duplicate elements\n    # So, return False indicating that the tuple is not distinct\n    if len(test_tup) == len(set_tup):\n        return False\n    # If the lengths are not equal, it means the tuple is distinct\n    # So, return True\n    else:\n        return True"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over the string to count the frequency of each character\n    for char in str1:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Iterate over the string again to find the first non-repeated character\n    for char in str1:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    \"\"\"\n    This function checks whether the given string starts and ends with the same character.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string starts and ends with the same character, False otherwise.\n    \"\"\"\n    \n    # Compile a regex pattern that matches the start and end of the string with the same character\n    pattern = re.compile(r'^([a-zA-Z])\\1$')\n    \n    # Use the pattern to match the string\n    match = pattern.match(string)\n    \n    # If the string matches the pattern, return True; otherwise, return False\n    return match is not None"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    \"\"\"\n    This function calculates the median of three specific numbers.\n\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    c (float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n    \"\"\"\n    # First, we need to sort the three numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Then, we find the middle number (or numbers) in the sorted list\n    middle_index = len(numbers) // 2\n    \n    # If the length of the list is odd, the median is the middle number\n    if len(numbers) % 2 != 0:\n        median = numbers[middle_index]\n    # If the length of the list is even, the median is the average of the two middle numbers\n    else:\n        median = (numbers[middle_index - 1] + numbers[middle_index]) / 2\n    \n    return median"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    \"\"\"\n    This function calculates the sum of digits of each number in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of sums of digits of each number in the input list.\n    \"\"\"\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the bitwise XOR operation across two given tuples.\n    \n    Args:\n        test_tup1 (tuple): The first tuple to perform the XOR operation on.\n        test_tup2 (tuple): The second tuple to perform the XOR operation on.\n    \n    Returns:\n        tuple: A new tuple containing the result of the XOR operation between the two input tuples.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Perform the XOR operation on the current elements of both tuples\n        xor_result = test_tup1[i] ^ test_tup2[i]\n        \n        # Append the result to the list\n        result.append(xor_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "389_0", "code": "from collections import Counter\n\ndef extract_freq(test_list):\n    # Convert the list to a set to remove duplicates and then convert it back to a list\n    unique_tuples = list(set(test_list))\n    \n    # Use the Counter class from the collections module to count the frequency of each tuple\n    freq_dict = Counter(unique_tuples)\n    \n    # Return the frequency dictionary\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise addition of tuple elements in the given two nested tuples.\n\n    Args:\n        test_tup1 (tuple): The first nested tuple.\n        test_tup2 (tuple): The second nested tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise addition of the elements in the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the input tuples\n    for i in range(len(test_tup1)):\n        # Check if the current elements in both tuples are tuples themselves\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function for the nested tuples\n            nested_result = add_nested_tuples(test_tup1[i], test_tup2[i])\n            # Append the result of the nested addition to the main result list\n            result.append(nested_result)\n        else:\n            # If the current elements are not tuples, perform the addition directly\n            result.append(test_tup1[i] + test_tup2[i])\n\n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    Args:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The prime number.\n\n    Returns:\n    int: The value of ncr%p.\n    \"\"\"\n    # Calculate the modular multiplicative inverse of r using Fermat's Little Theorem\n    def mod_inverse(r, p):\n        return pow(r, p - 2, p)\n\n    # Calculate the modular multiplicative inverse of (n-r+1) using Fermat's Little Theorem\n    def mod_inverse2(n_r_p1, p):\n        return pow(n_r_p1, p - 2, p)\n\n    # Calculate the modular multiplicative inverse of (n-r+1) * r using Fermat's Little Theorem\n    def mod_inverse3(n_r_p1, r, p):\n        return mod_inverse(mod_inverse2(n_r_p1, p) * r, p)\n\n    # Calculate the value of ncr%p using the formula: (n! / (r! * (n-r)!)) % p\n    def ncr(n, r, p):\n        if r > n - r:\n            r = n - r\n        result = 1\n        for i in range(r):\n            result = (result * (n - i)) % p\n            result = (result * mod_inverse(r - i, p)) % p\n        return result\n\n    # Calculate the value of ncr%p\n    return ncr(n, r, p)"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    \"\"\"\n    Checks if a given string is a valid URL.\n\n    Args:\n        str (str): The URL to be checked.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match a valid URL\n    pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    # Check if the URL matches the pattern\n    return bool(pattern.match(str))"}
{"id": "393_0", "code": "def minimum(a,b):\n    \"\"\"\n    This function calculates the minimum of two numbers.\n\n    Args:\n        a (float): The first number.\n        b (float): The second number.\n\n    Returns:\n        float: The minimum of the two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be searched.\n        tuple1 (tuple): The tuple to be searched in.\n\n    Returns:\n        bool: True if the element exists, False otherwise.\n    \"\"\"\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    \"\"\"\n    This function calculates the parity of a given number.\n    \n    Parameters:\n    x (int): The number to find the parity of.\n    \n    Returns:\n    str: The parity of the number ('Even' or 'Odd').\n    \"\"\"\n    if x % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Find the first pair of digits from the right that are in increasing order\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            break\n    else:\n        # If no such pair is found, the number is already the biggest possible\n        return n\n    \n    # Find the smallest digit to the right of the pair that is greater than the first digit of the pair\n    for j in range(len(digits) - 1, i, -1):\n        if digits[j] > digits[i]:\n            break\n    \n    # Swap the two digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the pair in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number and return it\n    return int(''.join(map(str, digits)))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    \"\"\"\n    Returns the k smallest pairs of elements from two sorted arrays.\n\n    Args:\n        nums1 (list): The first sorted array.\n        nums2 (list): The second sorted array.\n        k (int): The number of pairs to return.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a pair of elements from the input arrays.\n    \"\"\"\n    # Initialize an empty list to store the pairs\n    pairs = []\n    \n    # Iterate over the first array\n    for num1 in nums1:\n        # Iterate over the second array\n        for num2 in nums2:\n            # Append the pair to the list\n            pairs.append((num1, num2))\n    \n    # Sort the pairs based on their values\n    pairs.sort()\n    \n    # Return the k smallest pairs\n    return pairs[:k]"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    \"\"\"\n    This function finds the minimum product from the pairs of tuples within a given list.\n    \n    Parameters:\n    list1 (list): A list of tuples.\n    \n    Returns:\n    int: The minimum product from the pairs of tuples.\n    \"\"\"\n    \n    # Initialize the minimum product as infinity\n    min_product = float('inf')\n    \n    # Iterate over each pair of tuples in the list\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = list1[i][0] * list1[j][0]\n            \n            # Update the minimum product if the current product is smaller\n            min_product = min(min_product, product)\n    \n    # Return the minimum product\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    \"\"\"\n    This function finds the minimum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The minimum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not listval:\n        raise ValueError(\"Input list is empty\")\n\n    # Initialize the minimum value with the first element of the list\n    min_val = listval[0]\n\n    # Iterate over the list to find the minimum value\n    for val in listval:\n        # Check if the current value is smaller than the minimum value\n        if val < min_val:\n            min_val = val\n\n    # Return the minimum value\n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    \"\"\"\n    Convert a snake case string to camel case string.\n\n    Args:\n        word (str): The input snake case string.\n\n    Returns:\n        str: The converted camel case string.\n    \"\"\"\n    # Split the input string into words using regex\n    words = re.split(r'(?<!^)(?=[A-Z])', word)\n    \n    # Capitalize the first letter of each word except the first one\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words into a single string\n    camel_case = ''.join(words)\n    \n    return camel_case"}
{"id": "401_0", "code": "def remove_odd(l):\n    \"\"\"\n    This function removes all odd numbers from a given list.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A new list containing only the even numbers from the original list.\n    \"\"\"\n    return [i for i in l if i % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    \"\"\"\n    This function extracts the nth element from a given list of tuples.\n\n    Args:\n        list1 (list): A list of tuples.\n        n (int): The position of the element to be extracted.\n\n    Returns:\n        The nth element from the list of tuples. If n is out of range, returns None.\n    \"\"\"\n    # Check if n is within the valid range\n    if n < 1 or n > len(list1):\n        return None\n    \n    # Extract the nth element from the list of tuples\n    nth_element = list1[n - 1]\n    \n    return nth_element"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    \"\"\"\n    This function checks if the value exists in a sequence or not.\n    \n    Parameters:\n    list1 (list): The first list to be checked.\n    list2 (list): The second list to be checked.\n    \n    Returns:\n    bool: True if the value exists in the sequence, False otherwise.\n    \"\"\"\n    return list1 in list2 or list2 in list1"}
{"id": "404_0", "code": "def max_Product(arr):\n    \"\"\"\n    This function finds the pair with the highest product in a given array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    tuple: A tuple containing the pair of integers with the highest product.\n\n    Raises:\n    ValueError: If the input array has less than two elements.\n    \"\"\"\n\n    if len(arr) < 2:\n        raise ValueError(\"Input array must have at least two elements.\")\n\n    # Sort the array in ascending order\n    arr.sort()\n\n    # The maximum product can be either the product of the two largest numbers or the product of the two smallest numbers (in case they are negative)\n    max_product = max(arr[-1] * arr[-2], arr[0] * arr[1])\n\n    # Find the pair with the maximum product\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] * arr[j] == max_product:\n                return (arr[i], arr[j])\n\n    # If no pair with the maximum product is found, return None\n    return None"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than 3, return n\n    if n < 3:\n        return n\n\n    # Recursive case: try dividing n into three parts\n    max_sum = float('-inf')  # Initialize max_sum as negative infinity\n    for i in range(1, n // 3 + 1):\n        # Calculate the sum of the three parts\n        sum1 = i\n        sum2 = n - i * 2\n        sum3 = n - i - (n - i * 2)\n        \n        # Recursively find the maximum sum for each part\n        sum1 += breakSum(sum1)\n        sum2 += breakSum(sum2)\n        sum3 += breakSum(sum3)\n        \n        # Update max_sum if the current sum is larger\n        max_sum = max(max_sum, sum1, sum2, sum3)\n\n    return max_sum"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Create a dictionary to store the tuples\n    tuple_dict = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Convert the tuple to a string to use as a key in the dictionary\n        tup_str = str(tup)\n        \n        # If the tuple is already in the dictionary, append it to the list\n        if tup_str in tuple_dict:\n            tuple_dict[tup_str].append(tup)\n        # If the tuple is not in the dictionary, add it with a list containing the tuple\n        else:\n            tuple_dict[tup_str] = [tup]\n    \n    # Initialize an empty list to store the common first elements\n    common_first_elements = []\n    \n    # Iterate over each tuple in the input list again\n    for tup in Input:\n        # Convert the tuple to a string to use as a key in the dictionary\n        tup_str = str(tup)\n        \n        # Get the list of tuples from the dictionary\n        tup_list = tuple_dict[tup_str]\n        \n        # If the list of tuples is not empty, find the first element and add it to the list\n        if tup_list:\n            common_first_elements.append(tup_list[0][0])\n    \n    # Return the list of common first elements\n    return common_first_elements"}
{"id": "407_0", "code": "def Find_Max(lst):\n    \"\"\"\n    This function finds the sublist with the maximum length in a given list.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The sublist with the maximum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    max_len = 0\n    max_sublist = None\n\n    for sublst in lst:\n        if len(sublst) > max_len:\n            max_len = len(sublst)\n            max_sublist = sublst\n\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    # Initialize sum variable to zero\n    total_sum = 0\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Round the number to two decimal places\n        rounded_num = round(num, 2)\n        \n        # Add the rounded number to the total sum\n        total_sum += rounded_num\n    \n    # Calculate the product of the total sum and the length of the list\n    product = total_sum * len(list1)\n    \n    # Print the product\n    print(product)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    \"\"\"\n    This function calculates the sum of cubes of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of cubes of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the cube of the current even number\n        cube = i ** 3\n        # Add the cube to the total sum\n        total_sum += cube\n    \n    # Return the total sum\n    return total_sum"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    \"\"\"\n    Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        test_tup (tuple): The input tuple to be concatenated.\n\n    Returns:\n        str: A string containing the concatenated elements of the tuple.\n    \"\"\"\n    delimiter = ', '  # Define the delimiter\n    concatenated_str = delimiter.join(map(str, test_tup))  # Use join() to concatenate the elements\n    return concatenated_str"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        float: The average of cubes of first n natural numbers.\n    \"\"\"\n    # Initialize sum_of_cubes to 0\n    sum_of_cubes = 0\n    \n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to sum_of_cubes\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing sum_of_cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    \"\"\"\n    This function calculates the maximum gold that can be extracted from a mine.\n    \n    Parameters:\n    gold (list): A 2D list representing the gold distribution in the mine.\n    m (int): The number of rows in the mine.\n    n (int): The number of columns in the mine.\n    \n    Returns:\n    int: The maximum gold that can be extracted from the mine.\n    \"\"\"\n    \n    # Create a 2D list to store the maximum gold that can be extracted up to each cell\n    max_gold = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the maximum gold for the first cell\n    max_gold[0][0] = gold[0][0]\n    \n    # Calculate the maximum gold for the first row\n    for j in range(1, n):\n        max_gold[0][j] = max_gold[0][j-1] + gold[0][j]\n    \n    # Calculate the maximum gold for the first column\n    for i in range(1, m):\n        max_gold[i][0] = max_gold[i-1][0] + gold[i][0]\n    \n    # Calculate the maximum gold for the rest of the cells\n    for i in range(1, m):\n        for j in range(1, n):\n            max_gold[i][j] = max(max_gold[i-1][j], max_gold[i][j-1]) + gold[i][j]\n    \n    # Return the maximum gold that can be extracted from the mine\n    return max_gold[m-1][n-1]"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    \"\"\"\n    This function takes a tuple of strings as input and returns a tuple of the rear index element of each string.\n\n    Args:\n        test_tuple (tuple): A tuple of strings.\n\n    Returns:\n        tuple: A tuple of the rear index element of each string.\n    \"\"\"\n    return tuple(string[-1] for string in test_tuple)"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    \"\"\"\n    This function counts the number of sublists containing a particular element in a given list.\n\n    Args:\n        list1 (list): The input list.\n        x (any): The element to be searched.\n\n    Returns:\n        int: The number of sublists containing the element x.\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Define the pattern to match the date\n    pattern = r'\\d{4}-\\d{2}-\\d{2}'\n    \n    # Use regex to replace the matched date with the desired format\n    new_dt = re.sub(pattern, lambda x: x.group().replace('-', '')[::-1] + '-'\n                     + '0' + x.group().replace('-', '')[1:3] + '-'\n                     + x.group().replace('-', '')[3:], dt)\n    \n    return new_dt"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    \"\"\"\n    Sorts the given list using shell sort algorithm.\n\n    Args:\n        my_list (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(my_list) // 2\n\n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Iterate over the list with the current gap size\n        for i in range(gap, len(my_list)):\n            # Store the current element\n            temp = my_list[i]\n            # Initialize the index for the previous gap\n            j = i\n            # Shift the previous elements to the right until a smaller element is found\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            # Place the current element at its correct position\n            my_list[j] = temp\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n\n    # Return the sorted list\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a list of tuples.\n    Each tuple in the returned list contains an element from the first tuple and an element from the second tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        list: A list of tuples, where each tuple contains an element from the first tuple and an element from the second tuple.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Use the zip function to create an iterator of tuples, where the first item in each tuple is from the first tuple and the second item is from the second tuple\n    zipped = zip(test_tup1, test_tup2)\n\n    # Convert the iterator to a list of tuples\n    result = list(zipped)\n\n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    \"\"\"\n    This function calculates the directrix of a parabola given its coefficients a, b, and c.\n    \n    Parameters:\n    a (float): The coefficient of the squared term in the parabola equation.\n    b (float): The coefficient of the linear term in the parabola equation.\n    c (float): The constant term in the parabola equation.\n    \n    Returns:\n    float: The equation of the directrix in the form y = mx + b.\n    \"\"\"\n    \n    # Calculate the focal parameter p\n    p = 1 / (4 * a)\n    \n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = c - (b**2) / (4 * a)\n    \n    # Calculate the slope of the directrix\n    m = -1 / (2 * p)\n    \n    # Calculate the y-intercept of the directrix\n    b_directrix = y_vertex + p\n    \n    # Return the equation of the directrix\n    return f\"y = {m}x + {b_directrix}\""}
{"id": "420_0", "code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2)) > 0"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    \"\"\"\n    Calculate the median of a trapezium.\n\n    Parameters:\n    base1 (float): The length of the first base of the trapezium.\n    base2 (float): The length of the second base of the trapezium.\n    height (float): The height of the trapezium.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # Calculate the median using the formula: median = (2 * area) / (base1 + base2)\n    median = (2 * area) / (base1 + base2)\n    \n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    \"\"\"\n    This function checks whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): The given array of numbers.\n    number (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Iterate over each element in the array\n    for element in arr:\n        # If the number is not greater than any element, return False\n        if number <= element:\n            return False\n    # If the number is greater than all elements, return True\n    return True"}
{"id": "423_0", "code": "import re\n\ndef text_match_one(text):\n    \"\"\"\n    This function checks if the input string contains 'a' followed by one or more 'b's.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains 'a' followed by one or more 'b's, False otherwise.\n    \"\"\"\n    pattern = r\"a(b+)\"\n    return bool(re.search(pattern, text, re.IGNORECASE))"}
{"id": "424_0", "code": "def last_Digit(n):\n    \"\"\"\n    This function calculates the last digit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The last digit of the input number.\n    \"\"\"\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for i in list1:\n        if i < 0:\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    \"\"\"\n    This function removes all odd characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all odd characters removed.\n    \"\"\"\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    \"\"\"\n    This function counts the number of bidirectional tuple pairs in a given list.\n    \n    Args:\n        test_list (list): A list of tuples.\n    \n    Returns:\n        int: The number of bidirectional tuple pairs.\n    \"\"\"\n    # Initialize a variable to store the count of bidirectional tuple pairs\n    count = 0\n    \n    # Iterate over each tuple in the list\n    for i in range(len(test_list)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(test_list)):\n            # Check if the current tuple is a subset of the next tuple\n            if set(test_list[i]).issubset(set(test_list[j])):\n                # If it is, increment the count\n                count += 1\n    \n    # Return the count of bidirectional tuple pairs\n    return count"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    \"\"\"\n    This function takes a list of integers as input and returns a single integer.\n    The integers in the list are concatenated to form a single integer.\n    \n    Parameters:\n    L (list): A list of integers.\n    \n    Returns:\n    int: A single integer formed by concatenating the integers in the input list.\n    \"\"\"\n    # Convert each integer in the list to a string\n    str_L = [str(i) for i in L]\n    \n    # Join the strings together\n    concatenated_str = ''.join(str_L)\n    \n    # Convert the concatenated string back to an integer\n    result = int(concatenated_str)\n    \n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    This function finds all adverbs and their positions in a given sentence.\n\n    Args:\n        text (str): The input sentence.\n\n    Returns:\n        dict: A dictionary where keys are adverbs and values are their positions.\n    \"\"\"\n    # Define a list of adverbs\n    adverbs = ['very', 'well', 'well', 'really', 'so', 'just', 'exactly', 'just', 'really', 'so']\n\n    # Initialize an empty dictionary to store adverbs and their positions\n    adverb_positions = {}\n\n    # Split the text into words\n    words = text.split()\n\n    # Iterate over the words in the text\n    for i, word in enumerate(words):\n        # Check if the word is an adverb\n        if word.lower() in adverbs:\n            # If the word is an adverb, add it to the dictionary with its position\n            adverb_positions[word] = i\n\n    # Return the dictionary of adverbs and their positions\n    return adverb_positions\n\n# Example usage:\ntext = \"She sings very beautifully and plays well.\"\nprint(find_adverb_position(text))"}
{"id": "430_0", "code": "def surfacearea_cube(length):\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Args:\n        length (float): The length of the cube's edge.\n\n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    # Calculate the surface area of the cube\n    surface_area = 6 * (length ** 2)\n    return surface_area"}
{"id": "431_0", "code": "def positive_count(nums):\n    \"\"\"\n    This function calculates the ratio of positive numbers in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of positive numbers in the list.\n    \"\"\"\n    # Count the total number of positive numbers in the list\n    positive_count = sum(1 for num in nums if num > 0)\n    \n    # Calculate the total number of numbers in the list\n    total_count = len(nums)\n    \n    # Check if the list is empty to avoid division by zero error\n    if total_count == 0:\n        return 0\n    \n    # Calculate and return the ratio of positive numbers\n    return positive_count / total_count"}
{"id": "432_0", "code": "def largest_neg(list1):\n    \"\"\"\n    This function finds the largest negative number from the given list.\n\n    Args:\n        list1 (list): A list of integers.\n\n    Returns:\n        int: The largest negative number in the list. If no negative number is found, returns None.\n    \"\"\"\n    # Initialize max_neg to negative infinity\n    max_neg = float('-inf')\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Check if the number is negative and greater than max_neg\n        if num < 0 and num > max_neg:\n            # Update max_neg\n            max_neg = num\n    \n    # If max_neg is still negative infinity, return None\n    if max_neg == float('-inf'):\n        return None\n    else:\n        # Return the largest negative number\n        return max_neg"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    \"\"\"\n    This function trims each tuple in the given list by K elements from the beginning and end.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to trim from the beginning and end of each tuple.\n\n    Returns:\n        list: A list of trimmed tuples.\n    \"\"\"\n    trimmed_list = []\n    for tup in test_list:\n        trimmed_tup = tup[K:]  # Trim from the end\n        trimmed_tup = trimmed_tup[:len(tup) - K]  # Trim from the beginning\n        trimmed_list.append(trimmed_tup)\n    return trimmed_list"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise multiplication.\n\n    Raises:\n        ValueError: If the lengths of the two tuples are not equal.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The lengths of the two tuples must be equal.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function counts the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list to search for.\n\n    Returns:\n    dict: A dictionary where the keys are the elements of the list and the values are their occurrences in the tuple.\n    \"\"\"\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n\n    # Iterate over each element in the list\n    for elem in lst:\n        # Initialize a counter for the current element\n        count = 0\n        # Iterate over each element in the tuple\n        for tup_elem in tup:\n            # If the current element in the tuple is equal to the current element in the list, increment the counter\n            if tup_elem == elem:\n                count += 1\n        # Store the count in the dictionary\n        occurrences[elem] = count\n\n    # Return the dictionary with the occurrences\n    return occurrences"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth term.\n\n    Args:\n    n (int): The number of terms to calculate the sum for.\n\n    Returns:\n    int: The sum of Perrin numbers up to the nth term.\n    \"\"\"\n    # Initialize the first three Perrin numbers\n    a, b, c = 0, 1, 2\n    \n    # Initialize the sum of Perrin numbers\n    total = 0\n    \n    # Calculate the sum of Perrin numbers up to the nth term\n    for _ in range(n):\n        total += c\n        a, b, c = b, c, a + b + c\n    \n    return total"}
{"id": "438_0", "code": "def check_Triangle(x1,y1,x2,y2,x3,y3):\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n    b = ((x3 - x2)**2 + (y3 - y2)**2)**0.5\n    c = ((x1 - x3)**2 + (y1 - y3)**2)**0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "439_0", "code": "def extract_string(str, length):\n    \"\"\"\n    Extract specified size of strings from a given list of string values.\n\n    Args:\n        str (list): A list of string values.\n        length (int): The desired length of the extracted strings.\n\n    Returns:\n        list: A list of extracted strings of specified length.\n    \"\"\"\n    extracted_strings = []\n    for s in str:\n        if len(s) >= length:\n            extracted_strings.append(s[:length])\n    return extracted_strings"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    \"\"\"\n    This function removes all whitespaces from the given string using regex.\n\n    Args:\n        text1 (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    # Use regex to replace all whitespaces with an empty string\n    text_without_whitespaces = re.sub(r'\\s+', '', text1)\n    return text_without_whitespaces"}
{"id": "441_0", "code": "def loss_amount(actual_cost,sale_amount):\n    if actual_cost > sale_amount:\n        loss = actual_cost - sale_amount\n        return loss\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The sum of even factors of the input number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    sum_even_factors = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if i is even\n            if i % 2 == 0:\n                # Add i to the sum of even factors\n                sum_even_factors += i\n    \n    # Return the sum of even factors\n    return sum_even_factors"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    \"\"\"\n    This function matches a word containing 'z' in a given text.\n\n    Args:\n        text (str): The input text to search for words containing 'z'.\n\n    Returns:\n        list: A list of words containing 'z' found in the input text.\n    \"\"\"\n    # Split the input text into words\n    words = text.split()\n\n    # Initialize an empty list to store words containing 'z'\n    words_with_z = []\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word contains 'z' (case-insensitive)\n        if 'z' in word.lower():\n            # If the word contains 'z', add it to the list\n            words_with_z.append(word)\n\n    # Return the list of words containing 'z'\n    return words_with_z"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    month_days = {\n        1: 31,\n        2: 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    if monthnum2 in month_days:\n        return month_days[monthnum2] == 31\n    else:\n        return False"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    \"\"\"\n    This function takes a list of strings as input, reverses each string in the list, \n    and returns the resulting list of reversed strings.\n\n    Args:\n        stringlist (list): A list of strings to be reversed.\n\n    Returns:\n        list: A list of reversed strings.\n    \"\"\"\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in stringlist:\n        # Reverse the string using slicing and append it to the reversed list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    \"\"\"\n    This function finds the sublist with the minimum length in a given list of lists.\n    \n    Parameters:\n    lst (list): A list of lists.\n    \n    Returns:\n    list: The sublist with the minimum length.\n    \"\"\"\n    \n    # Check if the input list is empty\n    if not lst:\n        return None\n    \n    # Initialize the minimum length and the corresponding sublist\n    min_len = float('inf')\n    min_sublist = None\n    \n    # Iterate over each sublist in the input list\n    for sublst in lst:\n        # Check if the length of the current sublist is less than the minimum length found so far\n        if len(sublst) < min_len:\n            # Update the minimum length and the corresponding sublist\n            min_len = len(sublst)\n            min_sublist = sublst\n    \n    # Return the sublist with the minimum length\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(l,b):\n    \"\"\"\n    This function calculates the area of a rectangle.\n\n    Parameters:\n    l (float): The length of the rectangle.\n    b (float): The breadth of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    area = l * b\n    return area"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    \"\"\"\n    This function removes uppercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string.\n    \n    Returns:\n    str: The string with uppercase substrings removed.\n    \"\"\"\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    return re.sub(r'[A-Z]+', '', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: A new list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    \"\"\"\n    This function counts the number of upper case characters in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The number of upper case characters in the string.\n    \"\"\"\n    return sum(1 for char in str if char.isupper())"}
{"id": "451_0", "code": "import itertools\n\ndef combinations_list(list1):\n    # Generate all possible combinations of the elements of the list\n    all_combinations = list(itertools.chain(*itertools.combinations(list1, r) for r in range(1, len(list1) + 1)))\n    \n    return all_combinations\n\n# Example usage:\nmy_list = [1, 2, 3, 4, 5]\nprint(combinations_list(my_list))"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    \"\"\"\n    This function finds the maximum product subarray of the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The maximum product of a subarray.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n            \n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        result = max(result, max_product)\n    \n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    \"\"\"\n    This function checks if all values in a dictionary are the same.\n\n    Parameters:\n    dict (dict): The dictionary to be checked.\n    n (int): The expected value.\n\n    Returns:\n    bool: True if all values are the same, False otherwise.\n    \"\"\"\n    # Get the values from the dictionary\n    values = list(dict.values())\n    \n    # Check if all values are the same as the expected value\n    return all(value == n for value in values)"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    \"\"\"\n    This function drops empty items from a given dictionary.\n    \n    Args:\n        dict1 (dict): The input dictionary.\n    \n    Returns:\n        dict: The dictionary with empty items dropped.\n    \"\"\"\n    # Create a new dictionary to store the non-empty items\n    new_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dict1.items():\n        # Check if the value is not empty\n        if value:\n            # Add the key-value pair to the new dictionary\n            new_dict[key] = value\n    \n    # Return the new dictionary with empty items dropped\n    return new_dict"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    \"\"\"\n    This function finds the peak element in the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    \n    Returns:\n    int: The index of the peak element in the array.\n    \"\"\"\n    \n    # Initialize the low and high pointers\n    low = 0\n    high = n - 1\n    \n    # Continue the loop until low and high pointers meet\n    while low < high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is smaller than the next element, \n        # then the peak element must be on the right side\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        # If the middle element is greater than the next element, \n        # then the peak element must be on the left side\n        else:\n            high = mid\n    \n    # At this point, low and high pointers are pointing to the same index, \n    # which is the index of the peak element\n    return low"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    \"\"\"\n    This function converts a decimal number to octal number.\n    \n    Parameters:\n    deciNum (int): The decimal number to be converted.\n    \n    Returns:\n    str: The octal representation of the decimal number.\n    \"\"\"\n    # Use built-in function oct() to convert decimal to octal\n    octalNum = oct(deciNum)\n    \n    # Remove the '0o' prefix added by the oct() function\n    octalNum = octalNum[2:]\n    \n    return octalNum"}
{"id": "457_0", "code": "def max_product(arr, n):\n    # Initialize the dp array with zeros\n    dp = [0]*n\n    # Initialize the maximum product with negative infinity\n    max_product = float('-inf')\n    \n    # Initialize the minimum product with positive infinity\n    min_product = float('inf')\n    \n    # Initialize the first element of dp array with the first element of the array\n    dp[0] = arr[0]\n    \n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        # If the current element is negative, swap max_product and min_product\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update max_product and min_product\n        max_product = max(arr[i], max_product*arr[i])\n        min_product = min(arr[i], min_product*arr[i])\n        \n        # Update dp array\n        dp[i] = max(dp[i-1]*arr[i], max_product)\n    \n    # Return the maximum product\n    return max_product"}
{"id": "458_0", "code": "def max_profit(price, k):\n    \"\"\"\n    This function calculates the maximum possible profit from buying and selling a stock at most k times.\n\n    Parameters:\n    price (list): A list of stock prices for each day.\n    k (int): The maximum number of transactions allowed.\n\n    Returns:\n    int: The maximum possible profit.\n    \"\"\"\n    if not price or k == 0:\n        return 0\n\n    n = len(price)\n    if k >= n // 2:\n        return sum(max(0, b - a) for a, b in zip(price, price[1:]))\n\n    # Initialize a 2D array to store the maximum profit for each subproblem\n    dp = [[0] * n for _ in range(k + 1)]\n\n    # Iterate over each transaction\n    for i in range(1, k + 1):\n        # Initialize the maximum profit for the current transaction\n        max_profit_so_far = -price[0]\n        # Iterate over each day\n        for j in range(1, n):\n            # Update the maximum profit for the current transaction\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_profit_so_far)\n            # Update the maximum profit so far for the current transaction\n            max_profit_so_far = max(max_profit_so_far, dp[i - 1][j] - price[j])\n\n    # Return the maximum profit for the last transaction\n    return dp[k][n - 1]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    \"\"\"\n    This function calculates the pairwise addition of the elements of the given tuples.\n\n    Args:\n        test_tup (tuple): A tuple containing multiple tuples.\n\n    Returns:\n        list: A list of sums of each pair of elements from the input tuples.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            # Calculate the sum of the current pair of elements\n            pair_sum = sum(test_tup[i]) + sum(test_tup[j])\n            # Append the sum to the result list\n            result.append(pair_sum)\n    return result"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    \"\"\"\n    This function calculates the remainder of the product of all elements in the array\n    divided by the given number n.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    lens (int): The length of the input array.\n    n (int): The divisor.\n\n    Returns:\n    int: The remainder of the product of all elements in the array divided by n.\n    \"\"\"\n    # Initialize the product variable to 1\n    product = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current element with the product\n        product *= arr[i]\n    \n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    \n    # Return the remainder\n    return remainder"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    # Sort the list in ascending order\n    l.sort()\n    \n    # Initialize a variable to store the previous number\n    prev_num = l[0]\n    \n    # Iterate over the list starting from the second number\n    for num in l[1:]:\n        # If the difference between the current number and the previous number is not 1, return False\n        if num - prev_num != 1:\n            return False\n        # Update the previous number\n        prev_num = num\n    \n    # If the function hasn't returned False, it means the list contains consecutive numbers, so return True\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert the tuples to sets\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the intersection back to a tuple\n    result = tuple(intersection)\n\n    return result"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    \"\"\"\n    This function replaces a specified character in a given string with a new character.\n\n    Parameters:\n    str1 (str): The original string.\n    ch (str): The character to be replaced.\n    newch (str): The new character to replace with.\n\n    Returns:\n    str: The modified string with the character replaced.\n    \"\"\"\n    # Check if the input string is empty\n    if not str1:\n        return str1\n    \n    # Check if the character to be replaced is in the string\n    if ch not in str1:\n        return str1\n    \n    # Replace the character in the string\n    return str1.replace(ch, newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    \"\"\"\n    Sorts a dictionary by its values in descending order.\n\n    Args:\n        dict1 (dict): The dictionary to be sorted.\n\n    Returns:\n        dict: A new dictionary sorted by its values in descending order.\n    \"\"\"\n    # Use the sorted function to sort the dictionary items by their values\n    sorted_items = sorted(dict1.items(), key=lambda item: item[1], reverse=True)\n    \n    # Use dictionary comprehension to create a new dictionary with the sorted items\n    sorted_dict = {k: v for k, v in sorted_items}\n    \n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    \"\"\"\n    This function calculates the sum of the largest and smallest value in a given array.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of the largest and smallest value in the array.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Find the smallest and largest value in the array\n    smallest = min(nums)\n    largest = max(nums)\n\n    # Calculate the sum of the smallest and largest value\n    total_sum = smallest + largest\n\n    return total_sum"}
{"id": "466_0", "code": "def is_lower(string):\n    \"\"\"\n    This function converts the given string to lower case.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return string.lower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str1)):\n        if str1[i].isupper():\n            result += str1[i]\n        elif str1[i].islower():\n            if i > 0 and str1[i-1].isupper():\n                result += str1[i]\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The first digit of the number.\n    \"\"\"\n    # Convert the number to a string to easily access individual digits\n    str_n = str(n)\n    \n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If negative, return the first digit after the negative sign\n        return int(str_n[1])\n    else:\n        # If positive, return the first digit\n        return int(str_n[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    \"\"\"\n    This function finds the maximum occurring character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The maximum occurring character in the string.\n\n    \"\"\"\n    # Create an empty dictionary to store the frequency of each character\n    char_frequency = {}\n\n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n\n    # Find the character with the maximum frequency\n    max_char = max(char_frequency, key=char_frequency.get)\n\n    # Return the maximum occurring character\n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Create a table to store results of subproblems\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n\n    # Initialize the first row and column of the table\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the current sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                # Choose the maximum of including and excluding the current element\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The answer is stored in the last cell of the table\n    return dp[n][sum]"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    \"\"\"\n    This function finds sequences of one upper case letter followed by lower case letters in the given string.\n\n    Parameters:\n    text (str): The input string to search for the pattern.\n\n    Returns:\n    list: A list of tuples containing the start and end indices of the found sequences.\n    \"\"\"\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return [(m.start(), m.end()) for m in matches]"}
{"id": "472_0", "code": "import math\n\ndef first_Factorial_Divisible_Number(x):\n    \"\"\"\n    This function finds the first natural number whose factorial is divisible by x.\n\n    Args:\n        x (int): The number to check for divisibility.\n\n    Returns:\n        int: The first natural number whose factorial is divisible by x.\n    \"\"\"\n    i = 1\n    while True:\n        # Calculate the factorial of the current number\n        factorial = math.factorial(i)\n        \n        # Check if the factorial is divisible by x\n        if factorial % x == 0:\n            return i\n        \n        # If not, increment the number and try again\n        i += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    \"\"\"\n    This function removes the matching tuples from the given two tuples.\n    \n    Args:\n        test_list1 (tuple): The first tuple from which matching tuples will be removed.\n        test_list2 (tuple): The second tuple from which matching tuples will be removed.\n    \n    Returns:\n        tuple: A tuple containing the two modified lists.\n    \"\"\"\n    \n    # Convert the tuples to lists for easier manipulation\n    list1 = list(test_list1)\n    list2 = list(test_list2)\n    \n    # Find the matching tuples in list1\n    matching_tuples = [t for t in list1 if t in list2]\n    \n    # Remove the matching tuples from list1\n    list1 = [t for t in list1 if t not in matching_tuples]\n    \n    # Find the matching tuples in list2\n    matching_tuples = [t for t in list2 if t in list1]\n    \n    # Remove the matching tuples from list2\n    list2 = [t for t in list2 if t not in matching_tuples]\n    \n    # Convert the lists back to tuples\n    list1 = tuple(list1)\n    list2 = tuple(list2)\n    \n    # Return the modified tuples\n    return list1, list2"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = float('-inf')\n    for num in A:\n        if is_palindrome(num):\n            max_palindrome = max(max_palindrome, num)\n    return max_palindrome"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Compute the binomial probability for the given number.\n\n    Parameters:\n    n (int): The number of trials.\n    k (int): The number of successes.\n    p (float): The probability of success.\n\n    Returns:\n    float: The binomial probability.\n    \"\"\"\n    # Check if inputs are valid\n    if not isinstance(n, int) or not isinstance(k, int) or not isinstance(p, (int, float)):\n        raise ValueError(\"Inputs must be integers or floats.\")\n    if n < 0 or k < 0 or p < 0 or p > 1:\n        raise ValueError(\"Inputs must be non-negative and p must be less than or equal to 1.\")\n\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n\n    # Calculate the probability of success\n    probability_of_success = p ** k\n\n    # Calculate the probability of failure\n    probability_of_failure = (1 - p) ** (n - k)\n\n    # Calculate the binomial probability\n    binomial_probability = binomial_coefficient * probability_of_success * probability_of_failure\n\n    return binomial_probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    return sorted(tup, key=lambda x: x[-1])"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The area of the pentagon.\n    \"\"\"\n    # Calculate the apothem (distance from center to one vertex)\n    apothem = a / (2 * math.tan(math.pi/5))\n\n    # Calculate the area of one triangle\n    triangle_area = 0.5 * a * apothem\n\n    # Calculate the total area of the pentagon\n    total_area = 5 * triangle_area\n\n    return total_area"}
{"id": "478_0", "code": "def frequency_Of_Largest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the maximum value in the array\n    max_val = max(arr)\n\n    # Count the frequency of the maximum value\n    count = arr.count(max_val)\n\n    # Return the frequency of the maximum value\n    return count"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a,n,r):\n    \"\"\"\n    This function calculates the sum of a geometric progression series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The number of terms in the series.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The sum of the geometric progression series.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    \"\"\"\n    Searches for an item in a sorted list using binary search.\n\n    Args:\n        item_list (list): A sorted list of items.\n        item: The item to search for.\n\n    Returns:\n        int: The index of the item if found, -1 otherwise.\n    \"\"\"\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1"}
{"id": "482_0", "code": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    # Calculate the center of the hexagon\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the angle between each point\n    angle = 2 * math.pi / 6\n\n    # Initialize the list to store the points\n    points = []\n\n    # Calculate the points of the hexagon\n    for i in range(6):\n        # Calculate the x and y coordinates of the current point\n        x = center_x + radius * math.cos(i * angle)\n        y = center_y + radius * math.sin(i * angle)\n\n        # Append the point to the list\n        points.append((x, y))\n\n    # Return the list of points\n    return points"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    \"\"\"\n    This function converts a given binary tuple to an integer.\n\n    Args:\n        test_tup (tuple): A tuple containing binary digits (0s and 1s).\n\n    Returns:\n        int: The integer equivalent of the given binary tuple.\n\n    Raises:\n        ValueError: If the input tuple contains non-binary digits.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise ValueError(\"Input must be a tuple\")\n\n    # Check if the tuple contains only binary digits\n    if not all(digit in '01' for digit in test_tup):\n        raise ValueError(\"Tuple must contain only binary digits (0s and 1s)\")\n\n    # Convert the binary tuple to a string\n    binary_str = ''.join(test_tup)\n\n    # Convert the binary string to an integer\n    integer = int(binary_str, 2)\n\n    return integer"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string.\n    \n    Returns:\n    str: The string with all lowercase substrings removed.\n    \"\"\"\n    # Use regex to find all lowercase substrings and replace them with an empty string\n    return re.sub(r'[a-z]+', '', str1)"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    This function finds the smallest integers from a given list of numbers using heap queue algorithm.\n\n    Args:\n        nums (list): A list of integers.\n        n (int): The number of smallest integers to find.\n\n    Returns:\n        list: A list of the n smallest integers from the input list.\n    \"\"\"\n    # Create a min heap and push the first n elements into the heap\n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n\n    # Initialize an empty list to store the smallest integers\n    smallest_integers = []\n\n    # Loop until the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap and add it to the list\n        smallest_integers.append(heapq.heappop(min_heap))\n\n        # If the heap size is less than n, push the next element into the heap\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, nums[n])\n\n    return smallest_integers"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r,h):\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    \n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two positive integers.\n\n    Args:\n        x (int): The first positive integer.\n        y (int): The second positive integer.\n\n    Returns:\n        int: The GCD of x and y.\n\n    Raises:\n        TypeError: If x or y is not an integer.\n        ValueError: If x or y is not a positive integer.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both inputs must be positive integers.\")\n\n    # Use the Euclidean algorithm to find the GCD\n    while y:\n        x, y = y, x % y\n\n    return abs(x)"}
{"id": "488_0", "code": "import math\n\ndef diameter_circle(r):\n    \"\"\"\n    Calculate the diameter of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The diameter of the circle.\n    \"\"\"\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    \"\"\"\n    Concatenates all elements of the given list into a string.\n\n    Args:\n        lst (list): A list of strings to be concatenated.\n\n    Returns:\n        str: A string containing all elements of the input list.\n    \"\"\"\n    return ''.join(lst)"}
{"id": "490_0", "code": "def num_comm_div(x,y):\n    \"\"\"\n    This function finds the common divisor between two numbers in a given pair.\n    \n    Parameters:\n    x (int): The first number.\n    y (int): The second number.\n    \n    Returns:\n    int: The common divisor between x and y.\n    \"\"\"\n    # Initialize the divisor to 1\n    divisor = 1\n    \n    # Loop through all numbers from 1 to the smaller of x and y\n    for i in range(1, min(x, y) + 1):\n        # Check if i is a divisor of both x and y\n        if x % i == 0 and y % i == 0:\n            # If i is a divisor, update the divisor\n            divisor = i\n    \n    # Return the common divisor\n    return divisor"}
{"id": "491_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the remainder of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The remainder of n divided by m.\n    \"\"\"\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    \"\"\"\n    This function adds consecutive numbers in a given list.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        list: A list of sums of consecutive numbers.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Sort the list in ascending order\n    nums.sort()\n    \n    # Initialize the result list\n    result = []\n    \n    # Initialize the current sum\n    current_sum = nums[0]\n    \n    # Initialize the current number\n    current_num = nums[0]\n    \n    # Iterate over the list starting from the second number\n    for num in nums[1:]:\n        # If the current number is consecutive to the previous one, add it to the current sum\n        if num == current_num + 1:\n            current_sum += num\n            current_num = num\n        # If the current number is not consecutive, append the current sum to the result list and reset the current sum and number\n        else:\n            result.append(current_sum)\n            current_sum = num\n            current_num = num\n    \n    # Append the last sum to the result list\n    result.append(current_sum)\n    \n    return result"}
{"id": "493_0", "code": "def sum_Of_Series(n):\n    \"\"\"\n    This function calculates the cube sum of the first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to calculate the cube sum for.\n\n    Returns:\n        int: The cube sum of the first n natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through each number from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the total sum\n        total_sum += i ** 3\n    \n    # Return the total sum\n    return total_sum"}
{"id": "494_0", "code": "def re_order(A):\n    \"\"\"\n    This function reorders the given array by moving all zeroes to the end.\n    \n    Parameters:\n    A (list): The input array.\n    \n    Returns:\n    list: The reordered array with zeroes at the end.\n    \"\"\"\n    # Initialize two pointers, one at the beginning and one at the end of the array\n    left = 0\n    right = 0\n    \n    # Traverse the array from left to right\n    while right < len(A):\n        # If the current element is not zero, swap it with the element at the left pointer\n        if A[right] != 0:\n            A[left], A[right] = A[right], A[left]\n            # Move the left pointer to the right\n            left += 1\n        # Move the right pointer to the right\n        right += 1\n    \n    # Return the reordered array\n    return A"}
{"id": "495_0", "code": "import math\n\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient of given p(n, k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    float: The permutation coefficient p(n, k).\n    \"\"\"\n    # Check if k is greater than n\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n\n    # Calculate the permutation coefficient using the formula n! / (n-k)!\n    coefficient = math.factorial(n) / math.factorial(n - k)\n    return coefficient"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    \"\"\"\n    This function removes specific words from a given list.\n\n    Parameters:\n    list1 (list): The original list of words.\n    removewords (list): The list of words to be removed.\n\n    Returns:\n    list: The list of words with the specified words removed.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    new_list = list1.copy()\n    \n    # Iterate over each word to be removed\n    for word in removewords:\n        # Check if the word exists in the new list\n        if word in new_list:\n            # Remove the word from the new list\n            new_list.remove(word)\n    \n    # Return the new list with the specified words removed\n    return new_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    \"\"\"\n    This function checks if the common elements between two given lists are in the same order or not.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        bool: True if the common elements are in the same order, False otherwise.\n    \"\"\"\n    # Find the common elements between the two lists\n    common_elements = list(set(l1) & set(l2))\n    \n    # If there are no common elements, return True\n    if not common_elements:\n        return True\n    \n    # Initialize an index to keep track of the current position in the first list\n    i = 0\n    \n    # Iterate over the common elements\n    for element in common_elements:\n        # If the current element is not at the same position in the first list, return False\n        if l1[i] != element:\n            return False\n        # Move to the next position in the first list\n        i += 1\n    \n    # If we have checked all common elements and haven't returned False, return True\n    return True"}
{"id": "498_0", "code": "def average_Odd(n):\n    \"\"\"\n    This function calculates the average of odd numbers till a given odd number.\n\n    Args:\n        n (int): The given odd number.\n\n    Returns:\n        float: The average of odd numbers till the given odd number.\n    \"\"\"\n    # Initialize sum and count variables to zero\n    total_sum = 0\n    count = 0\n\n    # Loop through all odd numbers till the given odd number\n    for i in range(1, n + 1):\n        # Check if the current number is odd\n        if i % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += i\n            # Increment the count of odd numbers\n            count += 1\n\n    # Check if there are any odd numbers\n    if count == 0:\n        # If no odd numbers, return 0\n        return 0\n    else:\n        # Calculate and return the average of odd numbers\n        return total_sum / count"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(k, -1, -1):\n            if j >= arr[i]:\n                dp[j] += dp[j - arr[i]]\n    return dp[k]"}

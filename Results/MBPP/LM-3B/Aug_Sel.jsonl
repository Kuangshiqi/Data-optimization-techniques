{"id": "0_0", "code": "def remove_Occ(s,ch):\n    s = list(s)\n    first_occ = s.index(ch)\n    last_occ = len(s) - 1 - s[::-1].index(ch)\n    s[first_occ:last_occ+1] = []\n    return ''.join(s)"}
{"id": "1_0", "code": "def sort_matrix(M):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        M (list of lists): A 2D list representing the matrix.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    # Calculate the sum of each row and store it in a list of tuples\n    row_sums = [(sum(row), row) for row in M]\n\n    # Sort the list of tuples based on the sum of each row\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows from the list of tuples\n    sorted_M = [row for _, row in sorted_row_sums]\n\n    return sorted_M"}
{"id": "2_0", "code": "from collections import Counter\nimport re\n\ndef count_common(words):\n    # Convert all words to lower case and remove punctuation\n    cleaned_words = [re.sub(r'[^\\w\\s]', '', word).lower() for word in words]\n    \n    # Count the frequency of each word\n    word_counts = Counter(cleaned_words)\n    \n    # Get the most common words and their counts\n    common_words = word_counts.most_common(10)\n    \n    return common_words"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    \"\"\"\n    This function calculates the volume of a triangular prism.\n\n    Parameters:\n    l (float): The length of the prism.\n    b (float): The base of the prism.\n    h (float): The height of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the base triangle\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        list: A list of strings split at lowercase letters.\n    \"\"\"\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n            current_word += char\n        else:\n            current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "def text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an empty string to store the current sequence\n    current_sequence = \"\"\n    \n    # Iterate over each character in the input string\n    for char in text:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # If the character is a lowercase letter, add it to the current sequence\n            current_sequence += char\n        else:\n            # If the character is not a lowercase letter, check if the current sequence is not empty\n            if current_sequence:\n                # If the current sequence is not empty, add it to the result list\n                result.append(current_sequence)\n                # Reset the current sequence\n                current_sequence = \"\"\n    \n    # After iterating over all characters, check if the current sequence is not empty\n    if current_sequence:\n        # If the current sequence is not empty, add it to the result list\n        result.append(current_sequence)\n    \n    # Return the result list\n    return result"}
{"id": "6_0", "code": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Args:\n        a (float): The length of one side of the square.\n\n    Returns:\n        float: The perimeter of the square.\n    \"\"\"\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = 4 * a\n    return perimeter"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The original string.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters removed.\n    \"\"\"\n    # Convert the second string to a set for efficient lookups\n    dirty_chars = set(second_string)\n    \n    # Use a list comprehension to filter out characters in the first string\n    # that are present in the set of dirty characters\n    filtered_chars = [char for char in string if char not in dirty_chars]\n    \n    # Join the filtered characters back into a string\n    cleaned_string = ''.join(filtered_chars)\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    return len(arraynums) != len(set(arraynums))"}
{"id": "9_0", "code": "def is_woodall(x):\n    \"\"\"\n    Checks if the given number is woodall or not.\n    \n    A woodall number is a number that is the sum of its own digits raised to the power of their position in the number.\n    \n    Parameters:\n    x (int): The number to check.\n    \n    Returns:\n    bool: True if the number is woodall, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_x = str(x)\n    \n    # Initialize a variable to store the sum of the digits raised to the power of their position\n    total = 0\n    \n    # Iterate over each digit in the number\n    for i, digit in enumerate(str_x):\n        # Add the digit raised to the power of its position to the total\n        total += int(digit) ** (i + 1)\n    \n    # Check if the total is equal to the original number\n    return total == x"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    \"\"\"\n    This function generates m number of multiples of n.\n\n    Args:\n        m (int): The number of multiples to generate.\n        n (int): The number for which multiples are to be generated.\n\n    Returns:\n        list: A list of m number of multiples of n.\n    \"\"\"\n    # Initialize an empty list to store the multiples\n    multiples = []\n    \n    # Loop through the range from 1 to m+1 (to include m)\n    for i in range(1, m+1):\n        # Calculate the multiple by multiplying n with i\n        multiple = n * i\n        \n        # Append the multiple to the list\n        multiples.append(multiple)\n    \n    # Return the list of multiples\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    \"\"\"\n    This function finds the first duplicate element in a given array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first duplicate element if found, otherwise -1.\n\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize max_sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Calculate the sum of the current sublist\n        sublist_sum = sum(sublist)\n        \n        # Update max_sum if the current sublist sum is greater\n        max_sum = max(max_sum, sublist_sum)\n    \n    # Return the maximum sum found\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    This function converts a binary number to its decimal equivalent.\n\n    Args:\n        binary (str): A string of binary digits (0s and 1s).\n\n    Returns:\n        int: The decimal equivalent of the given binary number.\n\n    Raises:\n        ValueError: If the input string contains characters other than 0 and 1.\n    \"\"\"\n    # Check if the input string contains only 0s and 1s\n    if not set(binary).issubset({'0', '1'}):\n        raise ValueError(\"Invalid binary number. It should only contain 0s and 1s.\")\n\n    # Initialize the decimal number to 0\n    decimal = 0\n\n    # Iterate over the binary number from right to left\n    for i, bit in enumerate(reversed(binary)):\n        # If the current bit is 1, add 2^i to the decimal number\n        if bit == '1':\n            decimal += 2 ** i\n\n    return decimal"}
{"id": "14_0", "code": "def find_Product(arr,n):\n    # Create a frequency dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize product variable to 1\n    product = 1\n\n    # Iterate through the frequency dictionary\n    for key, value in freq_dict.items():\n        # If the frequency of the element is 1, multiply the product by the element\n        if value == 1:\n            product *= key\n\n    # Return the product\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    \"\"\"\n    This function checks if the given tuple list has all k elements.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to check for.\n\n    Returns:\n        bool: True if the list has all k elements, False otherwise.\n    \"\"\"\n    # Check if the input test_list is a list\n    if not isinstance(test_list, list):\n        raise TypeError(\"test_list must be a list\")\n\n    # Check if the input K is an integer\n    if not isinstance(K, int):\n        raise TypeError(\"K must be an integer\")\n\n    # Check if the list is empty\n    if len(test_list) == 0:\n        return False\n\n    # Check if all elements in the list are tuples\n    if not all(isinstance(element, tuple) for element in test_list):\n        raise TypeError(\"All elements in the list must be tuples\")\n\n    # Check if all tuples have the same length\n    tuple_length = len(test_list[0])\n    if not all(len(element) == tuple_length for element in test_list):\n        raise TypeError(\"All tuples in the list must have the same length\")\n\n    # Check if the list has all k elements\n    return len(test_list) == K"}
{"id": "16_0", "code": "def remove(lst):\n    \"\"\"\n    This function removes all digits from a list of strings.\n\n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        list: A list of strings with all digits removed.\n    \"\"\"\n    return [''.join(filter(str.isalpha, s)) for s in lst]"}
{"id": "17_0", "code": "import math\n\ndef binomial_Coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k)\n    \n    Parameters:\n    n (int): The total number of items\n    k (int): The number of items to choose\n    \n    Returns:\n    int: The binomial coefficient (n choose k)\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    return int(result)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through the array to count the frequency of each element\n    for i in range(arr_size):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n    \n    # Iterate through the dictionary to find the element occurring odd number of times\n    for key, value in freq_dict.items():\n        if value % 2 != 0:\n            return key"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "import heapq\nfrom collections import Counter\n\ndef func(nums, k):\n    # Count the frequency of each integer\n    freq = Counter(nums)\n    \n    # Create a min heap to store the top k integers\n    min_heap = []\n    \n    # Push the first k integers into the min heap\n    for num, count in freq.most_common(k):\n        heapq.heappush(min_heap, (-count, num))\n    \n    # Pop the top k integers from the min heap\n    top_k = []\n    while min_heap:\n        count, num = heapq.heappop(min_heap)\n        top_k.append(num)\n    \n    return top_k"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_prime = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            max_prime = max(max_prime, i)\n    return max_prime"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    \"\"\"\n    This function converts a decimal number to binary number.\n    \n    Parameters:\n    N (int): The decimal number to be converted.\n    \n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    # Check if the input is an integer\n    if not isinstance(N, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    # Check if the input is non-negative\n    if N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Convert the decimal number to binary using built-in function bin()\n    binary = bin(N)\n    \n    # Remove the '0b' prefix from the binary string\n    binary = binary[2:]\n    \n    return binary"}
{"id": "23_0", "code": "def find_missing(ar,N):\n    \"\"\"\n    This function finds the missing number in a sorted array.\n    \n    Parameters:\n    ar (list): A sorted list of integers.\n    N (int): The total number of elements in the array.\n    \n    Returns:\n    int: The missing number in the array.\n    \"\"\"\n    # Initialize the low and high pointers\n    low = 0\n    high = len(ar) - 1\n    \n    # Continue the loop until low and high pointers meet\n    while low <= high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is equal to its index plus one, \n        # then the missing number is in the right half\n        if ar[mid] == mid + 1:\n            low = mid + 1\n        # If the middle element is not equal to its index plus one, \n        # then the missing number is in the left half\n        else:\n            high = mid - 1\n    \n    # At this point, low and high pointers are pointing to the missing number\n    return low + 1"}
{"id": "24_0", "code": "def find_rect_num(n):\n    \"\"\"\n    This function calculates the n-th rectangular number.\n    \n    Parameters:\n    n (int): The position of the rectangular number to be found.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    # Initialize the first rectangular number\n    rect_num = 1\n    \n    # Loop through the numbers from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the next rectangular number\n        rect_num = rect_num * (i + 1)\n    \n    # Return the n-th rectangular number\n    return rect_num"}
{"id": "25_0", "code": "from fractions import Fraction\n\ndef find_Nth_Digit(p, q, N):\n    \"\"\"\n    This function finds the nth digit in the proper fraction of two given numbers.\n    \n    Parameters:\n    p (int): The numerator of the fraction.\n    q (int): The denominator of the fraction.\n    N (int): The position of the digit to be found.\n    \n    Returns:\n    int: The nth digit in the proper fraction of p/q.\n    \"\"\"\n    \n    # Calculate the greatest common divisor of p and q\n    gcd = gcd_helper(p, q)\n    \n    # Reduce the fraction to its simplest form\n    p = p // gcd\n    q = q // gcd\n    \n    # Calculate the decimal representation of the fraction\n    decimal = p / q\n    \n    # Convert the decimal to a string\n    decimal_str = str(decimal)\n    \n    # Remove the leading 0. and the decimal point\n    decimal_str = decimal_str[2:]\n    \n    # Check if N is within the range of the decimal representation\n    if N > len(decimal_str):\n        raise ValueError(\"N is out of range\")\n    \n    # Return the nth digit\n    return int(decimal_str[N-1])"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a given mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing a mix of integers and strings.\n\n    Returns:\n        list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the integers and strings separately\n    integers.sort()\n    strings.sort()\n\n    # Combine the sorted integers and strings into a single list\n    sorted_list = integers + strings\n\n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Separate even and odd numbers\n    even_numbers = [num for num in list1 if num % 2 == 0]\n    odd_numbers = [num for num in list1 if num % 2 != 0]\n\n    # Check if there are at least two numbers in each list\n    if len(even_numbers) < 2 or len(odd_numbers) < 2:\n        return \"Not enough numbers in the list\"\n\n    # Calculate the division of the first even and odd numbers\n    first_even = even_numbers[0]\n    first_odd = odd_numbers[0]\n    division = first_even / first_odd\n\n    return division"}
{"id": "28_0", "code": "from collections import Counter\n\ndef rearange_string(S):\n    # Count the frequency of each character in the string\n    char_count = Counter(S)\n    \n    # Sort the characters by their frequency in descending order\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    \n    # Initialize variables to keep track of the current character and its count\n    current_char = None\n    current_count = 0\n    \n    # Initialize a list to store the rearranged characters\n    rearranged_chars = []\n    \n    # Iterate over the sorted characters\n    for char, count in sorted_chars:\n        # If the current character is the same as the previous one, increment its count\n        if current_char == char:\n            current_count += count\n        # If the current character is different from the previous one, reset its count\n        else:\n            current_char = char\n            current_count = count\n        \n        # Add the current character to the rearranged list\n        rearranged_chars.extend([char] * current_count)\n    \n    # If the length of the rearranged list is not equal to the length of the original string, return False\n    if len(rearranged_chars) != len(S):\n        return False\n    \n    # Return True if the rearranged list is valid, False otherwise\n    return all(rearranged_chars[i] != rearranged_chars[i+1] for i in range(len(rearranged_chars)-1))"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    \"\"\"\n    This function calculates the frequency of each element in a given list of lists.\n\n    Args:\n        nums (list): A list of lists containing elements.\n\n    Returns:\n        dict: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq_dict = Counter(flat_list)\n    \n    return dict(freq_dict)"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr,n):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over the array to count the frequency of each element\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n    \n    # Initialize a variable to store the sum of repeated elements\n    sum_repeated = 0\n    \n    # Iterate over the dictionary to find the sum of repeated elements\n    for key, value in freq_dict.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    # Return the sum of repeated elements\n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    \"\"\"\n    This function checks if a word is at the beginning of a given string.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the word is at the beginning of the string, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    text = text.strip()\n    \n    # Check if the string is not empty\n    if not text:\n        return False\n    \n    # Split the string into words\n    words = text.split()\n    \n    # Check if the first word is the same as the input word\n    return words[0] == text.split()[0]"}
{"id": "34_0", "code": "import math\n\ndef get_gcd(lst):\n    def _gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = lst[0]\n    for num in lst[1:]:\n        result = _gcd(result, num)\n    return result"}
{"id": "35_0", "code": "def test_distinct(data):\n    return len(data) == len(set(data))"}
{"id": "36_0", "code": "import math\n\ndef compute_Last_Digit(A,B):\n    # Calculate the factorial of A and B\n    fact_A = math.factorial(A)\n    fact_B = math.factorial(B)\n\n    # Calculate the remainder of fact_B divided by fact_A\n    remainder = fact_B % fact_A\n\n    # Return the last digit of the remainder\n    return remainder % 10"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result as 0\n    result = 0\n    \n    # Iterate over each bit in the number\n    for i in range(n.bit_length()):\n        # Check if the current bit is odd\n        if (n >> i) & 1:\n            # If the bit is odd, set the corresponding bit in the result\n            result |= 1 << i\n    \n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every first or specified element from a given two-dimensional list.\n\n    Args:\n        nums (list): A two-dimensional list of integers.\n        N (int): The position of the element to extract (0-indexed).\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    extracted_elements = []\n    for row in nums:\n        if N < len(row):\n            extracted_elements.append(row[N])\n        else:\n            extracted_elements.append(row[0])\n    return extracted_elements"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=len)"}
{"id": "40_0", "code": "def check_equilateral(x,y,z):\n    # Check if all sides are equal\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b,h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n\n    Parameters:\n    str (str): The input string to be checked.\n\n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is not empty\n    if len(str) == 0:\n        return False  # Return False for empty string\n\n    # Get the first and last characters of the string\n    first_char = str[0]\n    last_char = str[-1]\n\n    # Compare the first and last characters\n    if first_char == last_char:\n        return True  # Return True if they are equal\n    else:\n        return False  # Return False if they are not equal"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    max_val = max(my_list)\n    min_val = min(my_list)\n    count = [0] * (max_val - min_val + 1)\n    for num in my_list:\n        count[num - min_val] += 1\n    sorted_list = []\n    for i, cnt in enumerate(count):\n        sorted_list.extend([i + min_val] * cnt)\n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a,n,r):\n    \"\"\"\n    This function calculates the t-nth term of a geometric series.\n\n    Parameters:\n    a (float): The first term of the geometric series.\n    n (int): The term number to be calculated.\n    r (float): The common ratio of the geometric series.\n\n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if r == 1:\n        return a\n    else:\n        return a * (r ** (n - 1))"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to easily reverse it\n    str_n = str(n)\n    \n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    \n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"id": "46_0", "code": "def find_Max_Num(arr,n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Join the sorted array into a string\n    max_num_str = ''.join(map(str, arr))\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x,y):\n    \"\"\"\n    This function checks whether the given two integers have opposite sign or not.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        bool: True if the integers have opposite sign, False otherwise.\n    \"\"\"\n    # Check if the signs of the two integers are different\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)"}
{"id": "48_0", "code": "def is_octagonal(n):\n    \"\"\"\n    Checks if a number is an octagonal number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is an octagonal number, False otherwise.\n    \"\"\"\n    # Calculate the nth octagonal number\n    octagonal_num = (8 * n * (n + 1)) // 2\n    \n    # Check if the number is equal to the calculated octagonal number\n    return n == octagonal_num\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    Calculates the nth octagonal number.\n\n    Args:\n    n (int): The position of the octagonal number to calculate.\n\n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    # Calculate the nth octagonal number using the formula\n    return (8 * n * (n + 1)) // 2"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    # Initialize variables to store the maximum length and the current length\n    max_len = 1\n    curr_len = 1\n\n    # Iterate through the array starting from the second element\n    for i in range(1, n):\n        # If the difference between the current element and the previous one is positive\n        if arr[i] - arr[i - 1] > 0:\n            # Increase the current length\n            curr_len += 1\n        else:\n            # Update the maximum length if the current length is greater\n            max_len = max(max_len, curr_len)\n            # Reset the current length\n            curr_len = 1\n\n    # Update the maximum length one last time\n    max_len = max(max_len, curr_len)\n\n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s,n):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    \"\"\"\n    This function calculates the maximum difference between available pairs in the given tuple list.\n    \n    Parameters:\n    test_list (list): A list of tuples containing the available pairs.\n    \n    Returns:\n    int: The maximum difference between available pairs.\n    \"\"\"\n    \n    # Initialize the maximum difference as 0\n    max_diff = 0\n    \n    # Iterate over each pair in the test list\n    for pair in test_list:\n        # Calculate the difference between the first and second elements of the pair\n        diff = abs(pair[0] - pair[1])\n        \n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_subject_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subject_marks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    \"\"\"\n    This function calculates the sum of all elements in a list using recursion.\n    \n    Args:\n        data_list (list): A list of numbers.\n    \n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    # Base case: If the list is empty, return 0\n    if not data_list:\n        return 0\n    \n    # Recursive case: Add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    \"\"\"\n    This function counts the number of positive numbers in a given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The count of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize the list to store bell numbers\n    bell = [0] * (n + 1)\n    # Initialize the first two bell numbers\n    bell[0] = 1\n    bell[1] = 1\n    # Calculate the rest of the bell numbers\n    for i in range(2, n + 1):\n        bell[i] = sum(bell[j] for j in range(i))\n    return bell[n]\n\ndef partition_bell_numbers(n):\n    # Initialize the list to store the number of ways to partition\n    ways = [0] * (n + 1)\n    # Initialize the first two ways\n    ways[0] = 1\n    ways[1] = 1\n    # Calculate the rest of the ways\n    for i in range(2, n + 1):\n        for j in range(i):\n            ways[i] += ways[j] * bell_number(j)\n    return ways[n]\n\n# Test the function\nprint(partition_bell_numbers(5))"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    # Check if the array is empty\n    if len(A) == 0:\n        return True  # An empty array is considered monotonic\n\n    # Check if the array is monotonic in the increasing order\n    increasing = all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n\n    # Check if the array is monotonic in the decreasing order\n    decreasing = all(A[i] >= A[i + 1] for i in range(len(A) - 1))\n\n    # Return True if the array is monotonic in either order, False otherwise\n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    \"\"\"\n    Checks if list l contains the given sublist s.\n\n    Args:\n        l (list): The list to search in.\n        s (list): The sublist to search for.\n\n    Returns:\n        bool: True if l contains s, False otherwise.\n    \"\"\"\n    # Check if the sublist is empty\n    if not s:\n        return True  # An empty sublist is a sublist of any list\n\n    # Check if the sublist is longer than the list\n    if len(s) > len(l):\n        return False  # A sublist longer than the list cannot be a sublist\n\n    # Iterate over the list with a sliding window of the same size as the sublist\n    for i in range(len(l) - len(s) + 1):\n        # Check if the current window matches the sublist\n        if l[i:i+len(s)] == s:\n            return True  # If a match is found, return True\n\n    # If no match is found after iterating over the entire list, return False\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    \"\"\"\n    This function checks if all the given tuples have equal length.\n\n    Args:\n        Input (list): A list of tuples.\n        k (int): The length to compare with.\n\n    Returns:\n        bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(Input, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n\n    # Check if all elements in the list are tuples\n    if not all(isinstance(t, tuple) for t in Input):\n        raise TypeError(\"All elements in the list must be tuples.\")\n\n    # Check if all tuples have the same length\n    return len(set(len(t) for t in Input)) == 1"}
{"id": "60_0", "code": "def comb_sort(nums):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    \"\"\"\n    Checks whether the given number can be represented as difference of two squares or not.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as difference of two squares, False otherwise.\n    \"\"\"\n    i = 1\n    while i * i <= n:\n        # Check if n can be represented as difference of two squares\n        if (i * i) - n == (i + 1) * (i + 1):\n            return True\n        i += 1\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define the delimiters\n    delimiters = [\",\", \";\", \"\\t\", \"\\n\", \"\\r\", \" \", \"|\", \"-\", \"+\"]\n\n    # Escape special characters in delimiters\n    escaped_delimiters = [re.escape(d) for d in delimiters]\n\n    # Join the escaped delimiters into a single string\n    delimiter_string = \"\".join(escaped_delimiters)\n\n    # Use regex to split the text\n    split_text = re.split(delimiter_string, text)\n\n    # Remove empty strings from the result\n    split_text = [s for s in split_text if s != \"\"]\n\n    return split_text"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks whether the given colors follow the sequence given in the patterns array.\n\n    Args:\n        colors (list): A list of colors.\n        patterns (list): A list of patterns.\n\n    Returns:\n        bool: True if the colors follow the patterns, False otherwise.\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    \"\"\"\n    This function finds tuples in the given list that have all elements divisible by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The divisor.\n\n    Returns:\n        list: A list of tuples where all elements are divisible by K.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over each tuple in the test list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(element % K == 0 for element in tup):\n            # If all elements are divisible by K, add the tuple to the result\n            result.append(tup)\n\n    # Return the result\n    return result"}
{"id": "65_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # m is the number of rows and n is the number of columns\n    # We assume that the rectangle is a square (m = n)\n    # If the rectangle is not a square, we calculate the number of squares in each row and sum them up\n    if m == n:\n        return m * n\n    else:\n        return m * n"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize variables to store the sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each character (digit) in the string\n    for digit in str_n:\n        # Convert the character back into an integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd\n        if int_digit % 2 == 0:\n            # If the digit is even, add it to the even sum\n            even_sum += int_digit\n        else:\n            # If the digit is odd, add it to the odd sum\n            odd_sum += int_digit\n    \n    # Calculate the difference between the sum of even and odd digits\n    diff = abs(even_sum - odd_sum)\n    \n    # Return the difference\n    return diff"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(n + 1):\n        # Calculate the number of set bits in i\n        set_bits = bin(i).count('1')\n        # If the number of set bits is odd, increment the count\n        if set_bits % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    \"\"\"\n    This function checks whether the length of the word is odd or not.\n\n    Parameters:\n    s (str): The input word.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(s) % 2 != 0"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    The nth tetrahedral number is the number of ways to choose 4 elements from a set of n elements.\n\n    Args:\n        n (int): The position of the tetrahedral number to calculate.\n\n    Returns:\n        int: The nth tetrahedral number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Calculate the nth tetrahedral number using the formula: n*(n+1)*(n+2)/6\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple with the elements from the input tuples zipped together.\n    \n    Args:\n        test_tup1 (tuple): The first tuple to be zipped.\n        test_tup2 (tuple): The second tuple to be zipped.\n    \n    Returns:\n        tuple: A new tuple with the elements from the input tuples zipped together.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    # Use the built-in zip function to zip the tuples\n    zipped_tuple = zip(test_tup1, test_tup2)\n    \n    # Convert the zipped tuple to a list and then back to a tuple\n    zipped_list = list(zipped_tuple)\n    zipped_tuple = tuple(zipped_list)\n    \n    return zipped_tuple"}
{"id": "71_0", "code": "import math\n\ndef volume_sphere(r):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    volume = (4/3) * math.pi * (r ** 3)\n    return volume"}
{"id": "72_0", "code": "def get_Char(strr):\n    \"\"\"\n    This function calculates the character made by adding all the characters of the given string.\n    \n    Parameters:\n    strr (str): The input string.\n    \n    Returns:\n    str: The character made by adding all the characters of the given string.\n    \"\"\"\n    # Initialize a variable to store the sum of ASCII values\n    ascii_sum = 0\n    \n    # Iterate over each character in the string\n    for char in strr:\n        # Add the ASCII value of the character to the sum\n        ascii_sum += ord(char)\n    \n    # Convert the sum to a character using the chr function\n    generated_char = chr(ascii_sum)\n    \n    # Return the generated character\n    return generated_char"}
{"id": "73_0", "code": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is a sequence of numbers that starts with 1, \n    and each subsequent number is the sum of the previous number and the \n    number of terms in the sequence up to that point.\n    \n    Parameters:\n    n (int): The position of the number in the sequence.\n    \n    Returns:\n    int: The n-th number in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    sequence = [1]\n    for i in range(1, n):\n        sequence.append(sequence[i-1] + i)\n    \n    return sequence[-1]"}
{"id": "74_0", "code": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    Args:\n        n (int): The position of the centered hexagonal number to calculate.\n\n    Returns:\n        int: The nth centered hexagonal number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n\n    # The formula for the nth centered hexagonal number is given by:\n    # C(n) = 3n^2 - 3n + 1\n    # We can use this formula to calculate the nth centered hexagonal number.\n    return 3 * n ** 2 - 3 * n + 1"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1,dict2, dict3):\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy the key-value pairs from the first dictionary to the merged dictionary\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    \n    # Copy the key-value pairs from the second dictionary to the merged dictionary\n    for key, value in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    # Copy the key-value pairs from the third dictionary to the merged dictionary\n    for key, value in dict3.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            if isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dictionaries_three(merged_dict[key], value)\n            elif isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            else:\n                merged_dict[key] = [merged_dict[key], value]\n    \n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    \"\"\"\n    This function calculates the frequency of each element in a given list.\n\n    Args:\n        list1 (list): A list of elements.\n\n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for element in list1:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict"}
{"id": "78_0", "code": "def closest_num(N):\n    \"\"\"\n    This function finds the closest smaller number than N.\n\n    Args:\n        N (int): The input number.\n\n    Returns:\n        int: The closest smaller number than N.\n    \"\"\"\n    # Initialize the lower and upper bounds\n    low = N - 1\n    high = N\n\n    # Perform binary search\n    while low <= high:\n        mid = (low + high) // 2\n        # If mid is smaller than N, update the lower bound\n        if mid < N:\n            low = mid + 1\n        # If mid is not smaller than N, update the upper bound\n        else:\n            high = mid - 1\n\n    # After the loop, low will be the closest smaller number than N\n    return low"}
{"id": "79_0", "code": "def len_log(list1):\n    \"\"\"\n    This function finds the length of the longest word in a given list.\n\n    Args:\n        list1 (list): A list of words.\n\n    Returns:\n        int: The length of the longest word in the list.\n    \"\"\"\n    # Check if the list is empty\n    if not list1:\n        return 0\n\n    # Initialize the maximum length with the length of the first word\n    max_length = len(list1[0])\n\n    # Iterate over each word in the list\n    for word in list1:\n        # If the length of the current word is greater than the max_length\n        if len(word) > max_length:\n            # Update max_length with the length of the current word\n            max_length = len(word)\n\n    # Return the maximum length\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    \"\"\"\n    This function checks if a substring is present in a given list of string values.\n\n    Parameters:\n    str1 (list): A list of string values.\n    sub_str (str): The substring to be searched.\n\n    Returns:\n    bool: True if the substring is found, False otherwise.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False"}
{"id": "81_0", "code": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a variable to store the difference between the first and last digit\n    diff = abs(int(str_n[0]) - int(str_n[-1]))\n    \n    # Iterate over the digits in the number\n    for i in range(1, len(str_n) - 1):\n        # Calculate the difference between the current digit and the next digit\n        curr_diff = abs(int(str_n[i]) - int(str_n[i + 1]))\n        \n        # If the difference between the first and last digit is not equal to the difference between the current digit and the next digit, the number is not undulating\n        if diff != curr_diff:\n            return False\n    \n    # If the function has not returned False, the number is undulating\n    return True"}
{"id": "82_0", "code": "def power(a,b):\n    return a ** b"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    \"\"\"\n    This function takes a list of tuples as input, where each tuple contains a value and its index.\n    It returns the index and minimum value of the tuple with the smallest value.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains a value and its index.\n\n    Returns:\n        tuple: A tuple containing the index and minimum value of the tuple with the smallest value.\n    \"\"\"\n    # Check if the input list is empty\n    if not test_list:\n        return None\n\n    # Initialize the minimum value and its index with the first element of the list\n    min_value = test_list[0][0]\n    min_index = test_list[0][1]\n\n    # Iterate over the list of tuples\n    for i, (value, index) in enumerate(test_list):\n        # Check if the current value is smaller than the minimum value found so far\n        if value < min_value:\n            # Update the minimum value and its index\n            min_value = value\n            min_index = index\n\n    # Return the index and minimum value of the tuple with the smallest value\n    return (min_index, min_value)"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    \"\"\"\n    This function finds the minimum length of a sublist in a given list.\n    \n    Parameters:\n    lst (list): The input list.\n    \n    Returns:\n    int: The minimum length of a sublist.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = float('inf')\n    \n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            min_length = min(min_length, len(sublist))\n    \n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    \"\"\"\n    This function calculates the frequency count of each sublist in a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        dict: A dictionary where keys are sublists and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store frequency count\n    freq_count = {}\n\n    # Iterate over each sublist in the given list\n    for sublist in list1:\n        # Convert the sublist to a tuple (because lists are not hashable) and use it as a key\n        # If the key already exists, increment its value; otherwise, set its value to 1\n        freq_count[tuple(sublist)] = freq_count.get(tuple(sublist), 0) + 1\n\n    # Return the frequency count dictionary\n    return freq_count"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    \"\"\"\n    This function multiplies all the numbers in a list and divides the result by the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of the multiplication and division.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n\n    # Initialize the product variable to 1\n    product = 1\n\n    # Iterate over each number in the list\n    for num in numbers:\n        # Multiply the current product by the current number\n        product *= num\n\n    # Calculate the result by dividing the product by the length of the list\n    result = product / len(numbers)\n\n    # Return the result\n    return result"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    \"\"\"\n    This function converts a decimal number to its binary equivalent.\n\n    Args:\n        n (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary equivalent of the given decimal number.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Convert the decimal number to binary using the built-in bin() function\n    binary = bin(n)[2:]\n\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    \"\"\"\n    This function finds the kth element in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The position of the element to be found.\n\n    Returns:\n    int: The kth element in the array.\n\n    Raises:\n    ValueError: If k is larger than the array size.\n    \"\"\"\n\n    # Check if k is within the valid range\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of range\")\n\n    # Since Python uses 0-based indexing, subtract 1 from k\n    k -= 1\n\n    # Return the kth element\n    return arr[k]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    \"\"\"\n    Convert snake case string to camel case string.\n\n    Args:\n        word (str): The input string in snake case.\n\n    Returns:\n        str: The output string in camel case.\n    \"\"\"\n    words = word.split('_')\n    return words[0] + ''.join(word.capitalize() for word in words[1:])"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    m (int): The number of elements to select.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    if m > n:\n        return 0\n    if m == 0 or m == n:\n        return 1\n\n    # Initialize the matrix\n    matrix = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Fill the matrix\n    for i in range(1, n + 1):\n        for j in range(1, min(i + 1, m + 1)):\n            if j == 1 or j == i:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = matrix[i - 1][j - 1] + matrix[i - 1][j]\n\n    # Return the Eulerian number\n    return matrix[n][m]"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    return sorted(input_list, key=lambda x: [i.lower() for i in x])"}
{"id": "94_0", "code": "def count(lst):\n    \"\"\"\n    Counts the number of true booleans in a given list.\n\n    Args:\n        lst (list): A list containing boolean values.\n\n    Returns:\n        int: The number of true booleans in the list.\n    \"\"\"\n    return sum(1 for bool_val in lst if bool_val)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    \"\"\"\n    This function adds the given list to the given tuple.\n    \n    Args:\n        test_list (list): The list to be added to the tuple.\n        test_tup (tuple): The tuple to which the list will be added.\n    \n    Returns:\n        tuple: A new tuple containing the original tuple and the list.\n    \"\"\"\n    # Convert the tuple to a list to make it mutable\n    test_list = list(test_tup)\n    \n    # Add the list to the tuple\n    test_list.extend(test_list)\n    \n    # Convert the list back to a tuple\n    test_list = tuple(test_list)\n    \n    # Return the new tuple\n    return test_list"}
{"id": "96_0", "code": "def count_Hexadecimal(L,R):\n    \"\"\"\n    This function counts the number of hexadecimal numbers in a given range.\n    \n    Parameters:\n    L (int): The lower bound of the range (inclusive).\n    R (int): The upper bound of the range (inclusive).\n    \n    Returns:\n    int: The number of hexadecimal numbers in the range [L, R].\n    \"\"\"\n    count = 0\n    for i in range(L, R + 1):\n        # Convert the number to hexadecimal and check if it's a hexadecimal number\n        hex_str = hex(i)[2:]  # Remove the '0x' prefix\n        if all(c in '0123456789abcdefABCDEF' for c in hex_str):\n            count += 1\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a min heap to store the elements from the input lists\n    min_heap = []\n    # Push the first element from each list into the heap\n    heapq.heappush(min_heap, (num1[0], 0, 'num1'))  # (value, list_index, list_name)\n    heapq.heappush(min_heap, (num2[0], 0, 'num2'))\n    heapq.heappush(min_heap, (num3[0], 0, 'num3'))\n\n    # Create a generator to yield the sorted elements\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, idx, lst = heapq.heappop(min_heap)\n        # Yield the smallest element\n        yield val\n        # If there are more elements in the list, push the next element into the heap\n        if idx + 1 < len(lst):\n            heapq.heappush(min_heap, (lst[idx + 1], idx + 1, lst))\n\n# Example usage:\nlist1 = [1, 3, 5, 7]\nlist2 = [2, 4, 6, 8]\nlist3 = [0, 9, 10, 11]\n\nmerged_list = merge_sorted_list(list1, list2, list3)\nfor val in merged_list:\n    print(val)"}
{"id": "98_0", "code": "def odd_Equivalent(s,n):\n    # Convert the binary string to an integer\n    num = int(s, 2)\n    \n    # Perform the rotation\n    rotated_num = (num << n) | (num >> (len(s) - n))\n    \n    # Check if the rotated number has an odd value\n    if rotated_num % 2 == 1:\n        return 1\n    else:\n        return 0"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    # Convert the input list to a set for efficient lookups\n    test_set = set(test_list)\n    \n    # Initialize an empty list to store the missing ranges\n    missing_ranges = []\n    \n    # Iterate over the range from strt_val to stop_val (inclusive)\n    for i in range(strt_val, stop_val + 1):\n        # Check if the current number is not in the test set\n        if i not in test_set:\n            # If it's not in the test set, append the range to the missing_ranges list\n            missing_ranges.append((i, i))\n    \n    # Return the list of missing ranges\n    return missing_ranges"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Flatten the nested list\n    flat_list = flatten(nestedlist)\n    \n    # Find common elements with the first sublist\n    common = set(flat_list).intersection(set(flat_list[0]))\n    \n    return list(common)"}
{"id": "101_0", "code": "import math\n\ndef perimeter(diameter, height):\n    \"\"\"\n    Calculate the perimeter of a cylinder.\n\n    Parameters:\n    diameter (float): The diameter of the cylinder's base.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The perimeter of the cylinder.\n    \"\"\"\n    # Calculate the radius from the diameter\n    radius = diameter / 2\n    \n    # Calculate the circumference of the base\n    base_circumference = 2 * math.pi * radius\n    \n    # Calculate the lateral surface area of the cylinder\n    lateral_surface_area = 2 * math.pi * radius * height\n    \n    # Calculate the total perimeter of the cylinder\n    total_perimeter = base_circumference + lateral_surface_area\n    \n    return total_perimeter"}
{"id": "102_0", "code": "def check_integer(text):\n    \"\"\"\n    Checks if a given string represents an integer or not.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        # Attempt to convert the string to an integer\n        int(text)\n        # If successful, return True\n        return True\n    except ValueError:\n        # If a ValueError is raised, the string does not represent an integer\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    \"\"\"\n    This function assigns frequency to each tuple in the given tuple list.\n    \n    Parameters:\n    test_list (list): A list of tuples.\n    \n    Returns:\n    dict: A dictionary where keys are tuples and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    \"\"\"\n    This function checks whether all dictionaries in a list are empty or not.\n\n    Args:\n        list1 (list): A list of dictionaries.\n\n    Returns:\n        bool: True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(list1, list):\n        raise ValueError(\"Input must be a list\")\n\n    # Check if all elements in the list are dictionaries\n    if not all(isinstance(item, dict) for item in list1):\n        raise ValueError(\"All elements in the list must be dictionaries\")\n\n    # Check if all dictionaries in the list are empty\n    return all(len(item) == 0 for item in list1)"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    \"\"\"\n    Converts a tuple of positive integers into an integer.\n\n    Args:\n        nums (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The integer equivalent of the tuple.\n\n    Raises:\n        ValueError: If the tuple contains non-positive integers or non-integer values.\n    \"\"\"\n    # Check if all elements in the tuple are integers\n    if not all(isinstance(num, int) for num in nums):\n        raise ValueError(\"The tuple must only contain integers.\")\n\n    # Check if all elements in the tuple are positive\n    if not all(num > 0 for num in nums):\n        raise ValueError(\"The tuple must only contain positive integers.\")\n\n    # Convert the tuple to a string\n    num_str = ''.join(map(str, nums))\n\n    # Convert the string to an integer\n    result = int(num_str)\n\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    \"\"\"\n    This function takes a list as input, identifies all possible convertible elements \n    (i.e., strings that can be converted to float), and converts them to float.\n\n    Args:\n        test_list (list): A list containing elements that can be converted to float.\n\n    Returns:\n        list: The input list with all convertible elements converted to float.\n    \"\"\"\n    # Initialize an empty list to store the converted elements\n    converted_list = []\n\n    # Iterate over each element in the input list\n    for element in test_list:\n        # Check if the element is a string\n        if isinstance(element, str):\n            # Try to convert the string to float\n            try:\n                # Append the converted float to the converted list\n                converted_list.append(float(element))\n            except ValueError:\n                # If the string cannot be converted to float, append the original string\n                converted_list.append(element)\n        else:\n            # If the element is not a string, append it to the converted list as is\n            converted_list.append(element)\n\n    # Return the converted list\n    return converted_list"}
{"id": "107_0", "code": "def string_to_list(string):\n    \"\"\"\n    Converts a string into a list of characters.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        list: A list of characters from the input string.\n    \"\"\"\n    return list(string)"}
{"id": "108_0", "code": "def search(arr,n):\n    # Initialize the result variable\n    res = -1\n    \n    # Iterate through the array\n    for i in range(n):\n        # If the current element is 1, update the result\n        if arr[i] == 1:\n            res = i\n            break\n    \n    # Return the result\n    return res"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    \"\"\"\n    This function finds the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        list1 (list): A list of tuples.\n\n    Returns:\n        int: The maximum product from the pairs of tuples.\n\n    Raises:\n        ValueError: If the input list is empty or contains less than two tuples.\n    \"\"\"\n    # Check if the input list is empty or contains less than two tuples\n    if len(list1) < 2:\n        raise ValueError(\"Input list must contain at least two tuples.\")\n\n    # Initialize the maximum product with the product of the first two tuples\n    max_product = list1[0][0] * list1[0][1]\n\n    # Iterate over the list of tuples in steps of 2\n    for i in range(0, len(list1), 2):\n        # Calculate the product of the current pair of tuples\n        product = list1[i][0] * list1[i][1]\n\n        # Update the maximum product if the current product is greater\n        if product > max_product:\n            max_product = product\n\n    # Return the maximum product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    for i in range(n-2):\n        # Initialize two pointers\n        left = i + 1\n        right = n - 1\n        while left < right:\n            # Calculate the sum of the current triplet\n            current_sum = A[i] + A[left] + A[right]\n            # If the sum is equal to the given sum, increment the count and move the pointers\n            if current_sum == sum:\n                count[0] += 1\n                left += 1\n                right -= 1\n            # If the sum is less than the given sum, move the left pointer to increase the sum\n            elif current_sum < sum:\n                left += 1\n            # If the sum is greater than the given sum, move the right pointer to decrease the sum\n            else:\n                right -= 1\n    return count[0]"}
{"id": "111_0", "code": "def smartNumber(n):\n    \"\"\"\n    This function generates the nth smart number.\n    \n    A smart number is a number that is the sum of its proper divisors, excluding the number itself.\n    \n    Parameters:\n    n (int): The position of the smart number to be generated.\n    \n    Returns:\n    int: The nth smart number.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Helper function to check if a number is prime.\n        \n        Parameters:\n        num (int): The number to be checked.\n        \n        Returns:\n        bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def get_divisors(num):\n        \"\"\"\n        Helper function to get the proper divisors of a number.\n        \n        Parameters:\n        num (int): The number for which the divisors are to be found.\n        \n        Returns:\n        list: A list of proper divisors of the number.\n        \"\"\"\n        divisors = []\n        for i in range(1, num):\n            if num % i == 0:\n                divisors.append(i)\n        return divisors\n\n    smart_nums = []\n    num = 1\n    while len(smart_nums) < n:\n        num += 1\n        if num not in smart_nums and num > 1:\n            if sum(get_divisors(num)) == num:\n                smart_nums.append(num)\n\n    return smart_nums[-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    \"\"\"\n    This function calculates the sum of all amicable numbers from 1 to a specified limit.\n    \n    Args:\n        limit (int): The upper limit for the amicable numbers.\n    \n    Returns:\n        int: The sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    \n    # Initialize a dictionary to store the sum of amicable numbers for each number\n    amicable_sums = {}\n    \n    # Iterate over all numbers from 1 to the limit\n    for num in range(1, limit + 1):\n        # Calculate the sum of the proper divisors of the current number\n        sum_of_divisors = sum(i for i in range(1, num) if num % i == 0)\n        \n        # Check if the sum of the proper divisors is within the limit and not equal to the current number\n        if sum_of_divisors <= limit and sum_of_divisors != num:\n            # Store the sum of the proper divisors in the dictionary\n            amicable_sums[num] = sum_of_divisors\n            \n            # Check if the sum of the proper divisors is within the limit and not equal to the current number\n            if sum_of_divisors <= limit and sum_of_divisors != num:\n                # Calculate the sum of the proper divisors of the sum of the proper divisors\n                sum_of_divisors_of_sum = sum(i for i in range(1, sum_of_divisors) if sum_of_divisors % i == 0)\n                \n                # Check if the sum of the proper divisors of the sum of the proper divisors is equal to the current number\n                if sum_of_divisors_of_sum == num:\n                    # Add the current number to the sum of amicable numbers\n                    amicable_sums[num] += num\n    \n    # Return the sum of all amicable numbers\n    return sum(amicable_sums.values())"}
{"id": "113_0", "code": "import math\n\ndef angle_complex(a,b):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    # Calculate the angle using the atan2 function\n    angle = math.atan2(b, a)\n    \n    # Return the angle\n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    for char in string:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        max_diff = max(max_diff, abs(count_0 - count_1))\n    return max_diff"}
{"id": "115_0", "code": "def sum(a,b):\n    def gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n\n    return sum(common_divisors)"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    \"\"\"\n    Multiply two integers without using the * operator.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        int: The product of x and y.\n    \"\"\"\n    # Handle edge cases\n    if x == 0 or y == 0:\n        return 0\n\n    # Determine the sign of the result\n    sign = -1 if (x < 0) ^ (y < 0) else 1\n\n    # Convert both numbers to positive\n    x, y = abs(x), abs(y)\n\n    # Initialize the result\n    result = 0\n\n    # Multiply using bit shifting\n    while y > 0:\n        # If y is odd, add x to the result\n        if y & 1:\n            result += x\n\n        # Shift x to the left (multiply by 2)\n        x <<= 1\n\n        # Shift y to the right (divide by 2)\n        y >>= 1\n\n    # Apply the sign\n    result *= sign\n\n    return result"}
{"id": "117_0", "code": "def long_words(n, string):\n    \"\"\"\n    This function shortlists words that are longer than n from a given list of words.\n\n    Parameters:\n    n (int): The minimum length of words to be shortlisted.\n    string (str): The input string containing a list of words separated by spaces.\n\n    Returns:\n    list: A list of words that are longer than n.\n    \"\"\"\n    # Split the input string into a list of words\n    words = string.split()\n\n    # Initialize an empty list to store the shortlisted words\n    shortlisted_words = []\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If the word is longer than n, add it to the shortlisted words list\n            shortlisted_words.append(word)\n\n    # Return the list of shortlisted words\n    return shortlisted_words"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the input matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return \"Error: Input matrix is not a square matrix.\"\n\n    # Check if the input matrix is a magic square\n    if not is_magic_square(my_matrix):\n        return \"Error: Input matrix is not a magic square.\"\n\n    # Calculate the magic constant\n    magic_constant = calculate_magic_constant(my_matrix)\n\n    # Print the magic square\n    print(\"Magic Square:\")\n    for row in my_matrix:\n        print(row)\n\n    # Print the magic constant\n    print(\"Magic Constant:\", magic_constant)\n\n\ndef is_magic_square(my_matrix):\n    # Check if the matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Calculate the sum of the first row\n    target_sum = sum(my_matrix[0])\n\n    # Check if the sum of each row is equal to the target sum\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Calculate the sum of the first column\n    target_sum = sum(my_matrix[0])\n\n    # Check if the sum of each column is equal to the target sum\n    for col in range(len(my_matrix)):\n        if sum([my_matrix[row][col] for row in range(len(my_matrix))]) != target_sum:\n            return False\n\n    # Check if the sum of the main diagonal is equal to the target sum\n    target_sum = sum([my_matrix[i][i] for i in range(len(my_matrix))])\n    if target_sum != target_size(my_matrix):\n        return False\n\n    # Check if the sum of the anti-diagonal is equal to the target sum\n    target_sum = sum([my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))])\n    if target_sum != target_size(my_matrix):\n        return False\n\n    # If all checks pass, the matrix is a magic square\n    return True\n\n\ndef calculate_magic_constant(my_matrix):\n    # Calculate the size of the matrix\n    size = len(my_matrix)\n\n    # Calculate the magic constant\n    magic_constant = size * (size ** 2 + 1) // 2\n\n    return magic_constant\n\n\ndef target_size(my_matrix):\n    # Calculate the size of the matrix\n    size = len(my_matrix)\n\n    # Calculate the target sum\n    target_sum = size * (size ** 2 + 1) // 2\n\n    return target_sum"}
{"id": "119_0", "code": "from collections import Counter\n\ndef max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum frequency in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum frequency in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Count the frequency of each item in the list\n    freq = Counter(nums)\n\n    # Find the item with maximum frequency\n    max_freq_item = max(freq, key=freq.get)\n\n    return max_freq_item"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    \"\"\"\n    This function converts a tuple into a string.\n\n    Args:\n        tup1 (tuple): The input tuple to be converted.\n\n    Returns:\n        str: A string representation of the input tuple.\n    \"\"\"\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(filter(lambda x: x<0, nums))"}
{"id": "123_0", "code": "def check_last(arr,n,p):\n    # Perform operation p times\n    for _ in range(p):\n        arr = arr[-1] % arr[0]\n    \n    # Check if the last element is even or odd\n    if arr[-1] % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "124_0", "code": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    Args:\n    n (int): The position of the hexagonal number to calculate.\n\n    Returns:\n    int: The nth hexagonal number.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n\n    # The formula for the nth hexagonal number is given by: \n    # Hn = n * (2n - 1)\n    # We use this formula to calculate the nth hexagonal number.\n    return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    # Electricity charges per unit in Rs.\n    charge_per_unit = 2.0\n    \n    # Base charge for 50 units or less\n    base_charge = 50 * charge_per_unit\n    \n    # Additional charge for units more than 50\n    additional_charge = (units - 50) * charge_per_unit\n    \n    # Total charge\n    total_charge = base_charge + additional_charge\n    \n    # Tax (8% of total charge)\n    tax = total_charge * 0.08\n    \n    # Total bill\n    total_bill = total_charge + tax\n    \n    return total_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    \"\"\"\n    This function calculates the ratio of zeroes in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of zeroes in the list.\n\n    Raises:\n        ZeroDivisionError: If the input list is empty.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        raise ZeroDivisionError(\"Cannot calculate ratio of zeroes for an empty list\")\n\n    # Count the number of zeroes in the list\n    zero_count = nums.count(0)\n\n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n\n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize a variable to store the count of consecutive 1's\n    count = 0\n    \n    # Iterate over the binary representation\n    for digit in bin_n:\n        # If the digit is '1', increment the count\n        if digit == '1':\n            count += 1\n        # If the digit is '0' and the count is greater than 0, reset the count\n        elif count > 0:\n            count = 0\n    \n    # If the count is greater than 0, it means there are consecutive 1's, so return False\n    # Otherwise, return True\n    return count == 0"}
{"id": "128_0", "code": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    # Use the math library to calculate the circumference\n    # The formula for the circumference of a circle is 2 * pi * r\n    circumference = 2 * math.pi * r\n    return circumference"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list of tuples where each tuple contains elements that occur singly in the input list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples where each tuple contains elements that occur singly in the input list.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of each element\n    freq_dict = {}\n\n    # Iterate over each tuple in the input list\n    for tup in test_list:\n        # Iterate over each element in the tuple\n        for elem in tup:\n            # If the element is already in the dictionary, increment its count\n            if elem in freq_dict:\n                freq_dict[elem] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                freq_dict[elem] = 1\n\n    # Initialize an empty list to store the tuples with singly occurring elements\n    singly_occuring = []\n\n    # Iterate over each tuple in the input list again\n    for tup in test_list:\n        # Initialize an empty list to store the elements of the current tuple that occur singly\n        singly_occuring_tuple = []\n        # Iterate over each element in the tuple\n        for elem in tup:\n            # If the element occurs singly, add it to the list of singly occurring elements\n            if freq_dict[elem] == 1:\n                singly_occuring_tuple.append(elem)\n        # If the tuple has any elements that occur singly, add it to the list of singly occurring tuples\n        if singly_occuring_tuple:\n            singly_occuring.append(singly_occuring_tuple)\n\n    # Return the list of tuples with singly occurring elements\n    return singly_occuring"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    \"\"\"\n    Sorts a list of elements using pancake sort algorithm.\n\n    Args:\n        nums (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers.\n    \"\"\"\n    # Create a copy of the input list to avoid modifying it in-place\n    nums_copy = nums.copy()\n\n    # Iterate over the list from the end to the beginning\n    for size in range(len(nums_copy), 0, -1):\n        # Find the maximum element in the unsorted part of the list\n        max_idx = nums_copy.index(max(nums_copy[:size]))\n\n        # If the maximum element is not at the end of the unsorted part, flip it to the end\n        if max_idx != size - 1:\n            # Flip the maximum element to the end of the unsorted part\n            nums_copy[:max_idx + 1] = reversed(nums_copy[:max_idx + 1])\n\n            # Flip the maximum element to the beginning of the unsorted part\n            nums_copy[:size] = reversed(nums_copy[:size])\n\n    return nums_copy"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(list1)\n    set2 = set(list2)\n    set3 = set(list3)\n\n    # Initialize a counter for the same pairs\n    same_pairs = 0\n\n    # Iterate over the elements in the first set\n    for elem in set1:\n        # Check if the element is also in the second and third sets\n        if elem in set2 and elem in set3:\n            # If it is, increment the counter\n            same_pairs += 1\n\n    # Return the count of same pairs\n    return same_pairs"}
{"id": "132_0", "code": "def find_lists(Input):\n    \"\"\"\n    This function takes a tuple as input and returns the number of lists present in the tuple.\n\n    Args:\n        Input (tuple): A tuple containing lists.\n\n    Returns:\n        int: The number of lists present in the tuple.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr,n):\n    # Calculate the sum of absolute differences in all pairs of the given array\n    total_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    \"\"\"\n    This function calculates the maximum absolute difference between any two elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Initialize minimum and maximum values with the first element of the array\n    min_val = arr[0]\n    max_val = arr[0]\n\n    # Iterate through the array to find the minimum and maximum values\n    for i in range(1, n):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    # Calculate the maximum absolute difference\n    max_diff = max_val - min_val\n\n    return max_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    \"\"\"\n    This function calculates the total ASCII value of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total ASCII value of characters in the string.\n    \"\"\"\n    # Initialize a variable to store the total ASCII value\n    total_ascii = 0\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Add the ASCII value of the current character to the total\n        total_ascii += ord(char)\n    \n    # Return the total ASCII value\n    return total_ascii"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Create a 2D array to store the maximum path sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = tri[i][0]\n    for j in range(n):\n        dp[0][j] = tri[0][j]\n    \n    # Fill up the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum path sum at position (i, j) is the maximum of the path sum\n            # from the top, left, and top-left, plus the value at position (i, j)\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + tri[i][j]\n    \n    # The maximum total path sum is stored in the bottom-right corner of the dp array\n    return dp[m-1][n-1]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    def sum_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    max_sum = 0\n    for i in range(1, N):\n        for j in range(i+1, N+1):\n            total_sum = sum_digits(i) + sum_digits(j)\n            if total_sum > max_sum:\n                max_sum = total_sum\n                max_i = i\n                max_j = j\n\n    return max_i, max_j"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    if n < 3:\n        return n\n\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = 1\n            for k in range(i, j):\n                if abs(arr[k] - arr[k + 1]) == 1:\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, dp[i][i] + 1)\n\n    return max_length"}
{"id": "139_0", "code": "def does_Contain_B(a,b,c):\n    \"\"\"\n    Checks if the given number is present in the infinite sequence.\n    \n    Parameters:\n    a (int): The first number in the sequence.\n    b (int): The second number in the sequence.\n    c (int): The third number in the sequence.\n    \n    Returns:\n    bool: True if the number is present in the sequence, False otherwise.\n    \"\"\"\n    # Calculate the common difference of the sequence\n    d = (b - a) / (c - b)\n    \n    # Calculate the nth term of the sequence\n    def nth_term(n):\n        return a + n * d\n    \n    # Check if the given number is present in the sequence\n    return nth_term(a) == b or nth_term(b) == c or nth_term(c) == a"}
{"id": "140_0", "code": "import math\n\ndef is_coprime(x,y):\n    \"\"\"\n    Checks whether two numbers are co-prime or not.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        bool: True if the numbers are co-prime, False otherwise.\n    \"\"\"\n    # Check if both numbers are integers\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both numbers must be integers\")\n\n    # Check if both numbers are positive\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both numbers must be positive\")\n\n    # Calculate the greatest common divisor (GCD) of the two numbers\n    gcd = math.gcd(x, y)\n\n    # If the GCD is 1, the numbers are co-prime\n    return gcd == 1"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) <= 1:\n        return x\n    mid = len(x) // 2\n    left_half = merge_sort(x[:mid])\n    right_half = merge_sort(x[mid:])\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    merged += left[left_index:]\n    merged += right[right_index:]\n    return merged"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculate the vertex of a parabola given its coefficients a, b, and c.\n    \n    Parameters:\n    a (float): The coefficient of the squared term in the parabola equation.\n    b (float): The coefficient of the linear term in the parabola equation.\n    c (float): The constant term in the parabola equation.\n    \n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the vertex.\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"The parabola is not a quadratic equation.\")\n    \n    x_vertex = -b / (2 * a)\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extracts every specified element from a given two dimensional list.\n\n    Args:\n        nums (list): A two dimensional list of integers.\n        N (int): The index of the element to be extracted.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    extracted_elements = []\n    for row in nums:\n        if N < len(row):\n            extracted_elements.append(row[N])\n    return extracted_elements"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    # Convert the number to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in bin_n:\n        # If the character is '0', toggle it to '1'\n        if char == '0':\n            result += '1'\n        # If the character is '1', toggle it to '0'\n        elif char == '1':\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    \"\"\"\n    This function takes a tuple of string values as input and returns a tuple of integer values.\n    \n    Parameters:\n    tuple_str (tuple): A tuple of string values.\n    \n    Returns:\n    tuple: A tuple of integer values.\n    \"\"\"\n    return tuple(int(value) for value in tuple_str)"}
{"id": "146_0", "code": "def encode_list(list1):\n    \"\"\"\n    This function takes a list as input and returns a string representing the run-length encoding of the input list.\n    \n    Args:\n        list1 (list): The input list to be encoded.\n    \n    Returns:\n        str: A string representing the run-length encoding of the input list.\n    \"\"\"\n    # Initialize an empty string to store the encoded result\n    encoded_str = \"\"\n    \n    # Initialize variables to keep track of the current character and its count\n    current_char = list1[0]\n    current_count = 1\n    \n    # Iterate over the input list starting from the second element\n    for char in list1[1:]:\n        # If the current character is the same as the previous one, increment the count\n        if char == current_char:\n            current_count += 1\n        # If the current character is different from the previous one, append the previous character and its count to the encoded string, and reset the count\n        else:\n            encoded_str += current_char + str(current_count)\n            current_char = char\n            current_count = 1\n    \n    # Append the last character and its count to the encoded string\n    encoded_str += current_char + str(current_count)\n    \n    return encoded_str"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    \"\"\"\n    This function calculates the minimum number of operations required to make all elements in the array equal.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The size of the input list.\n    k (int): The number of operations that can be performed.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    \n    # First, we sort the array in ascending order\n    arr.sort()\n    \n    # We calculate the median of the array, which will be the target value\n    median = arr[n // 2] if n % 2 != 0 else (arr[n // 2 - 1] + arr[n // 2]) / 2\n    \n    # We initialize a variable to store the total number of operations\n    total_ops = 0\n    \n    # We iterate over each element in the array\n    for num in arr:\n        # We calculate the absolute difference between the current number and the median\n        # This difference represents the number of operations required to make the current number equal to the median\n        ops = abs(num - median)\n        \n        # We add the number of operations to the total\n        total_ops += ops\n        \n        # If the total number of operations exceeds k, we return -1\n        if total_ops > k:\n            return -1\n    \n    # Finally, we return the total number of operations\n    return total_ops"}
{"id": "148_0", "code": "def month_season(month,days):\n    if month in [12,1,2]:\n        if days in [31,28,31]:\n            print(\"Winter\")\n        elif days in [31,29]:\n            print(\"Winter\")\n        elif days in [30,31]:\n            print(\"Winter\")\n    elif month in [3,4,5]:\n        if days in [31,30,31]:\n            print(\"Spring\")\n        elif days in [30,31]:\n            print(\"Spring\")\n        elif days in [31,30]:\n            print(\"Spring\")\n    elif month in [6,7,8]:\n        if days in [31,30,31]:\n            print(\"Summer\")\n        elif days in [30,31]:\n            print(\"Summer\")\n        elif days in [31,30]:\n            print(\"Summer\")\n    elif month in [9,10,11]:\n        if days in [31,30,31]:\n            print(\"Autumn\")\n        elif days in [30,31]:\n            print(\"Autumn\")\n        elif days in [31,30]:\n            print(\"Autumn\")\n    else:\n        print(\"Invalid month or day\")"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Calculate the gcd of a and b\n    gcd = gcd_helper(a, b)\n    \n    # If gcd is not 1, then there is no solution\n    if gcd != 1:\n        return None\n    \n    # Calculate the coefficients x and y\n    x = (n * pow(b, -1, gcd)) % gcd\n    y = (n * pow(a, -1, gcd)) % gcd\n    \n    return x, y\n\ndef gcd_helper(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    \"\"\"\n    Removes all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The list from which elements will be removed.\n        list2 (list): The list containing elements to be removed.\n\n    Returns:\n        list: The modified list1 with elements from list2 removed.\n    \"\"\"\n    # Convert list2 to a set for efficient lookups\n    set2 = set(list2)\n    \n    # Use a list comprehension to filter out elements in list1 that are in set2\n    return [element for element in list1 if element not in set2]"}
{"id": "151_0", "code": "def sum_series(n):\n    \"\"\"\n    This function calculates the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).\n    \n    Parameters:\n    n (int): The starting number of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize the x variable to 2 (since we start from n-2)\n    x = 2\n    \n    # Continue the loop until n-x is less than or equal to 0\n    while n - x >= 0:\n        # Add the current number to the total sum\n        total_sum += n - x\n        \n        # Decrement x by 2 (since we are adding n-x)\n        x += 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "152_0", "code": "import math\n\ndef area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (float): The length of one side of the polygon.\n    l (float): The number of sides of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the number of sides is valid\n    if l < 3:\n        raise ValueError(\"A polygon must have at least 3 sides\")\n\n    # Calculate the area using the formula: (n * s^2) / (4 * tan(/n))\n    area = (l * s**2) / (4 * math.tan(math.pi/l))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    \"\"\"\n    This function checks whether the sum of divisors of two numbers are same or not.\n    \n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n    \n    Returns:\n    bool: True if the sum of divisors of num1 and num2 are same, False otherwise.\n    \"\"\"\n    \n    # Function to calculate the sum of divisors of a number\n    def sum_of_divisors(n):\n        sum_divisors = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                sum_divisors += i\n                if i != n // i:  # Check if i is not the square root of n\n                    sum_divisors += n // i\n        return sum_divisors\n    \n    # Calculate the sum of divisors for both numbers\n    sum_divisors_num1 = sum_of_divisors(num1)\n    sum_divisors_num2 = sum_of_divisors(num2)\n    \n    # Return True if the sums are equal, False otherwise\n    return sum_divisors_num1 == sum_divisors_num2"}
{"id": "154_0", "code": "def count_char_position(str1):\n    \"\"\"\n    This function counts the characters at the same position in a given string \n    (lower and uppercase characters) as in English alphabet.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are the characters and values are their counts.\n    \"\"\"\n    # Initialize an empty dictionary to store the character counts\n    char_count = {}\n\n    # Iterate over the string\n    for char in str1:\n        # Check if the character is an alphabet\n        if char.isalpha():\n            # Convert the character to lowercase for comparison\n            lower_char = char.lower()\n            # Check if the character is already in the dictionary\n            if lower_char in char_count:\n                # If it is, increment its count\n                char_count[lower_char] += 1\n            else:\n                # If it's not, add it to the dictionary with a count of 1\n                char_count[lower_char] = 1\n\n    # Return the dictionary\n    return char_count"}
{"id": "155_0", "code": "def find_even_Pair(A,N):\n    count = 0\n    for i in range(N):\n        for j in range(i+1,N):\n            if (A[i]^A[j])%2 == 0:\n                count += 1\n    return count"}
{"id": "156_0", "code": "import math\n\ndef next_Power_Of_2(n):\n    \"\"\"\n    This function returns the smallest power of 2 that is greater than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The smallest power of 2 that is greater than or equal to n.\n    \"\"\"\n    # Calculate the base-2 logarithm of n\n    log_n = math.log2(n)\n    \n    # If n is a power of 2, return n\n    if log_n.is_integer():\n        return n\n    \n    # Calculate the smallest power of 2 greater than n\n    return 2 ** math.ceil(log_n)"}
{"id": "157_0", "code": "def frequency(a,x):\n    \"\"\"\n    This function calculates the frequency of a given number in a list.\n\n    Parameters:\n    a (list): The list of numbers to search in.\n    x (int): The number to search for.\n\n    Returns:\n    int: The frequency of the number in the list.\n    \"\"\"\n    # Initialize a counter variable to store the frequency\n    count = 0\n    \n    # Iterate over each element in the list\n    for num in a:\n        # Check if the current element is equal to the number we're searching for\n        if num == x:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the frequency\n    return count"}
{"id": "158_0", "code": "def get_pell(n):\n    \"\"\"\n    Calculate the nth Pell number.\n\n    Args:\n        n (int): The position of the Pell number to calculate.\n\n    Returns:\n        int: The nth Pell number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the first two Pell numbers\n    pell_0 = 0\n    pell_1 = 1\n\n    # Calculate the nth Pell number\n    for _ in range(2, n + 1):\n        pell_n = 2 * pell_0 + pell_1\n        pell_0 = pell_1\n        pell_1 = pell_n\n\n    return pell_n"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    \"\"\"\n    This function calculates the sum of the numbers in a list between the indices of a specified range.\n\n    Args:\n        list1 (list): The input list of numbers.\n        m (int): The starting index of the range (inclusive).\n        n (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of the numbers in the list between the specified range.\n\n    Raises:\n        TypeError: If the input list is not a list or if the indices are not integers.\n        IndexError: If the indices are out of range.\n    \"\"\"\n    # Check if the input list is a list and the indices are integers\n    if not isinstance(list1, list) or not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"Input list must be a list and indices must be integers.\")\n\n    # Check if the indices are within the range of the list\n    if m < 0 or n >= len(list1) or m > n:\n        raise IndexError(\"Indices out of range.\")\n\n    # Calculate the sum of the numbers in the list between the specified range\n    total_sum = sum(list1[m:n+1])\n\n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # Define the number of sides of a pentagon\n    n = 5\n    \n    # Calculate the perimeter using the formula: perimeter = n * side_length\n    perimeter = n * a\n    \n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    # Initialize a counter for the occurrence of 'std'\n    count = 0\n    # Iterate over the characters in the string\n    for char in s:\n        # Check if the character is 's', 't', or 'd'\n        if char in ['s', 't', 'd']:\n            # If the character is 's', 't', or 'd', increment the counter\n            count += 1\n    # Return the total count of 'std'\n    return count"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(char for char in text if char.isalnum())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    \"\"\"\n    This function groups a sequence of key-value pairs into a dictionary of lists.\n    \n    Parameters:\n    l (list): A list of tuples, where each tuple contains a key-value pair.\n    \n    Returns:\n    dict: A dictionary where each key is a unique key from the input list, and its corresponding value is a list of values that belong to that key.\n    \"\"\"\n    result = {}\n    for key, value in l:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result"}
{"id": "164_0", "code": "def is_valid_parenthese(str1):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in str1:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack"}
{"id": "165_0", "code": "def perimeter_triangle(a,b,c):\n    \"\"\"\n    This function calculates the perimeter of a triangle given the lengths of its sides.\n\n    Args:\n        a (float): The length of the first side of the triangle.\n        b (float): The length of the second side of the triangle.\n        c (float): The length of the third side of the triangle.\n\n    Returns:\n        float: The perimeter of the triangle.\n\n    Raises:\n        ValueError: If the sum of the lengths of any two sides is not greater than the length of the third side.\n    \"\"\"\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        raise ValueError(\"The given sides cannot form a triangle.\")\n\n    # Calculate the perimeter\n    perimeter = a + b + c\n\n    return perimeter"}
{"id": "166_0", "code": "import math\n\ndef answer(L, R):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            if lcm(i, j) <= R:\n                return (i, j)\n    return None"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for literals in a given text.\n\n    Args:\n        patterns (list): A list of literals to search for.\n        text (str): The text to search in.\n\n    Returns:\n        dict: A dictionary with the literals as keys and their indices as values.\n    \"\"\"\n    result = {}\n    for pattern in patterns:\n        index = text.find(pattern)\n        while index != -1:\n            result[pattern] = index\n            index = text.find(pattern, index + 1)\n    return result"}
{"id": "168_0", "code": "def is_num_keith(x):\n    \"\"\"\n    Checks if a given number is a Keith number.\n\n    A Keith number is a number that can be expressed as the sum of consecutive integers,\n    starting from 1, until the sum is greater than or equal to the given number.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Keith number, False otherwise.\n    \"\"\"\n    total = 0\n    i = 1\n    while total < x:\n        total += i\n        i += 1\n    return total >= x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Radius of the Earth in kilometers\n    R = 6371.0\n\n    # Convert degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n\n    # Differences in coordinates\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n\n    # Haversine formula\n    a = math.sin(dlat / 2)**2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Distance\n    distance = R * c\n\n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    \"\"\"\n    This function finds the longest common prefix in the given set of strings.\n\n    Parameters:\n    arr (list): A list of strings\n    n (int): The number of strings in the list\n\n    Returns:\n    str: The longest common prefix\n    \"\"\"\n    if not arr or n == 0:\n        return \"\"\n\n    # Sort the list of strings\n    arr.sort()\n\n    # Compare the first and last string in the sorted list\n    first_str = arr[0]\n    last_str = arr[n-1]\n\n    i = 0\n    while i < len(first_str) and i < len(last_str) and first_str[i] == last_str[i]:\n        i += 1\n\n    # Return the common prefix\n    return first_str[:i]"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    \"\"\"\n    This function takes a string as input and returns a dictionary containing \n    the count of uppercase, lowercase, special characters and numeric values.\n\n    Args:\n        string (str): The input string to be analyzed.\n\n    Returns:\n        dict: A dictionary containing the count of uppercase, lowercase, special \n        characters and numeric values.\n    \"\"\"\n\n    # Initialize a dictionary to store the count of each type of character\n    character_count = {\n        'uppercase': 0,\n        'lowercase': 0,\n        'special': 0,\n        'numeric': 0\n    }\n\n    # Use regex to find uppercase characters\n    uppercase_count = len(re.findall(r'[A-Z]', string))\n    character_count['uppercase'] = uppercase_count\n\n    # Use regex to find lowercase characters\n    lowercase_count = len(re.findall(r'[a-z]', string))\n    character_count['lowercase'] = lowercase_count\n\n    # Use regex to find special characters\n    special_count = len(re.findall(r'[^A-Za-z0-9]', string))\n    character_count['special'] = special_count\n\n    # Use regex to find numeric characters\n    numeric_count = len(re.findall(r'\\d', string))\n    character_count['numeric'] = numeric_count\n\n    return character_count\n\n# Example usage:\nstring = \"Hello, World! 123\"\nresult = find_character(string)\nprint(result)"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a hashmap to store the frequency of each element\n    freq_map = {}\n    for num in arr:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Traverse the array to find pairs with difference k\n    for num in arr:\n        # Check if the number plus k exists in the hashmap\n        if num + k in freq_map:\n            # If it exists, add the product of their frequencies to the count\n            count += freq_map[num + k] * freq_map[num]\n\n        # Check if the number minus k exists in the hashmap\n        if num - k in freq_map:\n            # If it exists, add the product of their frequencies to the count\n            count += freq_map[num - k] * freq_map[num]\n\n    # Divide the count by 2 to avoid counting each pair twice\n    return count // 2"}
{"id": "173_0", "code": "def greater_specificnum(lst, num):\n    \"\"\"\n    This function finds all the values in a list that are greater than a specified number.\n\n    Args:\n        lst (list): The input list of numbers.\n        num (int): The specified number.\n\n    Returns:\n        list: A list of numbers from the input list that are greater than the specified number.\n    \"\"\"\n    return [i for i in lst if i > num]"}
{"id": "174_0", "code": "import math\n\ndef parabola_focus(a, b, c):\n    \"\"\"\n    Calculate the focus of a parabola given its equation in the form ax^2 + bx + c = 0.\n\n    Parameters:\n    a (float): The coefficient of the squared term.\n    b (float): The coefficient of the linear term.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the focus.\n    \"\"\"\n    # Calculate the focal length\n    focal_length = math.sqrt(a**2 / (4 * (a * a - b**2)))\n\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n\n    # Calculate the y-coordinate of the focus\n    y_focus = c - (a * x_focus**2)\n\n    return (x_focus, y_focus)"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    \"\"\"\n    Searches for literals in a given text using regex.\n\n    Args:\n        text (str): The text to search in.\n        patterns (list): A list of literals to search for.\n\n    Returns:\n        dict: A dictionary with the literals found in the text and their positions.\n    \"\"\"\n    result = {}\n    for pattern in patterns:\n        matches = re.findall(pattern, text)\n        if matches:\n            result[pattern] = [match.start() for match in re.finditer(pattern, text)]\n    return result"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a table to store lengths of longest common subsequence of\n    # substrings. Note that lcs[i][j] contains length of LCS of X[0..i-1]\n    # and Y[0..j-1].\n    lcs = [[0 for w in range(n+1)] for x in range(m+1)]\n\n    # Fill lcs[m][n] in bottom up manner\n    for i in range(m, 0, -1):\n        for j in range(n, 0, -1):\n            if X[i-1] == Y[j-1]:\n                lcs[i][j] = lcs[i-1][j-1] + 1\n            else:\n                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])\n\n    # Following code is used to print LCS\n    index = lcs[m][n]\n\n    # Create a character array to store the lcs string\n    lcs_str = [\"\"] * (index+1)\n    lcs_str[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and\n    # one by one store characters in lcs_str\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X and Y are same, then\n        # current character is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs_str[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and\n        # go in the direction of larger value\n        elif lcs[i-1][j] > lcs[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs_str)"}
{"id": "177_0", "code": "def prod_Square(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 1\n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr,n):\n    # Create a set from the array\n    s = set(arr)\n    \n    # Initialize the first missing positive number to 1\n    missing = 1\n    \n    # Loop through the numbers from 1 to n\n    while missing <= n:\n        # If the number is not in the set, return it\n        if missing not in s:\n            return missing\n        # Otherwise, increment the number\n        missing += 1"}
{"id": "179_0", "code": "def count_Intgral_Points(x1,y1,x2,y2):\n    # Calculate the side length of the square\n    side_length = abs(x2 - x1)\n    \n    # Initialize a counter for integral points\n    integral_points = 0\n    \n    # Iterate over all possible x-coordinates\n    for x in range(x1, x2 + 1):\n        # Iterate over all possible y-coordinates\n        for y in range(y1, y2 + 1):\n            # Check if the point is an integer coordinate\n            if x == int(x) and y == int(y):\n                # Increment the counter if it is\n                integral_points += 1\n                \n    # Return the total count of integral points\n    return integral_points"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    monthdays = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in monthdays:\n        if monthdays[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "181_0", "code": "def check_String(str):\n    \"\"\"\n    This function checks if a given string has at least one letter and one number.\n    \n    Parameters:\n    str (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string has at least one letter and one number, False otherwise.\n    \"\"\"\n    \n    # Initialize flags for letter and number\n    has_letter = False\n    has_number = False\n    \n    # Iterate over each character in the string\n    for char in str:\n        # Check if the character is a letter\n        if char.isalpha():\n            has_letter = True\n        # Check if the character is a number\n        elif char.isdigit():\n            has_number = True\n    \n    # Return True if both conditions are met, False otherwise\n    return has_letter and has_number"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    return tuple(set(test_tup))"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\n    \"\"\"\n    This function converts an octal number to a decimal number.\n    \n    Parameters:\n    n (str): The octal number to be converted.\n    \n    Returns:\n    int: The decimal equivalent of the input octal number.\n    \"\"\"\n    # Remove leading zeros\n    n = n.lstrip('0')\n    \n    # If the string is empty after removing leading zeros, return 0\n    if not n:\n        return 0\n    \n    # Convert the octal number to decimal using built-in int function\n    decimal = int(n, 8)\n    \n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    low = 0\n    high = n-1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid-1] != x:\n                return mid\n            high = mid-1\n        elif arr[mid] > x:\n            high = mid-1\n        else:\n            low = mid+1\n    return -1"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    \"\"\"\n    This function removes all the tuples with length K from the given list.\n    \n    Parameters:\n    test_list (list): The input list containing tuples.\n    K (int): The length of the tuples to be removed.\n    \n    Returns:\n    list: The modified list with tuples of length K removed.\n    \"\"\"\n    return [t for t in test_list if len(t) != K]"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns the result of exponentiation of the first tuple element with the second tuple element.\n\n    Args:\n        test_tup1 (tuple): The first tuple containing the base number.\n        test_tup2 (tuple): The second tuple containing the exponent.\n\n    Returns:\n        float: The result of the exponentiation operation.\n\n    Raises:\n        TypeError: If either of the input tuples contains non-numeric values.\n    \"\"\"\n    # Check if both tuples contain only numeric values\n    if not all(isinstance(x, (int, float)) for x in test_tup1) or not all(isinstance(x, (int, float)) for x in test_tup2):\n        raise TypeError(\"Both tuples must contain only numeric values.\")\n\n    # Extract the base and exponent from the tuples\n    base = test_tup1[0]\n    exponent = test_tup2[0]\n\n    # Perform the exponentiation operation\n    result = base ** exponent\n\n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a,b):\n    # Calculate the maximum possible height of the triangle\n    max_height = min(a,b)\n    \n    # Calculate the maximum possible base of the triangle\n    max_base = 2 * math.sqrt(a**2 - max_height**2)\n    \n    # Return the area of the largest triangle\n    return 0.5 * max_base * max_height\n\n# Test the function\nprint(largest_triangle(5, 3))"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 less than or equal to the given number.\n\n    Parameters:\n    n (int): The given number.\n\n    Returns:\n    int: The highest power of 2 less than or equal to the given number.\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep doubling the power of 2 until it exceeds the given number\n    while power_of_2 <= n:\n        # Double the power of 2\n        power_of_2 *= 2\n    \n    # The highest power of 2 less than or equal to the given number is the previous power of 2\n    return power_of_2 // 2"}
{"id": "189_0", "code": "def position_max(list1):\n    \"\"\"\n    This function finds all index positions of the maximum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the maximum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n\n    return max_indices"}
{"id": "190_0", "code": "def chkList(lst):\n    \"\"\"\n    This function checks whether all elements in a list are the same or not.\n\n    Args:\n        lst (list): A list of elements to be checked.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if len(lst) == 0:\n        return True  # An empty list is considered to have all elements the same\n\n    # Get the first element of the list\n    first_element = lst[0]\n\n    # Iterate over the rest of the list\n    for element in lst[1:]:\n        # If any element is different from the first element, return False\n        if element != first_element:\n            return False\n\n    # If the function hasn't returned False, all elements are the same\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    \"\"\"\n    This function removes even characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with even characters removed.\n    \"\"\"\n    return ''.join([char for char in str1 if int(char) % 2 != 0])"}
{"id": "192_0", "code": "def hamming_Distance(n1,n2):\n    # Convert the integers to binary and remove the '0b' prefix\n    bin_n1 = bin(n1)[2:]\n    bin_n2 = bin(n2)[2:]\n    \n    # Find the maximum length between the two binary strings\n    max_len = max(len(bin_n1), len(bin_n2))\n    \n    # Pad the shorter string with zeros from the left\n    bin_n1 = bin_n1.zfill(max_len)\n    bin_n2 = bin_n2.zfill(max_len)\n    \n    # Initialize a counter for the Hamming distance\n    distance = 0\n    \n    # Iterate over the characters in the binary strings\n    for i in range(max_len):\n        # If the characters at the current position are different, increment the distance\n        if bin_n1[i] != bin_n2[i]:\n            distance += 1\n    \n    # Return the Hamming distance\n    return distance"}
{"id": "193_0", "code": "def count(s,c):\n    \"\"\"\n    This function counts the occurrence of a given character in a string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be counted.\n\n    Returns:\n    int: The number of occurrences of the character in the string.\n    \"\"\"\n    return s.count(c)"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    \"\"\"\n    This function calculates the inversions of tuple elements in the given tuple list.\n    \n    Args:\n        test_tup (list): A list of tuples.\n    \n    Returns:\n        int: The total number of inversions.\n    \"\"\"\n    # Initialize the inversion count to 0\n    inversion_count = 0\n    \n    # Iterate over each tuple in the list\n    for i in range(len(test_tup)):\n        # Iterate over each element in the tuple\n        for j in range(len(test_tup[i])):\n            # Iterate over each element in the remaining tuples\n            for k in range(i + 1, len(test_tup)):\n                # Iterate over each element in the remaining tuples\n                for m in range(len(test_tup[k])):\n                    # Check if the current element is greater than the element in the other tuple\n                    if test_tup[i][j] > test_tup[k][m]:\n                        # Increment the inversion count\n                        inversion_count += 1\n    \n    # Return the total inversion count\n    return inversion_count"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    \"\"\"\n    This function takes a tuple of strings as input, \n    and returns a new tuple where each element is the concatenation of the corresponding elements in the input tuple.\n\n    Args:\n        test_tup (tuple): A tuple of strings.\n\n    Returns:\n        tuple: A new tuple where each element is the concatenation of the corresponding elements in the input tuple.\n    \"\"\"\n    return tuple(str(a) + str(b) for a, b in zip(test_tup, test_tup[1:]))"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    max_len = 0\n    max_subseq = \"\"\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            elif length == 2:\n                if str[i] == str[j]:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 1\n            else:\n                if str[i] == str[j]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n            if dp[i][j] > max_len:\n                max_len = dp[i][j]\n                max_subseq = str[i:j + 1]\n\n    return max_len, max_subseq"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    \"\"\"\n    Checks if the given number is a decimal with a precision of 2.\n\n    Args:\n        num (str): The input number to be checked.\n\n    Returns:\n        bool: True if the number is a decimal with a precision of 2, False otherwise.\n    \"\"\"\n    # Define the pattern for a decimal with a precision of 2\n    pattern = r\"^[-+]?[0-9]*\\.?[0-9]{0,2}$\"\n    \n    # Use the fullmatch function to check if the entire string matches the pattern\n    return bool(re.fullmatch(pattern, num))"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    \"\"\"\n    Deletes the smallest element from the heap and inserts a new item.\n\n    Args:\n        heap (list): A list representing the heap.\n        a (int): The new item to be inserted.\n\n    Returns:\n        list: The updated heap after deletion and insertion.\n    \"\"\"\n    # Check if the heap is empty\n    if not heap:\n        return heap\n\n    # Find the smallest element in the heap\n    smallest = min(heap)\n\n    # Remove the smallest element from the heap\n    heap.remove(smallest)\n\n    # Insert the new item into the heap\n    heap.append(a)\n\n    # Heapify the heap to maintain the heap property\n    heapify(heap)\n\n    return heap\n\n\ndef heapify(heap):\n    \"\"\"\n    Maintains the heap property by bubbling up or down the heap.\n\n    Args:\n        heap (list): A list representing the heap.\n    \"\"\"\n    # Start from the last non-leaf node and work backwards\n    for i in range(len(heap) // 2 - 1, -1, -1):\n        # Heapify the subtree rooted at index i\n        heapify_subtree(heap, i)\n\n\ndef heapify_subtree(heap, i):\n    \"\"\"\n    Recursively heapifies the subtree rooted at index i.\n\n    Args:\n        heap (list): A list representing the heap.\n        i (int): The index of the root of the subtree.\n    \"\"\"\n    # Initialize the smallest element as the root\n    smallest = i\n\n    # Calculate the left and right child indices\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # Check if the left child exists and is smaller than the root\n    if left < len(heap) and heap[left] < heap[smallest]:\n        smallest = left\n\n    # Check if the right child exists and is smaller than the smallest element\n    if right < len(heap) and heap[right] < heap[smallest]:\n        smallest = right\n\n    # If the smallest element is not the root, swap them and continue heapifying\n    if smallest != i:\n        heap[i], heap[smallest] = heap[smallest], heap[i]\n        heapify_subtree(heap, smallest)"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    \"\"\"\n    Checks if the given string contains only a-z, a-z, and 0-9 characters.\n\n    Args:\n        string (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains only allowed characters, False otherwise.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, string))"}
{"id": "200_0", "code": "def count_Num(n):\n    count = 0\n    for i in range(n):\n        # Calculate the ith bit position\n        bit_position = i + 1\n        # Check if the ith bit is set\n        if (n & (1 << bit_position)):\n            count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fourth power of the first n natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to be summed.\n    \n    Returns:\n    int: The sum of the fourth power of the first n natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the fourth power of the current number\n        fourth_power = i ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenates two string tuples into a single string.\n\n    Args:\n        test_tup1 (tuple): The first tuple of strings to concatenate.\n        test_tup2 (tuple): The second tuple of strings to concatenate.\n\n    Returns:\n        str: A single string containing all the strings from both input tuples.\n    \"\"\"\n    # Check if both inputs are tuples\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples\")\n\n    # Check if both tuples contain only strings\n    if not all(isinstance(s, str) for s in test_tup1) or not all(isinstance(s, str) for s in test_tup2):\n        raise TypeError(\"Both tuples must contain only strings\")\n\n    # Use the join() method to concatenate the strings in both tuples\n    # The join() method returns a string concatenated with the elements of an iterable\n    # We use the comma join operator (',') to concatenate the strings in each tuple\n    result = ','.join(test_tup1) + ',' + ','.join(test_tup2)\n\n    return result"}
{"id": "203_0", "code": "import math\n\ndef degree_radian(radian):\n    \"\"\"\n    This function converts radians to degrees.\n\n    Args:\n        radian (float): The angle in radians.\n\n    Returns:\n        float: The angle in degrees.\n    \"\"\"\n    # Use the math library's rad2deg function to convert radians to degrees\n    # This function returns the angle in degrees\n    degrees = math.degrees(radian)\n    return degrees"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.append(char * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    \"\"\"\n    This function checks if list1 is a subset of list2.\n    \n    Args:\n        list1 (list): The list to be checked.\n        list2 (list): The list to be checked against.\n    \n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    \n    # Flatten both lists\n    flat_list1 = flatten_list(list1)\n    flat_list2 = flatten_list(list2)\n    \n    # Check if flat_list1 is a subset of flat_list2\n    return is_subset(flat_list1, flat_list2)\n\n\ndef flatten_list(nested_list):\n    \"\"\"\n    This function flattens a nested list into a one-dimensional list.\n    \n    Args:\n        nested_list (list): The list to be flattened.\n    \n    Returns:\n        list: The flattened list.\n    \"\"\"\n    \n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the nested list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, add it to the flat list\n        else:\n            flat_list.append(element)\n    \n    # Return the flattened list\n    return flat_list\n\n\ndef is_subset(list1, list2):\n    \"\"\"\n    This function checks if list1 is a subset of list2.\n    \n    Args:\n        list1 (list): The list to be checked.\n        list2 (list): The list to be checked against.\n    \n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    \n    # Iterate over each element in list1\n    for element in list1:\n        # If the element is not in list2, return False\n        if element not in list2:\n            return False\n    \n    # If all elements in list1 are in list2, return True\n    return True"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    # Convert the string to a set to remove duplicates\n    unique_chars = set(str)\n    \n    # Iterate over the unique characters\n    for char in unique_chars:\n        # Count the occurrences of the character in the string\n        count = str.count(char)\n        \n        # If the count is greater than 1, return the character\n        if count > 1:\n            return char\n    \n    # If no repeated character is found, return None\n    return None"}
{"id": "207_0", "code": "def min_Operations(A,B):\n    # Calculate the absolute difference between A and B\n    diff = abs(A - B)\n    \n    # If A and B are already equal, no operations are needed\n    if A == B:\n        return 0\n    \n    # If A is greater than B, we need to reduce A to B\n    if A > B:\n        # Calculate the number of operations to reduce A to B\n        # by subtracting B from A until A is less than or equal to B\n        operations = 0\n        while A > B:\n            A -= B\n            operations += 1\n        \n        # Add the remaining difference to the operations\n        operations += diff\n        \n        return operations\n    \n    # If B is greater than A, we need to increase A to B\n    else:\n        # Calculate the number of operations to increase A to B\n        # by adding A to itself until A is greater than or equal to B\n        operations = 0\n        while A < B:\n            A += A\n            operations += 1\n        \n        # Add the remaining difference to the operations\n        operations += diff\n        \n        return operations"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    \"\"\"\n    This function takes a tuple and an integer K as input, \n    and returns the minimum and maximum K elements in the tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n        K (int): The number of elements to extract.\n\n    Returns:\n        tuple: A tuple containing the minimum and maximum K elements.\n    \"\"\"\n    # Check if K is greater than the length of the tuple\n    if K > len(test_tup):\n        raise ValueError(\"K cannot be greater than the length of the tuple\")\n\n    # Sort the tuple in ascending order\n    sorted_tup = sorted(test_tup)\n\n    # Extract the minimum and maximum K elements\n    min_k = sorted_tup[:K]\n    max_k = sorted_tup[-K:]\n\n    # Return the minimum and maximum K elements\n    return min_k, max_k"}
{"id": "209_0", "code": "def replace_max_specialchar(text,n):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text"}
{"id": "210_0", "code": "def first_even(nums):\n    \"\"\"\n    This function finds the first even number in a given list of numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first even number in the list. If no even number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    \"\"\"\n    This function checks if all elements in a tuple have the same data type.\n\n    Args:\n        test_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    # Get the data type of the first element in the tuple\n    first_type = type(test_tuple[0])\n    \n    # Iterate over the rest of the elements in the tuple\n    for element in test_tuple[1:]:\n        # If the data type of the current element is different from the first type, return False\n        if type(element) != first_type:\n            return False\n    \n    # If the function hasn't returned False, it means all elements have the same data type, so return True\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    \"\"\"\n    Checks if the given element is a majority element in the sorted array.\n\n    Args:\n        arr (list): A sorted list of integers.\n        n (int): The size of the array.\n        x (int): The element to check.\n\n    Returns:\n        bool: True if the element is a majority element, False otherwise.\n    \"\"\"\n    # Initialize two pointers, one at the start and one at the end of the array\n    left, right = 0, n - 1\n    \n    # Continue the loop until the two pointers meet\n    while left < right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the target, we need to check the left half\n        if arr[mid] == x:\n            # If the middle element is equal to the target and it's the first element or the element before it is not equal to the target, return True\n            if mid == 0 or arr[mid - 1] != x:\n                return True\n            # Otherwise, move the right pointer to the middle index\n            else:\n                right = mid\n        # If the middle element is less than the target, move the left pointer to the middle index + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        # If the middle element is greater than the target, move the right pointer to the middle index - 1\n        else:\n            right = mid - 1\n    \n    # If the loop ends and the left pointer is equal to the target, return True\n    if left == x:\n        return True\n    \n    # If the loop ends and the left pointer is not equal to the target, return False\n    return False"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    \"\"\"\n    This function counts the number of set bits in a given integer.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The number of set bits in the input integer.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    \"\"\"\n    This function finds the minimum element in a sorted and rotated array.\n    \n    Parameters:\n    arr (list): The input array\n    low (int): The low index of the current search range\n    high (int): The high index of the current search range\n    \n    Returns:\n    int: The minimum element in the array\n    \"\"\"\n    # If the array is not rotated, the minimum element is the first element\n    if high < low:\n        return arr[low]\n    \n    # If the array is rotated, find the middle element\n    mid = (low + high) // 2\n    \n    # If the middle element is greater than the next element, the minimum element is in the right half\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return find_Min(arr, mid + 1, high)\n    \n    # If the middle element is less than the previous element, the minimum element is in the left half\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return find_Min(arr, low, mid - 1)\n    \n    # If the middle element is greater than the first element, the minimum element is in the right half\n    if arr[mid] > arr[low]:\n        return find_Min(arr, low, mid)\n    \n    # If the middle element is less than the first element, the minimum element is in the left half\n    return find_Min(arr, mid + 1, high)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    \"\"\"\n    This function removes characters with odd index values from a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The modified string with characters at odd index values removed.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    \"\"\"\n    This function returns the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):\n    # Convert the numbers to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    bin_l = bin(l)[2:]\n    bin_r = bin(r)[2:]\n\n    # Calculate the maximum length of the binary strings\n    max_len = max(len(bin_n), len(bin_l), len(bin_r))\n\n    # Pad the binary strings with leading zeros if necessary\n    bin_n = bin_n.zfill(max_len)\n    bin_l = bin_l.zfill(max_len)\n    bin_r = bin_r.zfill(max_len)\n\n    # Check if all bits are set in the given range\n    for i in range(max_len):\n        if bin_n[i] == '0' and bin_l[i] == '0' and bin_r[i] == '0':\n            return False\n    return True"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    \"\"\"\n    Re-arranges the elements of the given array so that all negative elements appear before positive ones.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the array.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    # Initialize two lists, one for negative numbers and one for positive numbers\n    negative = []\n    positive = []\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is negative, add it to the negative list\n        if arr[i] < 0:\n            negative.append(arr[i])\n        # If the current element is positive, add it to the positive list\n        else:\n            positive.append(arr[i])\n\n    # Combine the two lists to get the final rearranged array\n    rearranged_arr = negative + positive\n\n    # Return the rearranged array\n    return rearranged_arr"}
{"id": "219_0", "code": "def replace_blank(str1,char):\n    return str1.replace(\" \", char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    \"\"\"\n    This function calculates the maximum sum in a right triangle of numbers.\n\n    Parameters:\n    tri (list): A list of numbers representing the sides of the right triangle.\n    n (int): The number of rows in the triangle.\n\n    Returns:\n    int: The maximum sum in the triangle.\n\n    \"\"\"\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n\n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Calculate the sum of the current row\n        row_sum = sum(tri[i*n + i: (i+1)*n + i + 1])\n        \n        # Update the maximum sum if the current row sum is greater\n        max_sum = max(max_sum, row_sum)\n\n    # Return the maximum sum\n    return max_sum"}
{"id": "221_0", "code": "def larg_nnum(list1,n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n\n    Args:\n        list1 (list): The dataset to select from.\n        n (int): The number of largest items to return.\n\n    Returns:\n        list: A list of the n largest items from the dataset.\n    \"\"\"\n    # Check if n is greater than the length of the list\n    if n > len(list1):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n\n    # Return the n largest items\n    return sorted_list[:n]"}
{"id": "222_0", "code": "import math\n\ndef lateralsuface_cylinder(r,h):\n    \"\"\"\n    This function calculates the lateral surface area of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    # Calculate the lateral surface area using the formula 2rh\n    lateral_surface_area = 2 * math.pi * r * h\n    \n    return lateral_surface_area"}
{"id": "223_0", "code": "def volume_cube(length):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Args:\n        length (float): The length of a side of the cube.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return length ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all even bits set.\n    \"\"\"\n    # Initialize result variable to store the final result\n    result = 0\n    \n    # Iterate over each bit in the binary representation of the number\n    for i in range(32):\n        # Check if the current bit is even (i.e., 0)\n        if (n >> i) & 1 == 0:\n            # If the bit is even, set it to 1 in the result\n            result |= 1 << i\n    \n    # Return the result\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Calculate the area of the large equilateral triangle\n    area_large = (N * N * N) / (4 * 3 * math.sqrt(3) / 4)\n    \n    # Calculate the area of the small equilateral triangle\n    area_small = (K * K * K) / (4 * 3 * math.sqrt(3) / 4)\n    \n    # Calculate the maximum number of small triangles that can fit in the large triangle\n    max_triangles = area_large / area_small\n    \n    # Since we can't have a fraction of a triangle, we use the floor function to get the maximum number of whole triangles\n    max_triangles = math.floor(max_triangles)\n    \n    return max_triangles"}
{"id": "226_0", "code": "from collections import defaultdict\n\ndef check_occurences(test_list):\n    # Create a dictionary to store the count of each record\n    record_count = defaultdict(int)\n    \n    # Create a dictionary to store the count of each time\n    time_count = defaultdict(int)\n    \n    # Iterate over the test list\n    for record, time in test_list:\n        # Increment the count of the record\n        record_count[record] += 1\n        \n        # Increment the count of the time\n        time_count[time] += 1\n    \n    # Initialize a variable to store the maximum count of a record\n    max_record_count = 0\n    \n    # Iterate over the record count dictionary\n    for record, count in record_count.items():\n        # Update the maximum count of a record\n        max_record_count = max(max_record_count, count)\n    \n    # Initialize a variable to store the maximum count of a time\n    max_time_count = 0\n    \n    # Iterate over the time count dictionary\n    for time, count in time_count.items():\n        # Update the maximum count of a time\n        max_time_count = max(max_time_count, count)\n    \n    # Check if the maximum count of a record and a time are equal\n    if max_record_count == max_time_count:\n        return True\n    else:\n        return False"}
{"id": "227_0", "code": "def number_of_substrings(s):\n    \"\"\"\n    This function calculates the number of non-empty substrings of a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n\n    \"\"\"\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            # Check if the substring is not empty\n            if s[i:j] != \"\":\n                count += 1\n    return count"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m,n):\n    if n == 1:\n        return m\n    else:\n        total = 0\n        for i in range(1, m+1):\n            total += get_total_number_of_sequences(i, n-1)\n        return total"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    \"\"\"\n    This function replaces the last element of the first list with the second list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1] = list2\n    # Return the modified list\n    return list1"}
{"id": "230_0", "code": "def array_3d(m,n,o):\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_charac(str1):\n    \"\"\"\n    This function counts the total number of characters in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    # Initialize a variable to store the count of characters\n    char_count = 0\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Increment the character count by 1 for each character\n        char_count += 1\n    \n    # Return the total character count\n    return char_count"}
{"id": "232_0", "code": "from collections import Counter\n\ndef sort_on_occurence(lst):\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    \n    # Sort the list based on the count of each element\n    sorted_lst = sorted(lst, key=lambda x: count[x])\n    \n    return sorted_lst"}
{"id": "233_0", "code": "import math\n\ndef next_Perfect_Square(N):\n    # Calculate the square root of the given number\n    sqrt_N = math.sqrt(N)\n    \n    # If the square root is an integer, then the number is a perfect square\n    if sqrt_N == int(sqrt_N):\n        # Return the number itself as it is a perfect square\n        return N\n    else:\n        # Calculate the next integer after the square root\n        next_sqrt = math.ceil(sqrt_N)\n        \n        # Calculate the next perfect square by squaring the next integer\n        next_perfect_square = next_sqrt ** 2\n        \n        # Return the next perfect square\n        return next_perfect_square"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Initialize a list to store the maximum sum of bi-tonic sub-sequence\n    max_sum = [0]*n\n    \n    # Initialize a list to store the maximum sum of bi-tonic sub-sequence ending at each position\n    max_ending_here = [0]*n\n    \n    # Initialize the maximum sum of bi-tonic sub-sequence\n    max_so_far = 0\n    \n    # Initialize the maximum sum of bi-tonic sub-sequence ending at the first position\n    max_ending_here[0] = arr[0]\n    \n    # Iterate over the array from the second position to the end\n    for i in range(1, n):\n        # If the current element is greater than the previous element, update the maximum sum of bi-tonic sub-sequence\n        if arr[i] > arr[i-1]:\n            max_ending_here[i] = max_ending_here[i-1] + arr[i]\n        else:\n            max_ending_here[i] = arr[i]\n        \n        # Update the maximum sum of bi-tonic sub-sequence\n        max_sum[i] = max(max_sum[i-1], max_ending_here[i])\n        \n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        max_so_far = max(max_so_far, max_sum[i])\n    \n    # Return the maximum sum of bi-tonic sub-sequence\n    return max_so_far"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    \"\"\"\n    Compute the square root of a given number using the Babylonian method.\n\n    Args:\n        number (float): The number for which to compute the square root.\n\n    Returns:\n        float: The approximate square root of the given number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n\n    # Initial guess for the square root\n    guess = number / 2.0\n\n    # Maximum number of iterations\n    max_iterations = 1000\n\n    # Tolerance for convergence\n    tolerance = 0.00001\n\n    for _ in range(max_iterations):\n        # Calculate the next guess using the Babylonian method formula\n        next_guess = (guess + number / guess) / 2.0\n\n        # Check for convergence\n        if abs(guess - next_guess) < tolerance:\n            return next_guess\n\n        # Update the guess for the next iteration\n        guess = next_guess\n\n    # If the maximum number of iterations is reached without convergence, raise an error\n    raise RuntimeError(\"Failed to converge after {} iterations.\".format(max_iterations))"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store the lengths of the longest palindromic subsequences\n    dp = [[0] * n for _ in range(n)]\n    \n    # All substrings of length 1 are palindromes\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for substring of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Check for lengths greater than 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # Find the longest palindromic subsequence\n    max_length = 0\n    start = 0\n    for i in range(n):\n        for j in range(i, n):\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                start = i\n                end = j\n    \n    # Return the longest palindromic subsequence\n    return str[start:end + 1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1.\n\n    The harmonic sum of n-1 is the sum of the reciprocals of the first n-1 positive integers.\n\n    Args:\n        n (int): The number of terms in the harmonic sum.\n\n    Returns:\n        float: The harmonic sum of n-1.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize the sum to 0\n    harmonic_sum = 0\n\n    # Calculate the harmonic sum\n    for i in range(1, n):\n        harmonic_sum += 1 / i\n\n    return harmonic_sum"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    return list(filter(lambda x: x in array_nums2, array_nums1))"}
{"id": "239_0", "code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        x: The element to search for.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(x)"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element of a list.\n\n    Args:\n        lst (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The modified list with the element inserted before each element.\n    \"\"\"\n    return [element] + lst + [element]"}
{"id": "241_0", "code": "import cmath\n\ndef convert(numbers):\n    \"\"\"\n    This function converts a complex number to polar coordinates.\n\n    Parameters:\n    numbers (complex): The complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude (r) and angle (theta) in radians.\n    \"\"\"\n    # Calculate the magnitude (r) using the abs function\n    r = abs(numbers)\n    \n    # Calculate the angle (theta) using the cmath.phase function\n    theta = cmath.phase(numbers)\n    \n    # Return the magnitude and angle as a tuple\n    return (r, theta)"}
{"id": "242_0", "code": "def count_integer(list1):\n    \"\"\"\n    This function counts the number of integers in a given list.\n\n    Args:\n        list1 (list): A list containing integers.\n\n    Returns:\n        int: The number of integers in the list.\n    \"\"\"\n    count = 0\n    for num in list1:\n        if isinstance(num, int):\n            count += 1\n    return count"}
{"id": "243_0", "code": "def words_ae(text):\n    \"\"\"\n    This function finds all words starting with 'a' or 'e' in a given string.\n\n    Parameters:\n    text (str): The input string to search for words.\n\n    Returns:\n    list: A list of words starting with 'a' or 'e'.\n    \"\"\"\n    # Split the input string into words\n    words = text.split()\n\n    # Use list comprehension to filter words starting with 'a' or 'e'\n    result = [word for word in words if word.lower().startswith(('a', 'e'))]\n\n    return result"}
{"id": "244_0", "code": "import itertools\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Generate all combinations with repetitions of specified number of colours from three different colours.\n\n    Parameters:\n    l (list): List of three different colours.\n    n (int): Number of colours to choose.\n\n    Returns:\n    list: List of all combinations with repetitions.\n    \"\"\"\n    # Use itertools.product to generate all combinations with repetitions\n    combinations = list(itertools.product(l, repeat=n))\n    return combinations"}
{"id": "245_0", "code": "def count_primes_nums(n):\n    \"\"\"\n    This function counts the number of prime numbers less than a given non-negative number.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers\n    \n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime*2, n, current_prime):\n                sieve[multiple] = False\n    \n    return sum(sieve)"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    \"\"\"\n    This function swaps two numbers.\n    \n    Args:\n        a (int): The first number.\n        b (int): The second number.\n    \n    Returns:\n        tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    # Swap the numbers using tuple packing and unpacking\n    return b, a"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    return sum(1 for num in array_nums if num % 2 != 0)"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Unpack the tuples into separate variables\n    tup1_first, tup1_second, tup1_third = test_tup1\n    tup2_first, tup2_second, tup2_third = test_tup2\n\n    # Compare the first elements of the tuples\n    if tup1_first > tup2_first:\n        # If the first element of the first tuple is greater, return the first tuple\n        return test_tup1\n    elif tup1_first < tup2_first:\n        # If the first element of the second tuple is greater, return the second tuple\n        return test_tup2\n    else:\n        # If the first elements are equal, compare the second elements\n        if tup1_second > tup2_second:\n            # If the second element of the first tuple is greater, return the first tuple\n            return test_tup1\n        elif tup1_second < tup2_second:\n            # If the second element of the second tuple is greater, return the second tuple\n            return test_tup2\n        else:\n            # If the second elements are equal, compare the third elements\n            if tup1_third > tup2_third:\n                # If the third element of the first tuple is greater, return the first tuple\n                return test_tup1\n            elif tup1_third < tup2_third:\n                # If the third element of the second tuple is greater, return the second tuple\n                return test_tup2\n            else:\n                # If all elements are equal, return the first tuple\n                return test_tup1"}
{"id": "249_0", "code": "def newman_prime(n):\n    \"\"\"\n    Returns the nth Newman-Shanks-Williams prime number.\n\n    Parameters:\n    n (int): The position of the prime number to find.\n\n    Returns:\n    int: The nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def next_prime(num):\n        \"\"\"Find the next prime number after num.\"\"\"\n        num += 1\n        while not is_prime(num):\n            num += 1\n        return num\n\n    def newman_shanks_williams(num):\n        \"\"\"Generate the Newman-Shanks-Williams sequence.\"\"\"\n        sequence = [2]\n        for i in range(1, num):\n            next_num = next_prime(sequence[-1])\n            while not is_prime(next_num):\n                next_num = next_prime(next_num)\n            sequence.append(next_num)\n        return sequence\n\n    # Generate the sequence up to the nth prime\n    sequence = newman_shanks_williams(n)\n    return sequence[-1]"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input, performs mathematical division operation \n    across the elements of the tuples, and returns the results as a new tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple containing numbers.\n        test_tup2 (tuple): The second tuple containing numbers.\n\n    Returns:\n        tuple: A new tuple containing the results of the division operation.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the divisor is zero to avoid ZeroDivisionError\n        if test_tup2[i] == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        # Perform the division operation and append the result to the list\n        result.append(test_tup1[i] / test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    \"\"\"\n    Splits a given list into two parts where the length of the first part of the list is given.\n\n    Args:\n        list1 (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing the first part of the list and the second part of the list.\n    \"\"\"\n    # Check if the length of the list is less than or equal to the given length\n    if len(list1) <= L:\n        # If true, return the list as it is and an empty list\n        return list1, []\n    else:\n        # If false, return the first part of the list and the second part of the list\n        return list1[:L], list1[L:]"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into one.\n\n    Args:\n        d1 (dict): The first dictionary to merge.\n        d2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from both input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Copy all key-value pairs from the first dictionary to the merged dictionary\n    for key, value in d1.items():\n        merged_dict[key] = value\n    \n    # Iterate over the key-value pairs of the second dictionary\n    for key, value in d2.items():\n        # If the key is already present in the merged dictionary, update its value\n        if key in merged_dict:\n            merged_dict[key] = value\n        # If the key is not present in the merged dictionary, add it\n        else:\n            merged_dict[key] = value\n    \n    # Return the merged dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    \"\"\"\n    Calculate a dog's age in dog years.\n\n    A dog's age in dog years is calculated as follows:\n    - The first two years of a dog's life are equivalent to 10-14 human years.\n    - After the first two years, each year of a dog's life is equivalent to 5 human years.\n\n    Args:\n        h_age (int): The dog's age in human years.\n\n    Returns:\n        int: The dog's age in dog years.\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10\n    else:\n        return (h_age - 2) * 5 + 2"}
{"id": "254_0", "code": "def list_split(S, step):\n    \"\"\"\n    Splits a list into sublists of size 'step' each.\n\n    Args:\n        S (list): The input list to be split.\n        step (int): The size of each sublist.\n\n    Returns:\n        list: A list of sublists of size 'step' each.\n    \"\"\"\n    return [S[i:i + step] for i in range(0, len(S), step)]"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): The length of the side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # Calculate the lateral surface area using the formula 4 * l^2\n    lateral_surface_area = 4 * (l ** 2)\n    return lateral_surface_area"}
{"id": "256_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n odd natural numbers\n    for i in range(n):\n        # Calculate the square of the current odd number\n        square = (2*i + 1) ** 2\n        \n        # Add the square to the total sum\n        total_sum += square\n    \n    # Return the total sum\n    return total_sum"}
{"id": "257_0", "code": "def find_star_num(n):\n    \"\"\"\n    This function calculates the nth star number.\n    \n    The first star number is 1, the second star number is 6, the third star number is 11, and so on.\n    The formula to calculate the nth star number is: 5n - 1\n    \n    Parameters:\n    n (int): The position of the star number to be found.\n    \n    Returns:\n    int: The nth star number.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    return 5 * n - 1"}
{"id": "258_0", "code": "def ascii_value(k):\n    \"\"\"\n    This function calculates the ASCII value of a given character.\n\n    Parameters:\n    k (str): The character for which the ASCII value is to be calculated.\n\n    Returns:\n    int: The ASCII value of the character.\n\n    Raises:\n    TypeError: If the input is not a string.\n    ValueError: If the input string is empty.\n    \"\"\"\n\n    # Check if the input is a string\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Check if the input string is not empty\n    if len(k) == 0:\n        raise ValueError(\"Input string cannot be empty.\")\n\n    # Calculate the ASCII value of the character\n    ascii_val = ord(k)\n\n    return ascii_val"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr,n):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in a given array.\n    \n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The size of the input list.\n    \n    Returns:\n    int: The sum of even numbers at even positions.\n    \"\"\"\n    \n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the array using the index and value\n    for i, num in enumerate(arr):\n        \n        # Check if the index is even and the number is even\n        if i % 2 == 0 and num % 2 == 0:\n            \n            # Add the number to the total sum\n            total_sum += num\n    \n    # Return the total sum\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the fifth power of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of the fifth power of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2 * n, 2):\n        # Calculate the fifth power of the current even number\n        fifth_power = i ** 5\n        \n        # Add the fifth power to the total sum\n        total_sum += fifth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a new list containing the last element of each tuple.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of last elements of each tuple in the input list.\n    \"\"\"\n    return [t[-1] for t in test_list]"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function subtracts the contents of one tuple with corresponding index of other tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the difference between the two input tuples.\n\n    Raises:\n        ValueError: If the two tuples do not have the same length.\n    \"\"\"\n    # Check if the two tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"The two tuples must have the same length.\")\n\n    # Initialize an empty list to store the differences\n    differences = []\n\n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append the result to the list\n        differences.append(test_tup1[i] - test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(differences)"}
{"id": "263_0", "code": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of even index binomial coefficients up to n.\n    \n    Parameters:\n    n (int): The number of terms to consider in the binomial expansion.\n    \n    Returns:\n    int: The sum of even index binomial coefficients.\n    \"\"\"\n    # Initialize the sum of even index binomial coefficients\n    even_sum = 0\n    \n    # Iterate over the range from 0 to n (inclusive)\n    for i in range(n + 1):\n        # Calculate the binomial coefficient using the math.comb function\n        binomial_coeff = math.comb(i, i % 2)\n        \n        # If the index is even, add the binomial coefficient to the sum\n        if i % 2 == 0:\n            even_sum += binomial_coeff\n    \n    # Return the sum of even index binomial coefficients\n    return even_sum"}
{"id": "264_0", "code": "def get_Position(a,n,m):\n    \"\"\"\n    This function finds the position of the last removed element from the given array.\n    \n    Parameters:\n    a (list): The input array.\n    n (int): The number of elements removed.\n    m (int): The size of the array.\n    \n    Returns:\n    int: The position of the last removed element.\n    \"\"\"\n    # Calculate the position of the last removed element\n    position = n - 1\n    \n    # Check if the position is within the array bounds\n    if position < 0 or position >= m:\n        return -1\n    \n    # Return the position\n    return position"}
{"id": "265_0", "code": "import math\n\ndef volume_cylinder(r,h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Calculate the volume using the formula V = rh\n    volume = math.pi * (r ** 2) * h\n    return volume"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    \"\"\"\n    This function filters a dictionary based on values.\n    \n    Parameters:\n    dict (dict): The dictionary to be filtered.\n    n (int): The value to filter by.\n    \n    Returns:\n    dict: A new dictionary containing only the key-value pairs where the value equals n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value == n}"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    \"\"\"\n    This function takes a tuple as input and returns the count of elements that occur before the record in the tuple.\n    \n    Parameters:\n    test_tup (tuple): The input tuple.\n    \n    Returns:\n    int: The count of elements that occur before the record in the tuple.\n    \"\"\"\n    # Initialize a counter variable to keep track of the count of elements before the record\n    count = 0\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # If the element is not the record, increment the counter\n        if element != test_tup[-1]:\n            count += 1\n    \n    # Return the count of elements before the record\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    # Check if n is a decagonal number\n    i = 1\n    while True:\n        decagonal_num = i * (10 + i) // 2\n        if decagonal_num == n:\n            return True\n        elif decagonal_num > n:\n            return False\n        i += 1"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    pos = 0\n    while pos < len(dlist):\n        if dlist[pos] == item:\n            return pos\n        else:\n            pos = pos + 1\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    \"\"\"\n    This function checks if all elements in a given list are unique or not.\n\n    Args:\n        test_list (list): A list of elements to be checked.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x: x - y for x, y in zip(nums1, nums2)))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number into a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq_dict = {}\n    \n    # Iterate over each digit in the number\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, freq in freq_dict.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if freq > int(digit):\n            return False\n    \n    # If no digit's frequency is greater than the digit itself, return True\n    return True"}
{"id": "273_0", "code": "def check_element(lst, element):\n    \"\"\"\n    Checks if all elements in the list are equal to the given element.\n\n    Args:\n        lst (list): The list to check.\n        element (str): The element to compare with.\n\n    Returns:\n        bool: True if all elements are equal to the given element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    \"\"\"\n    This function checks if the input string contains 'a' followed by two to three 'b's.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string contains 'a' followed by two to three 'b's, False otherwise.\n    \"\"\"\n    # Check if the length of the string is at least 3\n    if len(text) < 3:\n        return False\n    \n    # Check if the string starts with 'a'\n    if text[0] != 'a':\n        return False\n    \n    # Initialize a counter for 'b's\n    b_count = 0\n    \n    # Iterate over the string starting from the second character\n    for char in text[1:]:\n        # If the character is 'b', increment the counter\n        if char == 'b':\n            b_count += 1\n        # If the character is not 'b', reset the counter\n        else:\n            b_count = 0\n        \n        # If the counter exceeds 3, return False\n        if b_count > 3:\n            return False\n    \n    # If the function hasn't returned False, return True\n    return True"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the total length of the repeated array\n    total_length = n * k\n    \n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Initialize the window start index\n    window_start = 0\n    \n    # Iterate over the repeated array\n    for window_end in range(total_length):\n        # Add the current element to the current sum\n        current_sum += a[window_end % n]\n        \n        # If the window size is greater than n, remove the first element\n        if window_end >= n - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= a[window_start]\n            window_start += 1\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "276_0", "code": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of squares of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the square of the current even number\n        square = i ** 2\n        \n        # Add the square to the total sum\n        total_sum += square\n    \n    # Return the total sum\n    return total_sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    \"\"\"\n    This function counts the number of elements in the array 'arr' that have a modular inverse under the given prime number 'P' equal to itself.\n\n    Parameters:\n    arr (list): The input list of integers.\n    N (int): The size of the input list.\n    P (int): The given prime number.\n\n    Returns:\n    int: The count of elements in the array 'arr' that have a modular inverse under the given prime number 'P' equal to itself.\n    \"\"\"\n    count = 0  # Initialize a counter variable to store the count of elements with modular inverse equal to itself.\n    \n    # Iterate over each element in the input array 'arr'.\n    for num in arr:\n        # Check if the modular inverse of the current element 'num' under the prime number 'P' is equal to itself.\n        if pow(num, P-2, P) == num:\n            # If the condition is met, increment the counter variable 'count'.\n            count += 1\n    \n    # Return the count of elements with modular inverse equal to itself.\n    return count"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Initialize a counter for odd days\n    odd_count = 0\n\n    # Loop through each month of the year\n    for month in range(1, 13):\n        # Determine the number of days in the current month\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            days_in_month = 31\n        elif month == 2:\n            # February has 29 days in leap years and 28 days in non-leap years\n            if N % 4 == 0:\n                days_in_month = 29\n            else:\n                days_in_month = 28\n        else:\n            days_in_month = 30\n\n        # Count the odd days in the current month\n        odd_count += days_in_month // 2\n\n    # Return the total number of odd days in the year\n    return odd_count"}
{"id": "279_0", "code": "def max_length(lists):\n    \"\"\"\n    This function finds the list of lists with maximum length.\n\n    Args:\n        lists (list): A list of lists.\n\n    Returns:\n        list: The list of lists with maximum length.\n    \"\"\"\n    # Check if the input list is empty\n    if not lists:\n        return []\n\n    # Initialize the maximum length and the list of lists with maximum length\n    max_len = max(len(sublist) for sublist in lists)\n    max_len_list = [sublist for sublist in lists if len(sublist) == max_len]\n\n    return max_len_list"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    # Base case: If there are no posts or only one post, there is only one way to paint the fence.\n    if n == 0 or n == 1:\n        return 1\n    \n    # Base case: If there are two posts, there are k * k ways to paint the fence.\n    if n == 2:\n        return k * k\n    \n    # Initialize a list to store the number of ways to paint the fence for each post.\n    ways = [0] * n\n    ways[0] = 1\n    ways[1] = k * k\n    \n    # For each post from the third post onwards, calculate the number of ways to paint the fence.\n    for i in range(2, n):\n        # For each color, calculate the number of ways to paint the fence by considering the previous two posts.\n        for j in range(k):\n            # If the current post is not adjacent to a post with the same color, add the number of ways to paint the fence for the previous two posts.\n            if j != ways[i-1] % k:\n                ways[i] += ways[i-1]\n            # If the current post is adjacent to a post with the same color, add the number of ways to paint the fence for the previous post.\n            if j != ways[i-2] % k:\n                ways[i] += ways[i-2]\n    \n    # Return the number of ways to paint the fence for the last post.\n    return ways[-1]"}
{"id": "281_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the quotient of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The quotient of n and m.\n    \n    Raises:\n    ZeroDivisionError: If m is zero.\n    \"\"\"\n    if m == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return n // m"}
{"id": "282_0", "code": "import math\n\ndef otherside_rightangle(w,h):\n    # Calculate the length of the third side using the Pythagorean theorem\n    c = math.sqrt(w**2 + h**2)\n    return c"}
{"id": "283_0", "code": "def max_val(listval):\n    \"\"\"\n    This function finds the maximum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The maximum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"Input list is empty\")\n\n    max_val = listval[0]\n    for val in listval:\n        if val > max_val:\n            max_val = val\n\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    \"\"\"\n    Returns the sum of all divisors of a number.\n\n    Args:\n        number (int): The number for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of all divisors of the number.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize the sum of divisors to 0\n    sum_divisors = 0\n\n    # Iterate over all numbers from 1 to the input number\n    for i in range(1, number + 1):\n        # Check if the current number is a divisor of the input number\n        if number % i == 0:\n            # If it is, add it to the sum of divisors\n            sum_divisors += i\n\n    return sum_divisors"}
{"id": "285_0", "code": "def get_Inv_Count(arr,n):\n    # Initialize count of inversions\n    inv_count = 0\n    # Merge sort function\n    def merge_sort(arr, low, high):\n        nonlocal inv_count\n        # If subarray has only one element, it is already sorted\n        if low >= high:\n            return\n        mid = (low + high) // 2\n        # Recursively sort left and right halves\n        merge_sort(arr, low, mid)\n        merge_sort(arr, mid + 1, high)\n        # Merge sorted halves and count inversions\n        merge(arr, low, mid, high)\n    # Merge function to merge two sorted subarrays and count inversions\n    def merge(arr, low, mid, high):\n        nonlocal inv_count\n        left = arr[low:mid + 1]\n        right = arr[mid + 1:high + 1]\n        i = j = 0\n        k = low\n        # Merge smaller elements first\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                inv_count += len(left) - i\n                j += 1\n            k += 1\n        # Copy remaining elements, if any\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    # Call merge sort function\n    merge_sort(arr, 0, n - 1)\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    \"\"\"\n    This function takes a nested list as input and returns a flattened list.\n    \n    Args:\n        list1 (list): A nested list structure.\n    \n    Returns:\n        list: A flattened list structure.\n    \"\"\"\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    \"\"\"\n    This function finds the elements present in both nested lists.\n    \n    Parameters:\n    l1 (list): The first nested list.\n    l2 (list): The second nested list.\n    \n    Returns:\n    list: A list of elements present in both nested lists.\n    \"\"\"\n    # Flatten the first list\n    flat_list1 = flatten_list(l1)\n    \n    # Flatten the second list\n    flat_list2 = flatten_list(l2)\n    \n    # Find the intersection of the two lists\n    intersection = set(flat_list1) & set(flat_list2)\n    \n    # Convert the intersection set back to a list\n    result = list(intersection)\n    \n    return result\n\ndef flatten_list(nested_list):\n    \"\"\"\n    This function flattens a nested list.\n    \n    Parameters:\n    nested_list (list): The nested list to be flattened.\n    \n    Returns:\n    list: A flattened list.\n    \"\"\"\n    flat_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            flat_list.append(element)\n    return flat_list"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    \"\"\"\n    This function calculates the maximum aggregate from the list of tuples.\n    \n    Parameters:\n    stdata (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    int: The maximum aggregate from the list of tuples.\n    \"\"\"\n    max_sum = float('-inf')  # Initialize max_sum as negative infinity\n    for tup in stdata:\n        current_sum = tup[0] + tup[1]  # Calculate the sum of the current tuple\n        if current_sum > max_sum:  # Check if the current sum is greater than max_sum\n            max_sum = current_sum  # Update max_sum if necessary\n    return max_sum"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    \"\"\"\n    This function calculates the count of all binary sequences of length 2n \n    such that sum of first n bits is same as sum of last n bits.\n\n    Parameters:\n    n (int): The number of bits in the binary sequence.\n\n    Returns:\n    int: The count of all binary sequences of length 2n that satisfy the condition.\n    \"\"\"\n    # Initialize count to 0\n    count = 0\n    \n    # Loop through all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the number to binary and remove the '0b' prefix\n        bin_seq = bin(i)[2:].zfill(2*n)\n        \n        # Check if the sum of first n bits is equal to the sum of last n bits\n        if sum(int(bit) for bit in bin_seq[:n]) == sum(int(bit) for bit in bin_seq[n:]):\n            # If the condition is satisfied, increment the count\n            count += 1\n    \n    # Return the count\n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n        d (dict): The dictionary to calculate the depth of.\n\n    Returns:\n        int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        return 0  # If the input is not a dictionary, return 0\n\n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            # Recursively calculate the depth of the sub-dictionary\n            sub_depth = dict_depth(value)\n            # Update the maximum depth if necessary\n            max_depth = max(max_depth, sub_depth + 1)\n\n    return max_depth"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Find the most significant bit (MSB) position\n    msb_position = len(binary) - 1\n    \n    # Find the most significant bit number which is also a set bit\n    for i in range(msb_position, -1, -1):\n        if binary[i] == '1':\n            return i\n    \n    # If no set bit is found, return -1\n    return -1"}
{"id": "292_0", "code": "def solve(a,n):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left_half = merge_sort(arr[:mid])\n        right_half = merge_sort(arr[mid:])\n        return merge(left_half, right_half)\n\n    def merge(left, right):\n        merged = []\n        left_index = 0\n        right_index = 0\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n        merged += left[left_index:]\n        merged += right[right_index:]\n        return merged\n\n    def count_inversions(arr):\n        if len(arr) <= 1:\n            return 0, arr\n        mid = len(arr) // 2\n        left_inversions, left = count_inversions(arr[:mid])\n        right_inversions, right = count_inversions(arr[mid:])\n        merged_inversions = left_inversions + right_inversions\n        merged = merge(left, right)\n        return merged_inversions + left_inversions + right_inversions, merged\n\n    left_inversions, left = count_inversions(a)\n    right_inversions, right = count_inversions(a[::-1])\n    return left_inversions == right_inversions"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    \"\"\"\n    This function finds the element at a given index after a number of rotations.\n\n    Parameters:\n    arr (list): The input list of elements.\n    ranges (list): A list of ranges of elements in the array.\n    rotations (int): The number of rotations.\n    index (int): The index at which the element is to be found.\n\n    Returns:\n    The element at the given index after the number of rotations.\n    \"\"\"\n    # Calculate the effective index after rotations\n    effective_index = (index + rotations) % len(arr)\n    \n    # Check if the effective index is within the range of the array\n    if effective_index < len(ranges):\n        # If the effective index is within the range, return the element at the effective index\n        return arr[effective_index]\n    else:\n        # If the effective index is not within the range, return None\n        return None"}
{"id": "294_0", "code": "def start_withp(words):\n    \"\"\"\n    This function takes a list of words as input and returns a list of tuples.\n    Each tuple contains two words from the list that start with the letter 'p'.\n    If no such pairs are found, it returns an empty list.\n\n    Args:\n        words (list): A list of words\n\n    Returns:\n        list: A list of tuples containing pairs of words that start with 'p'\n    \"\"\"\n    # Filter the list to include only words that start with 'p'\n    p_words = [word for word in words if word.lower().startswith('p')]\n\n    # Initialize an empty list to store the pairs of words\n    pairs = []\n\n    # Iterate over the list of words\n    for i in range(len(p_words)):\n        for j in range(i + 1, len(p_words)):\n            # Check if the current pair of words is not already in the pairs list\n            if (p_words[i], p_words[j]) not in pairs and (p_words[j], p_words[i]) not in pairs:\n                # Add the pair to the pairs list\n                pairs.append((p_words[i], p_words[j]))\n\n    # Return the list of pairs\n    return pairs"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Create a table to store the maximum sum of increasing subsequence\n    dp = [[0 for _ in range(n)] for _ in range(index + 1)]\n    \n    # Initialize the first row of the table\n    for j in range(1, n):\n        dp[0][j] = a[j]\n    \n    # Fill the table in bottom-up manner\n    for i in range(1, index + 1):\n        for j in range(i, n):\n            # If the current element is greater than the previous element\n            if a[j] > a[j - 1]:\n                # Update the maximum sum of increasing subsequence\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1] + a[j])\n            else:\n                # If the current element is not greater than the previous element\n                # then the maximum sum of increasing subsequence is the same as the previous element\n                dp[i][j] = dp[i][j - 1]\n    \n    # Find the maximum sum of increasing subsequence including the kth element\n    max_sum = 0\n    for j in range(k, n):\n        max_sum = max(max_sum, dp[index][j])\n    \n    return max_sum"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\n    return tuplex[m:n]"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    # Combine the two lists into one\n    combined = nums1 + nums2\n    \n    # Sort the combined list in descending order\n    combined.sort(reverse=True)\n    \n    # Return the N largest products\n    return combined[:N]"}
{"id": "298_0", "code": "def maximum(a,b):\n    \"\"\"\n    This function returns the maximum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of the two numbers.\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    \"\"\"\n    This function converts a given string into a tuple.\n    \n    Parameters:\n    str1 (str): The input string to be converted into a tuple.\n    \n    Returns:\n    tuple: A tuple containing the input string.\n    \"\"\"\n    return (str1,)"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    \"\"\"\n    This function sets the left most unset bit in the binary representation of the input number n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with the left most unset bit set.\n    \"\"\"\n    # Calculate the left most unset bit\n    left_most_unset_bit = n & -n\n    \n    # Return the number with the left most unset bit set\n    return n | left_most_unset_bit"}
{"id": "301_0", "code": "import math\n\ndef volume_cone(r,h):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    r (float): radius of the cone's base\n    h (float): height of the cone\n\n    Returns:\n    float: volume of the cone\n    \"\"\"\n    # Calculate the volume using the formula (1/3)rh\n    volume = (1/3) * math.pi * (r**2) * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize a list to store the maximum sum at each column\n    max_sum = [0] * n\n    \n    # Initialize the maximum sum for the first column\n    max_sum[0] = grid[0][0]\n    \n    # Calculate the maximum sum for each column\n    for i in range(1, n):\n        # The maximum sum for the current column is the maximum of the sum of the current cell and the maximum sum of the previous column,\n        # and the maximum sum of the column before the previous one\n        max_sum[i] = max(max_sum[i-1], max_sum[i-2] + grid[0][i])\n    \n    # Return the maximum sum for the last column\n    return max_sum[-1]"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    \"\"\"\n    This function finds the first maximum length of even word in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The length of the first even word. If no even word is found, returns -1.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n\n    # Initialize the maximum length of even word to -1\n    max_len = -1\n\n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word is even (i.e., its length is even)\n        if len(word) % 2 == 0:\n            # If the word is even and its length is greater than the current max_len, update max_len\n            if len(word) > max_len:\n                max_len = len(word)\n\n    # Return the maximum length of even word\n    return max_len"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    \"\"\"\n    Find the index of the last occurrence of a given number in a sorted array.\n\n    Args:\n        A (list): A sorted list of integers.\n        x (int): The number to find.\n\n    Returns:\n        int: The index of the last occurrence of x in A. If x is not found, returns -1.\n\n    Raises:\n        ValueError: If A is not a list or if x is not an integer.\n    \"\"\"\n    if not isinstance(A, list) or not all(isinstance(i, int) for i in A):\n        raise ValueError(\"A must be a list of integers\")\n    if not isinstance(x, int):\n        raise ValueError(\"x must be an integer\")\n\n    # Initialize two pointers, one at the start and one at the end of the array\n    left, right = 0, len(A) - 1\n\n    # Continue the search until the two pointers meet\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n\n        # If the middle element is equal to x, we need to check if it's the last occurrence\n        if A[mid] == x:\n            # If the middle element is the last element or the next element is not equal to x, return the middle index\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            # Otherwise, move the left pointer to the right of the middle index\n            else:\n                left = mid + 1\n        # If the middle element is less than x, move the left pointer to the right of the middle index\n        elif A[mid] < x:\n            left = mid + 1\n        # If the middle element is greater than x, move the right pointer to the left of the middle index\n        else:\n            right = mid - 1\n\n    # If the loop ends without finding x, return -1\n    return -1"}
{"id": "306_0", "code": "def modified_encode(alist):\n    \"\"\"\n    This function takes a list of integers as input and returns a string representing the modified run-length encoding.\n    \n    Parameters:\n    alist (list): A list of integers.\n    \n    Returns:\n    str: A string representing the modified run-length encoding.\n    \"\"\"\n    if not alist:\n        return \"\"\n    \n    result = \"\"\n    count = 1\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            result += str(count) + alist[i - 1] + \" \"\n            count = 1\n    result += str(count) + alist[-1] + \" \"\n    return result.strip()"}
{"id": "307_0", "code": "def max_volume(s):\n    \"\"\"\n    This function calculates the maximum volume of a cuboid with a given sum of sides.\n\n    Parameters:\n    s (int): The sum of the sides of the cuboid.\n\n    Returns:\n    int: The maximum volume of the cuboid.\n\n    \"\"\"\n    # Initialize the maximum volume\n    max_vol = 0\n\n    # Iterate over all possible lengths\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible widths\n        for width in range(length, (s - length) // 2 + 1):\n            # Calculate the height\n            height = s - length - width\n            # Check if the current dimensions form a valid cuboid\n            if length * width * height == s:\n                # Update the maximum volume\n                max_vol = max(max_vol, length * width * height)\n\n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    \"\"\"\n    This function finds all five characters long words in the given text.\n\n    Args:\n        text (str): The input string to search for words.\n\n    Returns:\n        list: A list of all five characters long words found in the text.\n    \"\"\"\n    # Compile a regex pattern to match five characters long words\n    pattern = re.compile(r'\\b\\w{5}\\b')\n\n    # Find all matches of the pattern in the text\n    matches = pattern.findall(text)\n\n    # Return the list of matches\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    \"\"\"\n    Calculate the difference between the squared sum of first n natural numbers \n    and the sum of squared first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        int: The difference between the two sums.\n    \"\"\"\n    # Calculate the sum of first n natural numbers\n    sum_natural = n * (n + 1) // 2\n    \n    # Calculate the sum of squared first n natural numbers\n    sum_squared = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum = sum_natural ** 2\n    \n    # Calculate the difference between the two sums\n    difference = squared_sum - sum_squared\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    \"\"\"\n    This function finds the demlo number for the given number.\n    \n    Parameters:\n    s (int): The input number.\n    \n    Returns:\n    int: The demlo number for the given number.\n    \"\"\"\n    # Define the demlo numbers\n    demlo_numbers = {\n        1: 1,\n        2: 2,\n        3: 4,\n        4: 8,\n        5: 16,\n        6: 32,\n        7: 64,\n        8: 128,\n        9: 256,\n        10: 512,\n        11: 1024,\n        12: 2048,\n        13: 4096,\n        14: 8192,\n        15: 16384,\n        16: 32768,\n        17: 65536,\n        18: 131072,\n        19: 262144,\n        20: 524288,\n        21: 1048576,\n        22: 2097152,\n        23: 4194304,\n        24: 8388608,\n        25: 16777216,\n        26: 33554432,\n        27: 67108864,\n        28: 134217728,\n        29: 268435456,\n        30: 536870912,\n        31: 1073741824,\n        32: 2147483648,\n        33: 4294967296,\n        34: 8589934592,\n        35: 17179869184,\n        36: 34359738368,\n        37: 68719476736,\n        38: 137438953472,\n        39: 274877906944,\n        40: 549755813888,\n        41: 1099511627776,\n        42: 2199023255552,\n        43: 4398046511104,\n        44: 8796093022208,\n        45: 17592186044416,\n        46: 35184372088832,\n        47: 70368744177664,\n        48: 140737488355328,\n        49: 281474976710656,\n        50: 562949953421312,\n        51: 1125899906842624,\n        52: 2251799813685248,\n        53: 4503599627370496,\n        54: 9007199254740992,\n        55: 18014398509481984,\n        56: 36028797018963968,\n        57: 72057594037927936,\n        58: 144115188075855872,\n        59: 288230376151711744,\n        60: 576460752303423488,\n        61: 1152921504606846976,\n        62: 2305843009213693952,\n        63: 4611686018427387904,\n        64: 9223372036854775808\n    }\n    \n    # Check if the number is in the demlo numbers dictionary\n    if s in demlo_numbers:\n        # Return the demlo number for the given number\n        return demlo_numbers[s]\n    else:\n        # Return a message if the number is not in the demlo numbers dictionary\n        return \"Number not found in demlo numbers dictionary\""}
{"id": "311_0", "code": "def position_min(list1):\n    \"\"\"\n    This function finds all index positions of the minimum values in a given list.\n\n    Args:\n        list1 (list): A list of numbers.\n\n    Returns:\n        list: A list of index positions of the minimum values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    # Find the minimum value in the list\n    min_val = min(list1)\n\n    # Find all index positions of the minimum value\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n\n    return min_indices"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    \"\"\"\n    Re-arranges the given array in alternating positive and negative items.\n\n    Args:\n        arr (list): The input list of integers.\n        n (int): The number of elements to consider for the re-arrangement.\n\n    Returns:\n        list: The re-arranged list with alternating positive and negative items.\n    \"\"\"\n    # Separate positive and negative numbers\n    positive = [x for x in arr if x >= 0]\n    negative = [x for x in arr if x < 0]\n\n    # Initialize the result list\n    result = []\n\n    # Alternate between positive and negative numbers\n    for i in range(min(n, len(positive))):\n        result.append(positive[i])\n        result.append(negative[i])\n\n    # If there are remaining positive numbers, append them to the result\n    if len(positive) > n:\n        result.extend(positive[n:])\n\n    # If there are remaining negative numbers, append them to the result\n    if len(negative) > n:\n        result.extend(negative[:n])\n\n    return result"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    \"\"\"\n    This function calculates the sum of alternate chains of tuples.\n    \n    Args:\n        test_tuple (tuple): A tuple containing tuples as elements.\n    \n    Returns:\n        int: The sum of alternate chains of tuples.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize the index to 0\n    index = 0\n    \n    # Loop through the tuple\n    while index < len(test_tuple):\n        # Add the current tuple to the sum\n        total_sum += test_tuple[index]\n        \n        # Move to the next tuple, incrementing the index by 2\n        index += 2\n    \n    # Return the total sum\n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    \"\"\"\n    This function calculates the minimum number of squares whose sum is equal to a given number.\n    \n    Parameters:\n    n (int): The given number.\n    \n    Returns:\n    int: The minimum number of squares.\n    \"\"\"\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    dp = [float('inf')] * (n + 1)\n    \n    # Base case: 0 can be represented as the sum of 0 squares\n    dp[0] = 0\n    \n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Initialize the minimum number of squares for the current number to infinity\n        min_squares = float('inf')\n        \n        # Iterate over each square number from 1 to the current number\n        j = 1\n        while j * j <= i:\n            # Update the minimum number of squares for the current number\n            min_squares = min(min_squares, dp[i - j * j] + 1)\n            j += 1\n        \n        # Update the minimum number of squares for the current number in the dp list\n        dp[i] = min_squares\n    \n    # Return the minimum number of squares for the given number\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    \n    # Iterate over each string in the test list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # Convert the word to lowercase to ignore case sensitivity\n            word = word.lower()\n            \n            # If the word is already in the dictionary, increment its frequency\n            if word in word_freq:\n                word_freq[word] += 1\n            # If the word is not in the dictionary, add it with a frequency of 1\n            else:\n                word_freq[word] = 1\n                \n    # Find the word with the maximum frequency\n    most_common_word = max(word_freq, key=word_freq.get)\n    \n    # Return the word with the most occurrences\n    return most_common_word"}
{"id": "316_0", "code": "def check_isosceles(x,y,z):\n    # Check if any two sides are equal\n    if x == y or y == z or x == z:\n        # If two sides are equal, check if the third side is equal to the other two\n        if x == y == z:\n            print(\"The triangle is equilateral.\")\n        else:\n            print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is scalene.\")"}
{"id": "317_0", "code": "def rotate_left(list1, m, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the left direction.\n\n    Args:\n        list1 (list): The input list to be rotated.\n        m (int): The number of items to rotate to the left.\n        n (int): The number of items to rotate to the right.\n\n    Returns:\n        list: The rotated list.\n    \"\"\"\n    # Calculate the effective rotation number\n    effective_rotation = (m - n) % len(list1)\n    \n    # Split the list into two parts\n    first_part = list1[effective_rotation:]\n    second_part = list1[:effective_rotation]\n    \n    # Combine the two parts in reverse order\n    rotated_list = second_part + first_part\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    \"\"\"\n    This function counts the number of negative numbers in a given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The number of negative numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num < 0)"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Define the pattern for three, four, five characters long words\n    pattern = r'\\b\\w{3,5}\\b'\n\n    # Find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n\n    return matches"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    \"\"\"\n    This function counts the number of unset bits in a given integer.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The number of unset bits in the input integer.\n    \"\"\"\n    # Initialize a counter for unset bits\n    unset_bits = 0\n    \n    # Loop through each bit in the binary representation of n\n    while n:\n        # Use the bitwise AND operator (&) with 1 to check if the least significant bit is 0\n        # If the result is 0, it means the least significant bit is 0 (unset), so increment the counter\n        unset_bits += n & 1\n        \n        # Right shift the number by 1 bit to move to the next bit\n        n >>= 1\n    \n    # Return the total count of unset bits\n    return unset_bits"}
{"id": "321_0", "code": "def char_frequency(str1):\n    \"\"\"\n    This function calculates the frequency of each character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store character frequencies\n    freq_dict = {}\n\n    # Iterate over each character in the input string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in freq_dict:\n            freq_dict[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[char] = 1\n\n    # Return the dictionary containing character frequencies\n    return freq_dict"}
{"id": "322_0", "code": "def Sort(sub_li):\n    return sorted(sub_li, key=lambda x: x[1])"}
{"id": "323_0", "code": "def check_Validity(a,b,c):\n    # Check if the sides can form a triangle\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "324_0", "code": "def ap_sum(a,n,d):\n    \"\"\"\n    This function calculates the sum of an arithmetic progression.\n\n    Parameters:\n    a (int): The first term of the arithmetic progression.\n    n (int): The number of terms in the arithmetic progression.\n    d (int): The common difference of the arithmetic progression.\n\n    Returns:\n    int: The sum of the arithmetic progression.\n    \"\"\"\n    # Calculate the sum using the formula for the sum of an arithmetic progression\n    total = (n/2) * (2*a + (n-1)*d)\n    return int(total)"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    monthdays = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname1 in monthdays:\n        if monthdays[monthname1] == 28:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\""}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    # Define the pattern\n    pattern = r'\\b\\w+(?=[\\s.,!?]|$)'\n    \n    # Use the pattern to search for a match\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the matched word\n    if match:\n        return match.group()\n    else:\n        return None"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i] == s[j - 1]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    \"\"\"\n    This function finds the maximum occurring divisor in the interval [x, y].\n    \n    Parameters:\n    x (int): The start of the interval.\n    y (int): The end of the interval.\n    \n    Returns:\n    int: The maximum occurring divisor in the interval [x, y].\n    \"\"\"\n    \n    # Initialize an empty dictionary to store the frequency of each divisor\n    divisor_freq = {}\n    \n    # Iterate over the interval [x, y]\n    for i in range(x, y + 1):\n        # Iterate from 1 to the square root of i\n        for j in range(1, int(i ** 0.5) + 1):\n            # Check if j is a divisor of i\n            if i % j == 0:\n                # If j is a divisor, increment its frequency in the dictionary\n                if j in divisor_freq:\n                    divisor_freq[j] += 1\n                else:\n                    divisor_freq[j] = 1\n                \n                # If i // j is not equal to j, it's also a divisor, so increment its frequency\n                if i // j != j:\n                    if i // j in divisor_freq:\n                        divisor_freq[i // j] += 1\n                    else:\n                        divisor_freq[i // j] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(divisor_freq.values())\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [divisor for divisor, freq in divisor_freq.items() if freq == max_freq]\n    \n    # Return the maximum occurring divisor\n    return max(max_divisors)"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    \"\"\"\n    This function calculates the sum of the three smallest positive numbers from a given list of numbers.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of the three smallest positive numbers.\n\n    Raises:\n        ValueError: If the list is empty or contains only non-positive numbers.\n    \"\"\"\n    # Check if the list is empty\n    if not lst:\n        raise ValueError(\"The list is empty\")\n\n    # Filter out non-positive numbers\n    positive_nums = [num for num in lst if num > 0]\n\n    # Check if there are at least three positive numbers\n    if len(positive_nums) < 3:\n        raise ValueError(\"The list contains only non-positive numbers or less than three positive numbers\")\n\n    # Sort the positive numbers in ascending order\n    positive_nums.sort()\n\n    # Return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    \"\"\"\n    This function converts a given set into ordered tuples.\n\n    Args:\n        s (set): The input set to be converted.\n\n    Returns:\n        list: A list of ordered tuples.\n    \"\"\"\n    return list(s)"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Create a set to store the elements we have seen so far\n    seen = set()\n    \n    # Initialize the minimum range\n    min_range = float('inf')\n    \n    # Initialize the left pointer\n    left = 0\n    \n    # Iterate over the lists\n    for lst in lists:\n        # Iterate over the elements in the current list\n        for element in lst:\n            # If the element is not in the seen set\n            if element not in seen:\n                # Add the element to the seen set\n                seen.add(element)\n                # Add the element to the unique elements set\n                unique_elements.add(element)\n                # Update the minimum range\n                min_range = min(min_range, len(lst) - left)\n            # If the element is in the seen set\n            else:\n                # Remove the element from the unique elements set\n                unique_elements.remove(element)\n                # Move the left pointer to the right\n                left += 1\n    \n    # Return the minimum range\n    return min_range"}
{"id": "332_0", "code": "def dig_let(s):\n    \"\"\"\n    Calculate the number of digits and letters in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    tuple: A tuple containing the number of digits and letters in the string.\n    \"\"\"\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n,m):\n    count = 0\n    for i in range(n,m):\n        if i % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    \"\"\"\n    This function calculates the difference between two consecutive numbers in a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of differences between consecutive numbers.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"Input list must have at least two elements.\")\n\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]"}
{"id": "335_0", "code": "def zigzag(n, k):\n    # Calculate the number of zigzag sequences\n    num_sequences = n // k\n    \n    # Calculate the number of remaining elements\n    remaining_elements = n % k\n    \n    # Initialize the result\n    result = 0\n    \n    # Calculate the number of zigzag sequences\n    for i in range(num_sequences):\n        # Calculate the number of elements in the current sequence\n        sequence_length = k - 1\n        \n        # Calculate the number of elements in the remaining sequence\n        remaining_sequence_length = k - remaining_elements + 1\n        \n        # Calculate the number of zigzag sequences with the current sequence length\n        sequence_count = (k - 1) ** i\n        \n        # Calculate the number of zigzag sequences with the remaining sequence length\n        remaining_sequence_count = (k - remaining_elements + 1) ** (num_sequences - i - 1)\n        \n        # Update the result\n        result += sequence_count * sequence_length + remaining_sequence_count * remaining_sequence_length\n    \n    return result"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares in the rectangle\n    # m is the number of rows\n    # n is the number of columns\n    return m * n"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a 2D array to store the number of ways to get prefix sums\n    dp = [[0 for _ in range(M + 1)] for _ in range(M + 1)]\n    \n    # Base case: there is one way to get a prefix sum of 0 (by not using any numbers)\n    dp[0][0] = 1\n    \n    # For each possible prefix sum from 1 to M\n    for i in range(1, M + 1):\n        # For each possible number from 1 to i\n        for j in range(1, i + 1):\n            # For each possible previous prefix sum from 0 to i - j\n            for k in range(j):\n                # Update the number of ways to get the current prefix sum\n                dp[i][j] += dp[k][j - 1]\n    \n    # The number of ways to get a prefix sum of M is stored in dp[M][M]\n    return dp[M][M]"}
{"id": "338_0", "code": "def check(string):\n    \"\"\"\n    This function checks whether the given string is a binary string or not.\n    \n    A binary string is a string that contains only '0's and '1's.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string is a binary string, False otherwise.\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Check if the string contains only '0's and '1's\n    if set(string).issubset({'0', '1'}):\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Initialize the minimum length and the character to remove\n    min_length = float('inf')\n    char_to_remove = None\n\n    # Iterate over each character and its frequency\n    for char, freq in char_frequency.items():\n        # If the frequency is more than half of the string length, we can remove it\n        if freq > len(s) / 2:\n            # Update the minimum length and the character to remove\n            min_length = min(min_length, len(s) - freq)\n            char_to_remove = char\n\n    # If no character can be removed, return the original string\n    if min_length == float('inf'):\n        return s\n    else:\n        # Return the string with the character to remove\n        return s.replace(char_to_remove, '')"}
{"id": "340_0", "code": "from collections import Counter\n\ndef first_Element(arr,n,k):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = Counter(arr)\n    \n    # Iterate through the array to find the first element occurring k times\n    for i in range(n):\n        if freq_dict[arr[i]] == k:\n            return arr[i]\n    return None"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Convert the string to a set\n    unique_chars = set(str)\n    \n    # Check if the length of the set is equal to the length of the string\n    if len(unique_chars) == len(str):\n        return True\n    else:\n        return False"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    \"\"\"\n    Removes a specified column from a given nested list.\n\n    Args:\n        list1 (list): The input nested list.\n        n (int): The index of the column to be removed.\n\n    Returns:\n        list: The modified nested list with the specified column removed.\n    \"\"\"\n    # Check if the input list is empty\n    if not list1:\n        return list1\n\n    # Check if the column index is within the valid range\n    if n < 0 or n >= len(list1[0]):\n        raise ValueError(\"Invalid column index\")\n\n    # Use list comprehension to create a new list without the specified column\n    return [row[:n] + row[n+1:] for row in list1]"}
{"id": "343_0", "code": "def tn_ap(a,n,d):\n    \"\"\"\n    This function calculates the t-nth term of an arithmetic progression.\n    \n    Parameters:\n    a (float): The first term of the arithmetic progression.\n    n (int): The term number to be calculated.\n    d (float): The common difference of the arithmetic progression.\n    \n    Returns:\n    float: The t-nth term of the arithmetic progression.\n    \"\"\"\n    # Check if the inputs are valid\n    if not isinstance(a, (int, float)) or not isinstance(n, int) or not isinstance(d, (int, float)):\n        raise TypeError(\"Invalid input type. a should be a number, n should be an integer and d should be a number.\")\n    if n <= 0 or d == 0:\n        raise ValueError(\"Invalid input value. n should be a positive integer and d should be a non-zero number.\")\n    \n    # Calculate the t-nth term using the formula: a + (n-1)*d\n    t_n = a + (n-1)*d\n    \n    return t_n"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    \"\"\"\n    Calculate the number of rectangles in a circle of radius r.\n\n    The number of rectangles is calculated by dividing the circle into 4 equal quadrants,\n    and then counting the number of rectangles in each quadrant.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    int: The number of rectangles in the circle.\n    \"\"\"\n    # Calculate the area of the circle\n    circle_area = math.pi * radius ** 2\n    \n    # Calculate the area of each rectangle\n    rectangle_area = 2 * radius ** 2\n    \n    # Calculate the number of rectangles in the circle\n    num_rectangles = circle_area / rectangle_area\n    \n    # Since we can't have a fraction of a rectangle, we round down to the nearest whole number\n    num_rectangles = math.floor(num_rectangles)\n    \n    return num_rectangles"}
{"id": "345_0", "code": "def find_angle(a,b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    c = 180 - a - b\n    return c"}
{"id": "346_0", "code": "def find_max(test_list):\n    return max(test_list)"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    return list(map(lambda x, y: (x % y), nums1, nums2))"}
{"id": "348_0", "code": "import math\n\ndef Check_Solution(a,b,c):\n    # Calculate the discriminant\n    D = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if D < 0:\n        return \"This equation has no real solutions.\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(D)) / (2*a)\n    root2 = (-b - math.sqrt(D)) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return \"One root is twice the other.\"\n    else:\n        return \"No root is twice the other.\""}
{"id": "349_0", "code": "def get_carol(n):\n    \"\"\"\n    Returns the nth carol number.\n\n    The carol numbers are generated using the formula:\n    C(n) = (n-1)! / (n-2)! = n-1\n\n    :param n: The position of the carol number to find.\n    :return: The nth carol number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n - 1"}
{"id": "350_0", "code": "def remove_empty(list1):\n    \"\"\"\n    Removes empty lists from a given list of lists.\n\n    Args:\n        list1 (list): A list of lists.\n\n    Returns:\n        list: The input list with empty lists removed.\n    \"\"\"\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    This function finds the item with maximum occurrences in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum occurrences.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the number with maximum count\n    max_count = max(count_dict.values())\n    max_num = [num for num, count in count_dict.items() if count == max_count]\n\n    # Return the first number with maximum count\n    return max_num[0]"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    \"\"\"\n    This function adds K elements to each element in the tuple.\n\n    Args:\n        test_list (tuple): The input tuple.\n        K (int): The number of elements to add.\n\n    Returns:\n        list: A list of tuples, where each tuple contains the original element and the element with K added.\n    \"\"\"\n    result = []\n    for element in test_list:\n        new_element = element + K\n        result.append((element, new_element))\n    return result"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(s):\n    \"\"\"\n    This function calculates the minimum number of flips required to make a binary string a sequence of alternate characters.\n    \n    Parameters:\n    s (str): The input binary string.\n    \n    Returns:\n    int: The minimum number of flips required.\n    \"\"\"\n    flips = 0\n    prev_char = None\n    for char in s:\n        if char == '0' and prev_char == '0':\n            flips += 1\n        elif char == '1' and prev_char == '1':\n            flips += 1\n        prev_char = char\n    return flips"}
{"id": "354_0", "code": "def count_Digit(n):\n    # Convert the number to a string to easily count the digits\n    str_n = str(n)\n    \n    # Use the built-in len() function to count the number of digits\n    count = len(str_n)\n    \n    # Return the count\n    return count"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    \"\"\"\n    This function calculates the largest product of the pair of adjacent elements \n    from a given list of integers.\n\n    Args:\n        list_nums (list): A list of integers.\n\n    Returns:\n        int: The largest product of the pair of adjacent elements.\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(list_nums) < 2:\n        raise ValueError(\"Input list must have at least two elements.\")\n\n    max_product = float('-inf')  # Initialize max_product as negative infinity\n\n    # Iterate over the list of numbers, considering each number and the next one\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        # Update max_product if the current product is larger\n        if product > max_product:\n            max_product = product\n\n    return max_product"}
{"id": "356_0", "code": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_tree_balanced(root):\n    def check_balance(node):\n        if node is None:\n            return (True, 0)\n        left_balanced, left_height = check_balance(node.left)\n        right_balanced, right_height = check_balance(node.right)\n        if not left_balanced or not right_balanced:\n            return (False, 0)\n        return (abs(left_height - right_height) <= 1, max(left_height, right_height) + 1)\n\n    return check_balance(root)[0]"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    \"\"\"\n    Repeat the given tuple n times.\n\n    Args:\n        test_tup (tuple): The tuple to be repeated.\n        N (int): The number of times to repeat the tuple.\n\n    Returns:\n        list: A list of tuples, each containing the elements of the original tuple N times.\n    \"\"\"\n    return [tuple(test_tup) for _ in range(N)]"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l,w,h):\n    # Calculate the lateral surface area of the cuboid\n    lateral_surface_area = 2 * (l * h + w * h + l * w)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    \"\"\"\n    Sorts a tuple by its float element.\n\n    Args:\n        price (tuple): A tuple containing a float value.\n\n    Returns:\n        tuple: A sorted tuple of float values.\n    \"\"\"\n    return tuple(sorted(price, key=lambda x: float(x)))"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    \"\"\"\n    This function finds the smallest missing element in a sorted array.\n    \n    Parameters:\n    A (list): The input sorted array.\n    left_element (int): The left boundary of the search range.\n    right_element (int): The right boundary of the search range.\n    \n    Returns:\n    int: The smallest missing element in the array.\n    \"\"\"\n    \n    # Initialize the left and right pointers\n    left = left_element\n    right = right_element\n    \n    # Continue the search until the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the middle index, it means the middle element is the smallest missing element\n        if A[mid] == mid + left_element:\n            return mid + left_element\n        \n        # If the middle element is greater than the middle index, it means the smallest missing element is in the left half\n        elif A[mid] > mid + left_element:\n            right = mid - 1\n        \n        # If the middle element is less than the middle index, it means the smallest missing element is in the right half\n        else:\n            left = mid + 1\n    \n    # If the loop ends, it means the smallest missing element is the left element plus the left boundary\n    return left + left_element"}
{"id": "361_0", "code": "import heapq\n\ndef heap_ascending(nums):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements in ascending order.\n    \"\"\"\n    # Create a min heap from the input list\n    heapq.heapify(nums)\n\n    # Initialize an empty list to store the sorted elements\n    sorted_nums = []\n\n    # While the heap is not empty, pop the smallest element and add it to the sorted list\n    while nums:\n        sorted_nums.append(heapq.heappop(nums))\n\n    return sorted_nums\n\n# Example usage:\nnumbers = [64, 34, 25, 12, 22, 11, 90]\nprint(heap_ascending(numbers))  # Output: [11, 12, 22, 25, 34, 64, 90]"}
{"id": "362_0", "code": "def volume_cuboid(length, width, height):\n    \"\"\"\n    This function calculates the volume of a cuboid.\n\n    Parameters:\n    length (float): The length of the cuboid.\n    width (float): The width of the cuboid.\n    height (float): The height of the cuboid.\n\n    Returns:\n    float: The volume of the cuboid.\n    \"\"\"\n    # Calculate the volume by multiplying the length, width, and height\n    volume = length * width * height\n    return volume"}
{"id": "363_0", "code": "def permute_string(str):\n    def backtrack(start, end):\n        if start == end:\n            print(str)\n        for i in range(start, end):\n            str = str[:i] + str[i+1:] + str[i]\n            backtrack(i+1, end)\n\n    backtrack(0, len(str))"}
{"id": "364_0", "code": "def round_num(n,m):\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is less than half of m, round down\n    if remainder < m / 2:\n        return n - remainder\n    # If the remainder is greater than or equal to half of m, round up\n    else:\n        return n + (m - remainder)"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    # Create a dictionary to store the count of each element in the tuple\n    count_dict = {}\n    \n    # Iterate over the tuple and count the occurrence of each element\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    \n    # Create a new tuple with unique elements and their custom replacement value\n    new_tup = []\n    for element, count in count_dict.items():\n        if count == 1:\n            new_tup.append(element)\n        else:\n            new_tup.append((element, \"REPLICA\"))\n    \n    # Return the new tuple\n    return tuple(new_tup)"}
{"id": "366_0", "code": "def remove_Char(s,c):\n    \"\"\"\n    Removes all occurrences of a character in a given string.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to be removed.\n\n    Returns:\n    str: The string with all occurrences of the character removed.\n    \"\"\"\n    return s.replace(c, '')"}
{"id": "367_0", "code": "def move_first(test_list):\n    \"\"\"\n    Shifts the last element to the first position in the given list.\n\n    Args:\n        test_list (list): The input list.\n\n    Returns:\n        list: The modified list with the last element shifted to the first position.\n    \"\"\"\n    if len(test_list) > 0:\n        # Remove the last element from the list\n        last_element = test_list.pop()\n        # Insert the removed element at the beginning of the list\n        test_list.insert(0, last_element)\n    return test_list"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    Calculate the surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: surface area of the cuboid\n    \"\"\"\n    # Calculate the surface area of the cuboid\n    surface_area = 2 * (l * w + l * h + w * h)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum, colnum):\n    \"\"\"\n    This function generates a two-dimensional array with the specified number of rows and columns.\n    \n    Parameters:\n    rownum (int): The number of rows in the array.\n    colnum (int): The number of columns in the array.\n    \n    Returns:\n    list: A two-dimensional list (array) with the specified number of rows and columns.\n    \"\"\"\n    # Initialize an empty list to store the rows\n    result = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Initialize an empty list to store the columns in the current row\n        row = []\n        \n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append a default value (e.g., 0) to the current row\n            row.append(0)\n        \n        # Append the current row to the result\n        result.append(row)\n    \n    # Return the generated array\n    return result"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists based on a given index of the inner list.\n\n    Args:\n        list_data (list): A list of lists to be sorted.\n        index_no (int): The index of the inner list to sort by.\n\n    Returns:\n        list: The sorted list of lists.\n    \"\"\"\n    return sorted(list_data, key=lambda x: x[index_no])"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    n = len(A)\n    low = 0\n    high = n - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == 0 or A[mid] >= A[0]:\n            if A[0] <= A[mid]:\n                return mid\n            else:\n                low = mid + 1\n        else:\n            if A[mid] > A[0]:\n                high = mid - 1\n            else:\n                low = mid + 1\n    return -1"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    This function takes an integer as input, toggles all odd bits of the number and returns the result.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The integer with all odd bits toggled.\n    \"\"\"\n    # Initialize result as 0\n    result = 0\n    \n    # Iterate over each bit in the binary representation of n\n    for i in range(32):  # Assuming 32-bit integer\n        # Get the ith bit of n\n        bit = (n >> i) & 1\n        \n        # If the bit is odd (1), toggle it by setting it to 0\n        if bit == 1:\n            result |= ~(1 << i)\n        # If the bit is even (0), keep it as it is\n        else:\n            result |= 1 << i\n    \n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the smallest value in the array\n    smallest = min(arr)\n\n    # Count the frequency of the smallest value\n    count = arr.count(smallest)\n\n    return count"}
{"id": "374_0", "code": "def get_perrin(n):\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n\n    # Recursive case\n    else:\n        return get_perrin(n-1) + get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    # Initialize variables to keep track of opening and closing brackets\n    open_brackets = 0\n    close_brackets = 0\n    # Initialize a variable to keep track of the minimum number of swaps\n    min_swaps = 0\n    \n    # Iterate over the string\n    for char in s:\n        # If the character is an opening bracket, increment the open_brackets counter\n        if char == '(':\n            open_brackets += 1\n        # If the character is a closing bracket, increment the close_brackets counter\n        elif char == ')':\n            close_brackets += 1\n            # If there are more closing brackets than opening brackets, increment the min_swaps counter\n            if close_brackets > open_brackets:\n                min_swaps += 1\n                # Decrement the close_brackets counter to account for the swap\n                close_brackets -= 1\n    \n    # Return the minimum number of swaps\n    return min_swaps"}
{"id": "376_0", "code": "def even_or_odd(N):\n    # Convert the hexadecimal number to decimal\n    decimal_N = int(N, 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal_N % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function calculates the highest power of 2 that is less than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Initialize the power of 2 to 1\n    power_of_2 = 1\n    \n    # Keep doubling the power of 2 until it exceeds n\n    while power_of_2 <= n:\n        # Double the power of 2\n        power_of_2 *= 2\n    \n    # The highest power of 2 that is less than or equal to n is the previous power of 2\n    return power_of_2 // 2"}
{"id": "378_0", "code": "def find_lucas(n):\n    \"\"\"\n    This function calculates the nth Lucas number.\n    \n    Args:\n    n (int): The position of the Lucas number to be calculated.\n    \n    Returns:\n    int: The nth Lucas number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input should be a positive integer.\")\n    \n    # Initialize the first two Lucas numbers\n    a, b = 2, 1\n    \n    # Calculate the nth Lucas number\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b"}
{"id": "379_0", "code": "def add_string(lst, string):\n    \"\"\"\n    Inserts a given string at the beginning of all items in a list.\n\n    Args:\n        lst (list): The input list.\n        string (str): The string to be inserted.\n\n    Returns:\n        list: The modified list with the string inserted at the beginning of each item.\n    \"\"\"\n    return [string + item for item in lst]"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a nested dictionary.\n    \n    Args:\n        l1 (list): The first list to be converted.\n        l2 (list): The second list to be converted.\n        l3 (list): The third list to be converted.\n    \n    Returns:\n        dict: A nested dictionary with the input lists as keys.\n    \"\"\"\n    # Initialize an empty dictionary\n    nested_dict = {}\n    \n    # Iterate over the first list\n    for i, val in enumerate(l1):\n        # Create a new dictionary for each value in the first list\n        nested_dict[val] = {}\n        \n        # Iterate over the second list\n        for j, val2 in enumerate(l2):\n            # Create a new dictionary for each value in the second list\n            nested_dict[val][val2] = {}\n            \n            # Iterate over the third list\n            for k, val3 in enumerate(l3):\n                # Add the value from the third list to the nested dictionary\n                nested_dict[val][val2][val3] = val * val2 * val3\n    \n    # Return the nested dictionary\n    return nested_dict"}
{"id": "381_0", "code": "def get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 1:\n            return x\n        max_sum = 0\n        for i in [2, 3, 4, 5]:\n            if x % i == 0:\n                max_sum = max(max_sum, f(x // i) + f(i))\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    \"\"\"\n    This function checks if the given tuple is distinct or not.\n    \n    Args:\n        test_tup (tuple): The tuple to be checked for distinctness.\n    \n    Returns:\n        bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set\n    set_tup = set(test_tup)\n    \n    # Compare the length of the original tuple with the length of the set\n    # If they are equal, it means all elements in the tuple are distinct\n    return len(test_tup) == len(set_tup)"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over the string to count the frequency of each character\n    for char in str1:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Iterate over the string again to find the first non-repeated character\n    for char in str1:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    \"\"\"\n    This function checks whether the given string starts and ends with the same character.\n    \n    Parameters:\n    string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string starts and ends with the same character, False otherwise.\n    \"\"\"\n    \n    # Compile a regex pattern that matches the start and end of the string with the same character\n    pattern = re.compile(r'^([a-zA-Z])\\1$')\n    \n    # Use the pattern to match the string\n    match = pattern.match(string)\n    \n    # If the string matches the pattern, return True; otherwise, return False\n    return match is not None"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    \"\"\"\n    This function calculates the median of three numbers.\n\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    c (float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n    \"\"\"\n    # First, we sort the three numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Then, we find the middle number(s)\n    middle_index = len(numbers) // 2\n    \n    # If the length of the numbers list is odd, the median is the middle number\n    if len(numbers) % 2 != 0:\n        median = numbers[middle_index]\n    # If the length of the numbers list is even, the median is the average of the two middle numbers\n    else:\n        median = (numbers[middle_index - 1] + numbers[middle_index]) / 2\n    \n    return median"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    \"\"\"\n    This function calculates the sum of digits of each number in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of sums of digits of each number in the input list.\n    \"\"\"\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the bitwise XOR operation across the given tuples.\n    \n    Args:\n        test_tup1 (tuple): The first tuple to perform the XOR operation on.\n        test_tup2 (tuple): The second tuple to perform the XOR operation on.\n    \n    Returns:\n        tuple: A new tuple containing the result of the XOR operation between the two input tuples.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the input tuples\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        # Perform the bitwise XOR operation on the current elements\n        xor_result = elem1 ^ elem2\n        \n        # Append the result to the list\n        result.append(xor_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "389_0", "code": "from collections import Counter\nfrom itertools import combinations\n\ndef extract_freq(test_list):\n    # Generate all possible tuples of the given list\n    all_tuples = list(combinations(test_list, 2))\n    \n    # Count the frequency of each tuple\n    freq_dict = Counter(all_tuples)\n    \n    # Return the frequency of unique tuples\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise addition of tuple elements in the given two nested tuples.\n\n    Args:\n        test_tup1 (tuple): The first nested tuple.\n        test_tup2 (tuple): The second nested tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise addition of the elements in the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the elements at the current index are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function for the nested tuples\n            nested_result = add_nested_tuples(test_tup1[i], test_tup2[i])\n            # Append the result to the main result list\n            result.append(nested_result)\n        else:\n            # Check if the elements at the current index are numbers\n            if isinstance(test_tup1[i], (int, float)) and isinstance(test_tup2[i], (int, float)):\n                # Perform the addition and append the result to the main result list\n                result.append(test_tup1[i] + test_tup2[i])\n            else:\n                # If the elements are not numbers, raise a ValueError\n                raise ValueError(\"All elements in the input tuples must be numbers\")\n\n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    Args:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The prime number.\n\n    Returns:\n    int: The value of ncr%p.\n\n    \"\"\"\n    # Initialize the result\n    res = 1\n    \n    # Calculate the power of p\n    p_pow = pow(p, r, p)\n    \n    # Calculate the power of (n-r)\n    n_r_pow = pow(p, n-r, p)\n    \n    # Calculate the power of (n-r+1)\n    n_r_pow1 = pow(p, n-r+1, p)\n    \n    # Calculate the value of ncr%p\n    res = (res * p_pow * n_r_pow * n_r_pow1) % p\n    \n    return res"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    \"\"\"\n    Checks if a given URL is valid or not using regex.\n\n    Args:\n        str (str): The URL to be checked.\n\n    Returns:\n        bool: True if the URL is valid, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match a valid URL\n    pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    # Check if the URL matches the pattern\n    return bool(pattern.match(str))"}
{"id": "393_0", "code": "def minimum(a, b):\n    \"\"\"\n    This function returns the minimum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of a and b.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be searched.\n        tuple1 (tuple): The tuple to be searched in.\n\n    Returns:\n        bool: True if the element exists, False otherwise.\n    \"\"\"\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    \"\"\"\n    This function calculates the parity of a given number.\n    \n    Parameters:\n    x (int): The input number.\n    \n    Returns:\n    str: The parity of the number ('Even' or 'Odd').\n    \"\"\"\n    if x % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(x) for x in str(n)]\n    \n    # Find the first pair of digits from the right that are in increasing order\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            break\n    else:\n        # If no such pair is found, the number is already the biggest possible\n        return n\n    \n    # Find the smallest digit to the right of the pair that is greater than the first digit of the pair\n    for j in range(len(digits) - 1, i, -1):\n        if digits[j] > digits[i]:\n            break\n    \n    # Swap the two digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the pair in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number\n    return int(''.join(map(str, digits)))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    \"\"\"\n    Find k number of pairs which consist of one element from the first array and one element from the second array.\n\n    Args:\n        nums1 (list): The first list of numbers.\n        nums2 (list): The second list of numbers.\n        k (int): The number of pairs to find.\n\n    Returns:\n        list: A list of pairs, where each pair is a tuple of two numbers.\n    \"\"\"\n    # Combine the two lists into a list of pairs\n    pairs = list(zip(nums1, nums2))\n    \n    # Sort the pairs based on the sum of the elements in each pair\n    pairs.sort(key=lambda x: x[0] + x[1])\n    \n    # Return the k smallest pairs\n    return pairs[:k]"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    \"\"\"\n    This function finds the minimum product from the pairs of tuples within a given list.\n    \n    Parameters:\n    list1 (list): A list of tuples.\n    \n    Returns:\n    int: The minimum product from the pairs of tuples.\n    \"\"\"\n    \n    # Initialize the minimum product as infinity\n    min_product = float('inf')\n    \n    # Iterate over each pair of tuples in the list\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = list1[i][0] * list1[j][0]\n            \n            # Update the minimum product if the current product is smaller\n            min_product = min(min_product, product)\n    \n    # Return the minimum product\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    \"\"\"\n    This function finds the minimum value in a given heterogeneous list.\n    \n    Parameters:\n    listval (list): A list containing heterogeneous elements.\n    \n    Returns:\n    The minimum value in the list.\n    \"\"\"\n    # Check if the list is empty\n    if not listval:\n        return None\n    \n    # Initialize the minimum value with the first element of the list\n    min_val = listval[0]\n    \n    # Iterate over the list to find the minimum value\n    for val in listval:\n        # Check if the current value is smaller than the minimum value\n        if val < min_val:\n            min_val = val\n    \n    # Return the minimum value\n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    \"\"\"\n    Convert a snake case string to camel case string.\n\n    Args:\n        word (str): The input snake case string.\n\n    Returns:\n        str: The converted camel case string.\n    \"\"\"\n    # Split the input string into words using regex\n    words = re.split(r'(?<!^)(?=[A-Z])', word)\n    \n    # Capitalize the first letter of each word except the first one\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words into a single string\n    camel_case = ''.join(words)\n    \n    return camel_case"}
{"id": "401_0", "code": "def remove_odd(l):\n    \"\"\"\n    This function removes all odd numbers from a given list.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A new list containing only the even numbers from the original list.\n    \"\"\"\n    return [i for i in l if i % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    \"\"\"\n    This function extracts the nth element from a given list of tuples.\n\n    Args:\n        list1 (list): A list of tuples.\n        n (int): The position of the element to be extracted.\n\n    Returns:\n        The nth element from the list of tuples. If n is out of range, returns None.\n    \"\"\"\n    # Check if n is within the valid range\n    if n < 1 or n > len(list1):\n        return None\n    \n    # Return the nth element\n    return list1[n-1]"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    \"\"\"\n    This function checks if a value exists in a sequence or not.\n\n    Args:\n        list1 (list): The first sequence to check.\n        list2 (list): The second sequence to check.\n\n    Returns:\n        bool: True if the value exists in either sequence, False otherwise.\n    \"\"\"\n    return list1 in [list2] or list2 in [list1]"}
{"id": "404_0", "code": "def max_Product(arr):\n    \"\"\"\n    This function finds the pair with the highest product in a given array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    tuple: A tuple containing the pair with the highest product and the product value.\n\n    \"\"\"\n    # First, sort the array in ascending order\n    arr.sort()\n\n    # The maximum product can be either the product of the two largest numbers or the product of the two smallest numbers (in case they are negative)\n    # So, we need to consider both cases\n    max_product = max(arr[-1] * arr[-2], arr[0] * arr[1])\n\n    # Return the pair with the highest product and the product value\n    return (arr[-1], arr[-2], max_product)"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than 3, return n\n    if n < 3:\n        return n\n\n    # Recursive case: try dividing n into three parts\n    max_sum = float('-inf')\n    for i in range(1, n // 3 + 1):\n        # Calculate the sum of the three parts\n        sum1 = i\n        sum2 = n - i - 1\n        sum3 = n - i - sum2\n        # Recursively find the maximum sum for each part\n        sum1 += breakSum(sum1)\n        sum2 += breakSum(sum2)\n        sum3 += breakSum(sum3)\n        # Update the maximum sum\n        max_sum = max(max_sum, sum1 + sum2 + sum3)\n\n    return max_sum"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize an empty dictionary to store the tuples\n    tuple_dict = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Convert the tuple to a string to use as a dictionary key\n        tup_str = str(tup)\n        \n        # If the tuple is already in the dictionary, append it to the list\n        if tup_str in tuple_dict:\n            tuple_dict[tup_str].append(tup)\n        # If the tuple is not in the dictionary, add it with a list containing the tuple\n        else:\n            tuple_dict[tup_str] = [tup]\n    \n    # Initialize an empty list to store the common first elements\n    common_first_elements = []\n    \n    # Iterate over each tuple in the input list again\n    for tup in Input:\n        # Convert the tuple to a string to use as a dictionary key\n        tup_str = str(tup)\n        \n        # Get the list of tuples from the dictionary\n        tup_list = tuple_dict[tup_str]\n        \n        # Get the first element of the tuple\n        first_element = tup[0]\n        \n        # Check if the first element is already in the list of common first elements\n        if first_element not in common_first_elements:\n            common_first_elements.append(first_element)\n    \n    # Return the list of common first elements\n    return common_first_elements"}
{"id": "407_0", "code": "def Find_Max(lst):\n    \"\"\"\n    This function finds the sublist having maximum length in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: The sublist with maximum length.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return []\n\n    max_len = 0  # Initialize the maximum length\n    max_sublist = []  # Initialize the maximum sublist\n\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]  # Generate the current sublist\n            if len(sublist) > max_len:  # Check if the current sublist is longer\n                max_len = len(sublist)  # Update the maximum length\n                max_sublist = sublist  # Update the maximum sublist\n\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    # Round each number in the list and calculate the sum\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    \n    # Calculate the product of the sum and the length of the list\n    product = total_sum * len(list1)\n    \n    # Print the result\n    print(product)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    \"\"\"\n    This function calculates the sum of cubes of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The sum of cubes of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Calculate the cube of the current number\n        cube = i ** 3\n        # Add the cube to the total sum\n        total_sum += cube\n    \n    # Return the total sum\n    return total_sum"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    \"\"\"\n    Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        test_tup (tuple): The input tuple to be concatenated.\n\n    Returns:\n        str: A string containing the concatenated elements of the tuple.\n    \"\"\"\n    delimiter = ', '  # Define the delimiter\n    concatenated_str = delimiter.join(map(str, test_tup))  # Use join() to concatenate the elements\n    return concatenated_str"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to consider.\n    \n    Returns:\n    float: The average of cubes of first n natural numbers.\n    \"\"\"\n    # Initialize sum variable to store the sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing the sum by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    \"\"\"\n    This function calculates the maximum gold that can be obtained from a given 2D grid of gold.\n    \n    Parameters:\n    gold (list): A 2D list representing the grid of gold.\n    m (int): The number of rows in the grid.\n    n (int): The number of columns in the grid.\n    \n    Returns:\n    int: The maximum gold that can be obtained.\n    \"\"\"\n    \n    # Create a 2D list to store the maximum gold that can be obtained at each position\n    max_gold = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first element of max_gold with the gold value at the first position\n    max_gold[0][0] = gold[0][0]\n    \n    # Fill the first row of max_gold\n    for i in range(1, n):\n        max_gold[0][i] = max_gold[0][i-1] + gold[0][i]\n    \n    # Fill the first column of max_gold\n    for i in range(1, m):\n        max_gold[i][0] = max_gold[i-1][0] + gold[i][0]\n    \n    # Fill the rest of max_gold\n    for i in range(1, m):\n        for j in range(1, n):\n            max_gold[i][j] = max(max_gold[i-1][j], max_gold[i][j-1]) + gold[i][j]\n    \n    # Return the maximum gold that can be obtained\n    return max_gold[m-1][n-1]"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    \"\"\"\n    This function takes a tuple of strings as input and returns a tuple of the rear index element of each string.\n\n    Args:\n        test_tuple (tuple): A tuple of strings.\n\n    Returns:\n        tuple: A tuple of the rear index element of each string.\n    \"\"\"\n    return tuple(string[-1] for string in test_tuple)"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    \"\"\"\n    This function counts the number of sublists containing a particular element in a given list.\n\n    Args:\n        list1 (list): The input list.\n        x (any): The element to be searched.\n\n    Returns:\n        int: The number of sublists containing the element x.\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Define the regex pattern\n    pattern = r\"(\\d{4})-(\\d{2})-(\\d{2})\"\n    # Use the regex pattern to extract the year, month and day\n    year, month, day = re.match(pattern, dt).groups()\n    # Convert the month and day to two digits\n    month = month.zfill(2)\n    day = day.zfill(2)\n    # Return the date in the desired format\n    return f\"{day}-{month}-{year}\""}
{"id": "417_0", "code": "def shell_sort(my_list):\n    \"\"\"\n    Sorts the given list using shell sort algorithm.\n\n    Args:\n        my_list (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a list of tuples.\n    Each tuple in the list contains an element from the first tuple and an element from the second tuple.\n    \n    Parameters:\n    test_tup1 (tuple): The first tuple.\n    test_tup2 (tuple): The second tuple.\n    \n    Returns:\n    list: A list of tuples, where each tuple contains an element from the first tuple and an element from the second tuple.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    # Use the zip function to create an iterator of tuples, where the first item in each tuple is from the first tuple and the second item is from the second tuple\n    zipped = zip(test_tup1, test_tup2)\n    \n    # Convert the iterator to a list of tuples\n    result = list(zipped)\n    \n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its equation in the form ax^2 + bx + c = 0.\n\n    Parameters:\n    a (float): coefficient of x^2\n    b (float): coefficient of x\n    c (float): constant term\n\n    Returns:\n    float: the equation of the directrix in the form y = k\n    \"\"\"\n    # Calculate the focal parameter p\n    p = (a * (a + b**2) / (4 * a))**(1/2)\n    \n    # Calculate the directrix\n    directrix = -p\n    \n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2)) > 0"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    \"\"\"\n    Calculate the median of a trapezium.\n\n    Parameters:\n    base1 (float): The length of the first base of the trapezium.\n    base2 (float): The length of the second base of the trapezium.\n    height (float): The height of the trapezium.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # Calculate the height of the median\n    median_height = height / 2\n    \n    # Calculate the length of the median base\n    median_base = (base1 + base2) / 2\n    \n    # Calculate the area of the median trapezium\n    median_area = 0.5 * (median_base + base1) * median_height\n    \n    # Calculate the area of the other median trapezium\n    other_median_area = 0.5 * (median_base + base2) * median_height\n    \n    # Calculate the median of the two median areas\n    median = (median_area + other_median_area) / 2\n    \n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    \"\"\"\n    This function checks if the given number is greater than all elements in the array.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    number (int): The number to be compared with the array elements.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Check if the input array is empty\n    if not arr:\n        return True  # Return True if the array is empty\n\n    # Iterate over each element in the array\n    for element in arr:\n        # If the number is not greater than any element, return False\n        if number <= element:\n            return False\n\n    # If the function hasn't returned False, the number is greater than all elements\n    return True"}
{"id": "423_0", "code": "import re\n\ndef text_match_one(text):\n    pattern = r\"a(b+)\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "424_0", "code": "def last_Digit(n):\n    \"\"\"\n    This function calculates the last digit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The last digit of the input number.\n    \"\"\"\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for i in list1:\n        if i < 0:\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    \"\"\"\n    This function removes all odd characters from a given string.\n    \n    Parameters:\n    str1 (str): The input string.\n    \n    Returns:\n    str: The string with all odd characters removed.\n    \"\"\"\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    \"\"\"\n    This function counts the number of bidirectional tuple pairs in a given list.\n    \n    A bidirectional tuple pair is a pair of tuples where the first element of the first tuple is equal to the second element of the second tuple.\n    \n    Parameters:\n    test_list (list): A list of tuples.\n    \n    Returns:\n    int: The number of bidirectional tuple pairs.\n    \"\"\"\n    \n    # Initialize a variable to store the count of bidirectional tuple pairs\n    count = 0\n    \n    # Iterate over each tuple in the list\n    for i in range(len(test_list)):\n        # Iterate over each tuple in the list starting from the next tuple\n        for j in range(i + 1, len(test_list)):\n            # Check if the first element of the first tuple is equal to the second element of the second tuple\n            if test_list[i][0] == test_list[j][1]:\n                # If they are equal, increment the count\n                count += 1\n    \n    # Return the count of bidirectional tuple pairs\n    return count"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    \"\"\"\n    This function takes a list of integers as input and returns a single integer.\n    The integers in the list are concatenated to form a single integer.\n    \n    Parameters:\n    L (list): A list of integers.\n    \n    Returns:\n    int: A single integer formed by concatenating the integers in the input list.\n    \"\"\"\n    # Convert each integer in the list to a string\n    str_L = [str(i) for i in L]\n    \n    # Join the strings together\n    concatenated_str = ''.join(str_L)\n    \n    # Convert the concatenated string back to an integer\n    result = int(concatenated_str)\n    \n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    This function finds all adverbs and their positions in a given sentence.\n\n    Args:\n        text (str): The input sentence.\n\n    Returns:\n        dict: A dictionary where keys are adverbs and values are their positions.\n    \"\"\"\n    # Define a list of adverbs\n    adverbs = ['very', 'well', 'well', 'really', 'so', 'just', 'already', 'just', 'already', 'really', 'so']\n\n    # Initialize an empty dictionary to store the adverbs and their positions\n    adverb_positions = {}\n\n    # Split the text into words\n    words = text.split()\n\n    # Iterate over the words\n    for i, word in enumerate(words):\n        # Check if the word is an adverb\n        if word.lower() in adverbs:\n            # If the word is an adverb, add it to the dictionary with its position\n            adverb_positions[word] = i\n\n    # Return the dictionary\n    return adverb_positions\n\n# Example usage:\ntext = \"I am going to the store, and I will buy some milk, very quickly.\"\nprint(find_adverb_position(text))"}
{"id": "430_0", "code": "def surfacearea_cube(length):\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Args:\n        length (float): The length of the cube's edge.\n\n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    # Calculate the surface area of the cube\n    surface_area = 6 * (length ** 2)\n    return surface_area"}
{"id": "431_0", "code": "def positive_count(nums):\n    \"\"\"\n    This function calculates the ratio of positive numbers in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of positive numbers in the list.\n    \"\"\"\n    # Count the total number of positive numbers in the list\n    positive_count = sum(1 for num in nums if num > 0)\n    \n    # Calculate the total number of numbers in the list\n    total_count = len(nums)\n    \n    # Check if the list is empty to avoid division by zero error\n    if total_count == 0:\n        return 0\n    \n    # Calculate and return the ratio of positive numbers\n    return positive_count / total_count"}
{"id": "432_0", "code": "def largest_neg(list1):\n    \"\"\"\n    This function finds the largest negative number from the given list.\n\n    Args:\n        list1 (list): A list of integers.\n\n    Returns:\n        int: The largest negative number in the list. If no negative number is found, returns None.\n    \"\"\"\n    # Initialize max_neg to negative infinity\n    max_neg = float('-inf')\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Check if the number is negative and greater than max_neg\n        if num < 0 and num > max_neg:\n            # Update max_neg\n            max_neg = num\n    \n    # If max_neg is still negative infinity, return None\n    if max_neg == float('-inf'):\n        return None\n    else:\n        # Return the largest negative number\n        return max_neg"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    \"\"\"\n    This function trims each tuple by k in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to trim from the beginning and end of each tuple.\n\n    Returns:\n        list: A list of trimmed tuples.\n    \"\"\"\n    return [tuple(test_list[i][K:-K] for i in range(len(test_list))) for test_list in test_list]"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index wise multiplication.\n\n    Raises:\n        ValueError: If the lengths of the two tuples are not equal.\n    \"\"\"\n    # Check if the lengths of the two tuples are equal\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function counts the occurrence of all elements of list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list to search for.\n\n    Returns:\n    dict: A dictionary where the keys are the elements of the list and the values are their occurrences in the tuple.\n    \"\"\"\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n\n    # Iterate over each element in the list\n    for elem in lst:\n        # Initialize a counter for the current element\n        count = 0\n        # Iterate over each element in the tuple\n        for tup_elem in tup:\n            # If the current element of the tuple is equal to the current element of the list, increment the counter\n            if tup_elem == elem:\n                count += 1\n        # Store the count in the dictionary\n        occurrences[elem] = count\n\n    # Return the dictionary with the occurrences\n    return occurrences"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth term.\n\n    Args:\n        n (int): The number of terms to calculate the sum for.\n\n    Returns:\n        int: The sum of Perrin numbers up to the nth term.\n    \"\"\"\n    # Initialize the first three Perrin numbers\n    p1, p2, p3 = 0, 1, 2\n\n    # Initialize the sum of Perrin numbers\n    total_sum = 0\n\n    # Calculate the sum of Perrin numbers up to the nth term\n    for _ in range(n):\n        total_sum += p3\n        # Calculate the next Perrin number\n        p1, p2, p3 = p2, p3, p1 + p2 + p3\n\n    return total_sum"}
{"id": "438_0", "code": "def check_Triangle(x1,y1,x2,y2,x3,y3):\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "439_0", "code": "def extract_string(str, length):\n    \"\"\"\n    Extract specified size of strings from a given list of string values.\n\n    Args:\n        str (list): A list of string values.\n        length (int): The desired length of the extracted strings.\n\n    Returns:\n        list: A list of extracted strings of specified length.\n    \"\"\"\n    extracted_strings = []\n    for string in str:\n        if len(string) >= length:\n            extracted_strings.append(string[:length])\n    return extracted_strings"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    \"\"\"\n    This function removes all whitespaces from the given string using regex.\n\n    Args:\n        text1 (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    # Use regex to replace all whitespaces with an empty string\n    text_without_whitespaces = re.sub(r'\\s+', '', text1)\n    return text_without_whitespaces"}
{"id": "441_0", "code": "def loss_amount(actual_cost,sale_amount):\n    if sale_amount > actual_cost:\n        loss = sale_amount - actual_cost\n        return loss\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n    \n    Parameters:\n    n (int): The number for which the sum of even factors is to be calculated.\n    \n    Returns:\n    int: The sum of even factors of the given number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    sum_even_factors = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if i is an even factor\n            if i % 2 == 0:\n                # Add i to the sum of even factors\n                sum_even_factors += i\n    \n    # Return the sum of even factors\n    return sum_even_factors"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    \"\"\"\n    This function takes a text as input and returns a list of words that contain 'z'.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        list: A list of words that contain 'z'.\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n\n    # Initialize an empty list to store the words that contain 'z'\n    words_with_z = []\n\n    # Iterate over each word in the text\n    for word in words:\n        # Check if the word contains 'z'\n        if 'z' in word.lower():\n            # If the word contains 'z', add it to the list\n            words_with_z.append(word)\n\n    # Return the list of words that contain 'z'\n    return words_with_z"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    month_days = {\n        1: 31,\n        2: 28,\n        29,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31\n    }\n    return month_days.get(monthnum2, \"Invalid month number\")\n\n# Test the function\nprint(check_monthnumb_number(1))  # Output: 31\nprint(check_monthnumb_number(2))  # Output: 28\nprint(check_monthnumb_number(13))  # Output: Invalid month number"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    \"\"\"\n    This function takes a list of strings as input, reverses each string in the list, \n    and returns the resulting list of reversed strings.\n\n    Args:\n        stringlist (list): A list of strings to be reversed.\n\n    Returns:\n        list: A list of reversed strings.\n    \"\"\"\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in stringlist:\n        # Reverse the current string using slicing and append it to the reversed list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    \"\"\"\n    This function finds the sublist with the minimum length in a given list of lists.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The sublist with the minimum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    min_len = min(len(sublist) for sublist in lst)\n    min_sublists = [sublist for sublist in lst if len(sublist) == min_len]\n\n    if len(min_sublists) > 1:\n        return min(min_sublists, key=len)\n    else:\n        return min_sublists[0]"}
{"id": "447_0", "code": "def rectangle_area(length, breadth):\n    \"\"\"\n    This function calculates the area of a rectangle.\n\n    Parameters:\n    length (float): The length of the rectangle.\n    breadth (float): The breadth of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    area = length * breadth\n    return area"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    \"\"\"\n    This function removes uppercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string.\n    \n    Returns:\n    str: The string with uppercase substrings removed.\n    \"\"\"\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    return re.sub(r'[A-Z]+', '', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: A new list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    \"\"\"\n    This function counts the number of upper case characters in a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    int: The number of upper case characters in the string.\n    \"\"\"\n    return sum(1 for char in str if char.isupper())"}
{"id": "451_0", "code": "import itertools\n\ndef combinations_list(list1):\n    # Generate all possible combinations of the elements of the list\n    all_combinations = list(itertools.chain(*itertools.combinations(list1, r) for r in range(1, len(list1) + 1)))\n    \n    return all_combinations"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    \"\"\"\n    This function finds the maximum product subarray of the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The maximum product of a subarray.\n    \"\"\"\n    \n    # Initialize the maximum and minimum product ending at the current position\n    max_product = arr[0]\n    min_product = arr[0]\n    \n    # Initialize the maximum product found so far\n    max_global = arr[0]\n    \n    # Iterate over the array starting from the second element\n    for i in range(1, len(arr)):\n        # If the current element is negative, swap max_product and min_product\n        # Because a negative number can become maximum by multiplying with another negative number\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update max_product and min_product\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update max_global\n        max_global = max(max_global, max_product)\n    \n    return max_global"}
{"id": "453_0", "code": "def check_value(dict, n):\n    \"\"\"\n    This function checks if all values in a dictionary are the same.\n\n    Parameters:\n    dict (dict): The dictionary to be checked.\n    n (int): The expected value.\n\n    Returns:\n    bool: True if all values are the same, False otherwise.\n    \"\"\"\n    # Check if the dictionary is empty\n    if not dict:\n        return True  # All values are the same (all None)\n\n    # Get the first value\n    first_value = next(iter(dict.values()))\n\n    # Check if all values are the same as the first value\n    return all(value == first_value for value in dict.values())"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    \"\"\"\n    This function drops empty items from a given dictionary.\n\n    Args:\n        dict1 (dict): The dictionary to be cleaned.\n\n    Returns:\n        dict: The cleaned dictionary with empty items dropped.\n    \"\"\"\n    # Create a new dictionary to store the cleaned items\n    cleaned_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dict1.items():\n        # Check if the value is not empty\n        if value:\n            # If the value is not empty, add it to the cleaned dictionary\n            cleaned_dict[key] = value\n    \n    # Return the cleaned dictionary\n    return cleaned_dict"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    \"\"\"\n    This function finds the peak element in the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    \n    Returns:\n    int: The index of the peak element in the array.\n    \"\"\"\n    # Initialize the low and high pointers\n    low = 0\n    high = n - 1\n    \n    # Continue the loop until low and high pointers meet\n    while low < high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is smaller than the next element, \n        # then the peak element must be on the right side\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        # If the middle element is greater than the next element, \n        # then the peak element must be on the left side\n        else:\n            high = mid\n    \n    # At this point, low and high pointers are equal\n    # and point to the peak element\n    return low"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    \"\"\"\n    This function converts a decimal number to octal number.\n    \n    Parameters:\n    deciNum (int): The decimal number to be converted.\n    \n    Returns:\n    str: The octal representation of the decimal number.\n    \"\"\"\n    # Use built-in function oct() to convert decimal to octal\n    octalNum = oct(deciNum)\n    \n    # Remove the '0o' prefix added by the oct() function\n    octalNum = octalNum[2:]\n    \n    return octalNum"}
{"id": "457_0", "code": "def max_product(arr, n):\n    # Initialize the dp array with zeros\n    dp = [0]*n\n    # Initialize the maximum product with negative infinity\n    max_product = float('-inf')\n    \n    # Initialize the minimum product with positive infinity\n    min_product = float('inf')\n    \n    # Initialize the first element of dp array with the first element of the array\n    dp[0] = arr[0]\n    \n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        # If the current element is negative, swap max_product and min_product\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update max_product and min_product\n        max_product = max(arr[i], max_product*arr[i])\n        min_product = min(arr[i], min_product*arr[i])\n        \n        # Update the dp array\n        dp[i] = max(dp[i-1], max_product)\n    \n    # Return the maximum product\n    return dp[-1]"}
{"id": "458_0", "code": "def max_profit(price, k):\n    \"\"\"\n    This function calculates the maximum possible profit from buying and selling a stock at most k times.\n\n    Parameters:\n    price (list): A list of stock prices for each day.\n    k (int): The maximum number of transactions allowed.\n\n    Returns:\n    int: The maximum possible profit.\n    \"\"\"\n    if not price or k == 0:\n        return 0\n\n    # If k is 1, we can simply use the standard approach of iterating through the prices and keeping track of the maximum profit.\n    if k == 1:\n        return sum(max(0, b - a) for a, b in zip(price, price[1:]))\n\n    # Initialize a 2D array to store the maximum profit for each subproblem.\n    dp = [[0] * len(price) for _ in range(k + 1)]\n\n    # Iterate through each transaction.\n    for i in range(1, k + 1):\n        # Initialize the maximum profit for the first day of this transaction.\n        max_profit_so_far = -price[0]\n        # Iterate through each day.\n        for j in range(1, len(price)):\n            # Update the maximum profit for this day.\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_profit_so_far)\n            # Update the maximum profit so far for the next day.\n            max_profit_so_far = max(max_profit_so_far, dp[i - 1][j] - price[j])\n\n    # The maximum profit is stored in the last cell of the 2D array.\n    return dp[k][-1]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    \"\"\"\n    This function calculates the pairwise addition of the elements of the given tuple.\n\n    Args:\n        test_tup (tuple): A tuple containing elements to be added pairwise.\n\n    Returns:\n        list: A list of sums of each pair of elements from the input tuple.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    # Check if the tuple contains at least two elements\n    if len(test_tup) < 2:\n        raise ValueError(\"Tuple must contain at least two elements.\")\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over the indices of the tuple\n    for i in range(len(test_tup)):\n        # For each element, iterate over the remaining elements in the tuple\n        for j in range(i + 1, len(test_tup)):\n            # Calculate the sum of the current pair of elements and append it to the result list\n            result.append(test_tup[i] + test_tup[j])\n\n    # Return the list of sums\n    return result"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    \"\"\"\n    This function calculates the remainder of the product of all elements in the array\n    divided by the given number n.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    lens (int): The length of the array.\n    n (int): The divisor.\n\n    Returns:\n    int: The remainder of the product of all elements in the array divided by n.\n    \"\"\"\n    # Initialize the product variable to 1\n    product = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current element with the product\n        product *= arr[i]\n    \n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    \n    # Return the remainder\n    return remainder"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    # Sort the list in ascending order\n    l.sort()\n    \n    # Initialize a variable to store the previous number\n    prev_num = l[0]\n    \n    # Iterate over the list starting from the second element\n    for num in l[1:]:\n        # If the difference between the current number and the previous number is not 1, return False\n        if num - prev_num != 1:\n            return False\n        # Update the previous number\n        prev_num = num\n    \n    # If the function hasn't returned False, it means the list contains consecutive numbers, so return True\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert the tuples to sets\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the intersection set back to a tuple\n    intersection_tuple = tuple(intersection)\n\n    return intersection_tuple"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    \"\"\"\n    This function replaces a specified character in a string with a new character.\n\n    Parameters:\n    str1 (str): The original string.\n    ch (str): The character to be replaced.\n    newch (str): The new character to replace with.\n\n    Returns:\n    str: The modified string with the character replaced.\n    \"\"\"\n    # Check if the input string is empty\n    if not str1:\n        return str1\n    \n    # Check if the character to be replaced is in the string\n    if ch not in str1:\n        return str1\n    \n    # Replace the character in the string\n    return str1.replace(ch, newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    \"\"\"\n    Sorts a dictionary by its values in descending order.\n\n    Args:\n        dict1 (dict): The dictionary to be sorted.\n\n    Returns:\n        dict: A new dictionary sorted by its values in descending order.\n    \"\"\"\n    # Use the sorted function to sort the dictionary items by value\n    sorted_items = sorted(dict1.items(), key=lambda item: item[1], reverse=True)\n    \n    # Use dictionary comprehension to create a new dictionary with the sorted items\n    sorted_dict = {k: v for k, v in sorted_items}\n    \n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    \"\"\"\n    This function calculates the sum of the largest and smallest value in a given array.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    # Check if the list is empty\n    if not nums:\n        return 0\n\n    # Find the smallest value in the list\n    smallest = min(nums)\n\n    # Find the largest value in the list\n    largest = max(nums)\n\n    # Calculate the sum of the smallest and largest value\n    total = smallest + largest\n\n    return total"}
{"id": "466_0", "code": "def is_lower(string):\n    \"\"\"\n    This function converts the given string to lower case.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return string.lower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str1)):\n        if str1[i].isupper() or (i == 0 and str1[i].isupper()):\n            result += str1[i]\n        elif i > 0 and str1[i-1].isupper():\n            result += str1[i]\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The first digit of the number.\n    \"\"\"\n    # Convert the number to a string to easily access individual digits\n    str_n = str(n)\n    \n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If negative, return the first digit of the absolute value\n        return int(str_n[1])\n    else:\n        # If not negative, return the first digit\n        return int(str_n[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_frequency, key=char_frequency.get)\n    \n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Create a table to store results of subproblems\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n\n    # Initialize the first row and column\n    dp[0][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                # Choose the maximum of including and excluding the current element\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The answer is stored in the last cell of the table\n    return dp[n][sum]"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    \"\"\"\n    This function finds sequences of one upper case letter followed by lower case letters in the given string.\n\n    Args:\n        text (str): The input string to search for the pattern.\n\n    Returns:\n        list: A list of tuples containing the start and end indices of the found sequences.\n    \"\"\"\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return [(m.start(), m.end()) for m in matches]"}
{"id": "472_0", "code": "import math\n\ndef first_Factorial_Divisible_Number(x):\n    \"\"\"\n    This function finds the first natural number whose factorial is divisible by x.\n\n    Args:\n        x (int): The number to check for divisibility.\n\n    Returns:\n        int: The first natural number whose factorial is divisible by x.\n    \"\"\"\n    i = 1\n    while True:\n        # Calculate the factorial of i\n        factorial = math.factorial(i)\n        \n        # Check if the factorial is divisible by x\n        if factorial % x == 0:\n            return i\n        \n        # If not, increment i and try again\n        i += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    \"\"\"\n    This function removes the matching tuples from the given two tuples.\n    \n    Args:\n        test_list1 (list): The first list of tuples.\n        test_list2 (list): The second list of tuples.\n    \n    Returns:\n        tuple: A tuple containing the two lists after removing the matching tuples.\n    \"\"\"\n    # Convert the lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Remove the intersection from both lists\n    test_list1 = [t for t in test_list1 if t not in intersection]\n    test_list2 = [t for t in test_list2 if t not in intersection]\n    \n    # Return the modified lists as a tuple\n    return (test_list1, test_list2)"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = float('-inf')\n    for num in A:\n        if is_palindrome(num):\n            max_palindrome = max(max_palindrome, num)\n    return max_palindrome"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Compute the binomial probability for the given number.\n\n    Parameters:\n    n (int): The number of trials.\n    k (int): The number of successes.\n    p (float): The probability of success.\n\n    Returns:\n    float: The binomial probability.\n\n    Raises:\n    ValueError: If n or k is negative, or if p is not between 0 and 1.\n    \"\"\"\n\n    # Check if n and k are non-negative integers\n    if not isinstance(n, int) or not isinstance(k, int) or n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n\n    # Check if p is a float between 0 and 1\n    if not isinstance(p, float) or p < 0 or p > 1:\n        raise ValueError(\"p must be a float between 0 and 1\")\n\n    # Calculate the binomial coefficient using the math.comb function\n    binomial_coefficient = math.comb(n, k)\n\n    # Calculate the binomial probability using the formula\n    binomial_probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))\n\n    return binomial_probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    return sorted(tup, key=lambda x: x[-1])"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The area of the pentagon.\n    \"\"\"\n    # Calculate the apothem (the distance from the center of the pentagon to one of its vertices)\n    apothem = a / (2 * math.tan(math.pi/5))\n\n    # Calculate the area of the pentagon\n    area = (5 * a * apothem) / 2\n\n    return area"}
{"id": "478_0", "code": "def frequency_Of_Largest(n,arr):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n\n    # Find the maximum value in the array\n    max_val = max(arr)\n\n    # Count the frequency of the maximum value\n    count = arr.count(max_val)\n\n    return count"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a,n,r):\n    \"\"\"\n    This function calculates the sum of a geometric progression series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The number of terms in the series.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The sum of the geometric progression series.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    \"\"\"\n    Searches for an item in a sorted list using binary search.\n\n    Args:\n        item_list (list): A sorted list of items.\n        item: The item to search for.\n\n    Returns:\n        int: The index of the item if found, -1 otherwise.\n    \"\"\"\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1"}
{"id": "482_0", "code": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    # Calculate the center of the hexagon\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the angle between each point\n    angle = 2 * math.pi / 6\n\n    # Initialize the list to store the points\n    points = []\n\n    # Calculate the points of the hexagon\n    for i in range(6):\n        # Calculate the x and y coordinates of the point\n        x = center_x + radius * math.cos(i * angle)\n        y = center_y + radius * math.sin(i * angle)\n\n        # Append the point to the list\n        points.append((x, y))\n\n    # Return the list of points\n    return points"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    \"\"\"\n    This function converts a binary tuple to an integer.\n    \n    Parameters:\n    test_tup (tuple): A tuple containing binary digits (0s and 1s)\n    \n    Returns:\n    int: The integer equivalent of the given binary tuple\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    \n    # Iterate over each character in the tuple\n    for char in test_tup:\n        # Check if the character is '1'\n        if char == '1':\n            # If '1', left shift the result by 1 bit and add 1\n            result = result << 1 | 1\n        else:\n            # If '0', left shift the result by 1 bit\n            result = result << 1\n    \n    # Return the final result\n    return result"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase substrings will be removed.\n    \n    Returns:\n    str: The input string with all lowercase substrings removed.\n    \"\"\"\n    # Use regex to find all lowercase substrings and replace them with an empty string\n    str2 = re.sub(r'[a-z]+', '', str1)\n    return str2\n\n# Example usage:\nprint(remove_lowercase(\"Hello, World! This is a test string.\"))  # Output: \"H!, Wrld! s  tst strng.\""}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    This function finds the smallest integers from a given list of numbers using heap queue algorithm.\n\n    Args:\n        nums (list): A list of integers.\n        n (int): The number of smallest integers to find.\n\n    Returns:\n        list: A list of the n smallest integers from the input list.\n    \"\"\"\n    # Create a min heap and push the first n elements into the heap\n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n\n    # Initialize an empty list to store the smallest integers\n    smallest_integers = []\n\n    # Loop until we have found n smallest integers\n    while len(smallest_integers) < n:\n        # Pop the smallest element from the heap and add it to the list\n        smallest_integers.append(heapq.heappop(min_heap))\n\n    # Return the list of smallest integers\n    return smallest_integers"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r,h):\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    \n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two positive integers.\n\n    Args:\n        x (int): The first positive integer.\n        y (int): The second positive integer.\n\n    Returns:\n        int: The GCD of x and y.\n\n    Raises:\n        ValueError: If either x or y is not a positive integer.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both inputs must be integers.\")\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both inputs must be positive integers.\")\n\n    # Use the Euclidean algorithm to find the GCD\n    while y:\n        x, y = y, x % y\n\n    return x"}
{"id": "488_0", "code": "import math\n\ndef diameter_circle(r):\n    \"\"\"\n    Calculate the diameter of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The diameter of the circle.\n    \"\"\"\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    \"\"\"\n    Concatenates all elements of the given list into a string.\n\n    Args:\n        lst (list): The input list containing elements to be concatenated.\n\n    Returns:\n        str: A string containing all elements of the input list concatenated together.\n    \"\"\"\n    return ''.join(map(str, lst))"}
{"id": "490_0", "code": "def num_comm_div(x,y):\n    \"\"\"\n    This function finds the common divisor between two numbers in a given pair.\n\n    Parameters:\n    x (int): The first number.\n    y (int): The second number.\n\n    Returns:\n    int: The common divisor of x and y.\n    \"\"\"\n    # Initialize the common divisor to 1\n    common_div = 1\n    \n    # Find the smaller number\n    smaller_num = min(x, y)\n    \n    # Iterate from 2 to the smaller number\n    for i in range(2, smaller_num + 1):\n        # Check if i is a divisor of both x and y\n        if x % i == 0 and y % i == 0:\n            # If i is a divisor, update the common divisor\n            common_div = i\n    \n    # Return the common divisor\n    return common_div"}
{"id": "491_0", "code": "def find(n,m):\n    \"\"\"\n    This function calculates the remainder of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The remainder of n divided by m.\n    \"\"\"\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    \"\"\"\n    This function adds consecutive numbers in a given list.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        list: A list of sums of consecutive numbers.\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = []\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum += num\n        result.append(current_sum)\n    \n    return result"}
{"id": "493_0", "code": "def sum_Of_Series(n):\n    \"\"\"\n    This function calculates the cube sum of the first n natural numbers.\n    \n    Parameters:\n    n (int): The number of natural numbers to be cubed and summed.\n    \n    Returns:\n    int: The cube sum of the first n natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Loop through each number from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the total sum\n        total_sum += i ** 3\n    \n    # Return the total sum\n    return total_sum"}
{"id": "494_0", "code": "def re_order(A):\n    \"\"\"\n    This function reorders the given array by moving all zeroes to the end.\n    \n    Parameters:\n    A (list): The input array.\n    \n    Returns:\n    list: The reordered array with zeroes at the end.\n    \"\"\"\n    # Initialize two pointers, one at the beginning and one at the end of the array\n    left = 0\n    right = 0\n    \n    # Traverse the array from left to right\n    while right < len(A):\n        # If the current element is not zero, swap it with the element at the left pointer\n        if A[right] != 0:\n            A[left], A[right] = A[right], A[left]\n            # Move the left pointer to the right\n            left += 1\n        # Move the right pointer to the right\n        right += 1\n    \n    # Return the reordered array\n    return A"}
{"id": "495_0", "code": "import math\n\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient of given p(n, k).\n\n    Args:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n\n    Returns:\n        float: The permutation coefficient.\n\n    Raises:\n        ValueError: If k is greater than n or if either n or k is negative.\n    \"\"\"\n    if k > n or n < 0 or k < 0:\n        raise ValueError(\"k cannot be greater than n, and neither n nor k can be negative\")\n\n    # Calculate the permutation coefficient using the math.factorial function\n    coefficient = math.factorial(n) / math.factorial(n - k)\n    return coefficient"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    \"\"\"\n    This function removes specific words from a given list.\n\n    Parameters:\n    list1 (list): The original list of words.\n    removewords (list): The list of words to be removed.\n\n    Returns:\n    list: The list of words after removing the specified words.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    new_list = list1.copy()\n    \n    # Iterate over each word to be removed\n    for word in removewords:\n        # Check if the word exists in the new list\n        if word in new_list:\n            # Remove the word from the new list\n            new_list.remove(word)\n    \n    # Return the new list with the specified words removed\n    return new_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    \"\"\"\n    This function checks if the common elements between two given lists are in the same order or not.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        bool: True if the common elements are in the same order, False otherwise.\n    \"\"\"\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the common elements between the two sets\n    common_elements = set1 & set2\n\n    # If there are no common elements, return True\n    if not common_elements:\n        return True\n\n    # Convert the common elements back to lists\n    list1 = list(common_elements)\n    list2 = list(common_elements)\n\n    # Sort the lists\n    list1.sort()\n    list2.sort()\n\n    # Compare the sorted lists\n    return list1 == list2"}
{"id": "498_0", "code": "def average_Odd(n):\n    \"\"\"\n    This function calculates the average of odd numbers till a given odd number.\n\n    Args:\n        n (int): The given odd number.\n\n    Returns:\n        float: The average of odd numbers till the given odd number.\n    \"\"\"\n    # Initialize sum and count variables\n    total_sum = 0\n    count = 0\n\n    # Iterate from 1 to n (inclusive) with a step of 2 (to consider only odd numbers)\n    for i in range(1, n + 1, 2):\n        # Add the current odd number to the total sum\n        total_sum += i\n        # Increment the count of odd numbers\n        count += 1\n\n    # Check if there are any odd numbers in the range\n    if count == 0:\n        # If not, return 0 as there are no odd numbers to average\n        return 0\n    else:\n        # Calculate and return the average of the odd numbers\n        return total_sum / count"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(k, -1, -1):\n            if j >= arr[i]:\n                dp[j] += dp[j - arr[i]]\n    return dp[k]"}

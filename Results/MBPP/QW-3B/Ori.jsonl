{"id": "0_0", "code": "def remove_Occ(s,ch):\r\n    # Find the first occurrence of the character\r\n    first_occurrence = s.find(ch)\r\n    # Find the last occurrence of the character\r\n    last_occurrence = s.rfind(ch)\r\n    # If the character is not found, return the original string\r\n    if first_occurrence == -1:\r\n        return s\r\n    # If the first and last occurrences are the same, remove only the first occurrence\r\n    elif first_occurrence == last_occurrence:\r\n        return s[:first_occurrence] + s[first_occurrence+1:]\r\n    # Otherwise, remove both the first and last occurrences\r\n    else:\r\n        return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]"}
{"id": "1_0", "code": "def sort_matrix(M):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in M]\n    \n    # Sort the matrix based on the row sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, M))]\n    \n    return sorted_matrix"}
{"id": "2_0", "code": "def count_common(words):\n    # Initialize an empty dictionary to store word counts\n    word_count = {}\n    \n    # Iterate over each word in the input dictionary\n    for word in words:\n        # If the word is already in the dictionary, increment its count\n        if word in word_count:\n            word_count[word] += 1\n        # If the word is not in the dictionary, add it with a count of 1\n        else:\n            word_count[word] = 1\n    \n    # Find the maximum count\n    max_count = max(word_count.values())\n    \n    # Initialize a list to store the most common words\n    most_common = []\n    \n    # Iterate over each word in the dictionary\n    for word, count in word_count.items():\n        # If the word's count is equal to the maximum count, add it to the list\n        if count == max_count:\n            most_common.append(word)\n    \n    # Return the list of most common words\n    return most_common"}
{"id": "3_0", "code": "def find_Volume(l,b,h):\n    # Calculate the area of the triangular base\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n        current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "import re\n\ndef text_lowercase_underscore(text):\n    # Use regular expression to find sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "6_0", "code": "def square_perimeter(a):\n    return 4 * a"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    # Convert the second string into a set for faster lookup\n    dirty_chars = set(second_string)\n    \n    # Use a list comprehension to filter out characters present in the second string\n    cleaned_string = ''.join([char for char in string if char not in dirty_chars])\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    # Create an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each number in the array\n    for num in arraynums:\n        # If the number is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Otherwise, add the number to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False"}
{"id": "9_0", "code": "def is_woodall(x):\n    if x < 0:\n        return False\n    n = 1\n    while True:\n        if n * (n + 1) // 2 == x:\n            return True\n        if n * (n + 1) // 2 > x:\n            return False\n        n += 1"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    multiples = []\n    for i in range(1, m + 1):\n        multiples.append(i * n)\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    max_sum = float('-inf')\n    for sublist in list1:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n    while binary > 0:\n        remainder = binary % 10\n        decimal += remainder * (2 ** power)\n        binary //= 10\n        power += 1\n    return decimal"}
{"id": "14_0", "code": "def find_Product(arr,n):\r\n    product = 1\r\n    for i in range(n):\r\n        count = 0\r\n        for j in range(n):\r\n            if arr[i] == arr[j]:\r\n                count += 1\r\n        if count == 1:\r\n            product *= arr[i]\r\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\r\n    # Check if all elements in the list have at least K elements\r\n    result = all(len(ele) >= K for ele in test_list)\r\n    return result"}
{"id": "16_0", "code": "def remove(list):\n    return [s.replace(str(i), '') for s in list for i in range(10)]"}
{"id": "17_0", "code": "def binomial_Coeff(n,k):\r\n    if k > n:\r\n        return 0\r\n    if k == 0 or k == n:\r\n        return 1\r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    result = 0\n    for i in range(arr_size):\n        result = result ^ arr[i]\n    return result"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "from heapq import nlargest\n\ndef func(nums, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Use nlargest to find the top k most frequent elements\n    top_k_frequent = nlargest(k, flat_list, key=flat_list.count)\n    \n    return top_k_frequent"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n = n // 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i +2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, store i and divide n\n        while n % i == 0:\n            max_prime = i\n            n = n // i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    if N == 0:\n        return \"0\"\n    binary = \"\"\n    while N > 0:\n        remainder = N % 2\n        binary = str(remainder) + binary\n        N = N // 2\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar,N):\n    # Initialize the start and end pointers\n    start = 0\n    end = N - 1\n    \n    # Perform binary search\n    while start <= end:\n        mid = start + (end - start) // 2\n        \n        # Check if the mid element is the missing number\n        if ar[mid] != mid + 1:\n            # Check if the missing number is in the left half\n            if mid == 0 or ar[mid - 1] == mid:\n                return mid + 1\n            # Otherwise, search in the left half\n            end = mid - 1\n        else:\n            # Search in the right half\n            start = mid + 1\n    \n    # If no missing number is found, return N + 1\n    return N + 1"}
{"id": "24_0", "code": "def find_rect_num(n):\n    # Calculate the n-th rectangular number using the formula n * (n + 1) / 2\n    return n * (n + 1) // 2"}
{"id": "25_0", "code": "def find_Nth_Digit(p, q, N):\n    # Calculate the numerator and denominator of the fraction\n    numerator = p\n    denominator = q\n    \n    # Calculate the number of digits in the fraction\n    num_digits = 0\n    while numerator > 0:\n        numerator //= 10\n        num_digits += 1\n    \n    # Calculate the position of the Nth digit in the fraction\n    position = N - 1\n    \n    # Calculate the number of digits in the current position\n    current_digits = 1\n    while position >= num_digits:\n        position -= num_digits\n        current_digits += 1\n    \n    # Calculate the numerator and denominator of the current position\n    numerator = p * (10 ** (current_digits - 1))\n    denominator = q * (10 ** (current_digits - 1))\n    \n    # Calculate the Nth digit\n    while position > 0:\n        numerator //= 10\n        position -= 1\n    \n    return numerator % 10"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    # Separate integers and strings\n    integers = [item for item in mixed_list if isinstance(item, int)]\n    strings = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort integers and strings separately\n    integers.sort()\n    strings.sort()\n    \n    # Combine sorted integers and strings\n    sorted_list = integers + strings\n    \n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    even_count = 0\n    odd_count = 0\n    even_sum = 0\n    odd_sum = 0\n    \n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n            even_sum += num\n        else:\n            odd_count += 1\n            odd_sum += num\n    \n    if even_count > 0 and odd_count > 0:\n        even_avg = even_sum / even_count\n        odd_avg = odd_sum / odd_count\n        return even_avg, odd_avg\n    else:\n        return None"}
{"id": "28_0", "code": "def rearange_string(S):\n    # Count the frequency of each character in the string\n    char_count = {}\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the maximum frequency of any character\n    max_freq = max(char_count.values())\n    \n    # Calculate the number of characters that can be placed in the gaps\n    # between characters of maximum frequency\n    num_gaps = len(S) - max_freq\n    \n    # If the number of gaps is less than the number of characters\n    # with maximum frequency, it's not possible to rearrange the string\n    if num_gaps < max_freq - 1:\n        return False\n    \n    # If the number of gaps is greater than or equal to the number of characters\n    # with maximum frequency, it's possible to rearrange the string\n    return True"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flat_list)\n    \n    return frequency"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr,n):\r\n    # Initialize a dictionary to keep track of the count of each element\r\n    count_dict = {}\r\n    \r\n    # Iterate through the array to count occurrences of each element\r\n    for i in range(n):\r\n        if arr[i] in count_dict:\r\n            count_dict[arr[i]] += 1\r\n        else:\r\n            count_dict[arr[i]] = 1\r\n    \r\n    # Initialize a variable to store the sum of repeated elements\r\n    sum_repeated = 0\r\n    \r\n    # Iterate through the dictionary to find elements with a count greater than 1\r\n    for key, value in count_dict.items():\r\n        if value > 1:\r\n            sum_repeated += key * value\r\n    \r\n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Use regex to find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'"}
{"id": "33_0", "code": "def text_match_string(text):\n    # Check if the text starts with a word\n    if text.startswith('word'):\n        return True\n    else:\n        return False"}
{"id": "34_0", "code": "def get_gcd(l):\n    if len(l) == 0:\n        return None\n    if len(l) == 1:\n        return l[0]\n    gcd = l[0]\n    for num in l[1:]:\n        gcd = math.gcd(gcd, num)\n    return gcd"}
{"id": "35_0", "code": "def test_distinct(data):\n    # Check if the length of the data is equal to the length of the set of data\n    return len(data) == len(set(data))"}
{"id": "36_0", "code": "def compute_Last_Digit(A,B):\r\n    # Calculate the factorial of A and B\r\n    factorial_A = 1\r\n    factorial_B = 1\r\n    for i in range(2, A + 1):\r\n        factorial_A *= i\r\n    for i in range(2, B + 1):\r\n        factorial_B *= i\r\n    # Find the last digit of the division of factorial_A by factorial_B\r\n    last_digit = factorial_A % factorial_B\r\n    return last_digit"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over all bits of the number\n    for i in range(32):\n        # Check if the current bit is odd\n        if i % 2 == 1:\n            # Set the current bit in the result\n            result |= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    result = []\n    for sublist in nums:\n        if N == 0:\n            result.append(sublist[0])\n        else:\n            result.append(sublist[N])\n    return result"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=lambda x: len(x))"}
{"id": "40_0", "code": "def check_equilateral(x, y, z):\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b,h):\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    # Check if the string is empty\n    if len(str) == 0:\n        return False\n    \n    # Get the first and last characters of the string\n    first_char = str[0]\n    last_char = str[-1]\n    \n    # Compare the first and last characters\n    if first_char == last_char:\n        return True\n    else:\n        return False"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    # Find the maximum value in the list to determine the range of the count array\n    max_value = max(my_list)\n    \n    # Initialize the count array with zeros\n    count_array = [0] * (max_value + 1)\n    \n    # Count the occurrences of each element in the input list\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Create the sorted list using the count array\n    sorted_list = []\n    for i in range(len(count_array)):\n        sorted_list.extend([i] * count_array[i])\n    \n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a,n,r):\n    # Calculate the t-nth term of the geometric series\n    tn = a * (r ** (n - 1))\n    return tn"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to reverse it\n    str_n = str(n)\n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"id": "46_0", "code": "def find_Max_Num(arr,n):\r\n    # Sort the array in descending order\r\n    arr.sort(reverse=True)\r\n    # Join the sorted array into a string\r\n    max_num = ''.join(map(str, arr))\r\n    # Convert the string to an integer\r\n    max_num = int(max_num)\r\n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x, y):\n    return x * y < 0"}
{"id": "48_0", "code": "def is_octagonal(n):\n    # Check if n is a positive integer\n    if n <= 0:\n        return False\n    \n    # Calculate the nth octagonal number using the formula\n    octagonal_number = (3 * n * n - n) // 2\n    \n    # Check if the calculated number is equal to n\n    return octagonal_number == n"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    # Initialize the maximum length of subsequence to 1\n    max_len = 1\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, n):\n        # Check if the difference between the current element and the previous element is 1\n        if abs(arr[i] - arr[i - 1]) == 1:\n            # Increment the length of the subsequence\n            max_len += 1\n    \n    # Return the maximum length of the subsequence\n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s, n):\n    count = 0\n    for i in range(n):\n        sum_digits = 0\n        for j in range(i, n):\n            sum_digits += int(s[j])\n            if sum_digits == j - i + 1:\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    if not xs:\n        return None  # Return None if the list is empty\n    smallest = xs[0]  # Assume the first element is the smallest\n    for num in xs:\n        if num < smallest:\n            smallest = num  # Update smallest if a smaller number is found\n    return smallest"}
{"id": "52_0", "code": "def max_difference(test_list):\r\n    # Initialize the maximum difference to a very small number\r\n    max_diff = float('-inf')\r\n    \r\n    # Iterate through the list of tuples\r\n    for i in range(len(test_list)):\r\n        # Iterate through the remaining tuples in the list\r\n        for j in range(i + 1, len(test_list)):\r\n            # Calculate the difference between the two tuples\r\n            diff = abs(test_list[i][0] - test_list[j][0]) + abs(test_list[i][1] - test_list[j][1])\r\n            \r\n            # Update the maximum difference if the current difference is larger\r\n            if diff > max_diff:\r\n                max_diff = diff\r\n    \r\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the second element of each tuple (marks)\n    sorted_subjectmarks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subjectmarks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(list):\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize a list to store Bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1  # Base case: There is one way to partition an empty set\n\n    # Compute Bell numbers using the recursive relation\n    for i in range(1, n + 1):\n        bell[i] = 0\n        for j in range(i):\n            bell[i] += bell[j] * bell[i - j - 1]\n\n    return bell[n]"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    if not A:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n    \n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    # Check if all tuples in the list have the same length\n    all_equal = all(len(t) == k for t in Input)\n    return all_equal"}
{"id": "60_0", "code": "def comb_sort(nums):\n    gap = len(nums)\n    shrink = 1.3\n    is_sorted = False\n\n    while not is_sorted or gap > 1:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n\n        is_sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                is_sorted = False\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\r\n    if n < 0:\r\n        return False\r\n    for i in range(1, int(n**0.5) + 1):\r\n        if (n - i*i) % 2 == 0:\r\n            return True\r\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define the regex pattern to match multiple delimiters\n    pattern = r'[,\\s]+'\n    # Use re.split to split the text based on the pattern\n    return re.split(pattern, text)"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    # Check if the length of colors is equal to the length of patterns\n    if len(colors) != len(patterns):\n        return False\n    \n    # Iterate through each color and pattern pair\n    for color, pattern in zip(colors, patterns):\n        # Check if the color matches the pattern\n        if color != pattern:\n            return False\n    \n    # If all colors match their corresponding patterns, return True\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\r\n    res = [ele for ele in test_list if all(ele[i] % K == 0 for i in range(len(ele)))] \r\n    return res"}
{"id": "65_0", "code": "def count_Squares(m,n):\r\n    # Calculate the total number of squares that can be formed in a rectangle of size m x n\r\n    total_squares = (m * (m + 1) * (2 * m + 1) // 6) + (n * (n + 1) * (2 * n + 1) // 6)\r\n    return total_squares"}
{"id": "66_0", "code": "def is_Diff(n):\r\n    sum_even = 0\r\n    sum_odd = 0\r\n    while n > 0:\r\n        digit = n % 10\r\n        if digit % 2 == 0:\r\n            sum_even += digit\r\n        else:\r\n            sum_odd += digit\r\n        n = n // 10\r\n    return sum_even - sum_odd"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    if len(s) % 2 == 1:\n        return True\n    else:\n        return False"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    # Calculate the nth tetrahedral number using the formula\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    # Use the zip function to combine the two tuples\n    result = list(zip(test_tup1, test_tup2))\n    return result"}
{"id": "71_0", "code": "def volume_sphere(r):\n    import math\n    return (4/3) * math.pi * (r ** 3)"}
{"id": "72_0", "code": "def get_Char(strr):\n    total = 0\n    for char in strr:\n        total += ord(char)\n    return chr(total)"}
{"id": "73_0", "code": "def sequence(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        sequence = [1, 1]\n        for i in range(3, n + 1):\n            sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n        return sequence[n - 1]"}
{"id": "74_0", "code": "def surfacearea_sphere(r):\n    import math\n    return 4 * math.pi * r ** 2"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    # Create an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for element in list1:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency:\n            frequency[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency"}
{"id": "78_0", "code": "def closest_num(N):\n    # Initialize the closest number to N\n    closest = N - 1\n    \n    # Check if the closest number is less than 0\n    if closest < 0:\n        # If it is, return 0 as the closest number\n        return 0\n    \n    # Return the closest number\n    return closest"}
{"id": "79_0", "code": "def len_log(list1):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in list1:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the length of the longest word\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    # Check if the substring is present in the list of strings\n    if sub_str in str1:\n        return True\n    else:\n        return False"}
{"id": "81_0", "code": "def is_undulating(n):\n    # Convert the number to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Check if the string length is less than 3, as an undulating number must have at least 3 digits\n    if len(str_n) < 3:\n        return False\n    \n    # Check if the first two digits are the same and the last two digits are the same\n    if str_n[0] == str_n[1] and str_n[-1] == str_n[-2]:\n        return True\n    \n    # Check if the first two digits are different and the last two digits are different\n    if str_n[0] != str_n[1] and str_n[-1] != str_n[-2]:\n        return True\n    \n    # If none of the above conditions are met, the number is not undulating\n    return False"}
{"id": "82_0", "code": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result"}
{"id": "83_0", "code": "def index_minimum(test_list):\r\n    # Initialize variables to store the minimum value and its index\r\n    min_value = float('inf')\r\n    min_index = -1\r\n    \r\n    # Iterate through the list of tuples\r\n    for index, (key, value) in enumerate(test_list):\r\n        # Check if the current value is less than the minimum value found so far\r\n        if value < min_value:\r\n            min_value = value\r\n            min_index = index\r\n    \r\n    # Return the index of the tuple with the minimum value\r\n    return min_index"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    if not lst:\n        return 0\n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    frequency_dict = {}\n    for sublist in list1:\n        if tuple(sublist) in frequency_dict:\n            frequency_dict[tuple(sublist)] += 1\n        else:\n            frequency_dict[tuple(sublist)] = 1\n    return frequency_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    # Convert the number to a string to easily manipulate\n    num_str = str(num)\n    \n    # Start checking from the next number\n    for i in range(num + 1, 10**len(num_str)):\n        # Convert the number to a string and check if it's a palindrome\n        if str(i) == str(i)[::-1]:\n            return i"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    # Check if k is within the valid range\n    if k < 1 or k > n:\n        return \"Invalid k value\"\n    \n    # Sort the array\n    arr.sort()\n    \n    # Return the kth element (0-based index)\n    return arr[k-1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    # Split the word by underscores\n    parts = word.split('_')\n    # Capitalize the first letter of each part and join them together\n    camel_case_word = ''.join(part.capitalize() for part in parts)\n    return camel_case_word"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    # Use list comprehension to sort each sublist using lambda function\n    sorted_list = [sorted(sublist, key=lambda x: x) for sublist in input_list]\n    return sorted_list"}
{"id": "94_0", "code": "def count(lst):\n    return sum(1 for item in lst if item)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\r\n    # Convert the tuple to a list\r\n    test_tup = list(test_tup)\r\n    \r\n    # Extend the list with the elements of the tuple\r\n    test_list.extend(test_tup)\r\n    \r\n    # Return the modified list\r\n    return test_list"}
{"id": "96_0", "code": "def count_Hexadecimal(L,R):\n    count = 0\n    for i in range(L, R+1):\n        if i < 16:\n            count += 1\n        else:\n            count += 1\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a list of iterators from the input lists\n    iterators = [iter(num1), iter(num2), iter(num3)]\n    \n    # Use heapq.merge to merge the iterators\n    merged_iterator = heapq.merge(*iterators)\n    \n    # Convert the merged iterator to a list and return it\n    return list(merged_iterator)"}
{"id": "98_0", "code": "def odd_Equivalent(s, n):\n    # Initialize the count of rotations with odd value\n    count = 0\n    \n    # Iterate through all possible rotations of the binary string\n    for i in range(n):\n        # Convert the current rotation to an integer\n        num = int(s[i:] + s[:i], 2)\n        \n        # Check if the number is odd\n        if num % 2 != 0:\n            # Increment the count if the number is odd\n            count += 1\n    \n    # Return the count of rotations with odd value\n    return count"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\r\n    # Create a set of all numbers in the range from strt_val to stop_val\r\n    full_range = set(range(strt_val, stop_val + 1))\r\n    \r\n    # Create a set of numbers in the test_list\r\n    test_set = set(test_list)\r\n    \r\n    # Find the difference between the full range and the test set\r\n    missing_ranges = full_range - test_set\r\n    \r\n    # Convert the set of missing ranges to a list of tuples\r\n    missing_ranges_list = list(missing_ranges)\r\n    \r\n    # Sort the list of tuples by the start value of each range\r\n    missing_ranges_list.sort(key=lambda x: x[0])\r\n    \r\n    return missing_ranges_list"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Initialize a set to store common elements\n    common_elements = set()\n    \n    # Iterate over each sublist in the nested list\n    for sublist in nestedlist:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Add the element to the set if it is not already present\n            common_elements.add(element)\n    \n    # Convert the set to a list and return it\n    return list(common_elements)"}
{"id": "101_0", "code": "def perimeter(diameter,height):\n    return 2 * (diameter + height)"}
{"id": "102_0", "code": "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    # Initialize an empty dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over each tuple in the test_list\n    for tup in test_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Return the dictionary containing the frequency of each tuple\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    for i in list1:\n        if i:\n            return False\n    return True"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    # Convert each element in the tuple to a string\n    str_nums = [str(num) for num in nums]\n    # Join the string representations of the numbers into a single string\n    combined_str = ''.join(str_nums)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\r\n    # Initialize an empty list to store the converted elements\r\n    res = []\r\n    # Iterate through each element in the test_list\r\n    for ele in test_list:\r\n        # Check if the element is convertible to float\r\n        if isinstance(ele, (int, float)):\r\n            # Convert the element to float and append it to the result list\r\n            res.append(float(ele))\r\n        else:\r\n            # If the element is not convertible, append it as is\r\n            res.append(ele)\r\n    # Return the result list containing all elements converted to float\r\n    return res"}
{"id": "107_0", "code": "def string_to_list(string):\n    return list(string)"}
{"id": "108_0", "code": "def search(arr, n):\r\n    # Initialize the left and right pointers\r\n    left = 0\r\n    right = n - 1\r\n    \r\n    # Loop until the left pointer is less than or equal to the right pointer\r\n    while left <= right:\r\n        # Calculate the middle index\r\n        mid = left + (right - left) // 2\r\n        \r\n        # Check if the middle element is the only element\r\n        if mid == 0 and arr[mid] != arr[mid + 1]:\r\n            return arr[mid]\r\n        elif mid == n - 1 and arr[mid] != arr[mid - 1]:\r\n            return arr[mid]\r\n        elif arr[mid] != arr[mid - 1] and arr[mid] != arr[mid + 1]:\r\n            return arr[mid]\r\n        \r\n        # If the middle element is equal to the element before it, the only element must be on the left side\r\n        elif arr[mid] == arr[mid - 1]:\r\n            right = mid - 2\r\n        # If the middle element is equal to the element after it, the only element must be on the right side\r\n        else:\r\n            left = mid + 2\r\n    \r\n    # If no element is found, return -1\r\n    return -1"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    max_product = float('-inf')\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            product = list1[i][0] * list1[j][1]\n            if product > max_product:\n                max_product = product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    \n    # Iterate through the array\n    for i in range(n - 2):\n        # Use two pointers to find the other two numbers\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            \n            if current_sum == sum:\n                # Found a triplet\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    \n    return count"}
{"id": "111_0", "code": "def smartNumber(n):\n    # Initialize the first two smart numbers\n    smart_nums = [1, 2]\n    \n    # Generate smart numbers until we reach the nth one\n    while len(smart_nums) < n:\n        # The next smart number is the sum of the last two smart numbers\n        next_num = smart_nums[-1] + smart_nums[-2]\n        smart_nums.append(next_num)\n    \n    # Return the nth smart number\n    return smart_nums[n-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n) if n % i == 0)\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        divisor_sum = sum_of_divisors(num)\n        if divisor_sum != num and sum_of_divisors(divisor_sum) == num:\n            amicable_sum += num\n\n    return amicable_sum"}
{"id": "113_0", "code": "import cmath\n\ndef angle_complex(a, b):\n    # Create a complex number from the given real and imaginary parts\n    complex_num = complex(a, b)\n    # Calculate the angle of the complex number\n    angle = cmath.phase(complex_num)\n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\r\n    max_diff = 0\r\n    current_diff = 0\r\n    zero_count = 0\r\n    one_count = 0\r\n    \r\n    for i in range(n):\r\n        if string[i] == '0':\r\n            zero_count += 1\r\n        else:\r\n            one_count += 1\r\n        \r\n        current_diff = zero_count - one_count\r\n        \r\n        if current_diff > max_diff:\r\n            max_diff = current_diff\r\n    \r\n    return max_diff"}
{"id": "115_0", "code": "def sum(a,b):\r\n    # Initialize the sum of common divisors\r\n    common_divisors_sum = 0\r\n    \r\n    # Find the smaller of the two numbers\r\n    min_num = min(a, b)\r\n    \r\n    # Iterate through all numbers from 1 to the smaller number\r\n    for i in range(1, min_num + 1):\r\n        # Check if i is a divisor of both a and b\r\n        if a % i == 0 and b % i == 0:\r\n            # Add i to the sum of common divisors\r\n            common_divisors_sum += i\r\n    \r\n    # Return the sum of common divisors\r\n    return common_divisors_sum"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    # Initialize the result to 0\n    result = 0\n    \n    # Determine the sign of the result\n    sign = 1\n    if (x < 0 and y > 0) or (x > 0 and y < 0):\n        sign = -1\n    \n    # Convert x and y to positive\n    x = abs(x)\n    y = abs(y)\n    \n    # Multiply x and y using repeated addition\n    while y > 0:\n        if y % 2 == 1:\n            result += x\n        x <<= 1\n        y >>= 1\n    \n    # Apply the sign to the result\n    return result * sign"}
{"id": "117_0", "code": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split()\n    \n    # Filter the list to include only words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    # Return the list of long words\n    return long_words_list"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n    \n    # Calculate the sum of the first row\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    \n    # Check if all rows have the same sum\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check if all columns have the same sum\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check if the main diagonal has the same sum\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check if the secondary diagonal has the same sum\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True"}
{"id": "119_0", "code": "def max_occurrences(nums):\n    from collections import Counter\n    count = Counter(nums)\n    max_count = max(count.values())\n    max_items = [item for item, freq in count.items() if freq == max_count]\n    return max_items"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = \"aeiouAEIOU\"\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    \n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(filter(lambda x: x < 0, nums))"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    # Perform the operation p times\n    for _ in range(p):\n        # Check if the last element is even or odd\n        if arr[-1] % 2 == 0:\n            return \"Even\"\n        else:\n            return \"Odd\""}
{"id": "124_0", "code": "def hexagonal_num(n):\n    return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    # Define the base rate and additional rate\n    base_rate = 50  # Base rate per unit\n    additional_rate = 0.2  # Additional rate per unit after 100 units\n\n    # Calculate the total bill\n    if units <= 100:\n        total_bill = units * base_rate\n    else:\n        total_bill = (100 * base_rate) + ((units - 100) * (base_rate + additional_rate))\n\n    return total_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    count = 0\n    for num in nums:\n        if num == 0:\n            count += 1\n    return count"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    # Check if n is less than 1, as 0 cannot be represented as sum of powers of 2\n    if n < 1:\n        return False\n    \n    # Iterate through all powers of 2\n    for i in range(32):  # Assuming 32-bit integer\n        power_of_two = 1 << i\n        if power_of_two <= n:\n            n -= power_of_two\n        else:\n            break\n    \n    # If n is reduced to 0, it means n can be represented as sum of powers of 2\n    return n == 0"}
{"id": "128_0", "code": "def circle_circumference(r):\n    import math\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\r\n    # Initialize an empty dictionary to store the count of each element\r\n    count_dict = {}\r\n    \r\n    # Iterate over each tuple in the list\r\n    for tup in test_list:\r\n        # Iterate over each element in the tuple\r\n        for ele in tup:\r\n            # If the element is already in the dictionary, increment its count\r\n            if ele in count_dict:\r\n                count_dict[ele] += 1\r\n            # If the element is not in the dictionary, add it with a count of 1\r\n            else:\r\n                count_dict[ele] = 1\r\n    \r\n    # Initialize an empty list to store the elements that occur singly\r\n    result = []\r\n    \r\n    # Iterate over each element in the dictionary\r\n    for ele, count in count_dict.items():\r\n        # If the count of the element is 1, add it to the result list\r\n        if count == 1:\r\n            result.append(ele)\r\n    \r\n    # Return the result list\r\n    return result"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n):\n        # Find the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:n-i]))\n        \n        # Flip the maximum element to the beginning of the unsorted part\n        nums[:max_index+1] = nums[:max_index+1][::-1]\n        \n        # Flip the entire unsorted part to move the maximum element to its correct position\n        nums[:n-i] = nums[:n-i][::-1]\n    return nums"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                if list1[i] == list2[j] == list3[k]:\n                    count += 1\n    return count"}
{"id": "132_0", "code": "def find_lists(Input):\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr, n):\r\n    total_sum = 0\r\n    for i in range(n):\r\n        for j in range(i + 1, n):\r\n            total_sum += abs(arr[i] - arr[j])\r\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr,n):\r\n    # Initialize the maximum difference to a very small number\r\n    max_diff = float('-inf')\r\n    \r\n    # Iterate through the array to find the maximum difference\r\n    for i in range(n):\r\n        for j in range(i+1, n):\r\n            # Calculate the absolute difference between the two elements\r\n            diff = abs(arr[i] - arr[j])\r\n            \r\n            # Update the maximum difference if the current difference is larger\r\n            if diff > max_diff:\r\n                max_diff = diff\r\n    \r\n    # Return the maximum difference found\r\n    return max_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    total_ascii = 0\n    for char in str1:\n        total_ascii += ord(char)\n    return total_ascii"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Initialize a 2D list to store the maximum path sums\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Start from the bottom of the triangle\n    for i in range(m-1, -1, -1):\n        for j in range(i+1):\n            # Calculate the maximum path sum for the current position\n            dp[i][j] = tri[i][j] + max(dp[i+1][j], dp[i+1][j+1])\n    \n    # The top element of the dp table contains the maximum path sum\n    return dp[0][0]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    # Convert the number to a string to iterate over each digit\n    str_N = str(N)\n    # Initialize two lists to store the digits of the two parts\n    part1 = []\n    part2 = []\n    # Iterate over each digit in the string representation of N\n    for i, digit in enumerate(str_N):\n        # If the index is even, add the digit to part1\n        if i % 2 == 0:\n            part1.append(int(digit))\n        # If the index is odd, add the digit to part2\n        else:\n            part2.append(int(digit))\n    # Calculate the sum of digits for each part\n    sum_part1 = sum(part1)\n    sum_part2 = sum(part2)\n    # Return the two parts as a tuple\n    return (part1, part2)"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    # Initialize a dictionary to store the length of the longest subsequence ending at each index\n    dp = {}\n    \n    # Initialize the maximum length to 1 (the smallest subsequence is a single element)\n    max_length = 1\n    \n    # Iterate through the array\n    for i in range(n):\n        # Initialize the length of the subsequence ending at index i to 1\n        dp[i] = 1\n        \n        # Check for the previous index where the difference is 1\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                # Update the length of the subsequence ending at index i\n                dp[i] = max(dp[i], dp[j] + 1)\n        \n        # Update the maximum length found so far\n        max_length = max(max_length, dp[i])\n    \n    # Return the maximum length of the subsequence\n    return max_length"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    # Check if the number 'a' is present in the infinite sequence\n    # The sequence is defined as a + b * n, where n is a non-negative integer\n    # To check if 'a' is present, we need to find if there exists an integer n such that a = b * n\n    # This can be done by checking if 'a' is divisible by 'b'\n    if a % b == 0:\n        return True\n    else:\n        return False"}
{"id": "140_0", "code": "def is_coprime(x,y):\r\n    if x == 1 or y == 1:\r\n        return True\r\n    if x % y == 0 or y % x == 0:\r\n        return False\r\n    return True"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) > 1:\n        mid = len(x) // 2\n        L = x[:mid]\n        R = x[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                x[k] = L[i]\n                i += 1\n            else:\n                x[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            x[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            x[k] = R[j]\n            j += 1\n            k += 1"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    # Return the vertex as a tuple (x_vertex, y_vertex)\n    return (x_vertex, y_vertex)"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    result = []\n    for row in nums:\n        for element in row:\n            if element % N == 0:\n                result.append(element)\n    return result"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over the bits of the number\n    for i in range(32):\n        # Check if the current bit is even\n        if i % 2 == 0:\n            # If it is, set the corresponding bit in the result to 1\n            result |= (1 << i)\n    \n    # XOR the original number with the result to toggle the even bits\n    return n ^ result"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    # Initialize an empty list to store the integer values\n    int_list = []\n    \n    # Iterate over each string in the tuple\n    for string in tuple_str:\n        # Convert the string to an integer and append it to the list\n        int_list.append(int(string))\n    \n    # Convert the list of integers back to a tuple and return it\n    return tuple(int_list)"}
{"id": "146_0", "code": "def encode_list(list1):\n    if not list1:\n        return []\n    \n    encoded_list = []\n    count = 1\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            encoded_list.append((list1[i - 1], count))\n            count = 1\n    \n    # Append the last group\n    encoded_list.append((list1[-1], count))\n    \n    return encoded_list"}
{"id": "147_0", "code": "def min_Ops(arr,n,k):\r\n    # Sort the array to make it easier to find the minimum operations\r\n    arr.sort()\r\n    \r\n    # Initialize the minimum operations to 0\r\n    min_ops = 0\r\n    \r\n    # Iterate through the array and calculate the minimum operations required\r\n    for i in range(n):\r\n        # Calculate the difference between the current element and the target value\r\n        diff = arr[i] - k\r\n        \r\n        # If the difference is positive, add it to the minimum operations\r\n        if diff > 0:\r\n            min_ops += diff\r\n    \r\n    # Return the minimum operations required\r\n    return min_ops"}
{"id": "148_0", "code": "def month_season(month,days):\n    if month in ['January', 'February', 'March']:\n        if days < 21:\n            print(\"Winter\")\n        else:\n            print(\"Spring\")\n    elif month in ['April', 'May', 'June']:\n        if days < 21:\n            print(\"Spring\")\n        else:\n            print(\"Summer\")\n    elif month in ['July', 'August', 'September']:\n        if days < 21:\n            print(\"Summer\")\n        else:\n            print(\"Fall\")\n    elif month in ['October', 'November', 'December']:\n        if days < 21:\n            print(\"Fall\")\n        else:\n            print(\"Winter\")"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Check if a and b are coprime\n    if gcd(a, b) != 1:\n        return None\n    \n    # Find the modular inverse of a modulo b\n    inv_a = pow(a, -1, b)\n    \n    # Calculate x and y\n    x = (n * inv_a) % b\n    y = (n - a * x) // b\n    \n    return x, y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    # Use list comprehension to filter out elements in list2 from list1\n    result = [element for element in list1 if element not in list2]\n    return result"}
{"id": "151_0", "code": "def sum_series(n):\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total"}
{"id": "152_0", "code": "def area_polygon(s,l):\r\n    import math\r\n    area = (s*l**2)/(4*math.tan(math.pi/s))\r\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n + 1) if n % i == 0)\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)"}
{"id": "154_0", "code": "def count_char_position(str1):\n    # Initialize a dictionary to store the count of characters at each position\n    position_count = {i: 0 for i in range(26)}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Calculate the position of the character in the alphabet\n            position = ord(char) - ord('a')\n            # Increment the count for that position\n            position_count[position] += 1\n    \n    # Return the dictionary containing the count of characters at each position\n    return position_count"}
{"id": "155_0", "code": "def find_even_Pair(A,N):\r\n    count = 0\r\n    for i in range(N):\r\n        for j in range(i+1, N):\r\n            if (A[i] ^ A[j]) % 2 == 0:\r\n                count += 1\r\n    return count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power"}
{"id": "157_0", "code": "def frequency(a,x):\r\n    count = 0\r\n    for i in range(len(a)):\r\n        if a[i] == x:\r\n            count += 1\r\n    return count"}
{"id": "158_0", "code": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    # Check if the indices are within the bounds of the list\n    if m < 0 or n >= len(list1) or m > n:\n        return 0\n    \n    # Calculate the sum of the numbers in the specified range\n    return sum(list1[m:n+1])"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    # The perimeter of a pentagon is the sum of the lengths of its five sides.\n    # Since all sides of a regular pentagon are equal, the perimeter is 5 times the length of one side.\n    return 5 * a"}
{"id": "161_0", "code": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count"}
{"id": "162_0", "code": "import re\n\ndef remove_splchar(text):\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', text)"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    result = {}\n    for key, value in l:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result"}
{"id": "164_0", "code": "def is_valid_parentheses(str1):\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"}
{"id": "165_0", "code": "def perimeter_triangle(a, b, c):\n    return a + b + c"}
{"id": "166_0", "code": "def answer(L, R):\n    # Initialize the result as None\n    result = None\n    \n    # Iterate through possible values of x\n    for x in range(1, R + 1):\n        # Iterate through possible values of y\n        for y in range(x + 1, R + 1):\n            # Calculate the least common multiple (LCM) of x and y\n            lcm = (x * y) // gcd(x, y)\n            \n            # Check if the LCM lies within the given range [L, R]\n            if L <= lcm <= R:\n                # If a valid pair is found, set the result and break the loop\n                result = (x, y)\n                break\n    \n    # Return the result\n    return result"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    # Initialize an empty list to store the results\n    results = []\n    \n    # Iterate over each pattern in the patterns list\n    for pattern in patterns:\n        # Check if the pattern is found in the text\n        if pattern in text:\n            # If found, append the pattern to the results list\n            results.append(pattern)\n    \n    # Return the list of found patterns\n    return results"}
{"id": "168_0", "code": "def is_num_keith(x):\n    if x < 10:\n        return False\n    digits = [int(d) for d in str(x)]\n    n = len(digits)\n    current_sum = sum(digits)\n    while current_sum < x:\n        next_digit = current_sum % 10\n        digits.append(next_digit)\n        current_sum = sum(digits[-n:])\n    return current_sum == x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(math.radians, [slat, slon, elat, elon])\n    \n    # Haversine formula\n    dlat = elat - slat\n    dlon = elon - slon\n    a = math.sin(dlat/2)**2 + math.cos(slat) * math.cos(elat) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    \n    # Radius of Earth in kilometers\n    r = 6371\n    \n    # Calculate the distance\n    distance = c * r\n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\r\n    if n == 0:\r\n        return \"\"\r\n    if n == 1:\r\n        return arr[0]\r\n    arr.sort()\r\n    end = min(len(arr[0]), len(arr[n - 1]))\r\n    i = 0\r\n    while i < end and arr[0][i] == arr[n - 1][i]:\r\n        i += 1\r\n    return arr[0][:i]"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    uppercase = re.findall(r'[A-Z]', string)\n    lowercase = re.findall(r'[a-z]', string)\n    special_characters = re.findall(r'[!@#$%^&*(),.?\":{}|<>]', string)\n    numeric_values = re.findall(r'[0-9]', string)\n    \n    return uppercase, lowercase, special_characters, numeric_values"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Count the frequency of each element in the array\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the array and check for pairs with difference k\n    for num in arr:\n        if num + k in frequency:\n            count += frequency[num + k]\n    \n    return count"}
{"id": "173_0", "code": "def greater_specificnum(list, num):\n    result = []\n    for item in list:\n        if item > num:\n            result.append(item)\n    return result"}
{"id": "174_0", "code": "import math\n\ndef parabola_focus(a, b, c):\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the focus\n    y_focus = (1 - (b**2 - 4*a*c)) / (4 * a)\n    \n    # Return the focus as a tuple (x_focus, y_focus)\n    return (x_focus, y_focus)"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    # Initialize a list to store the results\n    results = []\n    \n    # Iterate over each pattern in the patterns list\n    for pattern in patterns:\n        # Use re.search to find the pattern in the text\n        match = re.search(pattern, text)\n        \n        # If a match is found, append the match object to the results list\n        if match:\n            results.append(match)\n    \n    # Return the results list\n    return results"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\r\n    # Create a 2D array to store lengths of longest common subsequence\r\n    L = [[0] * (n + 1) for i in range(m + 1)]\r\n    \r\n    # Build the L[][] array from bottom up\r\n    for i in range(m + 1):\r\n        for j in range(n + 1):\r\n            if i == 0 or j == 0:\r\n                L[i][j] = 0\r\n            elif X[i - 1] == Y[j - 1]:\r\n                L[i][j] = L[i - 1][j - 1] + 1\r\n            else:\r\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\r\n    \r\n    # The length of the longest common subsequence is in L[m][n]\r\n    return L[m][n]"}
{"id": "177_0", "code": "def prod_Square(n):\n    # Check if n is a perfect square\n    if int(n**0.5)**2 == n:\n        return True\n    \n    # Check if n can be expressed as a product of two squares\n    for i in range(1, int(n**0.5) + 1):\n        if int(n**0.5) % i == 0:\n            j = n // i\n            if int(j**0.5)**2 == j:\n                return True\n    \n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr, n):\n    # Step 1: Place each number in its correct position if possible\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:\n            # Swap arr[i] with arr[arr[i] - 1]\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    \n    # Step 2: Find the first index where the number is not in its correct position\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    \n    # Step 3: If all numbers are in their correct positions, the missing number is n + 1\n    return n + 1"}
{"id": "179_0", "code": "def count_Intgral_Points(x1, y1, x2, y2):\n    # Calculate the number of integral points inside the square\n    # The number of integral points is (x2 - x1 + 1) * (y2 - y1 + 1)\n    # This is because each row and each column can have integral points\n    # from x1 to x2 and y1 to y2 respectively\n    return (x2 - x1 + 1) * (y2 - y1 + 1)"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    # Define a list of months with 30 days\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    # Check if the given month name is in the list of months with 30 days\n    if monthname3 in months_with_30_days:\n        return True\n    else:\n        return False"}
{"id": "181_0", "code": "def check_String(str):\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        if has_letter and has_number:\n            return True\n    return False"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\r\n    # Convert the tuple to a set to remove duplicates\r\n    res = tuple(set(test_tup))\r\n    return res"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\r\n    decimal = 0\r\n    base = 1\r\n    while n:\r\n        last_digit = n % 10\r\n        decimal += last_digit * base\r\n        n //= 10\r\n        base *= 8\r\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\r\n    low = 0\r\n    high = n - 1\r\n    result = -1\r\n    while low <= high:\r\n        mid = low + (high - low) // 2\r\n        if arr[mid] == x:\r\n            result = mid\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            high = mid - 1\r\n    return result"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\r\n    # Using list comprehension to filter out tuples with length K\r\n    res = [ele for ele in test_list if len(ele) != K]\r\n    return res"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    # Initialize the result as 1\n    result = 1\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the result by the corresponding element of test_tup1 raised to the power of the corresponding element of test_tup2\n        result *= test_tup1[i] ** test_tup2[i]\n    \n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a, b):\n    # The largest triangle inscribed in an ellipse is an isosceles right triangle\n    # with its hypotenuse as the major axis of the ellipse.\n    # The legs of the triangle are equal to the semi-major axis of the ellipse.\n    # The area of the triangle is (1/2) * base * height.\n    # The base and height of the triangle are both equal to the semi-major axis of the ellipse.\n    # Therefore, the area of the triangle is (1/2) * a * a.\n    return 0.5 * a * a"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    power = 0\n    while (2 ** power) <= n:\n        power += 1\n    return 2 ** (power - 1)"}
{"id": "189_0", "code": "def position_max(list1):\n    max_value = max(list1)\n    positions = [index for index, value in enumerate(list1) if value == max_value]\n    return positions"}
{"id": "190_0", "code": "def chkList(lst):\n    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over each character in the string\n    for i in range(len(str1)):\n        # Check if the index is odd (i.e., not even)\n        if i % 2 != 0:\n            # Append the character to the result string\n            result += str1[i]\n    # Return the result string\n    return result"}
{"id": "192_0", "code": "def hamming_Distance(n1, n2):\n    # Calculate the XOR of the two numbers\n    xor_result = n1 ^ n2\n    \n    # Initialize a counter for the number of set bits\n    count = 0\n    \n    # Iterate through each bit of the XOR result\n    while xor_result > 0:\n        # Increment the counter if the least significant bit is set\n        count += xor_result & 1\n        # Right shift the XOR result to check the next bit\n        xor_result >>= 1\n    \n    return count"}
{"id": "193_0", "code": "def count(s,c):\n    count = 0\n    for char in s:\n        if char == c:\n            count += 1\n    return count"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\r\n    res = 0\r\n    for i in range(len(test_tup)):\r\n        for j in range(i + 1, len(test_tup)):\r\n            if test_tup[i] > test_tup[j]:\r\n                res += 1\r\n    return res"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\r\n    res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup, test_tup[1:]))\r\n    return res"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest common subsequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Build the dp array from bottom up\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if str[i - 1] == str[j - 1] and i != j:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest repeating subsequence\n    return dp[n][n]"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    # Define the regex pattern for a decimal number with precision of 2\n    pattern = r'^\\d+(\\.\\d{1,2})?$'\n    \n    # Use re.match to check if the number matches the pattern\n    if re.match(pattern, num):\n        return True\n    else:\n        return False"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    # Remove the smallest element from the heap\n    heapq.heapreplace(heap, a)"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    # Define the regex pattern to match only lowercase letters, uppercase letters, and digits\n    pattern = r'^[a-zA-Z0-9]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"}
{"id": "200_0", "code": "def count_Num(n):\r\n    count = 0\r\n    for i in range(1, n+1):\r\n        if (i & (1 << (n-1))) and (i & (1 << 0)):\r\n            count += 1\r\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 4\n    return total"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    # Initialize an empty list to store the concatenated strings\n    res = []\n    \n    # Iterate over each tuple in the input tuples\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Concatenate the strings from each tuple and append to the result list\n        res.append(tup1 + tup2)\n    \n    # Convert the list of concatenated strings to a tuple and return it\n    return tuple(res)"}
{"id": "203_0", "code": "def degree_radian(radian):\n    import math\n    return radian * (180 / math.pi)"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    # Check if list1 is empty, then it is a subset of any list\n    if not list1:\n        return True\n    \n    # Check if list2 is empty, then it cannot be a subset of any non-empty list\n    if not list2:\n        return False\n    \n    # Check if the first element of list1 is in list2\n    if list1[0] in list2:\n        # Recursively check the rest of list1 with the remaining elements of list2\n        return check_subset_list(list1[1:], [x for x in list2 if x != list1[0]])\n    else:\n        # If the first element of list1 is not in list2, it is not a subset\n        return False"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        char_count[char] = 1\n    return None"}
{"id": "207_0", "code": "def min_Operations(A, B):\n    # If A is already equal to B, no operations are needed\n    if A == B:\n        return 0\n    \n    # If A is greater than B, subtract B from A\n    if A > B:\n        return A - B\n    \n    # If B is greater than A, subtract A from B\n    return B - A"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\r\n    # Sort the tuple in ascending order\r\n    sorted_tup = sorted(test_tup)\r\n    \r\n    # Extract the first K elements (minimums)\r\n    min_elements = sorted_tup[:K]\r\n    \r\n    # Extract the last K elements (maximums)\r\n    max_elements = sorted_tup[-K:]\r\n    \r\n    # Return the minimum and maximum elements as a tuple\r\n    return (min_elements, max_elements)"}
{"id": "209_0", "code": "def replace_max_specialchar(text, n):\n    # Define the special characters to replace\n    special_chars = [' ', ',', '.']\n    \n    # Create a regular expression pattern to match the special characters\n    pattern = '|'.join(re.escape(char) for char in special_chars)\n    \n    # Use re.sub to replace the maximum n occurrences of the pattern with a colon\n    result = re.sub(pattern, ':', text, count=n)\n    \n    return result"}
{"id": "210_0", "code": "def first_even(nums):\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\r\n    # Initialize a variable to store the type of the first element\r\n    first_type = type(test_tuple[0])\r\n    \r\n    # Iterate through the tuple\r\n    for element in test_tuple:\r\n        # Check if the type of the current element is different from the first element's type\r\n        if type(element) != first_type:\r\n            # If different, return False\r\n            return False\r\n    \r\n    # If all elements have the same type, return True\r\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\r\n    # Find the first occurrence of x\r\n    low = 0\r\n    high = n - 1\r\n    while low <= high:\r\n        mid = (low + high) // 2\r\n        if arr[mid] == x:\r\n            if mid == 0 or arr[mid - 1] != x:\r\n                break\r\n            else:\r\n                high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            high = mid - 1\r\n    if low > n - 1 or arr[low] != x:\r\n        return False\r\n\r\n    # Find the last occurrence of x\r\n    low = 0\r\n    high = n - 1\r\n    while low <= high:\r\n        mid = (low + high) // 2\r\n        if arr[mid] == x:\r\n            if mid == n - 1 or arr[mid + 1] != x:\r\n                break\r\n            else:\r\n                low = mid + 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            high = mid - 1\r\n    if high < 0 or arr[high] != x:\r\n        return False\r\n\r\n    # Check if the count of x is greater than n/2\r\n    return (high - low + 1) > n // 2"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\r\n    # Base case: if there is only one element\r\n    if low == high:\r\n        return arr[low]\r\n    \r\n    # If there are two elements, return the smaller one\r\n    if high == low + 1:\r\n        return min(arr[low], arr[high])\r\n    \r\n    # Find the middle index\r\n    mid = (low + high) // 2\r\n    \r\n    # If the middle element is greater than the last element, the minimum is in the right half\r\n    if arr[mid] > arr[high]:\r\n        return find_Min(arr, mid + 1, high)\r\n    \r\n    # If the middle element is less than the last element, the minimum is in the left half\r\n    else:\r\n        return find_Min(arr, low, mid)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str):\n        # Check if the index is even (0-based index)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    # Return the result string\n    return result"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):\r\n    # Create a mask with bits set in the range [l, r]\r\n    mask = ((1 << (r - l + 1)) - 1) << (l - 1)\r\n    # Check if all bits in the range [l, r] are set in n\r\n    return (n & mask) == mask"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    # Initialize two pointers\n    left = 0\n    right = n - 1\n    \n    # Traverse the array\n    while left < right:\n        # Move the left pointer until a positive element is found\n        while left < right and arr[left] < 0:\n            left += 1\n        # Move the right pointer until a negative element is found\n        while left < right and arr[right] >= 0:\n            right -= 1\n        # Swap the elements at the left and right pointers\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return arr"}
{"id": "219_0", "code": "def replace_blank(str1,char):\n    return str1.replace(\" \",char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    # Initialize the last row of the triangle with the values from the last row of the input triangle\n    last_row = tri[n-1]\n    \n    # Iterate from the second last row to the first row\n    for i in range(n-2, -1, -1):\n        # For each element in the current row, update it to be the maximum of itself and the sum of itself and the element directly below it\n        for j in range(i+1):\n            last_row[j] = max(last_row[j], last_row[j] + tri[i][j])\n    \n    # The maximum sum will be the first element in the last row\n    return last_row[0]"}
{"id": "221_0", "code": "def larg_nnum(list1,n):\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n    # Return the first n elements from the sorted list\n    return sorted_list[:n]"}
{"id": "222_0", "code": "def lateralsuface_cylinder(r,h):\n    pi = 3.14159\n    return 2 * pi * r * h"}
{"id": "223_0", "code": "def volume_cube(l):\n    return l**3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over the bits of the number\n    for i in range(32):\n        # Check if the current bit is even\n        if i % 2 == 0:\n            # Set the current bit in the result\n            result |= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\r\n    # Calculate the number of equilateral triangles of side length K that can fit within an equilateral triangle of side length N\r\n    # The number of such triangles is given by the formula (N-K+1)*(N-K+2)/2\r\n    return (N-K+1)*(N-K+2)//2"}
{"id": "226_0", "code": "def check_occurences(test_list):\r\n    # Initialize an empty dictionary to store the count of occurrences\r\n    count_dict = {}\r\n    \r\n    # Iterate over each tuple in the list\r\n    for tup in test_list:\r\n        # Extract the time component from the tuple\r\n        time = tup[0]\r\n        \r\n        # If the time is already in the dictionary, increment its count\r\n        if time in count_dict:\r\n            count_dict[time] += 1\r\n        # If the time is not in the dictionary, add it with a count of 1\r\n        else:\r\n            count_dict[time] = 1\r\n    \r\n    # Initialize a list to store the tuples with similar times\r\n    similar_times = []\r\n    \r\n    # Iterate over the dictionary to find tuples with similar times\r\n    for time, count in count_dict.items():\r\n        # If the count is greater than 1, it means there are similar times\r\n        if count > 1:\r\n            # Iterate over the list of tuples to find tuples with the same time\r\n            for tup in test_list:\r\n                if tup[0] == time:\r\n                    # Add the tuple to the list of similar times\r\n                    similar_times.append(tup)\r\n    \r\n    # Return the list of tuples with similar times\r\n    return similar_times"}
{"id": "227_0", "code": "def number_of_substrings(str):\n    n = len(str)\n    return n * (n + 1) // 2"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m,n):\n    # Initialize a list to store the number of sequences for each length\n    dp = [0] * (n + 1)\n    # Base case: there is one sequence of length 0, which is an empty sequence\n    dp[0] = 1\n    \n    # Iterate over each possible length from 1 to n\n    for length in range(1, n + 1):\n        # Iterate over each possible starting value for the sequence\n        for start in range(1, m + 1):\n            # If the starting value is less than or equal to m, add the number of sequences of length length - 1\n            if start <= m:\n                dp[length] += dp[length - 1]\n    \n    # Return the number of sequences of length n\n    return dp[n]"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    # Check if list2 is not empty\n    if list2:\n        # Replace the last element of list1 with the first element of list2\n        list1[-1] = list2[0]\n    return list1"}
{"id": "230_0", "code": "def array_3d(m,n,o):\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_charac(str1):\n    return len(str1)"}
{"id": "232_0", "code": "def sort_on_occurence(lst):\n    # Create a dictionary to count occurrences of the first element of each tuple\n    count_dict = {}\n    for item in lst:\n        if item[0] in count_dict:\n            count_dict[item[0]] += 1\n        else:\n            count_dict[item[0]] = 1\n    \n    # Sort the list based on the count of the first element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: count_dict[x[0]])\n    \n    return sorted_lst"}
{"id": "233_0", "code": "def next_Perfect_Square(N):\n    # Calculate the integer square root of N\n    root = int(N**0.5)\n    # Check if the square of the root is equal to N\n    if root * root == N:\n        # If it is, increment the root by 1 to get the next perfect square\n        return (root + 1) * (root + 1)\n    else:\n        # If it is not, return the square of the next integer\n        return (root + 1) * (root + 1)"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Initialize two arrays to store the maximum sum of increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Fill the inc array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill the dec array\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of bi-tonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_sum"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    if number < 0:\n        raise ValueError(\"Cannot compute square root of a negative number\")\n    if number == 0:\n        return 0\n    guess = number / 2.0\n    while True:\n        new_guess = (guess + number / guess) / 2.0\n        if abs(new_guess - guess) < 1e-10:\n            return new_guess\n        guess = new_guess"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest palindromic subsequence\n    dp = [[0 for x in range(n)] for y in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. Note that the lower diagonal values of table are\n    # useless and not filled in the process.\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i + cl - 1\n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    # The length of the longest palindromic subsequence is in the top right corner of the table\n    return dp[0][n-1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    if n <= 0:\n        return 0\n    else:\n        return 1/n + harmonic_sum(n-1)"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    # Use a lambda function to find the intersection\n    intersection = list(filter(lambda x: x in array_nums2, array_nums1))\n    return intersection"}
{"id": "239_0", "code": "def count_X(tup, x):\r\n    count = 0\r\n    for i in tup:\r\n        if i == x:\r\n            count += 1\r\n    return count"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"id": "241_0", "code": "import cmath\n\ndef convert(numbers):\n    polar_coordinates = []\n    for number in numbers:\n        polar_coordinates.append(cmath.polar(number))\n    return polar_coordinates"}
{"id": "242_0", "code": "def count_integer(list1):\n    count = 0\n    for item in list1:\n        if isinstance(item, int):\n            count += 1\n    return count"}
{"id": "243_0", "code": "import re\n\ndef words_ae(text):\n    # Use regular expression to find all words starting with 'a' or 'e'\n    words = re.findall(r'\\b[ae]\\w+', text)\n    return words"}
{"id": "244_0", "code": "def combinations_colors(l, n):\n    from itertools import product\n    return list(product(l, repeat=n))"}
{"id": "245_0", "code": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    return sum(primes)"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    # Temporary variable to hold the value of a\n    temp = a\n    # Assign the value of b to a\n    a = b\n    # Assign the value stored in temp (original value of a) to b\n    b = temp\n    # Return the swapped values\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    odd_count = len(list(filter(lambda x: x % 2 != 0, array_nums)))\n    return odd_count"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Initialize a list to store the maximum elements\n    max_elements = []\n    \n    # Iterate through the elements of both tuples\n    for i in range(len(test_tup1)):\n        # Compare the elements and append the maximum to the list\n        max_elements.append(max(test_tup1[i], test_tup2[i]))\n    \n    # Return the list of maximum elements\n    return max_elements"}
{"id": "249_0", "code": "def newman_prime(n):\n    def is_newman_prime(p):\n        if p < 2:\n            return False\n        for i in range(2, int(p**0.5) + 1):\n            if p % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_newman_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Perform division and append the result to the list\n        res.append(test_tup1[i] / test_tup2[i])\n    \n    # Return the list of results\n    return res"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    # Check if L is within the valid range\n    if L < 0 or L > len(list1):\n        raise ValueError(\"L must be between 0 and the length of the list.\")\n    \n    # Split the list into two parts\n    part1 = list1[:L]\n    part2 = list1[L:]\n    \n    return part1, part2"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    merged = d1.copy()  # Create a copy of the first dictionary\n    merged.update(d2)  # Update the copy with the second dictionary\n    return merged"}
{"id": "253_0", "code": "def dog_age(h_age):\n    if h_age < 0:\n        return \"Invalid age\"\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"}
{"id": "254_0", "code": "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i+step])\n    return result"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    return 4 * l ** 2"}
{"id": "256_0", "code": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i-1)**2\n    return sum"}
{"id": "257_0", "code": "def find_star_num(n):\n    # Calculate the n'th star number using the formula\n    star_num = 8 * n * (n - 1) + 1\n    return star_num"}
{"id": "258_0", "code": "def ascii_value(k):\n    return ord(k)"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr, n):\n    sum_even = 0\n    for i in range(0, n, 2):  # Iterate over even indices\n        if arr[i] % 2 == 0:  # Check if the number at the even index is even\n            sum_even += arr[i]\n    return sum_even"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\r\n    # Extract the last element from each tuple in the list\r\n    res = [sub[-1] for sub in test_list]\r\n    return res"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append to the result list\n        res.append(test_tup1[i] - test_tup2[i])\n    \n    # Convert the list to a tuple and return\n    return tuple(res)"}
{"id": "263_0", "code": "def even_binomial_Coeff_Sum(n):\n    # Initialize the sum of even index binomial coefficients\n    sum_even = 0\n    \n    # Iterate over the range of binomial coefficients\n    for k in range(n + 1):\n        # Calculate the binomial coefficient using the formula\n        binomial_coeff = math.comb(n, k)\n        \n        # Check if the index is even\n        if k % 2 == 0:\n            # Add the binomial coefficient to the sum\n            sum_even += binomial_coeff\n    \n    # Return the sum of even index binomial coefficients\n    return sum_even"}
{"id": "264_0", "code": "def get_Position(a, n, m):\n    # Initialize the position of the last removed element to -1\n    last_removed_position = -1\n    \n    # Iterate through the array to find the last removed element\n    for i in range(n):\n        if a[i] == m:\n            last_removed_position = i\n    \n    # Return the position of the last removed element\n    return last_removed_position"}
{"id": "265_0", "code": "def volume_cylinder(r,h):\n    return 3.14159 * r**2 * h"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    # Create a new dictionary to store the filtered items\n    filtered_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n    \n    # Return the filtered dictionary\n    return filtered_dict"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\r\n    # Initialize the count to 0\r\n    count = 0\r\n    # Iterate through the tuple\r\n    for i in range(len(test_tup)):\r\n        # Check if the current element is the first element\r\n        if i == 0:\r\n            # Increment the count\r\n            count += 1\r\n        else:\r\n            # Break the loop as we only need the count of the first element\r\n            break\r\n    # Return the count\r\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n    \n    # Calculate the nth decagonal number using the formula\n    decagonal_number = (5 * n * n - 5 * n + 2) // 2\n    \n    # Check if the calculated number is equal to the input n\n    return decagonal_number == n"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\r\n    # Check if the length of the list is equal to the length of the set created from the list\r\n    if len(test_list) == len(set(test_list)):\r\n        return True\r\n    else:\r\n        return False"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x, y: x - y, nums1, nums2))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number to a string to iterate over each digit\n    digits = str(n)\n    \n    # Create a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Iterate over each digit in the string\n    for digit in digits:\n        # If the digit is already in the dictionary, increment its count\n        if digit in digit_count:\n            digit_count[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            digit_count[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        # Convert the digit and count to integers\n        digit = int(digit)\n        count = int(count)\n        \n        # If the frequency is greater than the digit, return False\n        if count > digit:\n            return False\n    \n    # If all frequencies are less than or equal to the digit, return True\n    return True"}
{"id": "273_0", "code": "def check_element(list, element):\n    # Check if all elements in the list are equal to the given element\n    return all(item == element for item in list)"}
{"id": "274_0", "code": "import re\n\ndef text_match_two_three(text):\n    # Define the regular expression pattern\n    pattern = r'ab{2,3}'\n    \n    # Use re.search to find the pattern in the text\n    if re.search(pattern, text):\n        return \"Match found!\"\n    else:\n        return \"No match found.\""}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the maximum subarray sum for the original array\n    def max_sub_array_sum(arr, n):\n        max_so_far = arr[0]\n        max_ending_here = arr[0]\n        for i in range(1, n):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the maximum subarray sum for the repeated array\n    total_sum = sum(a) * k\n    max_sum = max_sub_array_sum(a, n)\n    max_sum_repeated = max_sum * k\n\n    # If the total sum is negative, the maximum sum of the repeated array is the maximum subarray sum\n    if total_sum < 0:\n        return max_sum_repeated\n\n    # Otherwise, the maximum sum of the repeated array is the maximum subarray sum plus the sum of the remaining elements\n    remaining_sum = total_sum - max_sum\n    max_sum_repeated += remaining_sum\n\n    return max_sum_repeated"}
{"id": "276_0", "code": "def square_Sum(n):\r\n    sum = 0\r\n    for i in range(1, n+1):\r\n        sum += (2*i)**2\r\n    return sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    count = 0\n    for i in range(N):\n        if (arr[i] % P == arr[i]):\n            count += 1\n    return count"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Calculate the number of odd days in a given year\n    # A year is considered to have 365 days in a non-leap year and 366 days in a leap year\n    # An odd day is a day that falls on an odd day of the week\n    # The number of odd days in a year can be calculated using the formula:\n    # (N - 1) % 7 + 1\n    # where N is the number of days in the year\n    # If N is a leap year, then the number of odd days is (N - 1) % 7 + 1 + 1\n    # If N is not a leap year, then the number of odd days is (N - 1) % 7 + 1\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1)"}
{"id": "279_0", "code": "def max_length(list1):\n    max_length = 0\n    max_lists = []\n    for sublist in list1:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_lists = [sublist]\n        elif len(sublist) == max_length:\n            max_lists.append(sublist)\n    return max_lists"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    same = k  # Number of ways to paint the first two posts with the same color\n    diff = k * (k - 1)  # Number of ways to paint the first two posts with different colors\n    \n    for i in range(3, n + 1):\n        # The current post can be painted the same color as the previous post\n        # or a different color from the previous post\n        same = diff\n        # The current post can be painted the same color as the previous post\n        # or a different color from the previous post\n        diff = (same + diff) * (k - 1)\n    \n    return same + diff"}
{"id": "281_0", "code": "def find(n,m):\r\n    return n // m"}
{"id": "282_0", "code": "def otherside_rightangle(w, h):\n    # Calculate the third side using the Pythagorean theorem\n    c = (w**2 + h**2)**0.5\n    return c"}
{"id": "283_0", "code": "def max_val(listval):\n    # Initialize max_val with the first element of the list\n    max_val = listval[0]\n    \n    # Iterate through the list starting from the second element\n    for val in listval[1:]:\n        # Update max_val if the current value is greater\n        if val > max_val:\n            max_val = val\n    \n    # Return the maximum value found\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    if number <= 0:\n        return 0\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.append(i)\n            if i != number // i:\n                divisors.append(number // i)\n    return sum(divisors)"}
{"id": "285_0", "code": "def get_Inv_Count(arr,n):\r\n    inv_count = 0\r\n    for i in range(n):\r\n        for j in range(i+1,n):\r\n            if arr[i] > arr[j]:\r\n                inv_count += 1\r\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    # Initialize an empty list to store the intersection elements\n    intersection = []\n    \n    # Iterate over each element in the first list\n    for element in l1:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # If it is a list, check if any of its elements are in the second list\n            for sub_element in element:\n                if sub_element in l2:\n                    # If a match is found, add it to the intersection list\n                    intersection.append(sub_element)\n        else:\n            # If the element is not a list, check if it is in the second list\n            if element in l2:\n                # If a match is found, add it to the intersection list\n                intersection.append(element)\n    \n    # Return the list of intersection elements\n    return intersection"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    # Initialize the maximum aggregate to a very low number\n    max_aggregate = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for student in stdata:\n        # Calculate the aggregate of the current student\n        aggregate = sum(student)\n        \n        # Update the maximum aggregate if the current aggregate is greater\n        if aggregate > max_aggregate:\n            max_aggregate = aggregate\n    \n    # Return the maximum aggregate found\n    return max_aggregate"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    # Initialize the count of valid sequences\n    count = 0\n    \n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the number to a binary string and pad with zeros to length 2n\n        binary_str = format(i, '0' + str(2*n) + 'b')\n        \n        # Calculate the sum of the first n bits and the last n bits\n        sum_first_n = sum(int(bit) for bit in binary_str[:n])\n        sum_last_n = sum(int(bit) for bit in binary_str[n:])\n        \n        # If the sums are equal, increment the count\n        if sum_first_n == sum_last_n:\n            count += 1\n    \n    # Return the total count of valid sequences\n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())"}
{"id": "291_0", "code": "def set_Bit_Number(n):\r\n    # Initialize the result to 0\r\n    result = 0\r\n    # Iterate through the bits of n\r\n    while n > 0:\r\n        # Check if the current bit is set\r\n        if n & 1:\r\n            # Set the corresponding bit in the result\r\n            result |= (1 << (n.bit_length() - 1))\r\n        # Right shift n by 1 to check the next bit\r\n        n >>= 1\r\n    return result"}
{"id": "292_0", "code": "def solve(a,n):\r\n    count1 = 0\r\n    count2 = 0\r\n    for i in range(n):\r\n        for j in range(i+1,n):\r\n            if a[i] > a[j]:\r\n                count1 += 1\r\n            if a[i] < a[j]:\r\n                count2 += 1\r\n    if count1 == count2:\r\n        return True\r\n    else:\r\n        return False"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    # Calculate the effective rotation\n    effective_rotation = rotations % len(arr)\n    \n    # Adjust the index based on the effective rotation\n    adjusted_index = (index + effective_rotation) % len(arr)\n    \n    # Return the element at the adjusted index\n    return arr[adjusted_index]"}
{"id": "294_0", "code": "def start_withp(words):\n    # Filter words that start with 'p'\n    filtered_words = [word for word in words if word.startswith('p')]\n    \n    # Check if there are at least two words starting with 'p'\n    if len(filtered_words) < 2:\n        return \"Not enough words starting with 'p'\"\n    \n    # Return the first two words starting with 'p'\n    return filtered_words[:2]"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Initialize the maximum sum for the subsequence ending at index i\n    max_sum = a[index]\n    \n    # Iterate through the array starting from index + 1 to k\n    for j in range(index + 1, k + 1):\n        # If the current element is greater than the last element of the subsequence\n        if a[j] > a[index]:\n            # Update the maximum sum by adding the current element to the maximum sum of the subsequence ending at index j\n            max_sum = max(max_sum, max_sum_increasing_subseq(a, n, j, k) + a[j])\n    \n    return max_sum"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\r\n    # Check if the tuple has at least m elements\r\n    if len(tuplex) < m:\r\n        return \"Tuple does not have enough elements\"\r\n    \r\n    # Check if the tuple has at least n elements\r\n    if len(tuplex) < n:\r\n        return \"Tuple does not have enough elements\"\r\n    \r\n    # Get the colon of the tuple\r\n    colon = tuplex[m-1:n]\r\n    \r\n    return colon"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    # Sort nums1 and nums2 in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Initialize an empty list to store the largest products\n    largest_products = []\n    \n    # Iterate through the sorted lists to find the largest products\n    for i in range(N):\n        # Calculate the product of the current elements from nums1 and nums2\n        product = nums1[i] * nums2[i]\n        # Append the product to the largest_products list\n        largest_products.append(product)\n    \n    # Return the list of largest products\n    return largest_products"}
{"id": "298_0", "code": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    # Split the string by spaces to get individual elements\n    elements = str1.split()\n    # Convert each element to an integer and store in a list\n    numbers = [int(element) for element in elements]\n    # Convert the list to a tuple\n    result = tuple(numbers)\n    return result"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    unset_bit_position = n & -n\n    # Set the leftmost unset bit\n    return n | unset_bit_position"}
{"id": "301_0", "code": "def volume_cone(r, h):\n    pi = 3.14159\n    volume = (1/3) * pi * r**2 * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\r\n    for num in list1:\r\n        if num > 0:\r\n            print(num)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize the maximum sum for the first two columns\n    max_sum = max(grid[0][0], grid[1][0])\n    \n    # Iterate through the grid starting from the third column\n    for i in range(1, n):\n        # Calculate the maximum sum for the current column\n        max_sum = max(grid[0][i] + max_sum, grid[1][i] + max_sum)\n    \n    return max_sum"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    # Split the string into words\n    words = str.split()\n    \n    # Initialize variables to store the maximum length and the corresponding word\n    max_len = 0\n    max_word = \"\"\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the word length is even\n        if len(word) % 2 == 0:\n            # Update the maximum length and word if the current word is longer\n            if len(word) > max_len:\n                max_len = len(word)\n                max_word = word\n    \n    # Return the first maximum length of even word\n    return max_word"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    left, right = 0, len(A) - 1\n    last_index = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if A[mid] == x:\n            last_index = mid\n            left = mid + 1  # Move to the right to find the last occurrence\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return last_index"}
{"id": "306_0", "code": "def modified_encode(alist):\n    result = []\n    count = 1\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i-1]:\n            count += 1\n        else:\n            result.append((alist[i-1], count))\n            count = 1\n    result.append((alist[-1], count))\n    return result"}
{"id": "307_0", "code": "def max_volume(s):\n    # Initialize the maximum volume to a very small number\n    max_vol = float('-inf')\n    \n    # Iterate over all possible values for the length of the cuboid\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible values for the width of the cuboid\n        for width in range(1, (s - length) // 2 + 1):\n            # Calculate the height of the cuboid\n            height = s - length - width\n            \n            # Calculate the volume of the cuboid\n            volume = length * width * height\n            \n            # Update the maximum volume if the current volume is greater\n            if volume > max_vol:\n                max_vol = volume\n    \n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    # Use regex to find all five-character long words\n    pattern = r'\\b\\w{5}\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_n_squared = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the difference between the squared sum and the sum of squares\n    difference = sum_n_squared - sum_n**2\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    # Initialize an empty list to store the demlo number\n    demlo = []\n    \n    # Iterate over the string s\n    for i in range(len(s)):\n        # Append the current character to the demlo list\n        demlo.append(s[i])\n        # Append the remaining characters in reverse order to the demlo list\n        demlo.extend(s[i+1:][::-1])\n    \n    # Join the list into a string and return it\n    return ''.join(demlo)"}
{"id": "311_0", "code": "def position_min(list1):\n    min_value = min(list1)\n    positions = [index for index, value in enumerate(list1) if value == min_value]\n    return positions"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    # Initialize two pointers, one for positive and one for negative\n    pos = 0\n    neg = 0\n    \n    # Traverse the array\n    while pos < n and neg < n:\n        # Move the positive pointer to the next positive number\n        while pos < n and arr[pos] >= 0:\n            pos += 1\n        # Move the negative pointer to the next negative number\n        while neg < n and arr[neg] < 0:\n            neg += 1\n        \n        # If both pointers are within bounds, swap the elements\n        if pos < n and neg < n:\n            arr[pos], arr[neg] = arr[neg], arr[pos]\n            pos += 1\n            neg += 1\n    \n    return arr"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\r\n    # Initialize the sum\r\n    res = 0\r\n    # Iterate through the tuple\r\n    for i in range(0, len(test_tuple), 2):\r\n        # Add the alternate elements to the sum\r\n        res += test_tuple[i]\r\n    return res"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    # Base cases\n    if n <= 3:\n        return n\n    \n    # Initialize the result array\n    dp = [float('inf')] * (n + 1)\n    \n    # Base cases for dp array\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 3\n    \n    # Fill the dp array\n    for i in range(4, n + 1):\n        # Try all possible squares less than i\n        for j in range(1, int(i**0.5) + 1):\n            square = j * j\n            dp[i] = min(dp[i], dp[i - square] + 1)\n    \n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\r\n    # Initialize a dictionary to store the count of each word\r\n    word_count = {}\r\n    \r\n    # Iterate over each string in the list\r\n    for string in test_list:\r\n        # Split the string into words\r\n        words = string.split()\r\n        \r\n        # Iterate over each word in the string\r\n        for word in words:\r\n            # If the word is already in the dictionary, increment its count\r\n            if word in word_count:\r\n                word_count[word] += 1\r\n            # If the word is not in the dictionary, add it with a count of 1\r\n            else:\r\n                word_count[word] = 1\r\n    \r\n    # Find the word with the maximum count\r\n    max_word = max(word_count, key=word_count.get)\r\n    \r\n    # Return the word with the maximum count\r\n    return max_word"}
{"id": "316_0", "code": "def check_isosceles(x, y, z):\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"id": "317_0", "code": "def rotate_left(list1,m,n):\n    # Check if the list is empty or if m is greater than the length of the list\n    if not list1 or m > len(list1):\n        return list1\n    \n    # Calculate the effective rotation needed\n    effective_rotation = m % len(list1)\n    \n    # Perform the rotation\n    rotated_list = list1[effective_rotation:] + list1[:effective_rotation]\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(list):\n    count = 0\n    for num in list:\n        if num < 0:\n            count += 1\n    return count"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Find all three-character words\n    three_char_words = re.findall(r'\\b\\w{3}\\b', text)\n    # Find all four-character words\n    four_char_words = re.findall(r'\\b\\w{4}\\b', text)\n    # Find all five-character words\n    five_char_words = re.findall(r'\\b\\w{5}\\b', text)\n    \n    # Return the results as a dictionary\n    return {\n        'three_char_words': three_char_words,\n        'four_char_words': four_char_words,\n        'five_char_words': five_char_words\n    }"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "321_0", "code": "def char_frequency(str1):\n    # Initialize an empty dictionary to store character frequencies\n    frequency = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in frequency:\n            frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            frequency[char] = 1\n    \n    # Return the dictionary containing character frequencies\n    return frequency"}
{"id": "322_0", "code": "def Sort(sub_li):\r\n    sub_li.sort(key = lambda x: x[1])\r\n    return sub_li"}
{"id": "323_0", "code": "def check_Validity(a,b,c):\r\n    if a + b > c and a + c > b and b + c > a:\r\n        return True\r\n    else:\r\n        return False"}
{"id": "324_0", "code": "def ap_sum(a,n,d):\n    # Calculate the sum of an arithmetic progression\n    return (n/2) * (2*a + (n-1)*d)"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    # Define a list of months with 28 days\n    months_with_28_days = [\"February\"]\n    \n    # Check if the given month name is in the list\n    if monthname1 in months_with_28_days:\n        return True\n    else:\n        return False"}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    # Define the regex pattern to match a word at the end of the string with optional punctuation\n    pattern = r'\\b\\w+\\b\\W*$'\n    \n    # Use re.search to find the pattern in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the matched word\n    if match:\n        return match.group(0)\n    else:\n        return None"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    # Initialize a dictionary to store the frequency of each divisor\n    divisor_count = {}\n    \n    # Iterate through all numbers from x to y\n    for num in range(x, y + 1):\n        # Find all divisors of the current number\n        for i in range(1, num + 1):\n            if num % i == 0:\n                # Increment the count of the divisor in the dictionary\n                if i in divisor_count:\n                    divisor_count[i] += 1\n                else:\n                    divisor_count[i] = 1\n    \n    # Find the divisor with the maximum count\n    max_divisor = None\n    max_count = 0\n    for divisor, count in divisor_count.items():\n        if count > max_count:\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    # Filter out non-positive numbers\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Sort the positive numbers\n    positive_nums.sort()\n    \n    # Sum the first three numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    # Convert the set to a list\n    lst = list(s)\n    # Sort the list\n    lst.sort()\n    # Convert the sorted list to a tuple\n    return tuple(lst)"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    # Initialize variables to store the minimum range and the corresponding range values\n    min_range = float('inf')\n    min_range_start = 0\n    min_range_end = 0\n    \n    # Get the number of lists and the maximum number of elements in any list\n    num_lists = len(lists)\n    max_elements = max(len(lst) for lst in lists)\n    \n    # Iterate over all possible starting points of the range\n    for start in range(max_elements):\n        # Initialize variables to store the current range values\n        current_range_start = float('inf')\n        current_range_end = float('-inf')\n        \n        # Iterate over all lists and find the current range values\n        for i in range(num_lists):\n            # Get the current element from the list\n            current_element = lists[i][start]\n            \n            # Update the current range values\n            current_range_start = min(current_range_start, current_element)\n            current_range_end = max(current_range_end, current_element)\n        \n        # Update the minimum range if the current range is smaller\n        if current_range_end - current_range_start < min_range:\n            min_range = current_range_end - current_range_start\n            min_range_start = current_range_start\n            min_range_end = current_range_end\n    \n    # Return the minimum range and the corresponding range values\n    return min_range, min_range_start, min_range_end"}
{"id": "332_0", "code": "def dig_let(s):\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n,m):\r\n    count = 0\r\n    for i in range(n, m+1):\r\n        if i % 2 != 0:\r\n            count += 1\r\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    # Check if the list has less than 2 elements\n    if len(nums) < 2:\n        return \"The list must contain at least two elements.\"\n    \n    # Calculate the difference between consecutive numbers\n    differences = [nums[i] - nums[i+1] for i in range(len(nums)-1)]\n    \n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    if k == 0 or k == n:\n        return 1\n    return zigzag(n-1, k-1) + zigzag(n-1, k)"}
{"id": "336_0", "code": "def count_Squares(m,n):\r\n    # Calculate the number of squares of each size\r\n    total_squares = 0\r\n    for size in range(1, min(m, n) + 1):\r\n        # Number of squares of size 'size' in a rectangle of size 'm' x 'n'\r\n        num_squares = (m - size + 1) * (n - size + 1)\r\n        total_squares += num_squares\r\n    return total_squares"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a list to store the number of ways for each prefix sum\n    ways = [0] * (M + 1)\n    # There is one way to have a prefix sum of 0 (doing nothing)\n    ways[0] = 1\n    \n    # Iterate over each possible value in M\n    for value in M:\n        # Update the ways list for each prefix sum\n        for i in range(M, value - 1, -1):\n            ways[i] += ways[i - value]\n    \n    # The result is the number of ways to have a prefix sum of M\n    return ways[M]"}
{"id": "338_0", "code": "def check(string):\n    # Check if the string contains only '0' and '1'\n    if all(char in '01' for char in string):\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Initialize the minimum length to the length of the string\n    min_length = len(s)\n    \n    # Iterate over each character in the string\n    for char in set(s):\n        # Remove all occurrences of the current character\n        new_s = s.replace(char, '')\n        \n        # Update the minimum length if the new string is shorter\n        if len(new_s) < min_length:\n            min_length = len(new_s)\n    \n    return min_length"}
{"id": "340_0", "code": "def first_Element(arr,n,k):\r\n    # Create a dictionary to store the frequency of each element\r\n    frequency = {}\r\n    for i in range(n):\r\n        if arr[i] in frequency:\r\n            frequency[arr[i]] += 1\r\n        else:\r\n            frequency[arr[i]] = 1\r\n    # Iterate through the array again to find the first element occurring k times\r\n    for i in range(n):\r\n        if frequency[arr[i]] == k:\r\n            return arr[i]\r\n    # If no element occurs k times, return -1\r\n    return -1"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Create a set to store unique characters\n    char_set = set()\n    \n    # Iterate over each character in the string\n    for char in str:\n        # If the character is already in the set, return False\n        if char in char_set:\n            return False\n        # Add the character to the set\n        char_set.add(char)\n    \n    # If no duplicates were found, return True\n    return True"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    # Check if the list is empty or n is out of range\n    if not list1 or n < 0 or n >= len(list1[0]):\n        return list1\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over each row in the list\n    for row in list1:\n        # Create a new row by excluding the nth column\n        new_row = [row[i] for i in range(len(row)) if i != n]\n        # Append the new row to the result list\n        result.append(new_row)\n    \n    return result"}
{"id": "343_0", "code": "def tn_ap(a,n,d):\n    tn = a + (n-1)*d\n    return tn"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    # Calculate the area of the circle\n    area = math.pi * radius ** 2\n    \n    # The number of rectangles that can fit in the circle is proportional to the area of the circle\n    # Each rectangle has an area of 1 (assuming unit length sides)\n    # Therefore, the number of rectangles is approximately the area of the circle\n    num_rectangles = area\n    \n    return num_rectangles"}
{"id": "345_0", "code": "def find_angle(a, b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    c = 180 - (a + b)\n    return c"}
{"id": "346_0", "code": "def find_max(test_list):\r\n    # Initialize the maximum element with the first element of the tuple\r\n    max_element = test_list[0]\r\n    \r\n    # Iterate through each element in the tuple\r\n    for element in test_list:\r\n        # Update the maximum element if the current element is greater\r\n        if element > max_element:\r\n            max_element = element\r\n    \r\n    # Return the maximum element found\r\n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    return list(map(lambda x, y: x % y, nums1, nums2))"}
{"id": "348_0", "code": "def Check_Solution(a,b,c):\r\n    # Calculate the discriminant\r\n    discriminant = b**2 - 4*a*c\r\n    \r\n    # Check if the discriminant is non-negative\r\n    if discriminant < 0:\r\n        return False\r\n    \r\n    # Calculate the two roots using the quadratic formula\r\n    root1 = (-b + (discriminant**0.5)) / (2*a)\r\n    root2 = (-b - (discriminant**0.5)) / (2*a)\r\n    \r\n    # Check if one root is twice the other\r\n    if root1 == 2*root2 or root2 == 2*root1:\r\n        return True\r\n    else:\r\n        return False"}
{"id": "349_0", "code": "def get_carol(n):\n    # Calculate the Carol number using the formula: (2^n - 1)^2 - 2\n    carol_number = (2 ** n - 1) ** 2 - 2\n    return carol_number"}
{"id": "350_0", "code": "def remove_empty(list1):\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the number with the maximum occurrences\n    max_num = None\n    max_count = 0\n    for num, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_num = num\n    \n    return max_num"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\r\n    res = tuple(ele + K for ele in test_list)\r\n    return res"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(str):\n    # Initialize counters for both possible alternating sequences\n    flip_count_even = 0\n    flip_count_odd = 0\n    \n    # Iterate through the string to count flips for both sequences\n    for i in range(len(str)):\n        # Check if the current character matches the expected character for an even index\n        if i % 2 == 0:\n            if str[i] != '0':\n                flip_count_even += 1\n        else:\n            if str[i] != '1':\n                flip_count_even += 1\n        \n        # Check if the current character matches the expected character for an odd index\n        if i % 2 == 0:\n            if str[i] != '1':\n                flip_count_odd += 1\n        else:\n            if str[i] != '0':\n                flip_count_odd += 1\n    \n    # Return the minimum of the two flip counts\n    return min(flip_count_even, flip_count_odd)"}
{"id": "354_0", "code": "def count_Digit(n):\n    # Convert the number to a string to easily count the digits\n    n_str = str(n)\n    # Return the length of the string, which is the number of digits\n    return len(n_str)"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    if len(list_nums) < 2:\n        return None  # Not enough elements to form a pair\n\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(1, len(list_nums) - 1):\n        current_product = list_nums[i] * list_nums[i + 1]\n        if current_product > max_product:\n            max_product = current_product\n\n    return max_product"}
{"id": "356_0", "code": "def is_tree_balanced(root):\n    if not root:\n        return True\n    \n    def get_height(node):\n        if not node:\n            return 0\n        return max(get_height(node.left), get_height(node.right)) + 1\n    \n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    \n    if abs(left_height - right_height) > 1:\n        return False\n    \n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\r\n    # Repeat the tuple N times\r\n    result = test_tup * N\r\n    return result"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l, w, h):\n    # Calculate the lateral surface area of a cuboid\n    lateral_surface_area = 2 * h * (l + w)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    # Extract the float element from the tuple\n    float_element = price[1]\n    \n    # Sort the tuple based on the float element\n    sorted_price = sorted(price, key=lambda x: x[1])\n    \n    return sorted_price"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    if left_element > right_element:\n        return left_element\n    mid = (left_element + right_element) // 2\n    if A[mid] == mid:\n        return smallest_missing(A, mid + 1, right_element)\n    else:\n        return smallest_missing(A, left_element, mid - 1)"}
{"id": "361_0", "code": "import heapq\n\ndef heap_assending(nums):\n    # Convert the list into a heap\n    heapq.heapify(nums)\n    # Extract elements from the heap in sorted order\n    sorted_nums = [heapq.heappop(nums) for _ in range(len(nums))]\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(l, w, h):\n    return l * w * h"}
{"id": "363_0", "code": "def permute_string(str):\n    if len(str) == 0:\n        return ['']\n    else:\n        permutations = []\n        for i in range(len(str)):\n            char = str[i]\n            remaining_str = str[:i] + str[i+1:]\n            for perm in permute_string(remaining_str):\n                permutations.append(char + perm)\n        return permutations"}
{"id": "364_0", "code": "def round_num(n,m):\n    return round(n/m)*m"}
{"id": "365_0", "code": "def remove_replica(test_tup):\r\n    # Create a dictionary to count occurrences of each element\r\n    count_dict = {}\r\n    for ele in test_tup:\r\n        if ele in count_dict:\r\n            count_dict[ele] += 1\r\n        else:\r\n            count_dict[ele] = 1\r\n    \r\n    # Create a new list to store the result\r\n    result = []\r\n    for ele in test_tup:\r\n        if count_dict[ele] == 1:\r\n            result.append(ele)\r\n        else:\r\n            result.append('custom_value')  # Replace duplicates with 'custom_value'\r\n    \r\n    return tuple(result)"}
{"id": "366_0", "code": "def remove_Char(s,c):\n    return s.replace(c, \"\")"}
{"id": "367_0", "code": "def move_first(test_list):\r\n    # Check if the list is empty\r\n    if not test_list:\r\n        return test_list\r\n    # Get the last element of the list\r\n    last_element = test_list[-1]\r\n    # Remove the last element from the list\r\n    test_list.pop()\r\n    # Insert the last element at the beginning of the list\r\n    test_list.insert(0, last_element)\r\n    return test_list"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    # Calculate the surface area of a cuboid\n    surface_area = 2 * (l * w + w * h + h * l)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum,colnum):\n    return [[0 for x in range(colnum)] for y in range(rownum)]"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    # Sort the list of lists based on the specified index\n    sorted_list = sorted(list_data, key=lambda x: x[index_no])\n    return sorted_list"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    left, right = 0, len(A) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if A[mid] > A[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(32):\n        # Check if the bit is even\n        if i % 2 == 0:\n            # Set the bit to 1 if it's currently 0, or 0 if it's currently 1\n            result |= (1 << i)\n    \n    # XOR the original number with the result to toggle the even bits\n    return n ^ result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Initialize the smallest value with the first element of the array\n    smallest = arr[0]\n    # Initialize the frequency counter\n    frequency = 0\n    \n    # Iterate through the array to find the smallest value\n    for i in range(n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n    \n    # Count the frequency of the smallest value\n    for i in range(n):\n        if arr[i] == smallest:\n            frequency += 1\n    \n    return frequency"}
{"id": "374_0", "code": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    stack = []\n    swaps = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps"}
{"id": "376_0", "code": "def even_or_odd(N):\n    # Convert the hexadecimal number to an integer\n    num = int(N, 16)\n    \n    # Check if the number is even or odd\n    if num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    power = 0\n    while (2 ** power) <= n:\n        power += 1\n    return 2 ** (power - 1)"}
{"id": "378_0", "code": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"id": "379_0", "code": "def add_string(list, string):\n    return [string + item for item in list]"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    # Check if all lists have the same length\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Create a nested dictionary\n    nested_dict = {}\n    for i in range(len(l1)):\n        nested_dict[l1[i]] = {l2[i]: l3[i]}\n    \n    return nested_dict"}
{"id": "381_0", "code": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 5, return n itself\n    if n <= 5:\n        return n\n    \n    # Initialize the maximum sum for the current n\n    max_sum = n\n    \n    # Iterate over all possible divisors of n\n    for i in range(2, n + 1):\n        # Calculate the sum of the maximum sums of the divisors\n        max_sum = max(max_sum, get_max_sum(n // i) + get_max_sum(n // i))\n    \n    return max_sum"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\r\n    # Convert the tuple to a set to remove duplicates\r\n    unique_elements = set(test_tup)\r\n    \r\n    # Compare the length of the set with the original tuple\r\n    if len(unique_elements) == len(test_tup):\r\n        return True\r\n    else:\r\n        return False"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate through the string to count occurrences of each character\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first non-repeated character\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    # Use regex to check if the string starts and ends with the same character\n    pattern = r'^([a-zA-Z])\\1$'\n    match = re.match(pattern, string)\n    if match:\n        return True\n    else:\n        return False"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    # Sort the numbers\n    sorted_numbers = sorted([a, b, c])\n    # Return the middle number\n    return sorted_numbers[1]"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\r\n    # Initialize an empty list to store the results\r\n    res = []\r\n    # Iterate over the elements of the tuples\r\n    for i, j in zip(test_tup1, test_tup2):\r\n        # Perform bitwise XOR operation and append the result to the list\r\n        res.append(i ^ j)\r\n    # Return the list containing the results of the bitwise XOR operation\r\n    return res"}
{"id": "389_0", "code": "def extract_freq(test_list):\r\n    # Initialize an empty dictionary to store the frequency of tuples\r\n    freq_dict = {}\r\n    \r\n    # Iterate over each tuple in the list\r\n    for tup in test_list:\r\n        # If the tuple is already in the dictionary, increment its count\r\n        if tup in freq_dict:\r\n            freq_dict[tup] += 1\r\n        # If the tuple is not in the dictionary, add it with a count of 1\r\n        else:\r\n            freq_dict[tup] = 1\r\n    \r\n    # Return the dictionary containing the frequency of each tuple\r\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Initialize an empty list to store the results for the current index\n        temp = []\n        \n        # Iterate over the elements of the second tuple\n        for j in range(len(test_tup2)):\n            # Add the corresponding elements from both tuples\n            temp.append(test_tup1[i][j] + test_tup2[i][j])\n        \n        # Append the result for the current index to the results list\n        res.append(tuple(temp))\n    \n    # Return the final result as a list of tuples\n    return res"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    # Base cases\n    if r == 0 or r == n:\n        return 1\n    if r > n:\n        return 0\n    \n    # Initialize result\n    res = 1\n    \n    # Calculate nCr % p\n    for i in range(r):\n        res = (res * (n - i)) % p\n        res = (res * pow(i + 1, p - 2, p)) % p\n    \n    return res"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    # Define the regex pattern for a valid URL\n    pattern = re.compile(\n        r'^(https?:\\/\\/)?'  # optional http or https\n        r'www\\.'            # www.\n        r'[a-zA-Z0-9.-]+'    # domain name\n        r'\\.[a-zA-Z]{2,}'    # top-level domain\n        r'(\\/[^\\s]*)?$'      # optional path\n    )\n    # Check if the string matches the pattern\n    return bool(pattern.match(str))"}
{"id": "393_0", "code": "def minimum(a,b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\r\n    # Check if tuple1 is a subset of tuplex\r\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    # Initialize the parity to 0\n    parity = 0\n    \n    # Loop through each bit of the number\n    while x > 0:\n        # XOR the current bit with the parity\n        parity ^= x & 1\n        # Right shift the number by 1\n        x >>= 1\n    \n    # Return the parity\n    return parity"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    \n    # Find the first digit from the right that is smaller than the digit immediately to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the largest possible\n    if i == -1:\n        return -1\n    \n    # Find the smallest digit to the right of the found digit that is larger than it\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the found digit in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number\n    return int(''.join(digits))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    # Your code here"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    min_product = float('inf')\n    for pair in list1:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    # Initialize the minimum value with the first element of the list\n    min_val = listval[0]\n    \n    # Iterate through the list to find the minimum value\n    for val in listval:\n        if val < min_val:\n            min_val = val\n    \n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    # Use regex to find all occurrences of '_[a-z]' and replace them with the uppercase version of the following letter\n    return re.sub(r'_([a-z])', lambda match: match.group(1).upper(), word)"}
{"id": "401_0", "code": "def remove_odd(l):\n    return [x for x in l if x % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    # Check if the list is empty or n is out of range\n    if not list1 or n < 0 or n >= len(list1):\n        return None\n    # Return the nth element of the list\n    return list1[n]"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    # Check if any element of list1 is in list2\n    return any(item in list2 for item in list1)"}
{"id": "404_0", "code": "def max_Product(arr):\n    if len(arr) < 2:\n        return \"Array must contain at least two elements\"\n    \n    # Initialize the maximum and minimum products\n    max_product = arr[0] * arr[1]\n    min_product = arr[0] * arr[1]\n    result = arr[0] * arr[1]\n    \n    for i in range(2, len(arr)):\n        # If the current element is positive, swap max_product and min_product\n        if arr[i] > 0:\n            max_product, min_product = max_product * arr[i], min_product * arr[i]\n        else:\n            # If the current element is negative, swap max_product and min_product\n            max_product, min_product = min_product * arr[i], max_product * arr[i]\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than or equal to 3, return n itself\n    if n <= 3:\n        return n\n    \n    # Recursive case: divide n into three parts and sum them up\n    # The maximum sum is achieved by dividing n into three parts as evenly as possible\n    # and summing them up\n    return n - 1 + breakSum(n - 2) + breakSum(n - 3)"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize an empty dictionary to store the first elements of each tuple\n    first_elements = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Check if the first element of the tuple is already in the dictionary\n        if tup[0] in first_elements:\n            # If it is, append the current tuple to the list of tuples for that first element\n            first_elements[tup[0]].append(tup)\n        else:\n            # If it is not, create a new list with the current tuple and add it to the dictionary\n            first_elements[tup[0]] = [tup]\n    \n    # Return the dictionary containing the first elements and their corresponding tuples\n    return first_elements"}
{"id": "407_0", "code": "def Find_Max(lst):\n    max_length = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    return total_sum * len(list1)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    # Initialize an empty string to store the concatenated result\n    result = \"\"\n    # Iterate over each element in the tuple\n    for ele in test_tup:\n        # Concatenate the current element to the result string\n        result += str(ele)\n    # Return the concatenated result\n    return result"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i**3\n    average = sum_of_cubes / n\n    return average"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\r\n    # Create a table to store results of subproblems\r\n    max_gold = [[0 for x in range(n)] for y in range(m)]\r\n    \r\n    # Process all rows from bottom to top\r\n    for i in range(m - 1, -1, -1):\r\n        # Process all columns from left to right\r\n        for j in range(n):\r\n            # If it's the last column, the gold collected is the gold at that cell\r\n            if j == n - 1:\r\n                max_gold[i][j] = gold[i][j]\r\n            # If it's the first column, the gold collected is the gold at that cell plus the gold from the cell below\r\n            elif j == 0:\r\n                max_gold[i][j] = gold[i][j] + max_gold[i + 1][j]\r\n            else:\r\n                # The gold collected is the gold at that cell plus the maximum of the gold from the cell below and the cell to the right\r\n                max_gold[i][j] = gold[i][j] + max(max_gold[i + 1][j], max_gold[i][j + 1])\r\n    \r\n    # The maximum gold collected is the maximum value in the first column of the table\r\n    return max(max_gold[0])"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    # Initialize an empty list to store the rear index elements\n    result = []\n    \n    # Iterate over each string in the tuple\n    for string in test_tuple:\n        # Check if the string is not empty\n        if string:\n            # Append the last character of the string to the result list\n            result.append(string[-1])\n    \n    # Return the list of rear index elements\n    return result"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Use regex to find the date pattern yyyy-mm-dd\n    match = re.search(r'(\\d{4})-(\\d{2})-(\\d{2})', dt)\n    if match:\n        # Extract the year, month, and day\n        year, month, day = match.groups()\n        # Return the date in dd-mm-yyyy format\n        return f\"{day}-{month}-{year}\"\n    else:\n        # Return the original date if no match is found\n        return dt"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of both tuples\n    for i, j in zip(test_tup1, test_tup2):\n        # Append the elementwise and tuple of the current elements to the result list\n        res.append((i, j, (i, j)))\n    \n    # Return the list of tuples\n    return res"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    # Calculate the directrix using the formula: x = -b / (2a)\n    directrix = -b / (2 * a)\n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    # Convert both lists to sets to remove duplicates and allow for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there is any intersection between the two sets\n    return not set1.isdisjoint(set2)"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    for element in arr:\n        if element >= number:\n            return False\n    return True"}
{"id": "423_0", "code": "def text_match_one(text):\r\n    # Use regular expression to find the pattern\r\n    pattern = 'ab+'\r\n    # Search for the pattern in the text\r\n    if re.search(pattern, text):\r\n        return True\r\n    else:\r\n        return False"}
{"id": "424_0", "code": "def last_Digit(n):\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\r\n    for i in list1:\r\n        if i < 0:\r\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over each character in the input string\n    for char in str1:\n        # Check if the character is even (i.e., its ASCII value is even)\n        if ord(char) % 2 == 0:\n            # If even, append it to the result string\n            result += char\n    # Return the result string with odd characters removed\n    return result"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\r\n    res = 0\r\n    for i in range(len(test_list)):\r\n        for j in range(i + 1, len(test_list)):\r\n            if test_list[i] == test_list[j][::-1]:\r\n                res += 1\r\n    return res"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    # Convert each integer in the list to a string\n    str_list = [str(i) for i in L]\n    # Join the string representations of the integers into a single string\n    combined_str = ''.join(str_list)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    # Define a regular expression pattern to match adverbs\n    adverb_pattern = r'\\b\\w+ly\\b'\n    \n    # Use re.finditer to find all matches of the adverb pattern in the text\n    adverbs = re.finditer(adverb_pattern, text)\n    \n    # Create a list to store the positions of the adverbs\n    adverb_positions = []\n    \n    # Iterate over the matches and store their positions\n    for match in adverbs:\n        start = match.start()\n        end = match.end()\n        adverb_positions.append((start, end))\n    \n    return adverb_positions"}
{"id": "430_0", "code": "def surfacearea_cube(l):\n    return 6 * l ** 2"}
{"id": "431_0", "code": "def positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count"}
{"id": "432_0", "code": "def largest_neg(list1):\n    largest = None\n    for num in list1:\n        if num < 0:\n            if largest is None or num > largest:\n                largest = num\n    return largest"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\r\n    res = [tuple(ele[K:]) for ele in test_list]\r\n    return res"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the range of the length of the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index of both tuples\n        res.append(test_tup1[i] * test_tup2[i])\n    \n    # Convert the list to a tuple and return it\n    return tuple(res)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    # Initialize a dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in count_dict:\n            count_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[element] = 1\n    \n    # Initialize a list to store the result\n    result = []\n    \n    # Iterate over each element in the tuple\n    for element in tup:\n        # If the element is in the dictionary, append its count to the result list\n        if element in count_dict:\n            result.append(count_dict[element])\n        # If the element is not in the dictionary, append 0 to the result list\n        else:\n            result.append(0)\n    \n    # Return the result list\n    return result"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    else:\n        p0, p1, p2 = 3, 5, 8\n        sum_perrin = 13\n        for i in range(3, n):\n            p_next = p0 + p1\n            sum_perrin += p_next\n            p0, p1, p2 = p1, p2, p_next\n        return sum_perrin"}
{"id": "438_0", "code": "def check_Triangle(x1,y1,x2,y2,x3,y3):\r\n    # Calculate the lengths of the sides of the triangle\r\n    side1 = ((x2 - x1)**2 + (y2 - y1)**2)**0.5\r\n    side2 = ((x3 - x2)**2 + (y3 - y2)**2)**0.5\r\n    side3 = ((x1 - x3)**2 + (y1 - y3)**2)**0.5\r\n    \r\n    # Check if the sum of any two sides is greater than the third side\r\n    if side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1:\r\n        return True\r\n    else:\r\n        return False"}
{"id": "439_0", "code": "def extract_string(str, l):\n    return str[:l]"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    # Use regex to replace all whitespace characters with an empty string\n    return re.sub(r'\\s+', '', text1)"}
{"id": "441_0", "code": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\r\n    sum = 0\r\n    for i in range(1, n + 1):\r\n        if n % i == 0:\r\n            if i % 2 == 0:\r\n                sum += i\r\n    return sum"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    import re\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    # Define a list of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month number is in the list of months with 31 days\n    if monthnum2 in months_with_31_days:\n        return True\n    else:\n        return False"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    reversed_list = []\n    for string in stringlist:\n        reversed_list.append(string[::-1])\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n\n    min_length = float('inf')  # Initialize min_length to infinity\n    min_sublist = None  # Initialize min_sublist to None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(l, b):\n    return l * b"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    return re.sub('[A-Z]', '', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count"}
{"id": "451_0", "code": "def combinations_list(list1):\n    from itertools import combinations\n    return [list(comb) for comb in combinations(list1, r)]"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = min_product = result = arr[0]\n    \n    for num in arr[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        \n        result = max(result, max_product)\n    \n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    # Check if the dictionary is empty\n    if not dict:\n        return True\n    \n    # Get the first value in the dictionary\n    first_value = next(iter(dict.values()))\n    \n    # Compare each value in the dictionary with the first value\n    for value in dict.values():\n        if value != first_value:\n            return False\n    \n    return True"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    # Create a new dictionary to store non-empty items\n    new_dict = {}\n    # Iterate over the items in the input dictionary\n    for key, value in dict1.items():\n        # Check if the value is not empty\n        if value:\n            # Add the key-value pair to the new dictionary\n            new_dict[key] = value\n    # Return the new dictionary with empty items removed\n    return new_dict"}
{"id": "455_0", "code": "def find_peak(arr, n):\r\n    if n == 1:\r\n        return 0\r\n    if arr[0] > arr[1]:\r\n        return 0\r\n    if arr[n-1] > arr[n-2]:\r\n        return n-1\r\n    low = 1\r\n    high = n-2\r\n    while low <= high:\r\n        mid = low + (high - low) // 2\r\n        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:\r\n            return mid\r\n        elif arr[mid] < arr[mid-1]:\r\n            high = mid - 1\r\n        else:\r\n            low = mid + 1"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\r\n    # Initialize an empty string to store the octal number\r\n    octalNum = ''\r\n    # Loop until the decimal number becomes 0\r\n    while deciNum > 0:\r\n        # Get the remainder of the decimal number divided by 8\r\n        remainder = deciNum % 8\r\n        # Append the remainder to the octal number string\r\n        octalNum = str(remainder) + octalNum\r\n        # Divide the decimal number by 8\r\n        deciNum = deciNum // 8\r\n    # Return the octal number string\r\n    return octalNum"}
{"id": "457_0", "code": "def max_product(arr, n):\n    # Initialize the dp array where dp[i] will store the maximum product of increasing subsequence ending at index i\n    dp = [1] * n\n    \n    # Iterate through each element in the array\n    for i in range(1, n):\n        # Iterate through all previous elements\n        for j in range(i):\n            # If the current element is greater than the previous element, update the dp array\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # The maximum product of increasing subsequence will be the maximum value in the dp array\n    return max(dp)"}
{"id": "458_0", "code": "def max_profit(price, k):\r\n    n = len(price)\r\n    if n < 2 or k == 0:\r\n        return 0\r\n    if k >= n // 2:\r\n        return sum(price[i] - price[i - 1] for i in range(1, n) if price[i] > price[i - 1])\r\n    \r\n    dp = [[0] * (k + 1) for _ in range(n)]\r\n    for i in range(1, n):\r\n        for j in range(1, k + 1):\r\n            dp[i][j] = max(dp[i - 1][j], price[i] - price[i - 1] + dp[i - 2][j - 1])\r\n    return dp[n - 1][k]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\r\n    res = tuple(a + b for a, b in zip(test_tup[0], test_tup[1]))\r\n    return res"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    # Initialize the result to 1\n    result = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current result by the current element modulo n\n        result = (result * arr[i]) % n\n    \n    # Return the final result\n    return result"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    if len(l) < 2:\n        return False\n    l.sort()\n    for i in range(1, len(l)):\n        if l[i] != l[i-1] + 1:\n            return False\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert lists to sets to remove duplicates and allow for intersection\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a tuple\n    result = tuple(intersection)\n    \n    return result"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    return str1.replace(ch,newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    # Sort the dictionary by value in descending order\n    sorted_dict = dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    if not nums:\n        return 0\n    return max(nums) + min(nums)"}
{"id": "466_0", "code": "def is_lower(string):\n    return string.islower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    # Use a list comprehension to filter out lowercase characters\n    result = ''.join([char for char in str1 if not char.islower()])\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    # Convert the number to a string to easily access the first character\n    n_str = str(n)\n    # Return the first character of the string, which is the first digit\n    return int(n_str[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    # Initialize a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Initialize variables to store the maximum frequency and the corresponding character\n    max_freq = 0\n    max_char = ''\n    \n    # Iterate over the dictionary to find the character with the maximum frequency\n    for char, freq in char_count.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_char = char\n    \n    # Return the character with the maximum frequency\n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Base Case: If sum is 0, then answer is True\n    if sum == 0:\n        return True\n    # Base Case: If no items left or sum becomes negative, then answer is False\n    if n == 0 or sum < 0:\n        return False\n    # If last element is greater than sum, then ignore it\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    # Check if sum can be achieved by including or excluding the last element\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    # Use regex to find sequences of one upper case letter followed by lower case letters\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "472_0", "code": "def first_Factorial_Divisible_Number(x):\n    factorial = 1\n    n = 1\n    while True:\n        factorial *= n\n        if factorial % x == 0:\n            return n\n        n += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    # Use list comprehension to filter out matching tuples\n    result = [tup for tup in test_list1 if tup not in test_list2]\n    return result"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    # Initialize the largest palindrome to 0\n    largest_palindrome = 0\n    \n    # Iterate through each number in the array\n    for num in A:\n        # Convert the number to a string\n        num_str = str(num)\n        \n        # Check if the number is a palindrome\n        if num_str == num_str[::-1]:\n            # Update the largest palindrome if the current number is greater\n            largest_palindrome = max(largest_palindrome, num)\n    \n    # Return the largest palindrome found\n    return largest_palindrome"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate the binomial coefficient\n    binom_coeff = math.comb(n, k)\n    \n    # Calculate the probability of k successes in n trials\n    probability = binom_coeff * (p ** k) * ((1 - p) ** (n - k))\n    \n    return probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    # Sort the list of tuples based on the last element of each tuple\n    sorted_tup = sorted(tup, key=lambda x: x[-1])\n    return sorted_tup"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    # Calculate the area of a regular pentagon using the formula\n    # Area = (1/4) * sqrt(5 * (5 + 2 * sqrt(5))) * a^2\n    area = (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a**2\n    return area"}
{"id": "478_0", "code": "def frequency_Of_Largest(n, arr):\n    if n == 0:\n        return 0\n    max_value = max(arr)\n    frequency = arr.count(max_value)\n    return frequency"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\r\n    res = []\r\n    for i in range(len(test_list)):\r\n        for j in range(i + 1, len(test_list)):\r\n            if test_list[i] == test_list[j][::-1]:\r\n                res.append((test_list[i], test_list[j]))\r\n    return res"}
{"id": "480_0", "code": "def sum_gp(a,n,r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r**n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    # Initialize the start and end indices\n    start = 0\n    end = len(item_list) - 1\n    \n    # Loop until the start index is less than or equal to the end index\n    while start <= end:\n        # Calculate the middle index\n        mid = (start + end) // 2\n        \n        # Check if the middle element is the item we are looking for\n        if item_list[mid] == item:\n            return mid  # Return the index of the item\n        # If the item is greater than the middle element, search in the right half\n        elif item_list[mid] < item:\n            start = mid + 1\n        # If the item is less than the middle element, search in the left half\n        else:\n            end = mid - 1\n    \n    # If the item is not found, return -1\n    return -1"}
{"id": "482_0", "code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    # Initialize an empty list to store the polygons\n    polygons = []\n    \n    # Calculate the number of hexagons in the x and y directions\n    num_hexes_x = int((endx - startx) / (radius * 2 * (3 ** 0.5)))\n    num_hexes_y = int((endy - starty) / (radius * 2 * (3 ** 0.5)))\n    \n    # Calculate the center of the grid\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n    \n    # Calculate the coordinates of the hexagons\n    for i in range(num_hexes_y):\n        for j in range(num_hexes_x):\n            # Calculate the coordinates of the hexagon\n            x = center_x + j * radius * 2 * (3 ** 0.5)\n            y = center_y + i * radius * 2 * (3 ** 0.5)\n            # Calculate the coordinates of the vertices of the hexagon\n            vertices = [\n                (x, y),\n                (x + radius * (3 ** 0.5), y - radius),\n                (x + radius * (3 ** 0.5), y + radius),\n                (x, y + radius * 2 * (3 ** 0.5)),\n                (x - radius * (3 ** 0.5), y + radius),\n                (x - radius * (3 ** 0.5), y - radius)\n            ]\n            # Add the hexagon to the list of polygons\n            polygons.append(vertices)\n    \n    # Return the list of polygons\n    return polygons"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\r\n    # Initialize the result variable\r\n    res = 0\r\n    # Iterate over the binary tuple\r\n    for i in range(len(test_tup)):\r\n        # Multiply the current bit by 2 raised to the power of its position\r\n        res += test_tup[i] * (2 ** i)\r\n    return res"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    # Use regex to find all lowercase letters and replace them with an empty string\n    return re.sub(r'[a-z]', '', str1)"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    # Use heapq.nsmallest to find the n smallest elements in the list\n    smallest_nums = heapq.nsmallest(n, nums)\n    return smallest_nums"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r,h):\n    # Calculate the slant height of the cone\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + l)\n    \n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x"}
{"id": "488_0", "code": "def diameter_circle(r):\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(list):\n    return ''.join(list)"}
{"id": "490_0", "code": "def num_comm_div(x,y):\r\n    # Initialize the count of common divisors\r\n    count = 0\r\n    # Iterate through all numbers from 1 to the minimum of x and y\r\n    for i in range(1, min(x, y) + 1):\r\n        # Check if i is a divisor of both x and y\r\n        if x % i == 0 and y % i == 0:\r\n            # Increment the count of common divisors\r\n            count += 1\r\n    # Return the count of common divisors\r\n    return count"}
{"id": "491_0", "code": "def find(n,m):\r\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    total = 0\n    for i in range(len(nums) - 1):\n        total += nums[i] + nums[i + 1]\n    return total"}
{"id": "493_0", "code": "def sum_Of_Series(n):\r\n    # Initialize sum to 0\r\n    sum = 0\r\n    # Loop through first n natural numbers\r\n    for i in range(1, n + 1):\r\n        # Add the cube of the current number to sum\r\n        sum += i ** 3\r\n    # Return the sum of cubes\r\n    return sum"}
{"id": "494_0", "code": "def re_order(A):\n    # Initialize a pointer for the position to place the next non-zero element\n    next_non_zero = 0\n    \n    # Iterate through the array\n    for i in range(len(A)):\n        # If the current element is non-zero\n        if A[i] != 0:\n            # Swap the current element with the element at the next_non_zero position\n            A[next_non_zero], A[i] = A[i], A[next_non_zero]\n            # Move the next_non_zero pointer forward\n            next_non_zero += 1\n    \n    # The array is now reordered with all zeroes at the end\n    return A"}
{"id": "495_0", "code": "def permutation_coefficient(n, k):\n    # Base case: if k is greater than n, return 0\n    if k > n:\n        return 0\n    # Base case: if k is 0 or 1, return 1\n    if k == 0 or k == 1:\n        return 1\n    # Recursive case: use the formula P(n, k) = n * P(n-1, k-1)\n    return n * permutation_coefficient(n-1, k-1)"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    # Create a set of words to remove for faster lookup\n    remove_set = set(removewords)\n    \n    # Use list comprehension to filter out words that are in the remove_set\n    filtered_list = [word for word in list1 if word not in remove_set]\n    \n    return filtered_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    # Find the common elements between the two lists\n    common_elements = set(l1) & set(l2)\n    \n    # Check if the common elements are in the same order in both lists\n    for element in common_elements:\n        if l1.index(element) != l2.index(element):\n            return False\n    \n    return True"}
{"id": "498_0", "code": "def average_Odd(n):\n    sum_odd = 0\n    count_odd = 0\n    for i in range(1, n+1, 2):\n        sum_odd += i\n        count_odd += 1\n    if count_odd == 0:\n        return 0\n    return sum_odd / count_odd"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    if k == 0:\n        return 0\n    n = len(arr)\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(k, arr[i] - 1, -1):\n            dp[j] += dp[j - arr[i]]\n    return dp[k]"}

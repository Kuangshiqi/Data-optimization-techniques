{"id": "0_0", "code": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the last occurrence\n    s = s[:last_occurrence] + s[last_occurrence + 1:]\n    \n    return s"}
{"id": "1_0", "code": "def sort_matrix(M):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in M]\n    \n    # Create a list of tuples (row_sum, index) to sort by row sum\n    row_index_pairs = list(enumerate(row_sums))\n    \n    # Sort the list of tuples by row sum\n    row_index_pairs.sort(key=lambda x: x[1])\n    \n    # Extract the sorted rows\n    sorted_rows = [M[i] for i, _ in row_index_pairs]\n    \n    return sorted_rows"}
{"id": "2_0", "code": "def count_common(words):\n    # Initialize an empty dictionary to store word counts\n    word_count = {}\n    \n    # Iterate over each word in the input dictionary\n    for word, count in words.items():\n        # If the word is already in the dictionary, increment its count\n        if word in word_count:\n            word_count[word] += count\n        # If the word is not in the dictionary, add it with the given count\n        else:\n            word_count[word] = count\n    \n    # Find the maximum count\n    max_count = max(word_count.values())\n    \n    # Initialize a list to store the most common words\n    most_common = []\n    \n    # Iterate over the word count dictionary to find words with the maximum count\n    for word, count in word_count.items():\n        if count == max_count:\n            most_common.append(word)\n    \n    return most_common"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    # Calculate the area of the triangular base\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n        current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "import re\n\ndef text_lowercase_underscore(text):\n    # Use regular expression to find sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "6_0", "code": "def square_perimeter(a):\n    return 4 * a"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    # Convert the second string to a set for faster lookup\n    second_set = set(second_string)\n    \n    # Use a list comprehension to filter out characters present in the second set\n    cleaned_string = ''.join([char for char in string if char not in second_set])\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    # Create an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each number in the array\n    for num in arraynums:\n        # If the number is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the number to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False"}
{"id": "9_0", "code": "def is_woodall(x):\n    # A number is considered woodall if it can be expressed as x * 2^x - 1\n    # We need to check if there exists an integer n such that x * 2^n - 1 = x\n    # This simplifies to 2^n - 1 = 1, which means 2^n = 2\n    # The only integer n that satisfies this is n = 1\n    # Therefore, the only woodall number is 1\n    return x == 1"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    if m <= 0 or n <= 0:\n        return []\n    multiples = []\n    for i in range(1, m + 1):\n        multiples.append(i * n)\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    # Return the maximum sum found\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    # Initialize the decimal value to 0\n    decimal_value = 0\n    \n    # Get the length of the binary string\n    length = len(binary)\n    \n    # Iterate over each digit in the binary string\n    for i in range(length):\n        # Get the current digit\n        digit = binary[length - 1 - i]\n        \n        # Convert the digit to an integer\n        digit_value = int(digit)\n        \n        # Calculate the contribution of the current digit to the decimal value\n        decimal_value += digit_value * (2 ** i)\n    \n    return decimal_value"}
{"id": "14_0", "code": "def find_Product(arr, n):\n    # Dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Count the frequency of each element in the array\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Initialize the product to 1\n    product = 1\n    \n    # Iterate through the array again to find non-repeated elements\n    for num in arr:\n        # If the frequency of the element is 1, it is non-repeated\n        if frequency[num] == 1:\n            product *= num\n    \n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    # Check if all tuples in the list have at least K elements\n    return all(len(t) >= K for t in test_list)"}
{"id": "16_0", "code": "def remove(strings):\n    # Use a list comprehension to filter out strings containing digits\n    return [s for s in strings if not any(char.isdigit() for char in s)]"}
{"id": "17_0", "code": "def binomial_Coeff(n, k):\n    # Base cases\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a 2D list to store binomial coefficients\n    C = [[0 for x in range(k+1)] for y in range(n+1)]\n    \n    # Calculate binomial coefficients using Pascal's triangle\n    for i in range(n+1):\n        for j in range(min(i, k)+1):\n            if j == 0 or j == i:\n                C[i][j] = 1\n            else:\n                C[i][j] = C[i-1][j-1] + C[i-1][j]\n    \n    return C[n][k]"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    # Initialize result\n    result = 0\n    \n    # Iterate through all elements\n    for i in range(arr_size):\n        # XOR with the result\n        result ^= arr[i]\n    \n    return result"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the substring starts and ends with the same character\n            if s[i] == s[j]:\n                count += 1\n                \n    return count"}
{"id": "20_0", "code": "import heapq\n\ndef func(nums, k):\n    # Flatten the list of lists into a single list\n    flat_nums = [num for sublist in nums for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = {}\n    for num in flat_nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Use a max-heap to find the top k most frequent numbers\n    max_heap = []\n    for num, count in frequency.items():\n        heapq.heappush(max_heap, (-count, num))\n    \n    # Extract the top k numbers from the heap\n    top_k = [heapq.heappop(max_heap)[1] for _ in range(k)]\n    \n    return top_k"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i +2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, store i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    if N == 0:\n        return \"0\"\n    binary = \"\"\n    while N > 0:\n        remainder = N % 2\n        binary = str(remainder) + binary\n        N = N // 2\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar, N):\n    # Calculate the expected sum of the first N natural numbers\n    expected_sum = N * (N + 1) // 2\n    \n    # Calculate the actual sum of the array elements\n    actual_sum = sum(ar)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number"}
{"id": "24_0", "code": "def find_rect_num(n):\n    if n <= 0:\n        return 0\n    return n * (n + 1) // 2"}
{"id": "25_0", "code": "def find_Nth_Digit(p, q, N):\n    # Calculate the number of digits in the fraction p/q\n    num_digits = 0\n    while p > 0:\n        p //= 10\n        num_digits += 1\n    \n    # Calculate the starting position of the Nth digit\n    start_pos = N - 1\n    \n    # Calculate the number of complete cycles of the fraction\n    complete_cycles = start_pos // num_digits\n    \n    # Calculate the remaining position after complete cycles\n    remaining_pos = start_pos % num_digits\n    \n    # Calculate the numerator and denominator of the fraction at the remaining position\n    numerator = p * (10 ** remaining_pos) + q\n    denominator = q * (10 ** remaining_pos)\n    \n    # Find the Nth digit\n    while numerator > 0:\n        numerator //= 10\n        N -= 1\n    \n    return numerator"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    # Separate the integers and strings\n    integers = [item for item in mixed_list if isinstance(item, int)]\n    strings = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort the integers and strings separately\n    integers.sort()\n    strings.sort()\n    \n    # Concatenate the sorted integers and strings\n    sorted_list = integers + strings\n    \n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in list1:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    \n    # Check if both first even and first odd numbers are found\n    if first_even is not None and first_odd is not None:\n        # Calculate the division of the first even and odd numbers\n        result = first_even / first_odd\n        return result\n    else:\n        # Return None if either the first even or first odd number is not found\n        return None"}
{"id": "28_0", "code": "def rearrange_string(S):\n    # Count the frequency of each character in the string\n    char_count = {}\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the character with the highest frequency\n    max_freq = max(char_count.values())\n    max_freq_char = [char for char, count in char_count.items() if count == max_freq][0]\n    \n    # If the character with the highest frequency appears more than half the length of the string, it cannot be rearranged\n    if max_freq > (len(S) + 1) // 2:\n        return False\n    \n    # Try to rearrange the string\n    result = []\n    while max_freq_char in char_count:\n        result.append(max_freq_char)\n        char_count[max_freq_char] -= 1\n        if char_count[max_freq_char] == 0:\n            del char_count[max_freq_char]\n    \n    # If there are still characters left, try to place them in the gaps\n    for char, count in char_count.items():\n        while count > 0:\n            for i in range(len(result)):\n                if result[i] != char:\n                    result.insert(i, char)\n                    count -= 1\n                    break\n            else:\n                # If no gap is found, return False\n                return False\n    \n    return ''.join(result)"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flat_list)\n    \n    return frequency"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr, n):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    \n    # Iterate through the array to count occurrences of each element\n    for i in range(n):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n    \n    # Initialize the sum of repeated elements\n    sum_repeated = 0\n    \n    # Iterate through the dictionary to find elements with more than one occurrence\n    for key, value in count_dict.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Use regex to find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    # Check if the text starts with a word\n    if text and text[0].isalpha():\n        return True\n    return False"}
{"id": "34_0", "code": "def get_gcd(l):\n    if not l:\n        return None  # Return None if the list is empty\n\n    # Use the math.gcd function to find the gcd of the list\n    from math import gcd\n    result = l[0]\n    for num in l[1:]:\n        result = gcd(result, num)\n\n    return result"}
{"id": "35_0", "code": "def test_distinct(data):\n    # Convert the list to a set to remove duplicates\n    unique_data = set(data)\n    \n    # Compare the length of the original list with the set\n    # If they are the same, all elements were distinct\n    return len(data) == len(unique_data)"}
{"id": "36_0", "code": "def compute_Last_Digit(A, B):\n    # If A is greater than B, the last digit of A! divided by B! is 0\n    if A > B:\n        return 0\n    \n    # If A is less than B, the last digit of A! divided by B! is the same as the last digit of A!\n    if A < B:\n        return compute_Last_Digit(A, A)\n    \n    # If A is equal to B, the last digit of A! divided by B! is 1\n    return 1"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    # Initialize a mask with all odd bits set\n    mask = 0xAAAAAAAA  # This mask has all odd bits set (10101010... in binary)\n    \n    # Use the bitwise OR operation to set all odd bits of n\n    result = n | mask\n    \n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each sublist in the two-dimensional list\n    for sublist in nums:\n        # Check if the sublist has at least N elements\n        if len(sublist) >= N:\n            # Append the first N elements of the sublist to the result list\n            result.extend(sublist[:N])\n    \n    return result"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    # Use the min function with a lambda function to find the list with the minimum length\n    return min(input_list, key=lambda x: len(x))"}
{"id": "40_0", "code": "def check_equilateral(x, y, z):\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b, h):\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    # Check if the string is empty\n    if not str:\n        return False\n    \n    # Get the first and last characters of the string\n    first_char = str[0]\n    last_char = str[-1]\n    \n    # Compare the first and last characters\n    return first_char == last_char"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    if not my_list:\n        return []\n\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Initialize the count array with zeros\n    count = [0] * (max_value + 1)\n\n    # Count the occurrences of each element in the list\n    for num in my_list:\n        count[num] += 1\n\n    # Create the sorted list\n    sorted_list = []\n    for num, freq in enumerate(count):\n        sorted_list.extend([num] * freq)\n\n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a, n, r):\n    # Calculate the t-nth term of the geometric series\n    tn = a * (r ** (n - 1))\n    return tn"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to reverse it\n    str_n = str(n)\n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"id": "46_0", "code": "def find_Max_Num(arr, n):\n    # Convert each digit to a string to facilitate comparison\n    arr = [str(digit) for digit in arr]\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Join the sorted array into a single string\n    max_num_str = ''.join(arr)\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x, y):\n    # Check if both numbers are zero\n    if x == 0 and y == 0:\n        return False\n    \n    # Check if one number is positive and the other is negative\n    return (x > 0 and y < 0) or (x < 0 and y > 0)"}
{"id": "48_0", "code": "def is_octagonal(n):\n    # Check if n is a positive integer\n    if n <= 0:\n        return False\n    \n    # Calculate the nth octagonal number using the formula\n    octagonal_number = (3 * n * (n - 1)) + 1\n    \n    # Check if the calculated number is equal to n\n    return octagonal_number == n\n\ndef nth_octagonal(n):\n    # Check if n is a positive integer\n    if n <= 0:\n        return None\n    \n    # Calculate the nth octagonal number using the formula\n    octagonal_number = (3 * n * (n - 1)) + 1\n    \n    return octagonal_number"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    if n == 0:\n        return 0\n    \n    # Initialize the dp array where dp[i] will store the length of the longest subsequence\n    # ending at index i with the required property.\n    dp = [1] * n\n    \n    # Variable to store the maximum length found so far.\n    max_length = 1\n    \n    # Iterate through the array starting from the second element.\n    for i in range(1, n):\n        # Check for the condition that the difference between adjacent elements is 1.\n        if abs(arr[i] - arr[i - 1]) == 1:\n            # Update the dp array for the current index.\n            dp[i] = dp[i - 1] + 1\n            # Update the maximum length found so far.\n            max_length = max(max_length, dp[i])\n    \n    return max_length"}
{"id": "50_0", "code": "def count_Substrings(s, n):\n    def is_valid_substring(sub):\n        # Calculate the sum of digits in the substring\n        digit_sum = sum(int(digit) for digit in sub)\n        # Check if the sum of digits is equal to the length of the substring\n        return digit_sum == len(sub)\n    \n    count = 0\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_valid_substring(substring):\n                count += 1\n    \n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    if not xs:\n        raise ValueError(\"The list is empty\")\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate through each pair of elements in the list\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            # Calculate the absolute difference between the pair\n            diff = abs(test_list[i] - test_list[j])\n            \n            # Update the maximum difference if the current difference is larger\n            if diff > max_diff:\n                max_diff = diff\n    \n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples using a lambda function\n    sorted_subjectmarks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subjectmarks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize a list to store Bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1  # Base case: there is one way to partition an empty set\n\n    # Compute Bell numbers using the recursive relation\n    for i in range(1, n + 1):\n        # Compute the Bell number for i using the previous Bell numbers\n        bell[i] = sum(bell[j] for j in range(i))\n\n    return bell[n]"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    if not A:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n    \n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    # Check if the sublist is empty\n    if not s:\n        return True\n    \n    # Check if the sublist is longer than the list\n    if len(s) > len(l):\n        return False\n    \n    # Iterate through the list and check if the sublist matches\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    \n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    # Check if all tuples in the list have the same length\n    all_equal = all(len(t) == k for t in Input)\n    return all_equal"}
{"id": "60_0", "code": "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        sorted = True\n\n        for i in range(0, n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = False\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    # A number can be represented as the difference of two squares if and only if it is not of the form 4k + 2\n    return n % 4 != 2"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define a regex pattern that matches any of the delimiters: space, comma, semicolon, or colon\n    pattern = r'[ ,;:]'\n    \n    # Use re.split() to split the text based on the pattern\n    result = re.split(pattern, text)\n    \n    return result"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    # Check if the number of colors matches the number of patterns\n    if len(colors) != len(patterns):\n        return False\n    \n    # Iterate over each color and pattern pair\n    for color, pattern in zip(colors, patterns):\n        # Check if the color matches the pattern\n        if color != pattern:\n            return False\n    \n    # If all colors match their respective patterns, return True\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples where all elements are divisible by K\n    result = [tup for tup in test_list if all(ele % K == 0 for ele in tup)]\n    return result"}
{"id": "65_0", "code": "def count_Squares(m, n):\n    # The number of squares of side length k in a rectangle of size m x n is (m-k+1) * (n-k+1)\n    total_squares = 0\n    for k in range(1, min(m, n) + 1):\n        total_squares += (m - k + 1) * (n - k + 1)\n    return total_squares"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number to a string to iterate over each digit\n    n_str = str(n)\n    \n    # Initialize sums for even and odd digits\n    sum_even = 0\n    sum_odd = 0\n    \n    # Iterate over each character in the string\n    for char in n_str:\n        # Convert the character back to an integer\n        digit = int(char)\n        \n        # Check if the digit is even or odd and add to respective sum\n        if digit % 2 == 0:\n            sum_even += digit\n        else:\n            sum_odd += digit\n    \n    # Calculate the difference between the sum of even and odd digits\n    difference = sum_even - sum_odd\n    \n    # Return the difference\n    return difference"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    # Check if the length of the word is odd\n    if len(s) % 2 != 0:\n        return True\n    else:\n        return False"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    # Calculate the nth tetrahedral number using the formula\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length to be zipped.\")\n    \n    # Use zip to combine the tuples\n    zipped = zip(test_tup1, test_tup2)\n    \n    # Convert the zip object to a list of tuples\n    result = list(zipped)\n    \n    return result"}
{"id": "71_0", "code": "def volume_sphere(r):\n    import math\n    return (4/3) * math.pi * (r ** 3)"}
{"id": "72_0", "code": "def get_Char(strr):\n    # Initialize the sum of ASCII values to 0\n    total_sum = 0\n    \n    # Iterate over each character in the string\n    for char in strr:\n        # Add the ASCII value of the character to the total sum\n        total_sum += ord(char)\n    \n    # Convert the total sum to a character using chr()\n    result_char = chr(total_sum)\n    \n    # Return the resulting character\n    return result_char"}
{"id": "73_0", "code": "def sequence(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        sequence = [1, 1]\n        for i in range(3, n + 1):\n            next_value = sequence[sequence[i - 1] - 1] + sequence[i - sequence[i - 1]]\n            sequence.append(next_value)\n        return sequence[n - 1]"}
{"id": "74_0", "code": "def surfacearea_sphere(r):\n    import math\n    return 4 * math.pi * r ** 2"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    # The nth centered hexagonal number can be calculated using the formula:\n    # C(n) = 3n^2 - 3n + 1\n    return 3 * n**2 - 3 * n + 1"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    # Create a new dictionary to store the merged results\n    merged_dict = {}\n    \n    # Iterate over the keys in the first dictionary\n    for key in dict1:\n        # Add the key-value pair to the merged dictionary\n        merged_dict[key] = dict1[key]\n    \n    # Iterate over the keys in the second dictionary\n    for key in dict2:\n        # If the key is not already in the merged dictionary, add it\n        if key not in merged_dict:\n            merged_dict[key] = dict2[key]\n        else:\n            # If the key is already in the merged dictionary, update its value\n            merged_dict[key] = dict2[key]\n    \n    # Iterate over the keys in the third dictionary\n    for key in dict3:\n        # If the key is not already in the merged dictionary, add it\n        if key not in merged_dict:\n            merged_dict[key] = dict3[key]\n        else:\n            # If the key is already in the merged dictionary, update its value\n            merged_dict[key] = dict3[key]\n    \n    # Return the merged dictionary\n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    frequency = {}\n    for element in list1:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency"}
{"id": "78_0", "code": "def closest_num(N):\n    # If N is less than 1, there is no smaller number\n    if N < 1:\n        return None\n    \n    # Start checking from N-1 down to 1\n    for i in range(N-1, 0, -1):\n        if i < N:\n            return i\n    \n    # If no smaller number is found, return None\n    return None"}
{"id": "79_0", "code": "def len_log(list1):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in list1:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the length of the longest word\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    # Check if the substring is present in the list of strings\n    return sub_str in str1"}
{"id": "81_0", "code": "def is_undulating(n):\n    # Convert the number to a string to easily iterate over digits\n    str_n = str(n)\n    \n    # Check if the string length is less than 3, as an undulating number must have at least 3 digits\n    if len(str_n) < 3:\n        return False\n    \n    # Check if the first two digits are the same and the last two digits are the same\n    if str_n[0] == str_n[1] and str_n[-1] == str_n[-2]:\n        return True\n    \n    # Check if the first two digits are different and the last two digits are different\n    if str_n[0] != str_n[1] and str_n[-1] != str_n[-2]:\n        return True\n    \n    # If none of the above conditions are met, the number is not undulating\n    return False"}
{"id": "82_0", "code": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    # Initialize variables to store the minimum value and its index\n    min_value = float('inf')\n    min_index = -1\n    \n    # Iterate over the list of tuples\n    for index, (key, value) in enumerate(test_list):\n        # Check if the current value is less than the minimum value found so far\n        if value < min_value:\n            min_value = value\n            min_index = index\n    \n    # Return the index of the tuple with the minimum value\n    return min_index"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n\n    min_length = float('inf')  # Initialize min_length to infinity\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n\n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    frequency_dict = {}\n    for sublist in list1:\n        if tuple(sublist) in frequency_dict:\n            frequency_dict[tuple(sublist)] += 1\n        else:\n            frequency_dict[tuple(sublist)] = 1\n    return frequency_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    if not numbers:\n        return 0  # Return 0 if the list is empty to avoid division by zero\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        remainder = n % 2\n        binary = str(remainder) + binary\n        n = n // 2\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    # Convert the number to a string to easily manipulate\n    num_str = str(num)\n    \n    # Start checking from the next number\n    for i in range(num + 1, 10**len(num_str)):\n        # Convert the number to a string and check if it's a palindrome\n        if str(i) == str(i)[::-1]:\n            return i"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    # Check if k is within the valid range\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of bounds\")\n    \n    # Sort the array\n    arr.sort()\n    \n    # Return the kth element (0-based index)\n    return arr[k - 1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    # Split the word by underscores\n    parts = word.split('_')\n    # Capitalize the first letter of each part and join them together\n    camel_case_word = ''.join(part.capitalize() for part in parts)\n    return camel_case_word"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    # Use list comprehension to apply the sorted function to each sublist\n    return [sorted(sublist, key=lambda x: x) for sublist in input_list]"}
{"id": "94_0", "code": "def count(lst):\n    return sum(1 for item in lst if item)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    # Convert the list to a tuple\n    list_to_tuple = tuple(test_list)\n    \n    # Add the list to the tuple\n    result = list_to_tuple + test_tup\n    \n    return result"}
{"id": "96_0", "code": "def count_Hexadecimal(L, R):\n    # Initialize a counter for hexadecimal numbers\n    count = 0\n    \n    # Iterate through the range from L to R (inclusive)\n    for num in range(L, R + 1):\n        # Convert the number to hexadecimal\n        hex_num = hex(num)[2:]  # [2:] to remove the '0x' prefix\n        # Check if the hexadecimal number is valid (i.e., it contains only valid hexadecimal digits)\n        if all(char in '0123456789abcdef' for char in hex_num):\n            # Increment the counter if the number is valid\n            count += 1\n    \n    # Return the total count of valid hexadecimal numbers\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create iterators for each input\n    it1 = iter(num1)\n    it2 = iter(num2)\n    it3 = iter(num3)\n    \n    # Use heapq.merge to merge the iterators\n    merged = heapq.merge(it1, it2, it3)\n    \n    # Convert the merged iterator to a list and return it\n    return list(merged)"}
{"id": "98_0", "code": "def odd_Equivalent(s, n):\n    # Convert the binary string to an integer\n    num = int(s, 2)\n    \n    # Check if the number is odd\n    if num % 2 == 1:\n        # Count the number of rotations\n        rotations = n\n    else:\n        # If the number is even, no rotations are needed\n        rotations = 0\n    \n    return rotations"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    # Create a set of all numbers in the range from strt_val to stop_val\n    full_range = set(range(strt_val, stop_val + 1))\n    \n    # Create a set of numbers from the test_list\n    test_set = set(test_list)\n    \n    # Find the difference between the full range and the test set\n    missing_ranges = full_range - test_set\n    \n    # Convert the set of missing ranges to a list of tuples\n    missing_ranges_list = list(missing_ranges)\n    \n    return missing_ranges_list"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Flatten the nested list\n    flat_list = [item for sublist in nestedlist for item in sublist]\n    \n    # Use a set to find unique elements\n    unique_elements = set(flat_list)\n    \n    # Find common elements by comparing with the original list\n    common_elements = [item for item in unique_elements if item in nestedlist]\n    \n    return common_elements"}
{"id": "101_0", "code": "def perimeter(diameter, height):\n    # The perimeter of a cylinder is the sum of the circumference of the two circular bases\n    # and the height of the cylinder.\n    # The circumference of a circle is given by 2 * pi * radius.\n    # The radius is half of the diameter.\n    radius = diameter / 2\n    # Calculate the circumference of one base\n    circumference = 2 * 3.14159 * radius\n    # The perimeter is the sum of the circumferences of both bases and the height\n    perimeter = 2 * circumference + height\n    return perimeter"}
{"id": "102_0", "code": "def check_integer(text):\n    # Check if the text is empty\n    if not text:\n        return False\n    \n    # Check if the text is a valid integer\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    # Create a dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Return the dictionary containing the frequency of each tuple\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    # Check if all dictionaries in the list are empty\n    return all(not d for d in list1)"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    # Convert each number in the tuple to a string\n    num_strs = [str(num) for num in nums]\n    # Join the string representations of the numbers into a single string\n    num_str = ''.join(num_strs)\n    # Convert the resulting string back to an integer\n    return int(num_str)"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    # Use a list comprehension to convert each element to float\n    # The try-except block is used to handle non-convertible elements\n    result = [float(element) for element in test_list if isinstance(element, (int, float))]\n    return result"}
{"id": "107_0", "code": "def string_to_list(string):\n    # Split the string by spaces to get individual words\n    words = string.split()\n    # Convert the list of words into a list of strings\n    return words"}
{"id": "108_0", "code": "def search(arr, n):\n    # Initialize two pointers\n    left, right = 0, n - 1\n    \n    # Use binary search to find the unique element\n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if the middle element is the unique element\n        if mid % 2 == 0:\n            if arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        else:\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    # The unique element is found at the left pointer\n    return arr[left]"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    # Initialize the maximum product to a very small number\n    max_product = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for tup in list1:\n        # Calculate the product of the tuple elements\n        product = tup[0] * tup[1]\n        \n        # Update the maximum product if the current product is greater\n        if product > max_product:\n            max_product = product\n    \n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array to use the two-pointer technique\n    A.sort()\n    \n    # Iterate through the array\n    for i in range(n - 2):\n        # To avoid duplicate triplets\n        if i > 0 and A[i] == A[i - 1]:\n            continue\n        \n        # Initialize two pointers\n        left, right = i + 1, n - 1\n        \n        # Use two pointers to find the other two numbers\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            \n            if current_sum == sum:\n                # Found a triplet\n                count += 1\n                # Move the left pointer to the right to avoid duplicates\n                left += 1\n                # Move the right pointer to the left to avoid duplicates\n                right -= 1\n                # Skip duplicates\n                while left < right and A[left] == A[left - 1]:\n                    left += 1\n                while left < right and A[right] == A[right + 1]:\n                    right -= 1\n            elif current_sum < sum:\n                # If the sum is less than the target, move the left pointer to the right\n                left += 1\n            else:\n                # If the sum is greater than the target, move the right pointer to the left\n                right -= 1\n    \n    return count"}
{"id": "111_0", "code": "def smartNumber(n):\n    # Initialize the first two smart numbers\n    smart_numbers = [1, 2]\n    \n    # Generate smart numbers until we reach the nth one\n    while len(smart_numbers) < n:\n        # The next smart number is the sum of the last two smart numbers\n        next_smart_number = smart_numbers[-1] + smart_numbers[-2]\n        smart_numbers.append(next_smart_number)\n    \n    # Return the nth smart number\n    return smart_numbers[n-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n) if n % i == 0)\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        divisor_sum = sum_of_divisors(num)\n        if divisor_sum != num and sum_of_divisors(divisor_sum) == num:\n            amicable_sum += num\n\n    return amicable_sum"}
{"id": "113_0", "code": "import cmath\n\ndef angle_complex(a, b):\n    # Create a complex number from the given real and imaginary parts\n    complex_num = complex(a, b)\n    \n    # Calculate the angle of the complex number\n    angle = cmath.phase(complex_num)\n    \n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\n    max_diff = 0\n    current_diff = 0\n    zero_count = 0\n    one_count = 0\n\n    for i in range(n):\n        if string[i] == '0':\n            zero_count += 1\n        else:\n            one_count += 1\n\n        current_diff = zero_count - one_count\n\n        if current_diff > max_diff:\n            max_diff = current_diff\n\n    return max_diff"}
{"id": "115_0", "code": "def sum(a, b):\n    # Helper function to find the greatest common divisor (GCD)\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    # Helper function to find all divisors of a number\n    def divisors(n):\n        divs = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.append(i)\n                if i != n // i:\n                    divs.append(n // i)\n        return divs\n\n    # Find the GCD of the two numbers\n    common_gcd = gcd(a, b)\n\n    # Find all divisors of the GCD\n    common_divisors = divisors(common_gcd)\n\n    # Calculate the sum of the common divisors\n    return sum(common_divisors)"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    # Handle negative numbers\n    if x < 0:\n        x = -x\n        y = -y\n    elif y < 0:\n        y = -y\n    \n    # Initialize result\n    result = 0\n    \n    # Add x to result y times\n    for _ in range(y):\n        result += x\n    \n    # If the original numbers were negative, return the negative result\n    if (x < 0) ^ (y < 0):\n        return -result\n    else:\n        return result"}
{"id": "117_0", "code": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split()\n    \n    # Filter the list to include only words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n    \n    n = len(my_matrix)\n    total_sum = n * (n * n + 1) // 2\n    \n    # Check rows and columns\n    for i in range(n):\n        if sum(my_matrix[i]) != total_sum or sum(my_matrix[j][i] for j in range(n)) != total_sum:\n            return False\n    \n    # Check diagonals\n    if sum(my_matrix[i][i] for i in range(n)) != total_sum or sum(my_matrix[i][n-i-1] for i in range(n)) != total_sum:\n        return False\n    \n    return True"}
{"id": "119_0", "code": "def max_occurrences(nums):\n    from collections import Counter\n    \n    # Count the occurrences of each item in the list\n    counts = Counter(nums)\n    \n    # Find the item with the maximum frequency\n    max_item = counts.most_common(1)[0][0]\n    \n    return max_item"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = \"aeiouAEIOU\"\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    \n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    # Convert the tuple to a string\n    result = ''.join(map(str, tup1))\n    return result"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(filter(lambda x: x < 0, nums))"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    # Perform the operation p times\n    for _ in range(p):\n        # Check if the last element is even or odd\n        if arr[-1] % 2 == 0:\n            return \"Even\"\n        else:\n            return \"Odd\"\n    # If the loop completes without returning, the last element is even\n    return \"Even\""}
{"id": "124_0", "code": "def hexagonal_num(n):\n    # The nth hexagonal number can be calculated using the formula: n * (2n - 1)\n    return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    # Define the base rate and additional charges\n    base_rate = 5  # per unit\n    additional_charge = 0.1  # 10% of the total bill for units above 100\n    \n    # Calculate the total bill\n    total_bill = units * base_rate\n    \n    # Check if the units exceed 100 and apply additional charge\n    if units > 100:\n        total_bill += total_bill * additional_charge\n    \n    return total_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    # Initialize counters for zeroes and total elements\n    zero_count = 0\n    total_elements = len(nums)\n    \n    # Iterate through the array to count zeroes\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    \n    # Calculate the ratio of zeroes\n    if total_elements == 0:\n        return 0  # Avoid division by zero if the array is empty\n    ratio = zero_count / total_elements\n    \n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    # Check if n is less than 1, as 0 cannot be represented as sum of powers of 2\n    if n < 1:\n        return False\n    \n    # Iterate over all powers of 2\n    for i in range(32):  # Assuming 32-bit integer for simplicity\n        power_of_two = 1 << i\n        if power_of_two <= n:\n            n -= power_of_two\n        else:\n            break\n    \n    # If n is reduced to 0, it means n can be represented as sum of powers of 2\n    return n == 0"}
{"id": "128_0", "code": "def circle_circumference(r):\n    import math\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for sublist in test_list:\n        for element in sublist:\n            if element in count_dict:\n                count_dict[element] += 1\n            else:\n                count_dict[element] = 1\n    \n    # Extract elements that occur only once\n    result = [element for element, count in count_dict.items() if count == 1]\n    \n    return result"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n):\n        # Find the maximum element in the unsorted portion of the list\n        max_index = nums.index(max(nums[:n-i]))\n        \n        # Flip the maximum element to the beginning of the unsorted portion\n        nums[:max_index+1] = nums[:max_index+1][::-1]\n        \n        # Flip the entire unsorted portion to move the maximum element to its correct position\n        nums[:n-i] = nums[:n-i][::-1]\n    \n    return nums"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    # Initialize a counter for the same pairs\n    count = 0\n    \n    # Iterate over each element in list1\n    for item1 in list1:\n        # Iterate over each element in list2\n        for item2 in list2:\n            # Check if the pair (item1, item2) is in list3\n            if (item1, item2) in list3:\n                # Increment the counter if the pair is found\n                count += 1\n    \n    # Return the total count of same pairs\n    return count"}
{"id": "132_0", "code": "def find_lists(Input):\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    if n < 2:\n        return 0  # Not enough elements to form a difference\n\n    # Initialize the minimum and maximum elements\n    min_element = arr[0]\n    max_element = arr[0]\n\n    # Iterate through the array to find the minimum and maximum elements\n    for i in range(1, n):\n        if arr[i] < min_element:\n            min_element = arr[i]\n        if arr[i] > max_element:\n            max_element = arr[i]\n\n    # The maximum absolute difference is the difference between the maximum and minimum elements\n    return max_element - min_element"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    total_ascii_value = 0\n    for char in str1:\n        total_ascii_value += ord(char)\n    return total_ascii_value"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Create a 2D list to store the maximum path sums\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Start from the bottom of the triangle\n    for i in range(m - 1, -1, -1):\n        for j in range(i + 1):\n            # Calculate the maximum path sum for the current position\n            dp[i][j] = tri[i][j] + max(dp[i + 1][j], dp[i + 1][j + 1])\n    \n    # The maximum path sum will be in the top-left corner of the dp table\n    return dp[0][0]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    # Convert the number to a string to iterate over each digit\n    str_N = str(N)\n    # Initialize two lists to store the digits of the two parts\n    part1 = []\n    part2 = []\n    \n    # Iterate over the digits of the number\n    for i, digit in enumerate(str_N):\n        # If the index is even, add the digit to part1\n        if i % 2 == 0:\n            part1.append(int(digit))\n        # If the index is odd, add the digit to part2\n        else:\n            part2.append(int(digit))\n    \n    # Calculate the sum of digits for each part\n    sum_part1 = sum(part1)\n    sum_part2 = sum(part2)\n    \n    # Return the two parts\n    return part1, part2"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    # Initialize a list to store the length of the longest subsequence ending at each index\n    dp = [1] * n\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, n):\n        # Check if the difference between the current element and the previous one is 1\n        if arr[i] == arr[i - 1] + 1:\n            # Update the dp value for the current index\n            dp[i] = dp[i - 1] + 1\n    \n    # Find the maximum value in the dp list, which represents the length of the longest subsequence\n    max_length = max(dp)\n    \n    # Return the length of the longest subsequence\n    return max_length"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    # Check if the number 'a' is present in the infinite sequence defined by 'b' and 'c'\n    # The sequence is generated by the formula: b + (n-1) * c, where n is a positive integer\n    # We need to find if 'a' can be expressed in this form for some positive integer n\n    # Rearrange the formula to solve for n: n = (a - b) / c + 1\n    # If n is a positive integer, then 'a' is present in the sequence\n    if c == 0:\n        # If c is 0, the sequence is constant and only contains 'b'\n        return a == b\n    else:\n        # Calculate n\n        n = (a - b) / c + 1\n        # Check if n is a positive integer\n        return n.is_integer() and n > 0"}
{"id": "140_0", "code": "def is_coprime(x, y):\n    # Function to calculate the greatest common divisor (GCD)\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    # Check if the GCD of x and y is 1\n    return gcd(x, y) == 1"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) > 1:\n        mid = len(x) // 2\n        L = x[:mid]\n        R = x[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                x[k] = L[i]\n                i += 1\n            else:\n                x[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            x[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            x[k] = R[j]\n            j += 1\n            k += 1"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    # Calculate the x-coordinate of the vertex using the formula x = -b / (2a)\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex using the formula y = ax^2 + bx + c\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    # Return the vertex as a tuple (x_vertex, y_vertex)\n    return (x_vertex, y_vertex)"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    # Initialize an empty list to store the specified elements\n    result = []\n    \n    # Iterate over each row in the two-dimensional list\n    for row in nums:\n        # Iterate over each element in the row\n        for element in row:\n            # Check if the element is at the specified position N\n            if element == N:\n                # If it is, append it to the result list\n                result.append(element)\n    \n    # Return the list of specified elements\n    return result"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a mask with all even bits set to 1\n    mask = 0b10101010101010101010101010101010\n    # Use bitwise XOR to toggle even bits\n    return n ^ mask"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    # Convert each string in the tuple to an integer\n    return tuple(int(item) for item in tuple_str)"}
{"id": "146_0", "code": "def encode_list(list1):\n    if not list1:\n        return []\n    \n    encoded_list = []\n    count = 1\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            encoded_list.append((list1[i - 1], count))\n            count = 1\n    \n    # Append the last group\n    encoded_list.append((list1[-1], count))\n    \n    return encoded_list"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    # Sort the array to make it easier to find the minimum operations\n    arr.sort()\n    \n    # Initialize the minimum operations to 0\n    min_ops = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        # Calculate the number of operations needed to make all elements equal to arr[i]\n        ops = (arr[i] - arr[0]) * (n - i)\n        # Update the minimum operations\n        min_ops = min(min_ops, ops)\n    \n    return min_ops"}
{"id": "148_0", "code": "def month_season(month, days):\n    # Define the seasons based on the month and day\n    if (month == 12 and days >= 21) or (month == 1 and days < 20):\n        print(\"Winter\")\n    elif (month == 2 and days < 20) or (month == 3 and days >= 21):\n        print(\"Spring\")\n    elif (month == 4 and days < 20) or (month == 5 and days >= 21):\n        print(\"Summer\")\n    elif (month == 6 and days < 20) or (month == 7 and days >= 21):\n        print(\"Autumn\")\n    else:\n        print(\"Invalid month or day\")\n\n# Example usage:\nmonth_season(12, 25)  # Output: Winter\nmonth_season(3, 15)   # Output: Spring\nmonth_season(6, 10)   # Output: Summer\nmonth_season(9, 20)   # Output: Autumn\nmonth_season(11, 15)  # Output: Winter"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Check if a and b are coprime\n    if gcd(a, b) != 1:\n        return None  # No solution if a and b are not coprime\n\n    # Find the modular inverse of a modulo b\n    def mod_inverse(x, m):\n        m0, x0, x1 = m, 0, 1\n        while x > 0:\n            q = m // x\n            m, x = x, m % x\n            x0, x1 = x1 - q * x0, x0\n        return x1 if x1 >= 0 else x1 + m0\n\n    # Calculate the modular inverse of a modulo b\n    inv_a = mod_inverse(a, b)\n\n    # Calculate x and y\n    x = (n * inv_a) % b\n    y = (n - a * x) // b\n\n    return x, y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    # Use a list comprehension to filter out elements in list2 from list1\n    result = [element for element in list1 if element not in list2]\n    return result"}
{"id": "151_0", "code": "def sum_series(n):\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total"}
{"id": "152_0", "code": "def area_polygon(s, l):\n    # Calculate the area of a regular polygon\n    # s is the number of sides\n    # l is the length of each side\n    area = (s * l**2) / (4 * tan(pi / s))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n + 1) if n % i == 0)\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)"}
{"id": "154_0", "code": "def count_char_position(str1):\n    # Initialize a counter for matching characters\n    matching_count = 0\n    \n    # Iterate over each character in the string\n    for i in range(len(str1)):\n        # Check if the character is a lowercase letter\n        if 'a' <= str1[i] <= 'z':\n            # Check if the character's position in the alphabet matches its position in the string\n            if (ord(str1[i]) - ord('a') + 1) == (i + 1):\n                matching_count += 1\n        # Check if the character is an uppercase letter\n        elif 'A' <= str1[i] <= 'Z':\n            # Check if the character's position in the alphabet matches its position in the string\n            if (ord(str1[i]) - ord('A') + 1) == (i + 1):\n                matching_count += 1\n    \n    return matching_count"}
{"id": "155_0", "code": "def find_even_Pair(A, N):\n    # Initialize the count of pairs with even XOR\n    even_xor_count = 0\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate the XOR of the pair\n            xor_result = A[i] ^ A[j]\n            \n            # Check if the XOR result is even\n            if xor_result % 2 == 0:\n                # Increment the count if XOR is even\n                even_xor_count += 1\n    \n    # Return the count of pairs with even XOR\n    return even_xor_count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power"}
{"id": "157_0", "code": "def frequency(a, x):\n    count = 0\n    for num in a:\n        if num == x:\n            count += 1\n    return count"}
{"id": "158_0", "code": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    # Ensure m is less than or equal to n\n    if m > n:\n        return 0\n    \n    # Calculate the sum of the numbers between indices m and n (inclusive)\n    return sum(list1[m:n+1])"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    # A pentagon has 5 sides, so the perimeter is 5 times the length of one side\n    return 5 * a"}
{"id": "161_0", "code": "def count_occurance(s):\n    # Initialize a counter for occurrences\n    count = 0\n    \n    # Iterate over the string, checking for the substring 'std'\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    \n    return count"}
{"id": "162_0", "code": "def remove_splchar(text):\n    # Use a list comprehension to filter out non-alphanumeric characters\n    return ''.join([char for char in text if char.isalnum()])"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    result = {}\n    for key, value in l:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result"}
{"id": "164_0", "code": "def is_valid_parentheses(str1):\n    # Initialize a stack to keep track of opening parentheses\n    stack = []\n    \n    # Iterate through each character in the string\n    for char in str1:\n        # If the character is an opening parenthesis, push it onto the stack\n        if char == '(':\n            stack.append(char)\n        # If the character is a closing parenthesis\n        elif char == ')':\n            # Check if the stack is empty (no matching opening parenthesis)\n            if not stack:\n                return False\n            # Pop the last opening parenthesis from the stack\n            stack.pop()\n    \n    # If the stack is empty, all opening parentheses had matching closing ones\n    return len(stack) == 0"}
{"id": "165_0", "code": "def perimeter_triangle(a, b, c):\n    # Calculate the perimeter by summing the lengths of the sides\n    perimeter = a + b + c\n    return perimeter"}
{"id": "166_0", "code": "def answer(L, R):\n    # Start with the smallest possible numbers\n    a = 1\n    b = 2\n    \n    # Iterate through possible values of a and b\n    while a * b <= R:\n        # Check if the lcm of a and b is within the range [L, R]\n        if L <= a * b <= R:\n            return a, b\n        # Move to the next possible value of b\n        b += 1\n    \n    # If no such pair is found, return None\n    return None"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Search for multiple literal strings in a given text.\n\n    Parameters:\n    patterns (list of str): A list of literal strings to search for.\n    text (str): The text in which to search for the patterns.\n\n    Returns:\n    list of int: A list of indices where each pattern is found in the text.\n    \"\"\"\n    found_indices = []\n    for pattern in patterns:\n        start = 0\n        while start < len(text):\n            pos = text.find(pattern, start)\n            if pos != -1:\n                found_indices.append(pos)\n                start = pos + 1\n            else:\n                break\n    return found_indices"}
{"id": "168_0", "code": "def is_num_keith(x):\n    if x < 10:\n        return False\n    \n    digits = [int(d) for d in str(x)]\n    n = len(digits)\n    current_sum = sum(digits)\n    \n    while current_sum < x:\n        next_digit = current_sum % 10\n        digits.append(next_digit)\n        current_sum += next_digit\n        n += 1\n    \n    return current_sum == x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(math.radians, [slat, slon, elat, elon])\n    \n    # Haversine formula\n    dlat = elat - slat\n    dlon = elon - slon\n    a = math.sin(dlat/2)**2 + math.cos(slat) * math.cos(elat) * math.sin(dlon/2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n    distance = 6371 * c  # Radius of the Earth in kilometers\n    \n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    if not arr:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = arr[0]\n    \n    # Compare the prefix with each string in the array\n    for i in range(1, n):\n        while arr[i].find(prefix) != 0:\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix becomes empty, return an empty string\n            if not prefix:\n                return \"\"\n    \n    return prefix"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    # Initialize counters for each character type\n    uppercase_count = 0\n    lowercase_count = 0\n    special_count = 0\n    numeric_count = 0\n\n    # Define regex patterns for each character type\n    uppercase_pattern = re.compile(r'[A-Z]')\n    lowercase_pattern = re.compile(r'[a-z]')\n    special_pattern = re.compile(r'[!@#$%^&*(),.?\":{}|<>]')\n    numeric_pattern = re.compile(r'[0-9]')\n\n    # Find all matches for each pattern and update counters\n    uppercase_count = len(uppercase_pattern.findall(string))\n    lowercase_count = len(lowercase_pattern.findall(string))\n    special_count = len(special_pattern.findall(string))\n    numeric_count = len(numeric_pattern.findall(string))\n\n    # Return the counts as a dictionary\n    return {\n        'uppercase': uppercase_count,\n        'lowercase': lowercase_count,\n        'special': special_count,\n        'numeric': numeric_count\n    }"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a set to store distinct pairs\n    distinct_pairs = set()\n    \n    # Iterate through the array\n    for i in range(n):\n        # Check if the pair (arr[i], arr[i] + k) exists\n        if arr[i] + k in arr:\n            # Add the pair to the set\n            distinct_pairs.add((arr[i], arr[i] + k))\n    \n    # Return the number of distinct pairs\n    return len(distinct_pairs)"}
{"id": "173_0", "code": "def greater_specificnum(list, num):\n    # Use a list comprehension to filter elements greater than the specified number\n    return [x for x in list if x > num]"}
{"id": "174_0", "code": "def parabola_focus(a, b, c):\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the focus\n    y_focus = (1 - (4 * a * c)) / (4 * a)\n    \n    # Return the focus as a tuple (x_focus, y_focus)\n    return (x_focus, y_focus)"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    # Compile all the patterns into regex objects\n    compiled_patterns = [re.compile(pattern) for pattern in patterns]\n    \n    # Check each pattern in the text\n    for pattern in compiled_patterns:\n        if pattern.search(text):\n            return True\n    \n    return False"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array from bottom up\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in dp[m][n]\n    return dp[m][n]"}
{"id": "177_0", "code": "def prod_Square(n):\n    # Check if n can be expressed as a product of two squares\n    for i in range(int(n**0.5) + 1):\n        if i * i <= n:\n            j = int(n**0.5)\n            while j * j >= i * i:\n                if i * i * j * j == n:\n                    return True\n                j -= 1\n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr, n):\n    # Step 1: Place each number in its correct position\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:\n            # Swap arr[i] with arr[arr[i] - 1]\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    \n    # Step 2: Find the first position where the number is not in its correct place\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    \n    # Step 3: If all positions are correct, the missing number is n + 1\n    return n + 1"}
{"id": "179_0", "code": "def count_Integral_Points(x1, y1, x2, y2):\n    # Calculate the width and height of the square\n    width = abs(x2 - x1)\n    height = abs(y2 - y1)\n    \n    # The number of integral points inside the square is (width + 1) * (height + 1)\n    # This is because we include both the start and end points of the square\n    return (width + 1) * (height + 1)"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    # List of months with 30 days\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    # Check if the given month name is in the list of months with 30 days\n    if monthname3 in months_with_30_days:\n        return True\n    else:\n        return False"}
{"id": "181_0", "code": "def check_String(str):\n    has_letter = any(char.isalpha() for char in str)\n    has_number = any(char.isdigit() for char in str)\n    return has_letter and has_number"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    # Convert the tuple to a set to remove duplicates\n    unique_set = set(test_tup)\n    # Convert the set back to a tuple\n    unique_tuple = tuple(unique_set)\n    return unique_tuple"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\n    # Initialize the decimal number to 0\n    decimal_number = 0\n    # Initialize the power of 8 to 0\n    power = 0\n    \n    # Loop through each digit in the octal number\n    while n > 0:\n        # Extract the last digit of the octal number\n        digit = n % 10\n        # Add the digit multiplied by 8 raised to the current power to the decimal number\n        decimal_number += digit * (8 ** power)\n        # Remove the last digit from the octal number\n        n //= 10\n        # Increment the power of 8\n        power += 1\n    \n    return decimal_number"}
{"id": "184_0", "code": "def first(arr, x, n):\n    low = 0\n    high = n - 1\n    result = -1\n    \n    while low <= high:\n        mid = low + (high - low) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            high = mid - 1  # Move left to find the first occurrence\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    # Use list comprehension to filter out tuples with length K\n    result = [tup for tup in test_list if len(tup) != K]\n    return result"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    # Initialize the result as 1 (since 1 is the multiplicative identity)\n    result = 1\n    \n    # Iterate over each element in the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the result by the corresponding element in test_tup2\n        result *= test_tup2[i]\n    \n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a, b):\n    # The largest triangle inscribed in an ellipse is an isosceles right triangle\n    # with its hypotenuse along the major axis of the ellipse.\n    # The legs of the triangle are equal to the semi-major axis of the ellipse.\n    \n    # Calculate the area of the largest triangle\n    area = (a * b) / 2\n    \n    return area"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    if n <= 0:\n        return 0\n    power = 0\n    while (1 << power) <= n:\n        power += 1\n    return (1 << (power - 1))"}
{"id": "189_0", "code": "def position_max(list1):\n    # Find the maximum value in the list\n    max_value = max(list1)\n    \n    # Find all indices where the maximum value occurs\n    max_positions = [index for index, value in enumerate(list1) if value == max_value]\n    \n    return max_positions"}
{"id": "190_0", "code": "def chkList(lst):\n    if not lst:\n        return True  # An empty list is considered to have all elements the same\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the string\n    for i in range(len(str1)):\n        # Check if the index is odd (0-based index)\n        if i % 2 != 0:\n            # Append the character to the result string\n            result += str1[i]\n    \n    # Return the result string\n    return result"}
{"id": "192_0", "code": "def hamming_Distance(n1, n2):\n    # Calculate the XOR of the two numbers\n    xor_result = n1 ^ n2\n    \n    # Initialize a counter for the number of set bits\n    distance = 0\n    \n    # Iterate over each bit in the XOR result\n    while xor_result > 0:\n        # Increment the counter if the least significant bit is set\n        distance += xor_result & 1\n        # Right shift the XOR result to check the next bit\n        xor_result >>= 1\n    \n    return distance"}
{"id": "193_0", "code": "def count(s, c):\n    count = 0\n    for char in s:\n        if char == c:\n            count += 1\n    return count"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    # Initialize a counter for inversions\n    inversions = 0\n    \n    # Iterate over the tuple list\n    for i in range(len(test_tup)):\n        # Iterate over the tuple elements in the current tuple\n        for j in range(i + 1, len(test_tup[i])):\n            # Check if the current element is greater than the next element\n            if test_tup[i][j] > test_tup[i][j + 1]:\n                # Increment the inversion counter\n                inversions += 1\n    \n    # Return the total number of inversions\n    return inversions"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    # Initialize an empty list to store the concatenated elements\n    result = []\n    \n    # Iterate over the test tuple\n    for i in range(len(test_tup) - 1):\n        # Concatenate the current element with the next element\n        concatenated = test_tup[i] + test_tup[i + 1]\n        # Append the concatenated result to the list\n        result.append(concatenated)\n    \n    # Return the list of concatenated elements\n    return result"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest common subsequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Build the dp array from bottom up\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if str[i - 1] == str[j - 1] and i != j:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest repeating subsequence\n    return dp[n][n]"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    # Define the regex pattern for a decimal number with precision of 2\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    \n    # Use re.match to check if the number matches the pattern\n    if re.match(pattern, num):\n        return True\n    else:\n        return False"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    # Remove the smallest element from the heap\n    heapq.heapreplace(heap, a)"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    # Define the regex pattern to match only lowercase letters, uppercase letters, and digits\n    pattern = r'^[a-zA-Z0-9]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"}
{"id": "200_0", "code": "def count_Num(n):\n    count = 0\n    for i in range(n):\n        # Check if the ith and nth bits are set\n        if (i & (1 << i)) and (i & (1 << (n - 1))):\n            count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Add the fourth power of the current number to the total sum\n        total_sum += i ** 4\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    # Concatenate the two tuples\n    result = test_tup1 + test_tup2\n    return result"}
{"id": "203_0", "code": "def degree_radian(radian):\n    # Convert radians to degrees using the formula: degrees = radians * (180 / pi)\n    return radian * (180 / 3.141592653589793)"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    # Helper function to flatten a nested list\n    def flatten(lst):\n        for item in lst:\n            if isinstance(item, list):\n                yield from flatten(item)\n            else:\n                yield item\n\n    # Flatten both lists\n    flat_list1 = list(flatten(list1))\n    flat_list2 = list(flatten(list2))\n\n    # Check if all elements of flat_list1 are in flat_list2\n    return all(element in flat_list2 for element in flat_list1)"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        char_count[char] = 1\n    return None"}
{"id": "207_0", "code": "def min_Operations(A, B):\n    # If A is already equal to B, no operations are needed\n    if A == B:\n        return 0\n    \n    # If A is greater than B, subtract B from A\n    if A > B:\n        return A - B\n    \n    # If B is greater than A, subtract A from B\n    return B - A"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    # Convert the tuple to a list to allow sorting\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the first K elements (minimums)\n    min_elements = test_list[:K]\n    \n    # Extract the last K elements (maximums)\n    max_elements = test_list[-K:]\n    \n    # Return the minimums and maximums as a tuple\n    return min_elements, max_elements"}
{"id": "209_0", "code": "def replace_max_specialchar(text, n):\n    # Define the special characters to replace\n    special_chars = [' ', ',', '.']\n    \n    # Create a regular expression pattern to match any of the special characters\n    pattern = '[' + ''.join(special_chars) + ']'\n    \n    # Use re.sub to replace the maximum n occurrences of the pattern with a colon\n    result = re.sub(pattern, ':', text, count=n)\n    \n    return result"}
{"id": "210_0", "code": "def first_even(nums):\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    # Check if the tuple is empty\n    if not test_tuple:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Check if all elements in the tuple have the same type\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    \n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    first_occurrence = low\n\n    # Find the last occurrence of x\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] <= x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    last_occurrence = high\n\n    # Check if the count of x is greater than n/2\n    if (last_occurrence - first_occurrence + 1) > n // 2:\n        return True\n    else:\n        return False"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    # Base case: if there is only one element\n    if low == high:\n        return arr[low]\n    \n    # If there are more than one elements\n    mid = (low + high) // 2\n    \n    # Check if mid is the minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    \n    # Check if the left half is sorted\n    if arr[low] <= arr[mid]:\n        return find_Min(arr, mid + 1, high)\n    \n    # If the right half is sorted\n    return find_Min(arr, low, mid - 1)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str):\n        # Check if the index is even (0-based index)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    \n    # Return the resulting string with odd index characters removed\n    return result"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    return min(a, b, c)"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    # Create a mask with all bits set in the range [l, r]\n    mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if the mask is a subset of n\n    return (n & mask) == mask"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    # Initialize two pointers\n    left = 0\n    right = n - 1\n    \n    # Traverse the array\n    while left <= right:\n        # If the left element is negative, move the left pointer to the right\n        if arr[left] < 0:\n            left += 1\n        # If the right element is positive, move the right pointer to the left\n        elif arr[right] > 0:\n            right -= 1\n        # If both elements are in the correct position, swap them\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return arr"}
{"id": "219_0", "code": "def replace_blank(str1, char):\n    return str1.replace(\" \", char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    # Initialize the last row of the triangle with the values from the last row of the input\n    last_row = tri[-1]\n    \n    # Iterate from the second last row to the first row\n    for i in range(n - 2, -1, -1):\n        # For each element in the current row, update it to be the maximum of itself and the sum of itself and the element directly below it\n        for j in range(i + 1):\n            last_row[j] = max(last_row[j], last_row[j] + tri[i][j])\n    \n    # The maximum sum will be the first element of the last row\n    return last_row[0]"}
{"id": "221_0", "code": "def larg_nnum(list1, n):\n    if n <= 0:\n        return []\n    if n > len(list1):\n        return sorted(list1, reverse=True)\n    return sorted(list1, reverse=True)[:n]"}
{"id": "222_0", "code": "def lateralsurface_cylinder(r, h):\n    # Calculate the lateral surface area of a cylinder\n    lateral_surface_area = 2 * 3.14159 * r * h\n    return lateral_surface_area"}
{"id": "223_0", "code": "def volume_cube(l):\n    return l ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(32):  # Assuming a 32-bit integer\n        # Check if the bit at position i is even\n        if i % 2 == 0:\n            # Set the bit at position i in the result\n            result |= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N, K):\n    # Calculate the number of equilateral triangles of side length K that can fit within an equilateral triangle of side length N\n    # The number of such triangles is given by the formula: (N - K + 1) * (N - K + 2) / 2\n    return (N - K + 1) * (N - K + 2) // 2"}
{"id": "226_0", "code": "def check_occurences(test_list):\n    # Initialize a dictionary to store the count of occurrences\n    count_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Extract the time component from the tuple\n        time = tup[0]\n        \n        # If the time is already in the dictionary, increment its count\n        if time in count_dict:\n            count_dict[time] += 1\n        # Otherwise, add the time to the dictionary with a count of 1\n        else:\n            count_dict[time] = 1\n    \n    # Initialize a list to store the tuples with similar times\n    similar_times = []\n    \n    # Iterate over the dictionary to find tuples with similar times\n    for time, count in count_dict.items():\n        if count > 1:\n            # If there are multiple occurrences, add all tuples with that time to the list\n            similar_times.extend([tup for tup in test_list if tup[0] == time])\n    \n    return similar_times"}
{"id": "227_0", "code": "def number_of_substrings(s):\n    n = len(s)\n    # Each character can be the start of a substring\n    # Each pair of characters can be the start of a substring\n    # Each triplet of characters can be the start of a substring\n    # ...\n    # Each substring of length n can be formed\n    # Total number of substrings = n + (n-1) + (n-2) + ... + 1\n    return n * (n + 1) // 2"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table where dp[i][j] represents the number of sequences of length i ending with j\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: there is one sequence of length 1 ending with any number from 1 to m\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    \n    # Fill the DP table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # Count sequences ending with j\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    \n    # The total number of sequences of length n is the sum of sequences ending with any number from 1 to m\n    total_sequences = sum(dp[n])\n    \n    return total_sequences"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    else:\n        # If list1 is empty, append list2 to it\n        list1.extend(list2)"}
{"id": "230_0", "code": "def array_3d(m, n, o):\n    # Create a 3D array filled with '*'\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_chars(str1):\n    return len(str1)"}
{"id": "232_0", "code": "def sort_on_occurence(lst):\n    # Create a dictionary to count occurrences of the first element of each tuple\n    count_dict = {}\n    for item in lst:\n        if item[0] in count_dict:\n            count_dict[item[0]] += 1\n        else:\n            count_dict[item[0]] = 1\n    \n    # Sort the list based on the count of the first element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: count_dict[x[0]])\n    \n    return sorted_lst"}
{"id": "233_0", "code": "def next_Perfect_Square(N):\n    # Calculate the integer square root of N\n    root = int(N**0.5)\n    \n    # Check if the square of the root is equal to N\n    if root * root == N:\n        # If it is, increment the root by 1 to get the next perfect square\n        return (root + 1) ** 2\n    else:\n        # If it's not, return the square of the next integer\n        return (root + 1) ** 2"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Initialize two arrays to store the maximum sum of increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Fill inc array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill dec array\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of bi-tonic sub-sequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_sum"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    if number == 0:\n        return 0\n    \n    # Initial guess\n    guess = number / 2.0\n    \n    # Tolerance for convergence\n    tolerance = 1e-10\n    \n    while True:\n        # Calculate the next guess\n        next_guess = (guess + number / guess) / 2.0\n        \n        # Check for convergence\n        if abs(next_guess - guess) < tolerance:\n            return next_guess\n        \n        # Update the guess\n        guess = next_guess"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest palindromic subsequence\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. The outer loop is for substring lengths\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # The length of the longest palindromic subsequence is in the top right corner of the table\n    return dp[0][n - 1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    if n <= 1:\n        return 0\n    else:\n        return 1 / n + harmonic_sum(n - 1)"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    # Use a lambda function to find common elements\n    intersection = list(filter(lambda x: x in array_nums2, array_nums1))\n    return intersection"}
{"id": "239_0", "code": "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in lst:\n        # Append the element to the result list\n        result.append(element)\n        # Append the current item to the result list\n        result.append(item)\n    \n    return result"}
{"id": "241_0", "code": "def convert(numbers):\n    \"\"\"\n    Convert a list of complex numbers to their polar coordinates.\n\n    Parameters:\n    numbers (list): A list of complex numbers.\n\n    Returns:\n    list: A list of tuples, where each tuple contains the magnitude and phase of a complex number.\n    \"\"\"\n    polar_coordinates = []\n    for number in numbers:\n        magnitude = abs(number)\n        phase = cmath.phase(number)\n        polar_coordinates.append((magnitude, phase))\n    return polar_coordinates"}
{"id": "242_0", "code": "def count_integer(list1):\n    count = 0\n    for item in list1:\n        if isinstance(item, int):\n            count += 1\n    return count"}
{"id": "243_0", "code": "def words_ae(text):\n    # Split the text into words\n    words = text.split()\n    # Use a list comprehension to filter words starting with 'a' or 'e'\n    filtered_words = [word for word in words if word.lower().startswith(('a', 'e'))]\n    return filtered_words"}
{"id": "244_0", "code": "def combinations_colors(l, n):\n    # Define the three colors\n    colors = ['red', 'green', 'blue']\n    \n    # Generate all combinations with repetitions\n    from itertools import product\n    combinations = list(product(colors, repeat=n))\n    \n    # Filter combinations to include only those with the specified number of colors\n    filtered_combinations = [combo for combo in combinations if len(set(combo)) == l]\n    \n    return filtered_combinations"}
{"id": "245_0", "code": "def count_primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime status of numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Use the Sieve of Eratosthenes to find all primes\n    for start in range(2, int(n**0.5) + 1):\n        if is_prime[start]:\n            for multiple in range(start*start, n, start):\n                is_prime[multiple] = False\n    \n    # Count the number of prime numbers\n    prime_count = sum(is_prime)\n    \n    return prime_count"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    # Temporary variable to hold the value of a\n    temp = a\n    # Assign the value of b to a\n    a = b\n    # Assign the value stored in temp (original value of a) to b\n    b = temp\n    # Return the swapped values\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    # Use the filter function with a lambda to count odd numbers\n    odd_count = sum(1 for num in array_nums if num % 2 != 0)\n    return odd_count"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Initialize a list to store the maximum elements\n    max_elements = []\n    \n    # Iterate over the elements of both tuples\n    for i in range(len(test_tup1)):\n        # Compare the elements and append the maximum to the list\n        max_elements.append(max(test_tup1[i], test_tup2[i]))\n    \n    # Return the list of maximum elements\n    return max_elements"}
{"id": "249_0", "code": "def newman_prime(n):\n    def is_newman_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_newman_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Perform division element-wise\n    result = tuple(a / b for a, b in zip(test_tup1, test_tup2))\n    \n    return result"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    # Check if L is within the valid range\n    if L < 0 or L > len(list1):\n        raise ValueError(\"L must be between 0 and the length of the list.\")\n    \n    # Split the list into two parts\n    part1 = list1[:L]\n    part2 = list1[L:]\n    \n    return part1, part2"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into a single dictionary.\n    \n    Parameters:\n    d1 (dict): The first dictionary.\n    d2 (dict): The second dictionary.\n    \n    Returns:\n    dict: A new dictionary containing all key-value pairs from both d1 and d2.\n    \"\"\"\n    merged_dict = d1.copy()  # Start with a copy of the first dictionary\n    merged_dict.update(d2)  # Update with the second dictionary's key-value pairs\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    # The first two human years are equivalent to 10.5 dog years each\n    if h_age <= 2:\n        return h_age * 10.5\n    # After the first two years, each human year is equivalent to 4 dog years\n    else:\n        return 21 + (h_age - 2) * 4"}
{"id": "254_0", "code": "def list_split(S, step):\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer.\")\n    \n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i+step])\n    \n    return result"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    # The lateral surface area of a cube is 4 times the area of one of its faces\n    # Since a cube has 6 faces and each face is a square with side length l,\n    # the area of one face is l^2.\n    # Therefore, the lateral surface area is 4 * l^2.\n    return 4 * l ** 2"}
{"id": "256_0", "code": "def square_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 2\n    return total"}
{"id": "257_0", "code": "def find_star_num(n):\n    # The formula for the n'th star number is 8n(n-1) + 1\n    return 8 * n * (n - 1) + 1"}
{"id": "258_0", "code": "def ascii_value(k):\n    return ord(k)"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr, n):\n    total_sum = 0\n    for i in range(0, n, 2):  # Iterate over even indices\n        if arr[i] % 2 == 0:  # Check if the number at the even index is even\n            total_sum += arr[i]\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    # Extract the last element from each tuple in the list\n    rear_elements = [t[-1] for t in test_list]\n    return rear_elements"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append to the result list\n        result.append(test_tup1[i] - test_tup2[i])\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "263_0", "code": "def even_binomial_Coeff_Sum(n):\n    # Initialize the sum of even index binomial coefficients\n    sum_even = 0\n    \n    # Iterate over the range from 0 to n\n    for i in range(n + 1):\n        # Calculate the binomial coefficient using the formula C(n, i)\n        binomial_coeff = 1\n        for j in range(1, i + 1):\n            binomial_coeff *= (n - j + 1) // j\n        \n        # Check if the index i is even\n        if i % 2 == 0:\n            # Add the binomial coefficient to the sum if the index is even\n            sum_even += binomial_coeff\n    \n    return sum_even"}
{"id": "264_0", "code": "def get_Position(a, n, m):\n    # Initialize the position of the last removed element\n    last_removed_position = -1\n    \n    # Iterate through the array to find the last removed element\n    for i in range(n):\n        if a[i] == m:\n            last_removed_position = i\n    \n    return last_removed_position"}
{"id": "265_0", "code": "def volume_cylinder(r, h):\n    # Calculate the volume of a cylinder using the formula V = r^2h\n    import math\n    volume = math.pi * r**2 * h\n    return volume"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    # Create a new dictionary to store the filtered items\n    filtered_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n    \n    # Return the filtered dictionary\n    return filtered_dict"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    # Initialize a counter to keep track of the count of elements\n    count = 0\n    \n    # Iterate over the tuple\n    for element in test_tup:\n        # Increment the counter for each element\n        count += 1\n    \n    # Return the count of elements\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n    \n    # Calculate the nth decagonal number using the formula\n    decagonal_number = (5 * n * (n - 1)) + 1\n    \n    return decagonal_number\n\n# Example usage:\nn = 5\nprint(f\"The {n}th decagonal number is: {is_num_decagonal(n)}\")"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    \"\"\"\n    Perform a sequential search on a list to find the index of a given item.\n\n    Parameters:\n    dlist (list): The list to search through.\n    item: The item to search for in the list.\n\n    Returns:\n    int: The index of the item if found, otherwise -1.\n    \"\"\"\n    for index, value in enumerate(dlist):\n        if value == item:\n            return index\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    # Convert the list to a set to remove duplicates\n    unique_set = set(test_list)\n    \n    # Compare the length of the set with the original list\n    return len(unique_set) == len(test_list)"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    # Use map with a lambda function to subtract corresponding elements\n    result = list(map(lambda x, y: x - y, nums1, nums2))\n    return result"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number to a string to iterate over each digit\n    digits = str(n)\n    \n    # Create a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Count the frequency of each digit\n    for digit in digits:\n        if digit in digit_count:\n            digit_count[digit] += 1\n        else:\n            digit_count[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if int(digit) < count:\n            return False\n    \n    return True"}
{"id": "273_0", "code": "def check_element(lst, element):\n    # Check if all elements in the list are equal to the given element\n    return all(item == element for item in lst)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    # Use a regular expression to find the pattern\n    pattern = r'ab{2,3}'\n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the maximum subarray sum for the original array\n    def max_sub_array_sum(arr, n):\n        max_so_far = arr[0]\n        max_ending_here = arr[0]\n        \n        for i in range(1, n):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        \n        return max_so_far\n    \n    # Calculate the maximum subarray sum for the repeated array\n    total_sum = sum(a) * k\n    max_sum = max_sub_array_sum(a, n)\n    \n    # If the array is all negative, the maximum sum is the sum of the array repeated k times\n    if max_sum < 0:\n        return total_sum\n    \n    # Otherwise, find the maximum subarray sum in the repeated array\n    max_sum_repeated = max_sum\n    for i in range(n):\n        # Calculate the sum of the subarray from index i to n-1\n        subarray_sum = sum(a[i:])\n        # Calculate the sum of the subarray from index 0 to i-1\n        subarray_sum_repeated = sum(a[:i])\n        # Update the maximum sum\n        max_sum_repeated = max(max_sum_repeated, subarray_sum + subarray_sum_repeated)\n    \n    return max_sum_repeated"}
{"id": "276_0", "code": "def square_Sum(n):\n    # Calculate the sum of squares of the first n even natural numbers\n    sum_of_squares = sum((2*i)**2 for i in range(1, n+1))\n    return sum_of_squares"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    def is_self_inverse(x):\n        # Check if x is its own modular inverse under prime P\n        return (x * x) % P == 1\n    \n    count = 0\n    for x in arr:\n        if is_self_inverse(x):\n            count += 1\n    \n    return count"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Calculate the number of leap years in the given year\n    leap_years = N // 4 - N // 100 + N // 400\n    \n    # Calculate the number of odd days\n    odd_days = (N - leap_years) % 7\n    \n    return odd_days"}
{"id": "279_0", "code": "def max_length(list1):\n    # Initialize variables to track the maximum length and the list of lists with that length\n    max_length = 0\n    max_lists = []\n\n    # Iterate over each list in the input list\n    for sublist in list1:\n        # Check if the current sublist is longer than the previously recorded maximum length\n        if len(sublist) > max_length:\n            # Update the maximum length and reset the list of lists with that length\n            max_length = len(sublist)\n            max_lists = [sublist]\n        # If the current sublist has the same length as the maximum length, add it to the list of lists\n        elif len(sublist) == max_length:\n            max_lists.append(sublist)\n\n    # Return the list of lists with the maximum length\n    return max_lists"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    \n    # Initialize the base cases\n    same = k  # Number of ways to paint the first two posts with the same color\n    diff = k * (k - 1)  # Number of ways to paint the first two posts with different colors\n    \n    # Iterate from 3 to n to find the number of ways\n    for i in range(2, n):\n        # Calculate the number of ways for the current post\n        new_same = diff\n        new_diff = same * (k - 1) + diff * (k - 1)\n        \n        # Update the same and diff variables\n        same = new_same\n        diff = new_diff\n    \n    # The total number of ways is the sum of ways with the same and different colors\n    return same + diff"}
{"id": "281_0", "code": "def find(n, m):\n    if m == 0:\n        raise ValueError(\"Division by zero is not allowed.\")\n    return n // m"}
{"id": "282_0", "code": "def otherside_rightangle(w, h):\n    # Calculate the hypotenuse using the Pythagorean theorem\n    hypotenuse = (w**2 + h**2)**0.5\n    return hypotenuse"}
{"id": "283_0", "code": "def max_val(listval):\n    # Initialize max_val with the first element of the list\n    max_val = listval[0]\n    \n    # Iterate through the list starting from the second element\n    for val in listval[1:]:\n        # Update max_val if the current value is greater\n        if val > max_val:\n            max_val = val\n    \n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    if number <= 0:\n        return 0\n    divisors_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors_sum += i\n    return divisors_sum"}
{"id": "285_0", "code": "def get_Inv_Count(arr, n):\n    # Initialize the count of inversions\n    inv_count = 0\n    \n    # Traverse through all array elements\n    for i in range(n):\n        # Compare the current element with all elements after it\n        for j in range(i + 1, n):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    \n    # Return the total count of inversions\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    # Initialize an empty list to store the intersection elements\n    intersection = []\n    \n    # Iterate over each element in the first list\n    for sublist in l1:\n        # Check if the sublist is present in the second list\n        if sublist in l2:\n            # If present, add it to the intersection list\n            intersection.append(sublist)\n    \n    # Return the list of intersection elements\n    return intersection"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    # Initialize the maximum aggregate to a very low number\n    max_aggregate = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for student in stdata:\n        # Calculate the aggregate of the current student\n        aggregate = sum(student)\n        \n        # Update the maximum aggregate if the current one is higher\n        if aggregate > max_aggregate:\n            max_aggregate = aggregate\n    \n    # Return the maximum aggregate found\n    return max_aggregate"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    # Initialize the count of valid sequences\n    count = 0\n    \n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2 ** (2 * n)):\n        # Convert the number to a binary string and pad with zeros\n        binary_str = format(i, '0' + str(2 * n) + 'b')\n        \n        # Calculate the sum of the first n bits and the last n bits\n        sum_first_n = sum(int(bit) for bit in binary_str[:n])\n        sum_last_n = sum(int(bit) for bit in binary_str[n:])\n        \n        # If the sums are equal, increment the count\n        if sum_first_n == sum_last_n:\n            count += 1\n    \n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    # Initialize the result to 0\n    result = 0\n    \n    # Loop until n becomes 0\n    while n:\n        # Find the position of the rightmost set bit\n        position = n & -n\n        \n        # Set the corresponding bit in the result\n        result |= position\n        \n        # Remove the rightmost set bit from n\n        n ^= position\n    \n    return result"}
{"id": "292_0", "code": "def solve(a, n):\n    # Count of inversions of type 1: a[i] > a[j] where i < j\n    inv1 = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inv1 += 1\n    \n    # Count of inversions of type 2: a[i] < a[j] where i < j\n    inv2 = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] < a[j]:\n                inv2 += 1\n    \n    # Check if the counts of inversions of both types are the same\n    return inv1 == inv2"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    # Calculate the effective rotation\n    effective_rotation = rotations % len(arr)\n    \n    # Adjust the index based on the effective rotation\n    adjusted_index = (index + effective_rotation) % len(arr)\n    \n    # Return the element at the adjusted index\n    return arr[adjusted_index]"}
{"id": "294_0", "code": "def start_withp(words):\n    # Filter words that start with 'p'\n    p_words = [word for word in words if word.startswith('p')]\n    \n    # Check if there are at least two words starting with 'p'\n    if len(p_words) < 2:\n        return \"Not enough words starting with 'p'\"\n    \n    # Return the first two words starting with 'p'\n    return p_words[:2]"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Initialize a DP array where dp[i] will store the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each element in the array\n    for i in range(n):\n        # If the current element is greater than the element at the previous index, update the dp array\n        if i > 0 and a[i] > a[i - 1]:\n            dp[i] = dp[i - 1] + a[i]\n        else:\n            dp[i] = a[i]\n        \n        # If the current index is less than k, update the maximum sum\n        if i < k:\n            max_sum = max(max_sum, dp[i])\n    \n    return max_sum"}
{"id": "296_0", "code": "def colon_tuplex(tuplex, m, n):\n    # Check if the tuple has at least m elements\n    if len(tuplex) < m:\n        return \"Tuple does not have enough elements.\"\n    \n    # Check if the tuple has at least n elements\n    if len(tuplex) < n:\n        return \"Tuple does not have enough elements.\"\n    \n    # Get the elements from index m to n (exclusive)\n    result = tuplex[m:n]\n    \n    # Convert the result to a tuple and return it\n    return tuple(result)"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Initialize a list to store the largest products\n    largest_products = []\n    \n    # Iterate through the sorted lists to find the largest products\n    for i in range(N):\n        # Calculate the product of the current elements from both lists\n        product = nums1[i] * nums2[i]\n        # Append the product to the list of largest products\n        largest_products.append(product)\n    \n    return largest_products"}
{"id": "298_0", "code": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    # Split the string by spaces to get individual elements\n    elements = str1.split()\n    # Convert each element to an integer and store in a list\n    int_list = [int(element) for element in elements]\n    # Convert the list to a tuple\n    result_tuple = tuple(int_list)\n    return result_tuple"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    unset_bit_position = n & -n\n    # Set the leftmost unset bit\n    return n | unset_bit_position"}
{"id": "301_0", "code": "def volume_cone(r, h):\n    # Calculate the volume of a cone using the formula: (1/3) *  * r^2 * h\n    volume = (1/3) * 3.14159 * r**2 * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for num in list1:\n        if num > 0:\n            print(num)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize the maximum sum for the first two columns\n    max_sum = max(grid[0][0], grid[1][0])\n    \n    # Iterate through the grid starting from the third column\n    for i in range(1, n):\n        # Calculate the new maximum sum for the current column\n        new_max_sum = max(grid[0][i], grid[1][i])\n        new_max_sum = max(new_max_sum, max_sum + min(grid[0][i-1], grid[1][i-1]))\n        \n        # Update the maximum sum for the current column\n        max_sum = new_max_sum\n    \n    return max_sum"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    # Split the string into words\n    words = str.split()\n    \n    # Initialize variables to track the maximum length and the corresponding word\n    max_length = 0\n    max_word = \"\"\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Check if the word length is even\n        if len(word) % 2 == 0:\n            # Update the maximum length and word if the current word is longer\n            if len(word) > max_length:\n                max_length = len(word)\n                max_word = word\n    \n    # Return the first maximum length of even word\n    return max_word"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    left, right = 0, len(A) - 1\n    last_index = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if A[mid] == x:\n            last_index = mid\n            left = mid + 1  # Move to the right to find the last occurrence\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return last_index"}
{"id": "306_0", "code": "def modified_encode(alist):\n    if not alist:\n        return []\n\n    encoded = []\n    count = 1\n\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            encoded.append((alist[i - 1], count))\n            count = 1\n\n    # Append the last group\n    encoded.append((alist[-1], count))\n\n    return encoded"}
{"id": "307_0", "code": "def max_volume(s):\n    # Initialize the maximum volume to a very small number\n    max_vol = float('-inf')\n    \n    # Iterate over all possible values for the length of the cuboid\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible values for the width of the cuboid\n        for width in range(1, (s - length) // 2 + 1):\n            # Calculate the height of the cuboid\n            height = s - length - width\n            \n            # Calculate the volume of the cuboid\n            volume = length * width * height\n            \n            # Update the maximum volume if the current volume is greater\n            if volume > max_vol:\n                max_vol = volume\n    \n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    # Use regex to find all five-character long words\n    pattern = r'\\b\\w{5}\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_squares_n = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the difference between the squared sum and the sum of squares\n    difference = sum_squares_n - sum_n**2\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    # Initialize an empty list to store the demlo number\n    demlo_number = []\n    \n    # Iterate over the string in reverse order\n    for i in range(len(s) - 1, -1, -1):\n        # Append the current character to the demlo number list\n        demlo_number.append(s[i])\n    \n    # Join the list into a string and return it\n    return ''.join(demlo_number)"}
{"id": "311_0", "code": "def position_min(list1):\n    # Initialize an empty list to store the positions of the minimum values\n    min_positions = []\n    \n    # Find the minimum value in the list\n    min_value = min(list1)\n    \n    # Iterate over the list to find all positions of the minimum value\n    for index, value in enumerate(list1):\n        if value == min_value:\n            min_positions.append(index)\n    \n    # Return the list of positions\n    return min_positions"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    # Initialize two pointers, one for positive and one for negative\n    pos = 0\n    neg = 0\n    \n    # Move the positive pointer to the first positive number\n    while pos < n and arr[pos] < 0:\n        pos += 1\n    \n    # Move the negative pointer to the first negative number\n    while neg < n and arr[neg] >= 0:\n        neg += 1\n    \n    # If there are no positive or negative numbers, return the array as is\n    if pos == n or neg == n:\n        return arr\n    \n    # Swap the first positive and negative numbers\n    arr[pos], arr[neg] = arr[neg], arr[pos]\n    \n    # Continue swapping until all positive and negative numbers are in their correct positions\n    while pos < n and neg < n:\n        # Move the positive pointer to the next positive number\n        while pos < n and arr[pos] < 0:\n            pos += 1\n        # Move the negative pointer to the next negative number\n        while neg < n and arr[neg] >= 0:\n            neg += 1\n        # If there are no more positive or negative numbers, return the array as is\n        if pos == n or neg == n:\n            return arr\n        # Swap the next positive and negative numbers\n        arr[pos], arr[neg] = arr[neg], arr[pos]\n    \n    return arr"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate over the tuple\n    for i in range(0, len(test_tuple), 2):\n        # Add the first element of the alternate chain\n        total_sum += test_tuple[i]\n    \n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    # Base cases\n    if n <= 3:\n        return n\n    \n    # Initialize the result array\n    dp = [float('inf')] * (n + 1)\n    \n    # Base cases for dp array\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 3\n    \n    # Fill the dp array\n    for i in range(4, n + 1):\n        # Try all possible squares less than or equal to i\n        for j in range(1, int(i**0.5) + 1):\n            square = j * j\n            dp[i] = min(dp[i], dp[i - square] + 1)\n    \n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    # Initialize a dictionary to count occurrences of each word\n    word_count = {}\n    \n    # Iterate over each string in the list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # If the word is already in the dictionary, increment its count\n            if word in word_count:\n                word_count[word] += 1\n            # If the word is not in the dictionary, add it with a count of 1\n            else:\n                word_count[word] = 1\n    \n    # Find the word with the maximum count\n    max_word = max(word_count, key=word_count.get)\n    \n    # Return the word with the maximum count\n    return max_word"}
{"id": "316_0", "code": "def check_isosceles(x, y, z):\n    # Check if any two sides are equal\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"id": "317_0", "code": "def rotate_left(list1, m, n):\n    # Calculate the effective rotation needed\n    effective_rotation = (m + n) % len(list1)\n    \n    # Perform the rotation\n    rotated_list = list1[effective_rotation:] + list1[:effective_rotation]\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    count = 0\n    for num in lst:\n        if num < 0:\n            count += 1\n    return count"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Find all three-character words\n    three_char_words = re.findall(r'\\b\\w{3}\\b', text)\n    \n    # Find all four-character words\n    four_char_words = re.findall(r'\\b\\w{4}\\b', text)\n    \n    # Find all five-character words\n    five_char_words = re.findall(r'\\b\\w{5}\\b', text)\n    \n    # Return the results as a dictionary\n    return {\n        'three_char_words': three_char_words,\n        'four_char_words': four_char_words,\n        'five_char_words': five_char_words\n    }"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    count = 0\n    while n:\n        # Check if the least significant bit is 0\n        if n & 1 == 0:\n            count += 1\n        # Right shift n by 1 to check the next bit\n        n >>= 1\n    return count"}
{"id": "321_0", "code": "def char_frequency(str1):\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"}
{"id": "322_0", "code": "def Sort(sub_li):\n    # Sort the list using the second element of each sublist as the key\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li"}
{"id": "323_0", "code": "def check_Validity(a, b, c):\n    # Check if the sum of any two sides is greater than the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"id": "324_0", "code": "def ap_sum(a, n, d):\n    # Calculate the sum of an arithmetic progression\n    # The formula is: S = n/2 * (2a + (n-1)d)\n    return n / 2 * (2 * a + (n - 1) * d)"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    # List of months with 28 days\n    months_with_28_days = [\"February\"]\n    \n    # Check if the given month name is in the list\n    if monthname1 in months_with_28_days:\n        return True\n    else:\n        return False"}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    # Define the regular expression pattern to match a word at the end of the string with optional punctuation\n    pattern = r'\\b\\w+\\b\\W*$'\n    \n    # Use re.search to find the pattern in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the matched word\n    if match:\n        return match.group()\n    else:\n        return None"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    \n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are equal\n            if s[i] == s[j]:\n                count += 1\n                \n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    # Initialize a dictionary to store the frequency of each divisor\n    divisor_count = {}\n    \n    # Iterate through all numbers from x to y\n    for num in range(x, y + 1):\n        # Find all divisors of the current number\n        for divisor in range(1, num + 1):\n            if num % divisor == 0:\n                # Increment the count of this divisor\n                if divisor in divisor_count:\n                    divisor_count[divisor] += 1\n                else:\n                    divisor_count[divisor] = 1\n    \n    # Find the divisor with the maximum count\n    max_divisor = None\n    max_count = 0\n    for divisor, count in divisor_count.items():\n        if count > max_count:\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    # Filter out non-positive numbers\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Sort the positive numbers\n    positive_nums.sort()\n    \n    # Check if there are at least three positive numbers\n    if len(positive_nums) < 3:\n        return 0  # Return 0 if there are less than three positive numbers\n    \n    # Sum the three smallest positive numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    # Convert the set to a list and sort it\n    sorted_list = sorted(s)\n    # Convert the sorted list to a tuple\n    result_tuple = tuple(sorted_list)\n    return result_tuple"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    if not lists:\n        return None\n\n    # Initialize variables to track the minimum range\n    min_range = float('inf')\n    min_start = 0\n    min_end = 0\n\n    # Get the number of lists and the size of the smallest list\n    num_lists = len(lists)\n    min_list_size = min(len(lst) for lst in lists)\n\n    # Iterate over the possible starting points of the range\n    for start in range(min_list_size):\n        # Initialize pointers for each list\n        pointers = [start] * num_lists\n\n        # Initialize the current range\n        current_min = float('inf')\n        current_max = float('-inf')\n\n        # Iterate over the lists to find the current range\n        for i in range(num_lists):\n            current_min = min(current_min, lists[i][pointers[i]])\n            current_max = max(current_max, lists[i][pointers[i]])\n\n        # Update the minimum range if the current range is smaller\n        if current_max - current_min < min_range:\n            min_range = current_max - current_min\n            min_start = current_min\n            min_end = current_max\n\n        # Move the pointers to the next element in the current range\n        for i in range(num_lists):\n            pointers[i] += 1\n            if pointers[i] == len(lists[i]):\n                break\n\n    return (min_start, min_end)"}
{"id": "332_0", "code": "def dig_let(s):\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters"}
{"id": "333_0", "code": "def count_odd_squares(n, m):\n    count = 0\n    for i in range(n, m + 1):\n        if i % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    # Check if the list has at least two elements\n    if len(nums) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Calculate the difference between consecutive numbers\n    differences = [nums[i] - nums[i + 1] for i in range(len(nums) - 1)]\n    \n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    if k == 0 or k == n:\n        return 1\n    return zigzag(n-1, k-1) + zigzag(n-1, k)"}
{"id": "336_0", "code": "def count_Squares(m, n):\n    # The number of squares of side length k in an m x n rectangle is (m-k+1) * (n-k+1)\n    total_squares = 0\n    for k in range(1, min(m, n) + 1):\n        total_squares += (m - k + 1) * (n - k + 1)\n    return total_squares"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a dictionary to store the number of ways to achieve each prefix sum\n    prefix_sums = {0: 1}\n    \n    # Iterate over each value in the input list M\n    for value in M:\n        # Create a new dictionary to store the updated prefix sums\n        new_prefix_sums = {}\n        \n        # Iterate over each prefix sum in the current dictionary\n        for prefix_sum, count in prefix_sums.items():\n            # Calculate the new prefix sum by adding the current value\n            new_prefix_sum = prefix_sum + value\n            \n            # If the new prefix sum is already in the new dictionary, add the count\n            if new_prefix_sum in new_prefix_sums:\n                new_prefix_sums[new_prefix_sum] += count\n            # Otherwise, add the new prefix sum with a count of 1\n            else:\n                new_prefix_sums[new_prefix_sum] = 1\n        \n        # Update the prefix_sums dictionary with the new prefix sums\n        prefix_sums = new_prefix_sums\n    \n    # Return the number of ways to achieve a prefix sum of 0\n    return prefix_sums.get(0, 0)"}
{"id": "338_0", "code": "def check(string):\n    # Check if the string contains only '0' and '1'\n    return all(char in '01' for char in string)"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Check if the string is empty\n    if not s:\n        return 0\n    \n    # Initialize the minimum length to the length of the string\n    min_length = len(s)\n    \n    # Iterate over each character in the string\n    for char in set(s):\n        # Remove all occurrences of the current character\n        new_s = s.replace(char, '')\n        # Update the minimum length if the new string is shorter\n        min_length = min(min_length, len(new_s))\n    \n    return min_length"}
{"id": "340_0", "code": "def first_Element(arr, n, k):\n    # Dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through the array to count the frequency of each element\n    for i in range(n):\n        if arr[i] in frequency:\n            frequency[arr[i]] += 1\n        else:\n            frequency[arr[i]] = 1\n    \n    # Iterate through the array again to find the first element occurring k times\n    for i in range(n):\n        if frequency[arr[i]] == k:\n            return arr[i]\n    \n    # If no element occurs k times, return -1\n    return -1"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Create a set to store unique characters\n    char_set = set()\n    \n    # Iterate over each character in the string\n    for char in str:\n        # If the character is already in the set, return False\n        if char in char_set:\n            return False\n        # Add the character to the set\n        char_set.add(char)\n    \n    # If no duplicates were found, return True\n    return True"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    # Check if the list is empty or n is out of bounds\n    if not list1 or n < 0 or n >= len(list1[0]):\n        return list1\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over each row in the list\n    for row in list1:\n        # Create a new row by excluding the nth column\n        new_row = [row[i] for i in range(len(row)) if i != n]\n        # Append the new row to the result list\n        result.append(new_row)\n    \n    return result"}
{"id": "343_0", "code": "def tn_ap(a, n, d):\n    # Calculate the t-nth term of an arithmetic progression\n    tn = a + (n - 1) * d\n    return tn"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    # The number of rectangles in a circle of radius r is given by the formula:\n    # Number of rectangles = (2 * r)^2 * \n    # This formula comes from the fact that the maximum number of rectangles that can fit inside a circle\n    # is when the rectangle is a square with side length equal to the diameter of the circle.\n    # The area of such a square is (2 * r)^2, and since the circle's area is  * r^2,\n    # the number of rectangles is the ratio of the circle's area to the area of the square.\n    # However, this formula is an approximation and may not be exact for all cases.\n    return (2 * radius) ** 2 * math.pi"}
{"id": "345_0", "code": "def find_angle(a, b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    third_angle = 180 - a - b\n    return third_angle"}
{"id": "346_0", "code": "def find_max(test_list):\n    # Initialize the maximum element with the first element of the first tuple\n    max_element = test_list[0][0]\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Iterate through each element in the tuple\n        for element in tup:\n            # Update max_element if the current element is greater\n            if element > max_element:\n                max_element = element\n    \n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    # Use map with a lambda function to perform modulo division\n    result = list(map(lambda x, y: x % y, nums1, nums2))\n    return result"}
{"id": "348_0", "code": "def Check_Solution(a, b, c):\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is non-negative\n    if discriminant < 0:\n        return False\n    \n    # Calculate the two roots using the quadratic formula\n    root1 = (-b + (discriminant**0.5)) / (2*a)\n    root2 = (-b - (discriminant**0.5)) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2 * root2 or root2 == 2 * root1:\n        return True\n    else:\n        return False"}
{"id": "349_0", "code": "def get_carol(n):\n    # Calculate the Carol number using the formula: (2^n - 1)^2 - 2\n    carol_number = (2 ** n - 1) ** 2 - 2\n    return carol_number"}
{"id": "350_0", "code": "def remove_empty(list1):\n    # Use list comprehension to filter out empty lists\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    if not nums:\n        return None  # Return None if the list is empty\n\n    from collections import Counter\n\n    # Count the occurrences of each item in the list\n    counts = Counter(nums)\n\n    # Find the item with the maximum occurrences\n    max_item = counts.most_common(1)[0][0]\n\n    return max_item"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    # Use a list comprehension to add K to each element in the tuple\n    result = tuple(x + K for x in test_list)\n    return result"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(s):\n    # Initialize counters for both possible alternating sequences\n    flip_count_even = 0\n    flip_count_odd = 0\n    \n    # Iterate through the string to count flips for both sequences\n    for i in range(len(s)):\n        # Check if the current character matches the expected character for an even index\n        if i % 2 == 0:\n            if s[i] != '0':\n                flip_count_even += 1\n        else:\n            if s[i] != '1':\n                flip_count_even += 1\n        \n        # Check if the current character matches the expected character for an odd index\n        if i % 2 == 0:\n            if s[i] != '1':\n                flip_count_odd += 1\n        else:\n            if s[i] != '0':\n                flip_count_odd += 1\n    \n    # Return the minimum of the two flip counts\n    return min(flip_count_even, flip_count_odd)"}
{"id": "354_0", "code": "def count_Digit(n):\n    # Convert the number to a string to easily count the digits\n    n_str = str(n)\n    # Return the length of the string, which is the number of digits\n    return len(n_str)"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    if len(list_nums) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    max_product = float('-inf')\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    \n    return max_product"}
{"id": "356_0", "code": "def is_tree_balanced(root):\n    def get_height(node):\n        if not node:\n            return 0\n        left_height = get_height(node.left)\n        right_height = get_height(node.right)\n        if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n            return -1\n        return max(left_height, right_height) + 1\n\n    return get_height(root) != -1"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    # Repeat the tuple N times\n    result = test_tup * N\n    return result"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l, w, h):\n    # The lateral surface area of a cuboid is given by 2 * (length * height + width * height)\n    return 2 * (l * h + w * h)"}
{"id": "359_0", "code": "def float_sort(price):\n    # Extract the float element from the tuple\n    float_element = price[1]\n    \n    # Sort the tuple based on the float element\n    sorted_price = sorted(price, key=lambda x: x[1])\n    \n    return sorted_price"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    if left_element > right_element:\n        return left_element\n    \n    mid = (left_element + right_element) // 2\n    \n    if A[mid] == mid:\n        return smallest_missing(A, mid + 1, right_element)\n    else:\n        return smallest_missing(A, left_element, mid - 1)"}
{"id": "361_0", "code": "def heap_assending(nums):\n    import heapq\n    # Convert the list into a heap\n    heapq.heapify(nums)\n    # Extract elements from the heap in sorted order\n    sorted_nums = [heapq.heappop(nums) for _ in range(len(nums))]\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(l, w, h):\n    return l * w * h"}
{"id": "363_0", "code": "def permute_string(str):\n    if len(str) == 0:\n        return ['']\n    \n    # Get all permutations of the substring excluding the first character\n    permutations = permute_string(str[1:])\n    \n    # Insert the first character at every possible position in each permutation\n    result = []\n    for perm in permutations:\n        for i in range(len(perm) + 1):\n            result.append(perm[:i] + str[0] + perm[i:])\n    \n    return result"}
{"id": "364_0", "code": "def round_num(n, m):\n    # Calculate the nearest multiple of m to n\n    return round(n / m) * m"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for tup in test_tup:\n        for element in tup:\n            if element in count_dict:\n                count_dict[element] += 1\n            else:\n                count_dict[element] = 1\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over each tuple in the test tuple\n    for tup in test_tup:\n        # Create a new tuple with custom value for duplicates\n        new_tup = tuple(element if count_dict[element] == 1 else 'custom_value' for element in tup)\n        result.append(new_tup)\n    \n    return result"}
{"id": "366_0", "code": "def remove_Char(s, c):\n    # Use a list comprehension to filter out characters that match the specified character\n    return ''.join([char for char in s if char != c])"}
{"id": "367_0", "code": "def move_first(test_list):\n    if not test_list:\n        return test_list  # Return the list as is if it's empty\n    last_element = test_list.pop()  # Remove the last element\n    test_list.insert(0, last_element)  # Insert the last element at the beginning\n    return test_list"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    # Calculate the surface area of a cuboid\n    surface_area = 2 * (l * w + w * h + h * l)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum, colnum):\n    # Initialize an empty list to hold the rows\n    matrix = []\n    \n    # Loop through each row\n    for i in range(rownum):\n        # Initialize an empty list for the current row\n        row = []\n        \n        # Loop through each column\n        for j in range(colnum):\n            # Append a default value (0) to the row\n            row.append(0)\n        \n        # Append the completed row to the matrix\n        matrix.append(row)\n    \n    # Return the completed matrix\n    return matrix"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    # Sort the list of lists based on the specified index\n    sorted_list = sorted(list_data, key=lambda x: x[index_no])\n    return sorted_list"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    if not A:\n        return 0\n    \n    left, right = 0, len(A) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # If mid element is greater than the rightmost element, the rotation point is in the right half\n        if A[mid] > A[right]:\n            left = mid + 1\n        # If mid element is less than the rightmost element, the rotation point is in the left half or at mid\n        else:\n            right = mid\n    \n    # The left index will point to the smallest element, which is the rotation point\n    return left"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(32):\n        # Check if the bit at position i is odd\n        if i % 2 == 1:\n            # If it is odd, toggle the bit in the result\n            result |= (1 << i)\n    \n    # XOR the original number with the result to toggle even bits\n    return n ^ result"}
{"id": "373_0", "code": "def frequency_of_Smallest(n, arr):\n    if n == 0:\n        return 0  # Return 0 if the array is empty\n\n    smallest = arr[0]  # Assume the first element is the smallest\n    frequency = 1  # Initialize frequency to 1\n\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]  # Update smallest if a smaller element is found\n            frequency = 1  # Reset frequency to 1 for the new smallest element\n        elif arr[i] == smallest:\n            frequency += 1  # Increment frequency if the element is the same as the smallest\n\n    return frequency"}
{"id": "374_0", "code": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    # Initialize variables\n    open_brackets = 0\n    swap_count = 0\n    \n    # Iterate through the string\n    for char in s:\n        if char == '(':\n            open_brackets += 1\n        elif char == ')':\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                # If there's no matching opening bracket, we need a swap\n                swap_count += 1\n    \n    return swap_count"}
{"id": "376_0", "code": "def even_or_odd(N):\n    # Convert the hexadecimal string to an integer\n    num = int(N, 16)\n    \n    # Check if the number is even or odd\n    if num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    if n < 1:\n        return 0\n    power = 0\n    while (1 << power) <= n:\n        power += 1\n    return (1 << (power - 1))"}
{"id": "378_0", "code": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"id": "379_0", "code": "def add_string(list, string):\n    # Create a new list to store the modified items\n    modified_list = []\n    \n    # Iterate over each item in the original list\n    for item in list:\n        # Insert the given string at the beginning of the item\n        modified_item = string + item\n        # Append the modified item to the new list\n        modified_list.append(modified_item)\n    \n    # Return the new list with the modified items\n    return modified_list"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    # Check if all lists have the same length\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    # Create a nested dictionary\n    nested_dict = {}\n    for i in range(len(l1)):\n        nested_dict[l1[i]] = {\n            l2[i]: l3[i]\n        }\n    \n    return nested_dict"}
{"id": "381_0", "code": "def get_max_sum(n):\n    # Base case: if n is less than 1, return 0\n    if n < 1:\n        return 0\n    \n    # Initialize a dictionary to store computed results\n    memo = {}\n    \n    # Recursive function to calculate the maximum sum\n    def max_sum_helper(n):\n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Base case: if n is 1, return 1\n        if n == 1:\n            return 1\n        \n        # Calculate the maximum sum using the given equation\n        result = max(max_sum_helper(n // 2) + max_sum_helper(n // 3) + max_sum_helper(n // 4) + max_sum_helper(n // 5), n)\n        \n        # Store the result in the memo dictionary\n        memo[n] = result\n        \n        return result\n    \n    # Start the recursive calculation from n\n    return max_sum_helper(n)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    # Use the max function with a lambda function to find the list with the maximum length\n    return max(input_list, key=lambda x: len(x))"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    # Convert the tuple to a set to remove duplicates\n    unique_elements = set(test_tup)\n    \n    # Compare the length of the set with the original tuple\n    if len(unique_elements) == len(test_tup):\n        return True\n    else:\n        return False"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count occurrences of each character in the string\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    # Use regex to check if the string starts and ends with the same character\n    pattern = r'^([a-zA-Z])\\1$'\n    match = re.match(pattern, string)\n    return bool(match)"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    # Sort the numbers\n    numbers = sorted([a, b, c])\n    # Return the middle number\n    return numbers[1]"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Perform the bitwise XOR operation on corresponding elements\n        xor_result = test_tup1[i] ^ test_tup2[i]\n        # Append the result to the list\n        result.append(xor_result)\n    \n    # Return the list of results\n    return result"}
{"id": "389_0", "code": "def extract_freq(test_list):\n    # Create a dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Return the dictionary containing the frequency of each tuple\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Initialize an empty list to store the elements of the current nested tuple\n        nested_result = []\n        \n        # Iterate over the elements of the current nested tuple in the first tuple\n        for j in range(len(test_tup1[i])):\n            # Add the corresponding elements from both tuples and append to the nested result list\n            nested_result.append(test_tup1[i][j] + test_tup2[i][j])\n        \n        # Append the nested result list to the result list\n        result.append(nested_result)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    # Base cases\n    if r == 0 or r == n:\n        return 1\n    if r > n:\n        return 0\n    \n    # Initialize result\n    res = 1\n    \n    # Calculate nCr % p\n    for i in range(r):\n        res = (res * (n - i)) % p\n        res = (res * pow(i + 1, p - 2, p)) % p\n    \n    return res"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    # Define a regular expression pattern for a valid URL\n    pattern = re.compile(\n        r'^(https?|ftp)://'  # http:// or https:// or ftp://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4\n        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    # Use the pattern to match the input string\n    if re.match(pattern, str):\n        return True\n    else:\n        return False"}
{"id": "393_0", "code": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    # Check if tuple1 is a subset of tuplex\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    # Initialize the parity to 0\n    parity = 0\n    \n    # Loop through each bit of the number\n    while x:\n        # XOR the current bit with the parity\n        parity ^= x & 1\n        # Right shift the number by 1 to process the next bit\n        x >>= 1\n    \n    return parity"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    \n    # Find the first digit from the right that is smaller than the digit immediately to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the largest possible\n    if i == -1:\n        return -1\n    \n    # Find the smallest digit to the right of the found digit that is larger than it\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the found digit in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number\n    return int(''.join(digits))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    # Initialize a min-heap to store pairs and their sums\n    min_heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\n\n    result = []\n    while min_heap and len(result) < k:\n        # Pop the smallest pair from the heap\n        _, i, j = heapq.heappop(min_heap)\n        result.append((nums1[i], nums2[j]))\n\n        # If there is a next element in nums2, add the new pair to the heap\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    # Initialize the minimum product to a large number\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for tup in list1:\n        # Calculate the product of the tuple elements\n        product = tup[0] * tup[1]\n        \n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    # Check if the list is empty\n    if not listval:\n        return None  # Return None if the list is empty\n    \n    # Initialize min_val with the first element of the list\n    min_val = listval[0]\n    \n    # Iterate through the list to find the minimum value\n    for val in listval:\n        if val < min_val:\n            min_val = val\n    \n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    # Use regex to find all occurrences of '_[a-z]' and replace them with the uppercase version of the following letter\n    return re.sub(r'_([a-z])', lambda match: match.group(1).upper(), word)"}
{"id": "401_0", "code": "def remove_odd(l):\n    return [x for x in l if x % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    # Check if the list is empty or n is out of range\n    if not list1 or n < 0 or n >= len(list1):\n        return None\n    \n    # Extract the nth element from each tuple in the list\n    nth_elements = [t[n] for t in list1]\n    \n    return nth_elements"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    # Check if any element of list1 is in list2\n    return any(item in list2 for item in list1)"}
{"id": "404_0", "code": "def max_Product(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    \n    # Initialize the maximum and minimum products\n    max_product = float('-inf')\n    min_product = float('inf')\n    result = float('-inf')\n    \n    for num in arr:\n        # If the current number is negative, swap max and min\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update the maximum and minimum products\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than or equal to 3, return n itself\n    if n <= 3:\n        return n\n    \n    # Recursive case: divide n into three parts and sum them up\n    # The maximum sum is achieved by dividing n into three parts as evenly as possible\n    # This is because the sum of three parts is maximized when the parts are as close to each other as possible\n    # The maximum sum is achieved by dividing n into three parts of size n//3, n//3, and n%3\n    return n // 3 + n // 3 + n % 3"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize a dictionary to store the first elements of each tuple\n    first_elements = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Check if the tuple is not empty\n        if tup:\n            # Get the first element of the tuple\n            first_element = tup[0]\n            \n            # If the first element is already in the dictionary, increment its count\n            if first_element in first_elements:\n                first_elements[first_element] += 1\n            # Otherwise, add the first element to the dictionary with a count of 1\n            else:\n                first_elements[first_element] = 1\n    \n    # Find the first element that appears most frequently\n    most_common_first_element = None\n    max_count = 0\n    for element, count in first_elements.items():\n        if count > max_count:\n            max_count = count\n            most_common_first_element = element\n    \n    # Return the most common first element\n    return most_common_first_element"}
{"id": "407_0", "code": "def Find_Max(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n\n    max_length = 0\n    max_sublist = None\n\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    # Round each number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of the rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Calculate the total sum multiplied by the length of the list\n    result = total_sum * len(list1)\n    \n    # Print the result\n    print(result)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the even number\n        even_number = 2 * i\n        # Add the cube of the even number to the total sum\n        total_sum += even_number ** 3\n    \n    # Return the total sum of cubes\n    return total_sum"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    # Initialize an empty string to hold the concatenated result\n    result = \"\"\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # Concatenate the current element to the result string\n        result += str(element)\n    \n    # Return the concatenated result\n    return result"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    \n    # Calculate the average of these cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    return average_of_cubes"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    # Create a table to store results of subproblems\n    max_gold = [[0 for x in range(n)] for y in range(m)]\n    \n    # Process all rows from bottom to top\n    for i in range(m - 1, -1, -1):\n        # Process all columns from left to right\n        for j in range(n):\n            # If it's the last column, the gold collected is the gold at that cell\n            if j == n - 1:\n                max_gold[i][j] = gold[i][j]\n            # If it's the last row, the gold collected is the gold at that cell\n            elif i == m - 1:\n                max_gold[i][j] = gold[i][j]\n            # Otherwise, the gold collected is the gold at that cell plus the maximum of the gold collected from the cells below it\n            else:\n                max_gold[i][j] = gold[i][j] + max(max_gold[i + 1][j - 1], max_gold[i + 1][j], max_gold[i + 1][j + 1])\n    \n    # The maximum gold collected is the maximum value in the first column of the max_gold table\n    return max(max_gold[0])"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    rear_indices = [s[-1] for s in test_tuple]\n    return rear_indices"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Define the regex pattern to match the yyyy-mm-dd format\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    \n    # Use re.sub to replace the matched pattern with the dd-mm-yyyy format\n    new_date = re.sub(pattern, r'\\3-\\2-\\1', dt)\n    \n    return new_date"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    # Extracting elementwise and tuples from the given two tuples\n    result = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    # The directrix of a parabola given by ax^2 + bx + c = 0 is y = -1/(4a) - b/(4a)\n    # Simplifying, we get y = -1/(4a) - b/(4a) = -1/(4a) * (1 + b)\n    directrix = -1 / (4 * a) * (1 + b)\n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    # Convert both lists to sets to remove duplicates and allow for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there is any intersection between the two sets\n    return not set1.isdisjoint(set2)"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    # Iterate through each element in the array\n    for element in arr:\n        # Check if the current element is greater than the number\n        if element > number:\n            # If found, return True\n            return True\n    # If no element is greater than the number, return False\n    return False"}
{"id": "423_0", "code": "def text_match_one(text):\n    # Use a regular expression to match the pattern\n    pattern = r'ab+'\n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "424_0", "code": "def last_digit(n):\n    # Return the last digit of the number\n    return abs(n) % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for num in list1:\n        if num < 0:\n            print(num)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the input string\n    for char in str1:\n        # Check if the character is even (i.e., its ASCII value is even)\n        if ord(char) % 2 == 0:\n            # If even, append it to the result string\n            result += char\n    \n    # Return the result string with odd characters removed\n    return result"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    # Initialize a dictionary to store the count of bidirectional pairs\n    count_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Check if the tuple is bidirectional\n        if tup[0] == tup[1]:\n            # If the tuple is bidirectional, increment its count in the dictionary\n            if tup in count_dict:\n                count_dict[tup] += 1\n            else:\n                count_dict[tup] = 1\n    \n    # Return the dictionary containing the count of bidirectional pairs\n    return count_dict"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    # Convert each integer in the list to a string\n    str_list = [str(num) for num in L]\n    # Join the string representations with no separator\n    combined_str = ''.join(str_list)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    # Define a regular expression pattern to match adverbs\n    adverb_pattern = r'\\b\\w+ly\\b'\n    \n    # Use re.finditer to find all occurrences of the adverb pattern\n    adverbs = re.finditer(adverb_pattern, text)\n    \n    # Create a list to store the results\n    results = []\n    \n    # Iterate over the matches and store the adverb and its position\n    for match in adverbs:\n        adverb = match.group()\n        position = match.start()\n        results.append((adverb, position))\n    \n    return results"}
{"id": "430_0", "code": "def surfacearea_cube(l):\n    # Calculate the surface area of a cube\n    return 6 * l ** 2"}
{"id": "431_0", "code": "def positive_count(nums):\n    positive_count = sum(1 for num in nums if num > 0)\n    total_count = len(nums)\n    if total_count == 0:\n        return 0\n    return positive_count / total_count"}
{"id": "432_0", "code": "def largest_neg(list1):\n    # Initialize the largest negative number to None\n    largest_neg = None\n    \n    # Iterate through each number in the list\n    for num in list1:\n        # Check if the number is negative\n        if num < 0:\n            # If it's the first negative number or larger than the current largest, update largest_neg\n            if largest_neg is None or num > largest_neg:\n                largest_neg = num\n    \n    # Return the largest negative number found, or None if no negative numbers were found\n    return largest_neg"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    # Use list comprehension to trim each tuple by K\n    trimmed_list = [tuple(x[K:]) for x in test_list]\n    return trimmed_list"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Perform index-wise multiplication\n    result = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    \n    return result"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    # Initialize a dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in count_dict:\n            count_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[element] = 1\n    \n    # Initialize a list to store the result\n    result = []\n    \n    # Iterate over each element in the tuple\n    for element in tup:\n        # If the element is in the dictionary, append its count to the result list\n        if element in count_dict:\n            result.append(count_dict[element])\n        # If the element is not in the dictionary, append 0 to the result list\n        else:\n            result.append(0)\n    \n    return result"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    \n    perrin = [3, 5]\n    for i in range(3, n):\n        next_perrin = perrin[i-2] + perrin[i-3]\n        perrin.append(next_perrin)\n    \n    return sum(perrin)"}
{"id": "438_0", "code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the lengths of the sides of the triangle\n    side1 = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    side2 = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    side3 = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n    \n    # Check the triangle inequality theorem\n    if side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1:\n        return True\n    else:\n        return False"}
{"id": "439_0", "code": "def extract_string(str_list, l):\n    \"\"\"\n    Extracts specified size of strings from a given list of string values.\n\n    Parameters:\n    str_list (list of str): The list of string values to extract from.\n    l (int): The size of strings to extract.\n\n    Returns:\n    list of str: A list containing the extracted strings.\n    \"\"\"\n    return [s[:l] for s in str_list if len(s) >= l]"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    # Use regex to replace all whitespace characters with an empty string\n    return re.sub(r'\\s+', '', text1)"}
{"id": "441_0", "code": "def loss_amount(actual_cost, sale_amount):\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    # Initialize sum of factors\n    sum_factors = 0\n    \n    # Iterate over possible factors from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the sum\n                sum_factors += i\n    \n    return sum_factors"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    # Use a regular expression to find words containing 'z'\n    import re\n    pattern = r'\\b\\w*z\\w*\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    # List of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month number is in the list of months with 31 days\n    if monthnum2 in months_with_31_days:\n        return True\n    else:\n        return False"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in stringlist]\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(l, b):\n    return l * b"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    return re.sub(r'[A-Z]+', '', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count"}
{"id": "451_0", "code": "def combinations_list(list1):\n    from itertools import combinations\n    \n    def generate_combinations(current_combination, remaining_elements):\n        if not remaining_elements:\n            yield current_combination\n        else:\n            for i in range(len(remaining_elements)):\n                new_combination = current_combination + [remaining_elements[i]]\n                yield from generate_combinations(new_combination, remaining_elements[i+1:])\n    \n    all_combinations = []\n    for r in range(len(list1) + 1):\n        for combo in combinations(list1, r):\n            all_combinations.append(list(combo))\n    \n    return all_combinations"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = min_product = result = arr[0]\n    \n    for num in arr[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        \n        result = max(result, max_product)\n    \n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    # Check if the dictionary is empty\n    if not dict:\n        return True\n    \n    # Get the first value from the dictionary\n    first_value = next(iter(dict.values()))\n    \n    # Compare each value in the dictionary with the first value\n    for value in dict.values():\n        if value != first_value:\n            return False\n    \n    return True"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    # Use dictionary comprehension to filter out empty values\n    return {key: value for key, value in dict1.items() if value}"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    if n == 1:\n        return 0\n    if arr[0] > arr[1]:\n        return 0\n    if arr[n-1] > arr[n-2]:\n        return n-1\n    \n    low, high = 1, n-2\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:\n            return mid\n        elif arr[mid] < arr[mid-1]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    if deciNum == 0:\n        return \"0\"\n    \n    octal_num = \"\"\n    while deciNum > 0:\n        remainder = deciNum % 8\n        octal_num = str(remainder) + octal_num\n        deciNum = deciNum // 8\n    \n    return octal_num"}
{"id": "457_0", "code": "def max_product(arr, n):\n    if n == 0:\n        return 0\n    \n    # Initialize the dp array where dp[i] will store the maximum product of an increasing subsequence ending at index i\n    dp = [1] * n\n    \n    # Iterate through each element in the array\n    for i in range(1, n):\n        # Iterate through all previous elements to find the maximum product ending at index i\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # The maximum product of an increasing subsequence will be the maximum value in the dp array\n    return max(dp)"}
{"id": "458_0", "code": "def max_profit(price, k):\n    if k == 0 or not price:\n        return 0\n    \n    n = len(price)\n    if n < 2:\n        return 0\n    \n    # Create a DP table to store the maximum profit\n    dp = [[0] * (k + 1) for _ in range(n)]\n    \n    # Fill the DP table\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            # Calculate the maximum profit by either buying or selling\n            dp[i][j] = max(dp[i - 1][j], price[i] - price[i - 1] + dp[i - 1][j - 1])\n    \n    return dp[n - 1][k]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    # Initialize an empty list to store the pairwise sums\n    res = []\n    \n    # Iterate over the tuples using zip to pair elements\n    for a, b in zip(test_tup[0], test_tup[1]):\n        # Calculate the sum of each pair and append to the result list\n        res.append(a + b)\n    \n    return res"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    # Initialize the result to 1\n    result = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current result by the current element\n        result = (result * arr[i]) % n\n    \n    # Return the final result\n    return result"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    if not l:\n        return False\n    \n    sorted_l = sorted(l)\n    for i in range(1, len(sorted_l)):\n        if sorted_l[i] != sorted_l[i - 1] + 1:\n            return False\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert lists to sets to remove duplicates and allow for set operations\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a tuple\n    result = tuple(intersection)\n    \n    return result"}
{"id": "463_0", "code": "def replace_char(str1, ch, newch):\n    # Use the str.replace() method to replace all occurrences of ch with newch\n    return str1.replace(ch, newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    # Sort the dictionary by value in descending order\n    sorted_dict = dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    if not nums:\n        return 0  # Return 0 if the array is empty\n    \n    # Find the maximum and minimum values in the array\n    max_value = max(nums)\n    min_value = min(nums)\n    \n    # Calculate the sum of the largest and smallest values\n    result = max_value + min_value\n    \n    return result"}
{"id": "466_0", "code": "def is_lower(string):\n    return string.islower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    # Use a list comprehension to filter out lowercase characters\n    result = ''.join([char for char in str1 if not char.islower()])\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    # Convert the number to a string to easily access the first character\n    n_str = str(n)\n    # Return the first character of the string, which is the first digit\n    return int(n_str[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    # Initialize a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Initialize variables to keep track of the maximum occurrence and the corresponding character\n    max_occurrence = 0\n    max_char = ''\n    \n    # Iterate over the dictionary to find the character with the maximum occurrence\n    for char, count in char_count.items():\n        if count > max_occurrence:\n            max_occurrence = count\n            max_char = char\n    \n    # Return the character with the maximum occurrence\n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Base case: if sum is 0, an empty subset exists\n    if sum == 0:\n        return True\n    # Base case: if no elements are left and sum is not 0\n    if n == 0 and sum != 0:\n        return False\n    # If the last element is greater than the sum, ignore it\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    # Check two possibilities: including the last element or excluding it\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    # Use regex to find sequences of one upper case letter followed by lower case letters\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "472_0", "code": "def first_Factorial_Divisible_Number(x):\n    factorial = 1\n    n = 1\n    while True:\n        factorial *= n\n        if factorial % x == 0:\n            return n\n        n += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    # Use list comprehension to filter out matching tuples\n    result = [tup for tup in test_list1 if tup not in test_list2]\n    return result"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_palindrome = -1\n    for num in A:\n        if is_palindrome(num):\n            max_palindrome = max(max_palindrome, num)\n    \n    return max_palindrome"}
{"id": "475_0", "code": "def binomial_probability(n, k, p):\n    from math import comb\n    return comb(n, k) * (p ** k) * ((1 - p) ** (n - k))"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    # Sort the list of tuples based on the last element of each tuple\n    sorted_tup = sorted(tup, key=lambda x: x[-1])\n    return sorted_tup"}
{"id": "477_0", "code": "def area_pentagon(a):\n    # The formula for the area of a regular pentagon is (sqrt(5 * (5 + 2 * sqrt(5)))) * a^2 / 4\n    import math\n    return (math.sqrt(5 * (5 + 2 * math.sqrt(5)))) * a**2 / 4"}
{"id": "478_0", "code": "def frequency_of_largest(n, arr):\n    if not arr:\n        return 0  # Return 0 if the array is empty\n\n    # Find the maximum value in the array\n    max_value = max(arr)\n\n    # Count the frequency of the maximum value\n    frequency = arr.count(max_value)\n\n    return frequency"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    # Initialize an empty list to store symmetric pairs\n    symmetric_pairs = []\n    \n    # Iterate over each pair in the test list\n    for pair in test_list:\n        # Check if the pair is symmetric (i.e., the first element is the reverse of the second)\n        if pair[0] == pair[1][::-1]:\n            # If symmetric, add the pair to the symmetric_pairs list\n            symmetric_pairs.append(pair)\n    \n    # Return the list of symmetric pairs\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r**n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    # Initialize the start and end pointers\n    left, right = 0, len(item_list) - 1\n    \n    # Continue searching while the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n        \n        # Check if the middle element is the target item\n        if item_list[mid] == item:\n            return mid  # Return the index of the target item\n        # If the target item is greater than the middle element, search in the right half\n        elif item_list[mid] < item:\n            left = mid + 1\n        # If the target item is less than the middle element, search in the left half\n        else:\n            right = mid - 1\n    \n    # If the target item is not found, return -1\n    return -1"}
{"id": "482_0", "code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    # Calculate the number of hexagons in the x and y directions\n    num_hexes_x = int((endx - startx) / (radius * 2 * (3 ** 0.5)))\n    num_hexes_y = int((endy - starty) / (radius * 2 * (3 ** 0.5)))\n\n    # Initialize the list of hexagon coordinates\n    hexagon_coords = []\n\n    # Function to calculate the coordinates of a hexagon given its center\n    def hexagon_coords_from_center(center_x, center_y):\n        coords = []\n        for i in range(6):\n            angle = 2 * 3.14159 * i / 6\n            x = center_x + radius * 2 * (3 ** 0.5) * math.cos(angle)\n            y = center_y + radius * math.sin(angle)\n            coords.append((x, y))\n        return coords\n\n    # Iterate over each hexagon in the grid\n    for i in range(num_hexes_x):\n        for j in range(num_hexes_y):\n            # Calculate the center of the hexagon\n            center_x = startx + (i + 0.5) * radius * 2 * (3 ** 0.5)\n            center_y = starty + (j + 0.5) * radius * 2 * (3 ** 0.5)\n            # Get the coordinates of the hexagon\n            hexagon_coords.append(hexagon_coords_from_center(center_x, center_y))\n\n    return hexagon_coords"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    # Convert the binary tuple to a string\n    binary_str = ''.join(map(str, test_tup))\n    \n    # Convert the binary string to an integer\n    result = int(binary_str, 2)\n    \n    return result"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    # Use regex to find all lowercase letters and replace them with an empty string\n    return re.sub(r'[a-z]', '', str1)"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    # Use heapq.nsmallest to find the n smallest elements in the list\n    smallest_nums = heapq.nsmallest(n, nums)\n    return smallest_nums"}
{"id": "486_0", "code": "def surfacearea_cone(r, h):\n    import math\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x"}
{"id": "488_0", "code": "def diameter_circle(r):\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    return ''.join(lst)"}
{"id": "490_0", "code": "def num_comm_div(x, y):\n    # Initialize the count of common divisors\n    count = 0\n    \n    # Iterate through all numbers from 1 to the minimum of x and y\n    for i in range(1, min(x, y) + 1):\n        # Check if both x and y are divisible by i\n        if x % i == 0 and y % i == 0:\n            count += 1\n    \n    return count"}
{"id": "491_0", "code": "def find(n, m):\n    # Check if m is zero to avoid division by zero error\n    if m == 0:\n        return \"Error: Division by zero is not allowed.\"\n    # Calculate the remainder using the modulus operator\n    remainder = n % m\n    return remainder"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Iterate through the list of numbers\n    for i in range(len(nums) - 1):\n        # Add the current number and the next number to the total sum\n        total_sum += nums[i] + nums[i + 1]\n    \n    # Return the total sum of consecutive numbers\n    return total_sum"}
{"id": "493_0", "code": "def sum_Of_Series(n):\n    # Calculate the cube sum of the first n natural numbers\n    cube_sum = sum(i**3 for i in range(1, n+1))\n    return cube_sum"}
{"id": "494_0", "code": "def re_order(A):\n    # Initialize two pointers\n    left = 0\n    right = len(A) - 1\n    \n    # Traverse the array\n    while left <= right:\n        # If the current element is zero, move it to the end\n        if A[left] == 0:\n            # Swap the current element with the element at the right pointer\n            A[left], A[right] = A[right], A[left]\n            # Move the right pointer to the left\n            right -= 1\n        else:\n            # Move the left pointer to the right\n            left += 1"}
{"id": "495_0", "code": "def permutation_coefficient(n, k):\n    # Base case: if k is greater than n, or if k is 0, the permutation coefficient is 0\n    if k > n or k == 0:\n        return 0\n    \n    # Initialize the result\n    result = 1\n    \n    # Calculate the permutation coefficient using the formula n! / (n-k)!\n    for i in range(1, k + 1):\n        result *= (n - i + 1)\n    \n    return result"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    # Create a set of words to remove for faster lookup\n    remove_set = set(removewords)\n    \n    # Use a list comprehension to filter out the words to be removed\n    filtered_list = [word for word in list1 if word not in remove_set]\n    \n    return filtered_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    # Find the common elements between the two lists\n    common_elements = set(l1) & set(l2)\n    \n    # If there are no common elements, return True\n    if not common_elements:\n        return True\n    \n    # Get the indices of the common elements in both lists\n    indices_l1 = [l1.index(element) for element in common_elements]\n    indices_l2 = [l2.index(element) for element in common_elements]\n    \n    # Check if the indices are in the same order\n    return indices_l1 == indices_l2"}
{"id": "498_0", "code": "def average_Odd(n):\n    if n < 1:\n        return 0  # Return 0 for negative or zero input\n    sum_odd = 0\n    count_odd = 0\n    for i in range(1, n + 1, 2):  # Iterate over odd numbers from 1 to n\n        sum_odd += i\n        count_odd += 1\n    if count_odd == 0:\n        return 0  # Return 0 if there are no odd numbers\n    return sum_odd / count_odd"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    if k == 0:\n        return 0  # If k is 0, there are no subsequences with product less than k\n\n    n = len(arr)\n    count = 0\n\n    # Iterate over all possible starting points of subsequences\n    for start in range(n):\n        product = 1\n        # Iterate over all possible ending points of subsequences starting from 'start'\n        for end in range(start, n):\n            product *= arr[end]\n            # If the product is less than k, increment the count\n            if product < k:\n                count += 1\n            else:\n                break  # If the product is not less than k, break the inner loop\n\n    return count"}

{"id": "0_0", "code": "def remove_Occ(s,ch):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # Remove the last occurrence\n    s = s[:last_occurrence] + s[last_occurrence+1:]\n    \n    return s"}
{"id": "1_0", "code": "def sort_matrix(M):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in M]\n    \n    # Sort the matrix based on the row sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, M))]\n    \n    return sorted_matrix"}
{"id": "2_0", "code": "def count_common(words):\n    # Initialize an empty dictionary to store word counts\n    word_count = {}\n    \n    # Iterate over each word in the input dictionary\n    for word in words:\n        # If the word is already in the dictionary, increment its count\n        if word in word_count:\n            word_count[word] += 1\n        # If the word is not in the dictionary, add it with a count of 1\n        else:\n            word_count[word] = 1\n    \n    # Find the maximum count\n    max_count = max(word_count.values())\n    \n    # Initialize a list to store the most common words\n    most_common = []\n    \n    # Iterate over each word in the dictionary\n    for word, count in word_count.items():\n        # If the word's count is equal to the maximum count, add it to the list\n        if count == max_count:\n            most_common.append(word)\n    \n    # Return the list of most common words\n    return most_common"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    # Calculate the area of the triangular base\n    base_area = 0.5 * b * h\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * l\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    result = []\n    current_word = \"\"\n    for char in text:\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n        current_word += char\n    if current_word:\n        result.append(current_word)\n    return result"}
{"id": "5_0", "code": "import re\n\ndef text_lowercase_underscore(text):\n    # Use regular expression to find sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "6_0", "code": "def square_perimeter(a):\n    return 4 * a"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    # Convert the second string to a set for faster lookup\n    dirty_chars = set(second_string)\n    \n    # Use a list comprehension to filter out characters present in the second string\n    cleaned_string = ''.join([char for char in string if char not in dirty_chars])\n    \n    return cleaned_string"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    # Check if the length of the array is equal to the length of the set of the array\n    # If they are not equal, it means there are duplicate elements\n    return len(arraynums) != len(set(arraynums))"}
{"id": "9_0", "code": "def is_woodall(x):\n    if x < 0:\n        return False\n    n = 1\n    while True:\n        if n * (n + 1) // 2 == x:\n            return True\n        if n * (n + 1) // 2 > x:\n            return False\n        n += 1"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    multiples = []\n    for i in range(1, m + 1):\n        multiples.append(i * n)\n    return multiples"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    max_sum = float('-inf')\n    for sublist in list1:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n    while binary > 0:\n        digit = binary % 10\n        decimal += digit * (2 ** power)\n        binary //= 10\n        power += 1\n    return decimal"}
{"id": "14_0", "code": "def find_Product(arr,n):\n    product = 1\n    for i in range(n):\n        if arr[i] not in arr[:i] + arr[i+1:]:\n            product *= arr[i]\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    # Check if all elements in the list have at least K elements\n    result = all(len(ele) >= K for ele in test_list)\n    return result"}
{"id": "16_0", "code": "def remove(list):\n    return [s.replace(str(i), '') for s in list for i in range(10)]"}
{"id": "17_0", "code": "def binomial_Coeff(n,k):\n    # Base case: if k is 0 or n is k, the binomial coefficient is 1\n    if k == 0 or n == k:\n        return 1\n    # Recursive case: use the formula C(n, k) = C(n-1, k-1) + C(n-1, k)\n    else:\n        return binomial_Coeff(n-1, k-1) + binomial_Coeff(n-1, k)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    result = 0\n    for i in range(arr_size):\n        result = result ^ arr[i]\n    return result"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "from heapq import nlargest\n\ndef func(nums, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Use nlargest to find the top k most frequent elements\n    top_k_frequent = nlargest(k, flat_list, key=flat_list.count)\n    \n    return top_k_frequent"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i +2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, store i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime"}
{"id": "22_0", "code": "def decimal_To_Binary(N):\n    if N == 0:\n        return \"0\"\n    binary = \"\"\n    while N > 0:\n        remainder = N % 2\n        binary = str(remainder) + binary\n        N = N // 2\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar, N):\n    # Initialize the start and end pointers\n    start = 0\n    end = N - 1\n    \n    # Perform binary search to find the missing number\n    while start <= end:\n        mid = start + (end - start) // 2\n        \n        # Check if the missing number is in the left half\n        if mid == ar[mid]:\n            start = mid + 1\n        else:\n            end = mid - 1\n    \n    # The missing number is found at the position where start and end meet\n    return start"}
{"id": "24_0", "code": "def find_rect_num(n):\n    # Calculate the n-th rectangular number using the formula n * (n + 1) / 2\n    return n * (n + 1) // 2"}
{"id": "25_0", "code": "def find_Nth_Digit(p, q, N):\n    # Calculate the numerator and denominator of the fraction\n    numerator = p\n    denominator = q\n    \n    # Calculate the number of digits in the numerator\n    num_digits = len(str(numerator))\n    \n    # Calculate the number of digits in the denominator\n    den_digits = len(str(denominator))\n    \n    # Calculate the number of digits in the proper fraction\n    total_digits = num_digits + den_digits\n    \n    # Calculate the number of complete cycles of the proper fraction\n    complete_cycles = N // total_digits\n    \n    # Calculate the remaining digits after complete cycles\n    remaining_digits = N % total_digits\n    \n    # Calculate the position of the nth digit in the proper fraction\n    position = remaining_digits\n    \n    # Calculate the nth digit in the proper fraction\n    if position <= num_digits:\n        # The nth digit is in the numerator\n        nth_digit = str(numerator)[position - 1]\n    else:\n        # The nth digit is in the denominator\n        nth_digit = str(denominator)[position - num_digits - 1]\n    \n    return nth_digit"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    # Separate integers and strings\n    integers = [item for item in mixed_list if isinstance(item, int)]\n    strings = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort integers and strings separately\n    integers.sort()\n    strings.sort()\n    \n    # Combine sorted integers and strings\n    sorted_list = integers + strings\n    \n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    even_count = 0\n    odd_count = 0\n    even_sum = 0\n    odd_sum = 0\n    \n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n            even_sum += num\n        else:\n            odd_count += 1\n            odd_sum += num\n    \n    if even_count > 0 and odd_count > 0:\n        even_avg = even_sum / even_count\n        odd_avg = odd_sum / odd_count\n        return even_avg, odd_avg\n    else:\n        return None"}
{"id": "28_0", "code": "def rearange_string(S):\n    # Count the frequency of each character in the string\n    char_count = {}\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the character with the highest frequency\n    max_freq = max(char_count.values())\n    max_freq_char = [char for char, count in char_count.items() if count == max_freq][0]\n    \n    # Check if the string can be rearranged\n    if max_freq > (len(S) + 1) // 2:\n        return False\n    \n    # Rearrange the string\n    result = []\n    while max_freq_char in char_count:\n        result.append(max_freq_char)\n        char_count[max_freq_char] -= 1\n        if char_count[max_freq_char] == 0:\n            del char_count[max_freq_char]\n    \n    # Fill the remaining characters\n    for char, count in char_count.items():\n        while count > 0:\n            if len(result) > 0 and result[-1] == char:\n                return False\n            result.append(char)\n            count -= 1\n    \n    return ''.join(result)"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flat_list)\n    \n    return frequency"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr, n):\n    # Initialize a dictionary to keep track of the frequency of each element\n    frequency = {}\n    \n    # Iterate through the array to populate the frequency dictionary\n    for i in range(n):\n        if arr[i] in frequency:\n            frequency[arr[i]] += 1\n        else:\n            frequency[arr[i]] = 1\n    \n    # Initialize a variable to store the sum of repeated elements\n    sum_repeated = 0\n    \n    # Iterate through the frequency dictionary to find elements with a frequency greater than 1\n    for key, value in frequency.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    return sum_repeated"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    # Use regex to find sequences of lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'"}
{"id": "33_0", "code": "def text_match_string(text):\n    # Check if the text starts with a word\n    if text.startswith('word'):\n        return True\n    else:\n        return False"}
{"id": "34_0", "code": "def get_gcd(l):\n    if len(l) == 0:\n        return None\n    if len(l) == 1:\n        return l[0]\n    gcd = l[0]\n    for num in l[1:]:\n        gcd = math.gcd(gcd, num)\n    return gcd"}
{"id": "35_0", "code": "def test_distinct(data):\n    # Check if the length of the data is equal to the length of the set of data\n    return len(data) == len(set(data))"}
{"id": "36_0", "code": "def compute_Last_Digit(A, B):\n    # Calculate the factorial of A and B\n    factorial_A = 1\n    factorial_B = 1\n    \n    for i in range(1, A + 1):\n        factorial_A *= i\n    \n    for i in range(1, B + 1):\n        factorial_B *= i\n    \n    # Find the last digit of the division of factorial_A by factorial_B\n    last_digit = factorial_A % factorial_B\n    \n    return last_digit"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over the bits of the number\n    for i in range(32):\n        # Check if the current bit is odd\n        if i % 2 == 1:\n            # Set the current bit in the result\n            result |= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    result = []\n    for row in nums:\n        for element in row:\n            if element == N:\n                result.append(element)\n                break\n    return result"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=lambda x: len(x))"}
{"id": "40_0", "code": "def check_equilateral(x, y, z):\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"id": "41_0", "code": "def parallelogram_area(b,h):\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    if len(str) == 0:\n        return False\n    return str[0] == str[-1]"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    if not my_list:\n        return []\n\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Initialize the count array with zeros\n    count = [0] * (max_value + 1)\n\n    # Count the occurrences of each element in the list\n    for num in my_list:\n        count[num] += 1\n\n    # Build the sorted list using the count array\n    sorted_list = []\n    for num, freq in enumerate(count):\n        sorted_list.extend([num] * freq)\n\n    return sorted_list"}
{"id": "44_0", "code": "def tn_gp(a,n,r):\n    # Calculate the t-nth term of the geometric series\n    tn = a * (r ** (n - 1))\n    return tn"}
{"id": "45_0", "code": "def check(n):\n    # Convert the number to a string to reverse it\n    str_n = str(n)\n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"id": "46_0", "code": "def find_Max_Num(arr,n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Initialize the result string\n    result = \"\"\n    \n    # Iterate through the sorted array\n    for i in range(n):\n        # Append each digit to the result string\n        result += str(arr[i])\n    \n    # Convert the result string to an integer and return it\n    return int(result)"}
{"id": "47_0", "code": "def opposite_Signs(x, y):\n    return x * y < 0"}
{"id": "48_0", "code": "def is_octagonal(n):\n    # Check if n is a positive integer\n    if n <= 0:\n        return False\n    \n    # Calculate the nth octagonal number using the formula\n    octagonal_number = (3 * n * n - n) // 2\n    \n    # Check if the calculated number is equal to n\n    return octagonal_number == n"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    # Initialize the maximum length of subsequence\n    max_len = 1\n    \n    # Iterate through the array\n    for i in range(1, n):\n        # Check if the difference between adjacent elements is 1\n        if abs(arr[i] - arr[i - 1]) == 1:\n            # Increment the length of the subsequence\n            max_len += 1\n    \n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s, n):\n    count = 0\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            if current_sum == j - i + 1:\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    if not xs:\n        return None  # Return None if the list is empty\n    smallest = xs[0]  # Assume the first element is the smallest\n    for num in xs:\n        if num < smallest:\n            smallest = num  # Update smallest if a smaller number is found\n    return smallest"}
{"id": "52_0", "code": "def max_difference(test_list):\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate through the list of tuples\n    for tup in test_list:\n        # Calculate the difference between the first and second elements of the tuple\n        diff = tup[1] - tup[0]\n        \n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference found\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the second element of each tuple (marks)\n    sorted_subjectmarks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_subjectmarks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(list):\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count"}
{"id": "56_0", "code": "def bell_number(n):\n    # Initialize a list to store Bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1  # Base case: There is one way to partition an empty set\n\n    # Compute Bell numbers using the recursive relation\n    for i in range(1, n + 1):\n        bell[i] = 0\n        for j in range(i):\n            bell[i] += bell[j] * bell[i - j - 1]\n\n    return bell[n]"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    if not A:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n    \n    return increasing or decreasing"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    if not s:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    # Check if all tuples in the list have the same length\n    all_equal = all(len(t) == k for t in Input)\n    return all_equal"}
{"id": "60_0", "code": "def comb_sort(nums):\n    gap = len(nums)\n    shrink_factor = 1.3\n    is_sorted = False\n\n    while not is_sorted:\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        is_sorted = True\n\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                is_sorted = False\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    # Check if n is less than 4, as the smallest difference of two squares is 1 (1^2 - 0^2)\n    if n < 4:\n        return False\n    \n    # Check if n is even, as the difference of two squares is always even\n    if n % 2 == 0:\n        return True\n    \n    # Check if n is of the form 4k + 2, as the difference of two squares is never of this form\n    if n % 4 == 2:\n        return False\n    \n    # If none of the above conditions are met, n can be represented as a difference of two squares\n    return True"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    # Define the regex pattern to match multiple delimiters\n    pattern = r'[,\\s]+'\n    # Use re.split to split the text based on the pattern\n    return re.split(pattern, text)"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    # Check if the length of colors is equal to the length of patterns\n    if len(colors) != len(patterns):\n        return False\n    \n    # Iterate through each color and pattern pair\n    for color, pattern in zip(colors, patterns):\n        # Check if the color matches the pattern\n        if color != pattern:\n            return False\n    \n    # If all colors match their corresponding patterns, return True\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    res = [ele for ele in test_list if all(ele[i] % K == 0 for i in range(len(ele)))]\n    return res"}
{"id": "65_0", "code": "def count_Squares(m, n):\n    # Calculate the total number of squares in a rectangle of size m x n\n    total_squares = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # The number of squares of size k x k that can fit in a rectangle of size i x j\n            # is (i - k + 1) * (j - k + 1)\n            total_squares += (i - k + 1) * (j - k + 1)\n    return total_squares"}
{"id": "66_0", "code": "def is_Diff(n):\n    sum_even = 0\n    sum_odd = 0\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            sum_even += digit\n        else:\n            sum_odd += digit\n        n = n // 10\n    return sum_even - sum_odd"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    if len(s) % 2 == 1:\n        return True\n    else:\n        return False"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    # Calculate the nth tetrahedral number using the formula\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    # Use the zip function to combine the tuples\n    res = list(zip(test_tup1, test_tup2))\n    return res"}
{"id": "71_0", "code": "def volume_sphere(r):\n    import math\n    return (4/3) * math.pi * (r ** 3)"}
{"id": "72_0", "code": "def get_Char(strr):\n    total = 0\n    for char in strr:\n        total += ord(char)\n    return chr(total)"}
{"id": "73_0", "code": "def sequence(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        sequence = [1, 1]\n        for i in range(3, n + 1):\n            sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n        return sequence[n - 1]"}
{"id": "74_0", "code": "def surfacearea_sphere(r):\n    import math\n    return 4 * math.pi * r ** 2"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for element in list1:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency:\n            frequency[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency"}
{"id": "78_0", "code": "def closest_num(N):\n    # Initialize the closest number to N\n    closest = N - 1\n    \n    # Check if the closest number is less than 0\n    if closest < 0:\n        # If it is, return 0 as the closest number\n        return 0\n    \n    # Return the closest number\n    return closest"}
{"id": "79_0", "code": "def len_log(list1):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in list1:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the length of the longest word\n    return max_length"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    # Check if the substring is present in the string\n    if sub_str in str1:\n        return True\n    else:\n        return False"}
{"id": "81_0", "code": "def is_undulating(n):\n    # Convert the number to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Check if the string length is less than 3, as an undulating number must have at least 3 digits\n    if len(str_n) < 3:\n        return False\n    \n    # Check if the first two digits are the same and the last two digits are the same\n    if str_n[0] == str_n[1] and str_n[-1] == str_n[-2]:\n        return True\n    \n    # Check if the first two digits are different and the last two digits are different\n    if str_n[0] != str_n[1] and str_n[-1] != str_n[-2]:\n        return True\n    \n    # If none of the above conditions are met, the number is not undulating\n    return False"}
{"id": "82_0", "code": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    # Initialize variables to store the minimum value and its index\n    min_value = float('inf')\n    min_index = -1\n    \n    # Iterate through the list of tuples\n    for index, (key, value) in enumerate(test_list):\n        # Check if the current value is less than the minimum value found so far\n        if value < min_value:\n            min_value = value\n            min_index = index\n    \n    # Return the index of the tuple with the minimum value\n    return min_index"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    if not lst:\n        return 0\n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    frequency_dict = {}\n    for sublist in list1:\n        if tuple(sublist) in frequency_dict:\n            frequency_dict[tuple(sublist)] += 1\n        else:\n            frequency_dict[tuple(sublist)] = 1\n    return frequency_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n    \n    if num < 0:\n        return None  # Negative numbers cannot have palindromes\n    \n    # Start from the next number\n    num += 1\n    \n    # Check each number to see if it's a palindrome\n    while not is_palindrome(num):\n        num += 1\n    \n    return num"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    # Check if k is within the valid range\n    if k < 1 or k > n:\n        return \"Invalid k value\"\n    \n    # Sort the array\n    arr.sort()\n    \n    # Return the kth element (0-based index)\n    return arr[k - 1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    # Split the word by underscores\n    parts = word.split('_')\n    # Capitalize the first letter of each part and join them together\n    camel_case_word = ''.join(part.capitalize() for part in parts)\n    return camel_case_word"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    # Use list comprehension to sort each sublist using lambda function\n    sorted_list = [sorted(sublist, key=lambda x: x) for sublist in input_list]\n    return sorted_list"}
{"id": "94_0", "code": "def count(lst):\n    return sum(1 for item in lst if item)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    # Convert the list to a tuple\n    test_list = tuple(test_list)\n    \n    # Add the list to the tuple\n    result = test_list + test_tup\n    \n    return result"}
{"id": "96_0", "code": "def count_Hexadecimal(L, R):\n    count = 0\n    for num in range(L, R + 1):\n        if num < 0:\n            continue\n        hex_num = hex(num)[2:]  # Convert to hexadecimal and remove the '0x' prefix\n        if hex_num.isalpha():  # Check if the hexadecimal number contains any letters\n            count += 1\n    return count"}
{"id": "97_0", "code": "from heapq import merge\n\ndef merge_sorted_list(num1, num2, num3):\n    # Use the merge function from the heapq module to merge the sorted inputs\n    merged_iterator = merge(num1, num2, num3)\n    return merged_iterator"}
{"id": "98_0", "code": "def odd_Equivalent(s, n):\n    # Initialize the count of rotations with odd value\n    count = 0\n    \n    # Iterate through all possible rotations of the string\n    for i in range(n):\n        # Check if the current rotation has an odd value\n        if int(s[i:] + s[:i], 2) % 2 != 0:\n            count += 1\n    \n    return count"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    # Initialize an empty list to store the missing ranges\n    missing_ranges = []\n    \n    # Iterate over the range from start to stop\n    for i in range(strt_val, stop_val + 1):\n        # Check if the current number is not in the test_list\n        if i not in test_list:\n            # If the missing range is not already added, add it\n            if not missing_ranges or missing_ranges[-1][1] + 1 != i:\n                missing_ranges.append([i, i])\n            else:\n                # If the current number is consecutive to the last range, extend the range\n                missing_ranges[-1][1] = i\n    \n    return missing_ranges"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    # Initialize an empty set to store common elements\n    common_elements = set()\n    \n    # Iterate over each sublist in the nested list\n    for sublist in nestedlist:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Add the element to the set if it's not already present\n            common_elements.add(element)\n    \n    # Convert the set to a list and return it\n    return list(common_elements)"}
{"id": "101_0", "code": "def perimeter(diameter, height):\n    # Calculate the circumference of the base of the cylinder\n    base_circumference = 3.14159 * diameter\n    \n    # Calculate the perimeter of the cylinder\n    perimeter = 2 * (base_circumference + height)\n    \n    return perimeter"}
{"id": "102_0", "code": "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    # Initialize an empty dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over each tuple in the test_list\n    for tup in test_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Return the dictionary containing the frequency of each tuple\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    for i in list1:\n        if i:\n            return False\n    return True"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    # Convert each element in the tuple to a string\n    str_nums = [str(num) for num in nums]\n    # Join the string representations of the numbers into a single string\n    combined_str = ''.join(str_nums)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    # Initialize an empty list to store the converted float values\n    res = []\n    \n    # Iterate over each element in the input list\n    for ele in test_list:\n        # Check if the element is convertible to float\n        if isinstance(ele, (int, float)):\n            # Convert the element to float and append to the result list\n            res.append(float(ele))\n        else:\n            # If the element is not convertible, append it as is\n            res.append(ele)\n    \n    # Return the list of converted float values\n    return res"}
{"id": "107_0", "code": "def string_to_list(string):\n    return list(string)"}
{"id": "108_0", "code": "def search(arr, n):\n    # Initialize two pointers\n    left, right = 0, n - 1\n    \n    # Use binary search to find the unique element\n    while left < right:\n        mid = (left + right) // 2\n        \n        # If mid is even and the element at mid is equal to the element at mid + 1, the unique element is in the right half\n        if mid % 2 == 0 and arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        # If mid is odd and the element at mid is equal to the element at mid - 1, the unique element is in the left half\n        elif mid % 2 == 1 and arr[mid] == arr[mid - 1]:\n            right = mid - 2\n        # If the elements at mid and mid + 1 are not equal, the unique element is at mid\n        else:\n            return arr[mid]\n    \n    # If the loop ends, the unique element is at the left pointer\n    return arr[left]"}
{"id": "109_0", "code": "def max_product_tuple(list1):\n    max_product = float('-inf')\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            product = list1[i][0] * list1[j][1]\n            if product > max_product:\n                max_product = product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    \n    # Iterate through the array\n    for i in range(n - 2):\n        # Use two pointers to find the other two numbers\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            \n            if current_sum == sum:\n                # Found a triplet\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    \n    return count"}
{"id": "111_0", "code": "def smartNumber(n):\n    # Initialize the first two smart numbers\n    smart_nums = [1, 2]\n    \n    # Generate smart numbers until we reach the nth one\n    while len(smart_nums) < n:\n        # The next smart number is the sum of the last two smart numbers\n        next_num = smart_nums[-1] + smart_nums[-2]\n        smart_nums.append(next_num)\n    \n    # Return the nth smart number\n    return smart_nums[n-1]"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    def is_amicable(n):\n        def sum_of_divisors(m):\n            return sum(i for i in range(1, m) if m % i == 0)\n        \n        divisor_sum = sum_of_divisors(n)\n        if divisor_sum == n:\n            return False\n        return sum_of_divisors(divisor_sum) == n\n    \n    return sum(n for n in range(1, limit) if is_amicable(n))"}
{"id": "113_0", "code": "import cmath\n\ndef angle_complex(a, b):\n    # Create a complex number from the given real and imaginary parts\n    complex_num = complex(a, b)\n    \n    # Calculate the angle of the complex number\n    angle = cmath.phase(complex_num)\n    \n    return angle"}
{"id": "114_0", "code": "def find_length(string, n):\n    max_diff = 0\n    current_diff = 0\n    zero_count = 0\n    one_count = 0\n    \n    for i in range(n):\n        if string[i] == '0':\n            zero_count += 1\n        else:\n            one_count += 1\n        \n        current_diff = zero_count - one_count\n        \n        if current_diff > max_diff:\n            max_diff = current_diff\n    \n    return max_diff"}
{"id": "115_0", "code": "def sum(a,b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    common_divisors = set()\n    for i in range(1, gcd(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.add(i)\n\n    return sum(common_divisors)"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)"}
{"id": "117_0", "code": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split()\n    # Filter the list to include only words longer than n\n    long_words = [word for word in words if len(word) > n]\n    # Return the filtered list of long words\n    return long_words"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n    \n    # Calculate the sum of the first row\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    \n    # Check if all rows have the same sum\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check if all columns have the same sum\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check if the main diagonal has the same sum\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check if the secondary diagonal has the same sum\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True"}
{"id": "119_0", "code": "def max_occurrences(nums):\n    from collections import Counter\n    # Count the frequency of each item in the list\n    frequency = Counter(nums)\n    # Find the item with the maximum frequency\n    max_item = frequency.most_common(1)[0][0]\n    return max_item"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = \"aeiouAEIOU\"\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    \n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(str1)"}
{"id": "121_0", "code": "def tup_string(tup1):\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(filter(lambda x: x < 0, nums))"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    # Perform the operation p times\n    for _ in range(p):\n        # Check if the last element is even or odd\n        if arr[-1] % 2 == 0:\n            return \"Even\"\n        else:\n            return \"Odd\""}
{"id": "124_0", "code": "def hexagonal_num(n):\n    return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    if units <= 100:\n        bill = units * 0.5\n    elif units <= 300:\n        bill = 50 + (units - 100) * 0.75\n    else:\n        bill = 200 + (units - 300) * 1.2\n    return bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    count = 0\n    for num in nums:\n        if num == 0:\n            count += 1\n    return count"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    # Check if n is less than 1, as 0 cannot be represented as sum of powers of 2\n    if n < 1:\n        return False\n    \n    # Iterate through all powers of 2\n    for i in range(32):  # Assuming 32-bit integer\n        power_of_two = 1 << i\n        if power_of_two <= n:\n            n -= power_of_two\n        else:\n            break\n    \n    # If n is reduced to 0, it means n can be represented as sum of powers of 2\n    return n == 0"}
{"id": "128_0", "code": "def circle_circumference(r):\n    import math\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    # Initialize an empty dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Iterate through each element in the tuple\n        for ele in tup:\n            # If the element is already in the dictionary, increment its count\n            if ele in count_dict:\n                count_dict[ele] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                count_dict[ele] = 1\n    \n    # Initialize an empty list to store elements that occur singly\n    result = []\n    \n    # Iterate through each element in the dictionary\n    for ele, count in count_dict.items():\n        # If the count is 1, add the element to the result list\n        if count == 1:\n            result.append(ele)\n    \n    # Return the result list\n    return result"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n):\n        # Find the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:n-i]))\n        \n        # Flip the maximum element to the beginning of the unsorted part\n        nums[:max_index+1] = nums[:max_index+1][::-1]\n        \n        # Flip the entire unsorted part to move the maximum element to its correct position\n        nums[:n-i] = nums[:n-i][::-1]\n    return nums"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                if list1[i] == list2[j] == list3[k]:\n                    count += 1\n    return count"}
{"id": "132_0", "code": "def find_lists(Input):\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    # Initialize the minimum and maximum elements\n    min_element = arr[0]\n    max_element = arr[0]\n    \n    # Iterate through the array to find the minimum and maximum elements\n    for i in range(1, n):\n        if arr[i] < min_element:\n            min_element = arr[i]\n        if arr[i] > max_element:\n            max_element = arr[i]\n    \n    # Calculate the maximum absolute difference\n    max_diff = max_element - min_element\n    \n    return max_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    total_ascii = 0\n    for char in str1:\n        total_ascii += ord(char)\n    return total_ascii"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    # Initialize a 2D list to store the maximum path sums\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp table from bottom to top\n    for i in range(m - 1, -1, -1):\n        for j in range(i + 1):\n            # Calculate the maximum path sum for the current cell\n            dp[i][j] = tri[i][j] + max(dp[i + 1][j], dp[i + 1][j + 1])\n    \n    # The maximum path sum is stored in the top-left cell of the dp table\n    return dp[0][0]"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    # Convert the number to a string to iterate over each digit\n    str_N = str(N)\n    # Initialize two lists to store the digits of the two parts\n    part1 = []\n    part2 = []\n    # Iterate over each digit in the string representation of N\n    for i, digit in enumerate(str_N):\n        # If the index is even, add the digit to part1\n        if i % 2 == 0:\n            part1.append(int(digit))\n        # If the index is odd, add the digit to part2\n        else:\n            part2.append(int(digit))\n    # Calculate the sum of digits for each part\n    sum_part1 = sum(part1)\n    sum_part2 = sum(part2)\n    # Return the two parts as a tuple\n    return (part1, part2)"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    # Initialize a dictionary to store the length of the longest subsequence ending at each index\n    dp = {}\n    \n    # Iterate through each element in the array\n    for i in range(n):\n        # Initialize the length of the longest subsequence ending at index i to 1\n        dp[i] = 1\n        \n        # Check all previous indices to find the longest subsequence ending at index i\n        for j in range(i):\n            # If the difference between arr[i] and arr[j] is 1, update the length of the longest subsequence\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # Find the maximum length of the subsequence\n    max_length = max(dp.values())\n    \n    # Find the index of the last element of the longest subsequence\n    last_index = max(dp, key=dp.get)\n    \n    # Initialize the longest subsequence with the last element\n    longest_subseq = [arr[last_index]]\n    \n    # Traverse the dp array to find the longest subsequence\n    for i in range(last_index - 1, -1, -1):\n        if dp[i] == dp[last_index] - 1 and abs(arr[i] - arr[last_index]) == 1:\n            longest_subseq.append(arr[i])\n            last_index = i\n    \n    # Return the longest subsequence\n    return longest_subseq[::-1]"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    # Check if the number 'a' is present in the infinite sequence\n    # The sequence is defined as a + b * n, where n is a non-negative integer\n    # To check if 'a' is present, we need to find if there exists an integer n such that a = b * n\n    # This can be done by checking if 'a' is divisible by 'b'\n    if a % b == 0:\n        return True\n    else:\n        return False"}
{"id": "140_0", "code": "def is_coprime(x,y):\n    if x == 1 or y == 1:\n        return True\n    if x % y == 0 or y % x == 0:\n        return False\n    return True"}
{"id": "141_0", "code": "def merge_sort(x):\n    if len(x) > 1:\n        mid = len(x) // 2\n        L = x[:mid]\n        R = x[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                x[k] = L[i]\n                i += 1\n            else:\n                x[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            x[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            x[k] = R[j]\n            j += 1\n            k += 1"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    # Return the vertex as a tuple (x_vertex, y_vertex)\n    return (x_vertex, y_vertex)"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    result = []\n    for row in nums:\n        for element in row:\n            if element % N == 0:\n                result.append(element)\n    return result"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over the bits of the number\n    for i in range(32):\n        # Check if the current bit is even\n        if i % 2 == 0:\n            # If it is, set the corresponding bit in the result to 1\n            result |= (1 << i)\n    \n    # XOR the original number with the result to toggle the even bits\n    return n ^ result"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    # Initialize an empty list to store the converted integers\n    int_list = []\n    \n    # Iterate over each string in the tuple\n    for item in tuple_str:\n        # Convert the string to an integer and append it to the list\n        int_list.append(int(item))\n    \n    # Convert the list of integers back to a tuple and return it\n    return tuple(int_list)"}
{"id": "146_0", "code": "def encode_list(list1):\n    if not list1:\n        return []\n    \n    encoded_list = []\n    count = 1\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            encoded_list.append((list1[i - 1], count))\n            count = 1\n    \n    # Append the last group\n    encoded_list.append((list1[-1], count))\n    \n    return encoded_list"}
{"id": "147_0", "code": "def min_Ops(arr,n,k):\n    # Initialize the minimum operations to a large number\n    min_ops = float('inf')\n    \n    # Iterate through each element in the array\n    for i in range(n):\n        # Calculate the number of operations needed to make all elements equal to arr[i]\n        ops = 0\n        for j in range(n):\n            ops += abs(arr[j] - arr[i])\n        \n        # Update the minimum operations if the current operations are less\n        min_ops = min(min_ops, ops)\n    \n    return min_ops"}
{"id": "148_0", "code": "def month_season(month,days):\n    if month in ['January', 'February', 'March']:\n        if days < 21:\n            print(\"Winter\")\n        else:\n            print(\"Spring\")\n    elif month in ['April', 'May', 'June']:\n        if days < 21:\n            print(\"Spring\")\n        else:\n            print(\"Summer\")\n    elif month in ['July', 'August', 'September']:\n        if days < 21:\n            print(\"Summer\")\n        else:\n            print(\"Fall\")\n    elif month in ['October', 'November', 'December']:\n        if days < 21:\n            print(\"Fall\")\n        else:\n            print(\"Winter\")"}
{"id": "149_0", "code": "def solution(a, b, n):\n    # Check if a and b are coprime\n    if gcd(a, b) != 1:\n        return None\n    \n    # Find the modular inverse of a modulo b\n    inv_a = pow(a, -1, b)\n    \n    # Calculate x and y\n    x = (n * inv_a) % b\n    y = (n - a * x) // b\n    \n    return x, y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    # Use list comprehension to filter out elements in list2 from list1\n    result = [element for element in list1 if element not in list2]\n    return result"}
{"id": "151_0", "code": "def sum_series(n):\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total"}
{"id": "152_0", "code": "def area_polygon(s,l):\n    import math\n    area = (s * l**2) / (4 * math.tan(math.pi / s))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    def sum_of_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)"}
{"id": "154_0", "code": "def count_char_position(str1):\n    # Initialize a dictionary to store the count of characters at each position\n    position_count = {i: 0 for i in range(26)}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Calculate the position of the character in the alphabet\n            position = ord(char) - ord('a')\n            # Increment the count for that position\n            position_count[position] += 1\n    \n    # Return the dictionary containing the count of characters at each position\n    return position_count"}
{"id": "155_0", "code": "def find_even_Pair(A,N):\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power"}
{"id": "157_0", "code": "def frequency(a,x):\n    count = 0\n    for i in range(len(a)):\n        if a[i] == x:\n            count += 1\n    return count"}
{"id": "158_0", "code": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Iterate over the list from index m to n (inclusive)\n    for i in range(m, n + 1):\n        # Add the current element to the total sum\n        total_sum += list1[i]\n    \n    # Return the total sum\n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    # Calculate the perimeter of a pentagon\n    perimeter = 5 * a\n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(char for char in text if char.isalnum())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    result = {}\n    for key, value in l:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result"}
{"id": "164_0", "code": "def is_valid_parentheses(str1):\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"}
{"id": "165_0", "code": "def perimeter_triangle(a, b, c):\n    return a + b + c"}
{"id": "166_0", "code": "def answer(L, R):\n    # Initialize the result as None\n    result = None\n    \n    # Iterate through possible values of x\n    for x in range(1, R + 1):\n        # Iterate through possible values of y\n        for y in range(x + 1, R + 1):\n            # Calculate the lcm of x and y\n            lcm = (x * y) // gcd(x, y)\n            \n            # Check if the lcm lies within the given range\n            if L <= lcm <= R:\n                # If a valid pair is found, update the result\n                result = (x, y)\n                break\n        \n        # If a valid pair is found, break out of the outer loop\n        if result:\n            break\n    \n    # Return the result\n    return result"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    # Initialize an empty list to store the results\n    results = []\n    \n    # Iterate over each pattern in the patterns list\n    for pattern in patterns:\n        # Check if the pattern is found in the text\n        if pattern in text:\n            # If found, append the pattern to the results list\n            results.append(pattern)\n    \n    # Return the list of results\n    return results"}
{"id": "168_0", "code": "def is_num_keith(x):\n    if x < 10:\n        return False\n    digits = [int(d) for d in str(x)]\n    n = len(digits)\n    current_sum = sum(digits)\n    while current_sum < x:\n        next_digit = current_sum % 10\n        digits.append(next_digit)\n        current_sum = sum(digits[-n:])\n    return current_sum == x"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(math.radians, [slat, slon, elat, elon])\n    \n    # Haversine formula\n    dlat = elat - slat\n    dlon = elon - slon\n    a = math.sin(dlat/2)**2 + math.cos(slat) * math.cos(elat) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    r = 6371  # Radius of the Earth in kilometers\n    return c * r"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    if n == 0:\n        return \"\"\n    if n == 1:\n        return arr[0]\n    \n    # Sort the array of strings\n    arr.sort()\n    \n    # Compare the first and last string in the sorted array\n    first = arr[0]\n    last = arr[n-1]\n    \n    # Find the common prefix between the first and last string\n    i = 0\n    while i < len(first) and i < len(last) and first[i] == last[i]:\n        i += 1\n    \n    # Return the common prefix\n    return first[:i]"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    uppercase = re.findall(r'[A-Z]', string)\n    lowercase = re.findall(r'[a-z]', string)\n    special_characters = re.findall(r'[!@#$%^&*(),.?\":{}|<>]', string)\n    numeric_values = re.findall(r'[0-9]', string)\n    return uppercase, lowercase, special_characters, numeric_values"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Count the frequency of each element in the array\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the array and check for pairs with difference k\n    for num in arr:\n        if num + k in frequency:\n            count += frequency[num + k]\n    \n    return count"}
{"id": "173_0", "code": "def greater_specificnum(list, num):\n    result = []\n    for item in list:\n        if item > num:\n            result.append(item)\n    return result"}
{"id": "174_0", "code": "def parabola_focus(a, b, c):\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n    # Calculate the y-coordinate of the focus\n    y_focus = (1 - (b**2 - 4*a*c)) / (4 * a)\n    # Return the focus as a tuple\n    return (x_focus, y_focus)"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    # Initialize a list to store the results\n    results = []\n    \n    # Iterate over each pattern in the patterns list\n    for pattern in patterns:\n        # Use re.search to find the pattern in the text\n        match = re.search(pattern, text)\n        \n        # If a match is found, append the match object to the results list\n        if match:\n            results.append(match)\n    \n    # Return the results list\n    return results"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Create a 2D array to store lengths of longest common subsequence\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the L[][] array from bottom up\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    \n    # The length of the longest common subsequence is in L[m][n]\n    return L[m][n]"}
{"id": "177_0", "code": "def prod_Square(n):\n    # Check if n is a perfect square\n    if int(n**0.5)**2 == n:\n        return True\n    \n    # Check if n can be expressed as a product of two squares\n    for i in range(1, int(n**0.5) + 1):\n        if int(n**0.5) % i == 0:\n            j = n // i\n            if int(j**0.5)**2 == j:\n                return True\n    \n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr, n):\n    # Step 1: Place each number in its correct position if possible\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:\n            # Swap arr[i] with arr[arr[i] - 1]\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    \n    # Step 2: Find the first index where the number is not in its correct position\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    \n    # Step 3: If all numbers are in their correct positions, the missing number is n + 1\n    return n + 1"}
{"id": "179_0", "code": "def count_Intgral_Points(x1, y1, x2, y2):\n    # Calculate the number of integral points inside the square\n    # The number of integral points is (x2 - x1 + 1) * (y2 - y1 + 1)\n    # This is because each row and each column can have integral points\n    # from x1 to x2 and y1 to y2 respectively\n    return (x2 - x1 + 1) * (y2 - y1 + 1)"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    # Define a list of months with 30 days\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    # Check if the given month name is in the list of months with 30 days\n    if monthname3 in months_with_30_days:\n        return True\n    else:\n        return False"}
{"id": "181_0", "code": "def check_String(str):\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        if has_letter and has_number:\n            return True\n    return False"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    # Convert the tuple to a set to remove duplicates\n    res = tuple(set(test_tup))\n    return res"}
{"id": "183_0", "code": "def octal_To_Decimal(n):\n    decimal = 0\n    base = 1\n    while n:\n        last_digit = n % 10\n        decimal += last_digit * base\n        n //= 10\n        base *= 8\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    low = 0\n    high = n - 1\n    result = -1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if arr[mid] == x:\n            result = mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    # Use list comprehension to filter out tuples with length K\n    res = [ele for ele in test_list if len(ele) != K]\n    return res"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    # Initialize the result as 1\n    res = 1\n    \n    # Iterate through each element in the tuples\n    for i, j in zip(test_tup1, test_tup2):\n        # Multiply the result by the corresponding elements\n        res *= i ** j\n    \n    return res"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a, b):\n    # The largest triangle inscribed in an ellipse is an isosceles right triangle\n    # with its hypotenuse as the major axis of the ellipse.\n    # The legs of the triangle are equal to the semi-major axis of the ellipse.\n    # The area of the triangle is (1/2) * base * height.\n    # The base and height of the triangle are both equal to the semi-major axis of the ellipse.\n    # Therefore, the area of the triangle is (1/2) * a * a.\n    return (1/2) * a * a"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    power = 0\n    while (2 ** power) <= n:\n        power += 1\n    return 2 ** (power - 1)"}
{"id": "189_0", "code": "def position_max(list1):\n    max_value = max(list1)\n    positions = [index for index, value in enumerate(list1) if value == max_value]\n    return positions"}
{"id": "190_0", "code": "def chkList(lst):\n    if len(lst) == 0:\n        return True\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True"}
{"id": "191_0", "code": "def remove_even(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over each character in the string\n    for i in range(len(str1)):\n        # Check if the index is odd (i.e., not even)\n        if i % 2 != 0:\n            # Append the character to the result string\n            result += str1[i]\n    # Return the result string\n    return result"}
{"id": "192_0", "code": "def hamming_Distance(n1, n2):\n    # Calculate the XOR of the two numbers\n    xor_result = n1 ^ n2\n    \n    # Initialize a counter for the number of set bits\n    count = 0\n    \n    # Iterate through each bit of the XOR result\n    while xor_result > 0:\n        # Increment the counter if the least significant bit is set\n        count += xor_result & 1\n        # Right shift the XOR result to check the next bit\n        xor_result >>= 1\n    \n    return count"}
{"id": "193_0", "code": "def count(s, c):\n    count = 0\n    for char in s:\n        if char == c:\n            count += 1\n    return count"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    res = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i] > test_tup[j]:\n                res.append((test_tup[i], test_tup[j]))\n    return res"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup, test_tup[1:]))\n    return res"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest common subsequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Build the dp array from bottom up\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if str[i - 1] == str[j - 1] and i != j:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest repeating subsequence\n    return dp[n][n]"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    # Define the regex pattern for a decimal number with precision of 2\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    \n    # Use re.match to check if the number matches the pattern\n    if re.match(pattern, num):\n        return True\n    else:\n        return False"}
{"id": "198_0", "code": "def heap_replace(heap, a):\n    import heapq\n    # Remove the smallest element from the heap\n    heapq.heapreplace(heap, a)"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    # Define the regex pattern to match only lowercase letters, uppercase letters, and digits\n    pattern = r'^[a-zA-Z0-9]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"}
{"id": "200_0", "code": "def count_Num(n):\n    count = 0\n    for i in range(1, n+1):\n        if (i & (1 << (i-1))) and (i & (1 << (n-i))):\n            count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 4\n    return total"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    # Initialize an empty list to store the concatenated strings\n    res = []\n    \n    # Iterate over each tuple in the input tuples\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Concatenate the strings from each tuple and append to the result list\n        res.append(tup1 + tup2)\n    \n    # Convert the list of concatenated strings to a tuple and return\n    return tuple(res)"}
{"id": "203_0", "code": "def degree_radian(radian):\n    import math\n    return radian * (180 / math.pi)"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    # Check if list1 is empty, then it is a subset of any list\n    if not list1:\n        return True\n    \n    # Check if list2 is empty, then it cannot be a subset of any non-empty list\n    if not list2:\n        return False\n    \n    # Check if list1 is a subset of list2\n    for sublist in list1:\n        if sublist not in list2:\n            return False\n    \n    return True"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        char_count[char] = 1\n    return None"}
{"id": "207_0", "code": "def min_Operations(A, B):\n    # Initialize the count of operations\n    operations = 0\n    \n    # If A is greater than B, swap them\n    if A > B:\n        A, B = B, A\n    \n    # While A is less than B, perform the following operations:\n    while A < B:\n        # If B is even, divide B by 2\n        if B % 2 == 0:\n            B //= 2\n        else:\n            # If B is odd, add 1 to B\n            B += 1\n        # Increment the operation count\n        operations += 1\n    \n    # Return the total number of operations\n    return operations"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    # Sort the tuple in ascending order\n    sorted_tup = sorted(test_tup)\n    \n    # Extract the first K elements (minimums)\n    min_elements = sorted_tup[:K]\n    \n    # Extract the last K elements (maximums)\n    max_elements = sorted_tup[-K:]\n    \n    # Return the minimum and maximum elements as a tuple\n    return min_elements, max_elements"}
{"id": "209_0", "code": "def replace_max_specialchar(text, n):\n    # Define the special characters to replace\n    special_chars = [' ', ',', '.']\n    \n    # Create a regular expression pattern to match the special characters\n    pattern = '|'.join(re.escape(char) for char in special_chars)\n    \n    # Use re.sub to replace the maximum n occurrences of the pattern with a colon\n    result = re.sub(pattern, ':', text, count=n)\n    \n    return result"}
{"id": "210_0", "code": "def first_even(nums):\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    # Check if all elements in the tuple have the same data type\n    return all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple)"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                break\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    if low > n - 1 or arr[low] != x:\n        return False\n\n    # Find the last occurrence of x\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == n - 1 or arr[mid + 1] != x:\n                break\n            low = mid + 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    if high < 0 or arr[high] != x:\n        return False\n\n    # Check if the count of x is greater than n/2\n    return (high - low + 1) > n // 2"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    # Base case: if there is only one element\n    if low == high:\n        return arr[low]\n    \n    # If there are more than one elements, then find the middle point\n    mid = (low + high) // 2\n    \n    # Check if mid element is greater than the last element\n    if arr[mid] > arr[high]:\n        # If mid element is greater than the last element, then the minimum element is in the right half\n        return find_Min(arr, mid + 1, high)\n    \n    # If mid element is less than the last element, then the minimum element is in the left half\n    return find_Min(arr, low, mid)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str):\n        # Check if the index is even (0-based index)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    # Return the result string\n    return result"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    # Create a mask with bits set in the range [l, r]\n    mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if the mask is set in n\n    return (n & mask) == mask"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    # Initialize two pointers\n    left = 0\n    right = n - 1\n    \n    # Traverse the array\n    while left < right:\n        # Move the left pointer until a positive element is found\n        while left < right and arr[left] < 0:\n            left += 1\n        # Move the right pointer until a negative element is found\n        while left < right and arr[right] >= 0:\n            right -= 1\n        # Swap the elements at the left and right pointers\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return arr"}
{"id": "219_0", "code": "def replace_blank(str1,char):\n    return str1.replace(\" \",char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    # Initialize the last row of the triangle with the values from the last row of the input triangle\n    last_row = tri[n-1]\n    \n    # Iterate from the second last row to the first row\n    for i in range(n-2, -1, -1):\n        # For each element in the current row, update it to be the maximum of itself and the sum of itself and the element directly below it\n        for j in range(i+1):\n            last_row[j] = max(last_row[j], last_row[j] + tri[i][j])\n    \n    # The maximum sum will be the first element in the last row\n    return last_row[0]"}
{"id": "221_0", "code": "def larg_nnum(list1,n):\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n    # Return the first n elements from the sorted list\n    return sorted_list[:n]"}
{"id": "222_0", "code": "def lateralsuface_cylinder(r,h):\n    pi = 3.14159\n    return 2 * pi * r * h"}
{"id": "223_0", "code": "def volume_cube(l):\n    return l**3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over the bits of the number\n    for i in range(32):\n        # Check if the current bit is even\n        if i % 2 == 0:\n            # Set the current bit in the result\n            result |= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Calculate the number of equilateral triangles of side length K that can fit within an equilateral triangle of side length N\n    # The number of such triangles is given by the formula: (N-K+1) * (N-K+2) / 2\n    return (N-K+1) * (N-K+2) // 2"}
{"id": "226_0", "code": "def check_occurences(test_list):\n    # Initialize an empty dictionary to store the count of occurrences\n    count_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Extract the time component from the tuple\n        time = tup[0]\n        \n        # If the time is already in the dictionary, increment its count\n        if time in count_dict:\n            count_dict[time] += 1\n        # If the time is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[time] = 1\n    \n    # Initialize a list to store the tuples with similar times\n    similar_times = []\n    \n    # Iterate over the dictionary to find tuples with similar times\n    for time, count in count_dict.items():\n        # If the count is greater than 1, it means there are similar times\n        if count > 1:\n            # Append the tuples with the same time to the list\n            similar_times.extend([tup for tup in test_list if tup[0] == time])\n    \n    # Return the list of tuples with similar times\n    return similar_times"}
{"id": "227_0", "code": "def number_of_substrings(str):\n    n = len(str)\n    return n * (n + 1) // 2"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m,n):\n    # Initialize a list to store the number of sequences ending at each number\n    dp = [0] * (m + 1)\n    dp[0] = 1  # There is one way to form a sequence of length 0 with no elements\n\n    # Iterate over each possible ending number in the sequence\n    for i in range(1, m + 1):\n        # Iterate over each possible previous number in the sequence\n        for j in range(1, i // 2 + 1):\n            # Update the number of sequences ending at number i\n            dp[i] += dp[j]\n\n    # The result is the number of sequences of length n ending at any number from 1 to m\n    return dp[n]"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1"}
{"id": "230_0", "code": "def array_3d(m, n, o):\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"id": "231_0", "code": "def count_charac(str1):\n    return len(str1)"}
{"id": "232_0", "code": "def sort_on_occurence(lst):\n    # Create a dictionary to count occurrences of the first element of each tuple\n    count_dict = {}\n    for item in lst:\n        if item[0] in count_dict:\n            count_dict[item[0]] += 1\n        else:\n            count_dict[item[0]] = 1\n    \n    # Sort the list based on the count of the first element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: count_dict[x[0]])\n    \n    return sorted_lst"}
{"id": "233_0", "code": "def next_Perfect_Square(N):\n    # Calculate the integer square root of N\n    root = int(N**0.5)\n    # Check if the square of the root is equal to N\n    if root * root == N:\n        # If it is, increment the root by 1 to get the next perfect square\n        return (root + 1) ** 2\n    else:\n        # If it is not, return the square of the next integer\n        return (root + 1) ** 2"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    # Initialize two arrays to store the maximum sum of increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Fill the inc array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill the dec array\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i + 1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of bi-tonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_sum"}
{"id": "235_0", "code": "def babylonian_squareroot(number):\n    if number < 0:\n        raise ValueError(\"Cannot compute square root of a negative number\")\n    if number == 0:\n        return 0\n    guess = number / 2.0\n    while True:\n        new_guess = (guess + number / guess) / 2.0\n        if abs(new_guess - guess) < 1e-10:\n            return new_guess\n        guess = new_guess"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    # Create a 2D array to store lengths of longest palindromic subsequence\n    dp = [[0 for x in range(n)] for y in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. Note that the lower diagonal values of table are\n    # useless and not filled in the process.\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i + cl - 1\n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    # The length of the longest palindromic subsequence is in the top right corner of the table\n    return dp[0][n-1]"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    if n <= 1:\n        return 0\n    else:\n        return 1/n + harmonic_sum(n-1)"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    # Use a lambda function to find the intersection\n    intersection = list(filter(lambda x: x in array_nums2, array_nums1))\n    return intersection"}
{"id": "239_0", "code": "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count"}
{"id": "240_0", "code": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"id": "241_0", "code": "import cmath\n\ndef convert(numbers):\n    polar_coordinates = []\n    for number in numbers:\n        polar_coordinates.append(cmath.polar(number))\n    return polar_coordinates"}
{"id": "242_0", "code": "def count_integer(list1):\n    count = 0\n    for item in list1:\n        if isinstance(item, int):\n            count += 1\n    return count"}
{"id": "243_0", "code": "import re\n\ndef words_ae(text):\n    # Use regular expression to find all words starting with 'a' or 'e'\n    words = re.findall(r'\\b[ae]\\w+', text)\n    return words"}
{"id": "244_0", "code": "def combinations_colors(l, n):\n    from itertools import product\n    return list(product(l, repeat=n))"}
{"id": "245_0", "code": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    return sum(primes)"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    # Create a temporary variable to hold the value of a\n    temp = a\n    # Assign the value of b to a\n    a = b\n    # Assign the value stored in temp (original value of a) to b\n    b = temp\n    # Return the swapped values\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    odd_count = len(list(filter(lambda x: x % 2 != 0, array_nums)))\n    return odd_count"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Initialize a list to store the maximum elements\n    max_elements = []\n    \n    # Iterate through the elements of both tuples\n    for i in range(len(test_tup1)):\n        # Compare the elements and append the maximum to the list\n        max_elements.append(max(test_tup1[i], test_tup2[i]))\n    \n    # Return the list of maximum elements\n    return max_elements"}
{"id": "249_0", "code": "def newman_prime(n):\n    def is_newman_prime(p):\n        if p < 2:\n            return False\n        if p == 2:\n            return True\n        if p % 2 == 0:\n            return False\n        for i in range(3, int(p**0.5) + 1, 2):\n            if p % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_newman_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Perform division and append the result to the list\n        res.append(test_tup1[i] / test_tup2[i])\n    \n    # Return the list of results\n    return res"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    # Check if L is within the valid range\n    if L < 0 or L > len(list1):\n        raise ValueError(\"L must be between 0 and the length of the list.\")\n    \n    # Split the list into two parts\n    part1 = list1[:L]\n    part2 = list1[L:]\n    \n    return part1, part2"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    merged_dict = d1.copy()  # Create a copy of the first dictionary\n    merged_dict.update(d2)  # Update the copy with the second dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    if h_age < 0:\n        return \"Invalid age\"\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4"}
{"id": "254_0", "code": "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i+step])\n    return result"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    return 4 * l ** 2"}
{"id": "256_0", "code": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i-1)**2\n    return sum"}
{"id": "257_0", "code": "def find_star_num(n):\n    # Calculate the n'th star number using the formula\n    star_num = 8 * n * (n - 1) + 1\n    return star_num"}
{"id": "258_0", "code": "def ascii_value(k):\n    return ord(k)"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr, n):\n    sum_even = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum_even += arr[i]\n    return sum_even"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    # Initialize an empty list to store the rear elements\n    rear_elements = []\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Extract the last element of the tuple and append it to the rear_elements list\n        rear_elements.append(tup[-1])\n    \n    # Return the list of rear elements\n    return rear_elements"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append to the result list\n        res.append(test_tup1[i] - test_tup2[i])\n    \n    # Convert the list to a tuple and return\n    return tuple(res)"}
{"id": "263_0", "code": "def even_binomial_Coeff_Sum(n):\n    # Initialize the sum of even index binomial coefficients\n    sum_even = 0\n    \n    # Iterate over the range of binomial coefficients\n    for k in range(n + 1):\n        # Calculate the binomial coefficient using the formula\n        binomial_coeff = math.comb(n, k)\n        \n        # Check if the index is even\n        if k % 2 == 0:\n            # Add the binomial coefficient to the sum\n            sum_even += binomial_coeff\n    \n    # Return the sum of even index binomial coefficients\n    return sum_even"}
{"id": "264_0", "code": "def get_Position(a, n, m):\n    # Initialize the position of the last removed element to -1\n    last_removed_position = -1\n    \n    # Iterate through the array to find the last removed element\n    for i in range(n):\n        # Check if the current element is equal to m\n        if a[i] == m:\n            # Update the position of the last removed element\n            last_removed_position = i\n    \n    # Return the position of the last removed element\n    return last_removed_position"}
{"id": "265_0", "code": "def volume_cylinder(r, h):\n    pi = 3.14159\n    volume = pi * r**2 * h\n    return volume"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    # Create a new dictionary to store the filtered items\n    filtered_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n    \n    # Return the filtered dictionary\n    return filtered_dict"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    # Initialize the count to 0\n    count = 0\n    \n    # Iterate through the tuple\n    for i in range(len(test_tup)):\n        # Check if the current element is the first element\n        if i == 0:\n            # Increment the count\n            count += 1\n        else:\n            # Break the loop as we only need the count of the first element\n            break\n    \n    # Return the count\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return False\n    \n    # Calculate the nth decagonal number using the formula\n    decagonal_number = (5 * n * n - 5 * n + 2) // 2\n    \n    # Check if the calculated number is equal to the input n\n    return decagonal_number == n"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    # Check if the length of the list is equal to the length of the set created from the list\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x, y: x - y, nums1, nums2))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number to a string to iterate over each digit\n    digits = str(n)\n    \n    # Create a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Iterate over each digit in the string\n    for digit in digits:\n        # If the digit is already in the dictionary, increment its count\n        if digit in digit_count:\n            digit_count[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            digit_count[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        # Convert the digit and count to integers\n        digit = int(digit)\n        count = int(count)\n        \n        # If the frequency is greater than the digit, return False\n        if count > digit:\n            return False\n    \n    # If all frequencies are less than or equal to the digit, return True\n    return True"}
{"id": "273_0", "code": "def check_element(list, element):\n    # Check if all elements in the list are equal to the given element\n    return all(item == element for item in list)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    # Use regular expression to find the pattern\n    pattern = r'ab{2,3}'\n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return \"Match found!\"\n    else:\n        return \"No match found.\""}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    # Calculate the maximum subarray sum for the original array\n    def max_sub_array_sum(arr, n):\n        max_so_far = arr[0]\n        max_ending_here = arr[0]\n        for i in range(1, n):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the maximum subarray sum for the repeated array\n    total_sum = sum(a) * k\n    max_sum = max_sub_array_sum(a, n)\n    max_sum_repeated = max_sum * k\n\n    # If the total sum is negative, the maximum sum of the repeated array is the maximum subarray sum\n    if total_sum < 0:\n        return max_sum_repeated\n\n    # Otherwise, the maximum sum of the repeated array is the maximum subarray sum plus the sum of the remaining elements\n    remaining_sum = total_sum - max_sum\n    max_sum_repeated += remaining_sum\n\n    return max_sum_repeated"}
{"id": "276_0", "code": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**2\n    return sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    count = 0\n    for i in range(N):\n        if arr[i] % P == 0:\n            count += 1\n    return count"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Calculate the number of odd days in a given year\n    # A year is considered to have 365 days in a non-leap year and 366 days in a leap year\n    # An odd day is a day that falls on an odd day of the week\n    # The number of odd days in a year can be calculated using the formula:\n    # (N - 1) % 7 + 1\n    # where N is the number of days in the year\n    # If N is a leap year, then the number of odd days is (N - 1) % 7 + 1 + 1\n    # If N is not a leap year, then the number of odd days is (N - 1) % 7 + 1\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1) % 7 + 1 gives the number of odd days in a year\n    # The formula (N - 1) % 7 + 1 + 1 gives the number of odd days in a leap year\n    # The formula (N - 1)"}
{"id": "279_0", "code": "def max_length(list1):\n    max_length = 0\n    max_lists = []\n    for sublist in list1:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_lists = [sublist]\n        elif len(sublist) == max_length:\n            max_lists.append(sublist)\n    return max_lists"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    same = k  # Number of ways to paint the first two posts with the same color\n    diff = k * (k - 1)  # Number of ways to paint the first two posts with different colors\n    \n    for i in range(3, n + 1):\n        new_same = diff  # New ways to paint the current post with the same color as the previous post\n        new_diff = same * (k - 1) + diff * (k - 1)  # New ways to paint the current post with a different color from the previous post\n        same, diff = new_same, new_diff\n    \n    return same + diff"}
{"id": "281_0", "code": "def find(n,m):\n    if m == 0:\n        return \"Error: Division by zero is not allowed.\"\n    return n // m"}
{"id": "282_0", "code": "def otherside_rightangle(w, h):\n    # Calculate the third side using the Pythagorean theorem\n    c = (w**2 + h**2)**0.5\n    return c"}
{"id": "283_0", "code": "def max_val(listval):\n    # Initialize max_val with the first element of the list\n    max_val = listval[0]\n    \n    # Iterate through the list starting from the second element\n    for val in listval[1:]:\n        # Update max_val if the current value is greater\n        if val > max_val:\n            max_val = val\n    \n    # Return the maximum value found\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    if number <= 0:\n        return 0\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.append(i)\n            if i != number // i:\n                divisors.append(number // i)\n    return sum(divisors)"}
{"id": "285_0", "code": "def get_Inv_Count(arr,n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    # Initialize an empty list to store the intersection elements\n    intersection = []\n    \n    # Iterate over each element in the first list\n    for element in l1:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # Recursively find the intersection of the nested list with the second list\n            nested_intersection = intersection_nested_lists(element, l2)\n            # If there are any intersection elements, add them to the main intersection list\n            if nested_intersection:\n                intersection.extend(nested_intersection)\n        else:\n            # If the element is not a list, check if it is present in the second list\n            if element in l2:\n                # If it is present, add it to the main intersection list\n                intersection.append(element)\n    \n    # Return the list of intersection elements\n    return intersection"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    # Initialize the maximum aggregate to a very low number\n    max_aggregate = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for student in stdata:\n        # Calculate the aggregate of the current student\n        aggregate = sum(student)\n        \n        # Update the maximum aggregate if the current aggregate is greater\n        if aggregate > max_aggregate:\n            max_aggregate = aggregate\n    \n    # Return the maximum aggregate found\n    return max_aggregate"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    # Initialize the count of valid sequences\n    count = 0\n    \n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the number to a binary string and pad with zeros to length 2n\n        binary_str = format(i, '0' + str(2*n) + 'b')\n        \n        # Calculate the sum of the first n bits and the last n bits\n        sum_first_n = sum(int(bit) for bit in binary_str[:n])\n        sum_last_n = sum(int(bit) for bit in binary_str[n:])\n        \n        # If the sums are equal, increment the count\n        if sum_first_n == sum_last_n:\n            count += 1\n    \n    # Return the total count of valid sequences\n    return count"}
{"id": "290_0", "code": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    # Initialize the result to 0\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(32):\n        # Check if the i-th bit is set in n\n        if (n & (1 << i)) != 0:\n            # Set the i-th bit in result\n            result |= (1 << i)\n    \n    return result"}
{"id": "292_0", "code": "def solve(a,n):\n    # Initialize counters for type 1 and type 2 inversions\n    count_type1 = 0\n    count_type2 = 0\n    \n    # Iterate through the array to count inversions\n    for i in range(n):\n        for j in range(i+1, n):\n            # Check if the current pair forms a type 1 inversion\n            if a[i] > a[j]:\n                count_type1 += 1\n            # Check if the current pair forms a type 2 inversion\n            elif a[i] < a[j]:\n                count_type2 += 1\n    \n    # Compare the counts of type 1 and type 2 inversions\n    if count_type1 == count_type2:\n        return True\n    else:\n        return False"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    # Calculate the effective rotation\n    effective_rotation = rotations % len(arr)\n    \n    # Adjust the index based on the effective rotation\n    adjusted_index = (index + effective_rotation) % len(arr)\n    \n    # Return the element at the adjusted index\n    return arr[adjusted_index]"}
{"id": "294_0", "code": "def start_withp(words):\n    # Filter words that start with 'p'\n    filtered_words = [word for word in words if word.startswith('p')]\n    \n    # Check if there are at least two words starting with 'p'\n    if len(filtered_words) < 2:\n        return \"Not enough words starting with 'p'\"\n    \n    # Return the first two words starting with 'p'\n    return filtered_words[:2]"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate through the array from index to k\n    for i in range(index, k + 1):\n        # Calculate the sum of the subsequence ending at index i\n        current_sum = a[i]\n        \n        # Check if there is a previous element that can be included in the subsequence\n        for j in range(index, i):\n            if a[j] < a[i]:\n                current_sum += max_sum_increasing_subseq(a, n, j, i)\n        \n        # Update the maximum sum if the current sum is greater\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\n    # Check if the tuple has at least m elements\n    if len(tuplex) < m:\n        return \"Tuple does not have enough elements\"\n    \n    # Check if the tuple has at least n elements\n    if len(tuplex) < n:\n        return \"Tuple does not have enough elements\"\n    \n    # Get the colon of the tuple\n    colon = tuplex[m-1:n]\n    \n    return colon"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    # Sort nums1 and nums2 in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Initialize a list to store the largest products\n    largest_products = []\n    \n    # Iterate through the sorted lists to find the largest products\n    for i in range(N):\n        # Calculate the product of the current elements from nums1 and nums2\n        product = nums1[i] * nums2[i]\n        # Append the product to the list of largest products\n        largest_products.append(product)\n    \n    # Return the list of largest products\n    return largest_products"}
{"id": "298_0", "code": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    # Split the string by spaces to get individual elements\n    elements = str1.split()\n    # Convert each element to an integer and store in a list\n    numbers = [int(element) for element in elements]\n    # Convert the list to a tuple\n    result = tuple(numbers)\n    return result"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    unset_bit_position = n & -n\n    # Set the leftmost unset bit\n    return n | unset_bit_position"}
{"id": "301_0", "code": "def volume_cone(r, h):\n    pi = 3.14159\n    volume = (1/3) * pi * r**2 * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for num in list1:\n        if num > 0:\n            print(num)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    # Initialize the maximum sum for the first two columns\n    max_sum = max(grid[0][0], grid[1][0])\n    \n    # Iterate through the grid starting from the third column\n    for i in range(1, n):\n        # Calculate the maximum sum for the current column\n        max_sum = max(grid[0][i] + max_sum, grid[1][i] + max_sum)\n    \n    return max_sum"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    # Split the string into words\n    words = str.split()\n    \n    # Initialize variables to store the maximum length and the corresponding word\n    max_len = 0\n    max_word = \"\"\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the word length is even\n        if len(word) % 2 == 0:\n            # Update the maximum length and word if the current word is longer\n            if len(word) > max_len:\n                max_len = len(word)\n                max_word = word\n    \n    # Return the first maximum length of even word\n    return max_word"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    left, right = 0, len(A) - 1\n    last_occurrence = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if A[mid] == x:\n            last_occurrence = mid\n            left = mid + 1  # Move to the right to find the last occurrence\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return last_occurrence"}
{"id": "306_0", "code": "def modified_encode(alist):\n    result = []\n    count = 1\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            result.append((alist[i - 1], count))\n            count = 1\n    result.append((alist[-1], count))\n    return result"}
{"id": "307_0", "code": "def max_volume(s):\n    # Initialize the maximum volume to a very small number\n    max_vol = float('-inf')\n    \n    # Iterate over all possible values for the length of the cuboid\n    for length in range(1, s // 3 + 1):\n        # Iterate over all possible values for the width of the cuboid\n        for width in range(1, (s - length) // 2 + 1):\n            # Calculate the height of the cuboid\n            height = s - length - width\n            \n            # Calculate the volume of the cuboid\n            volume = length * width * height\n            \n            # Update the maximum volume if the current volume is greater\n            if volume > max_vol:\n                max_vol = volume\n    \n    return max_vol"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    # Use regex to find all five-character long words\n    pattern = r'\\b\\w{5}\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    sum_n_squared = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the difference between the squared sum and the sum of squares\n    difference = sum_n_squared - sum_n**2\n    \n    return difference"}
{"id": "310_0", "code": "def find_demlo(s):\n    # Initialize an empty list to store the demlo number\n    demlo = []\n    \n    # Iterate over the string s\n    for i in range(len(s)):\n        # Append the current character to the demlo list\n        demlo.append(s[i])\n        # Append the remaining characters in reverse order to the demlo list\n        demlo.extend(s[i+1:][::-1])\n    \n    # Join the list into a string and return it\n    return ''.join(demlo)"}
{"id": "311_0", "code": "def position_min(list1):\n    min_value = min(list1)\n    positions = [index for index, value in enumerate(list1) if value == min_value]\n    return positions"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    # Initialize two pointers, one for positive and one for negative\n    pos = 0\n    neg = 0\n    \n    # Traverse the array\n    while pos < n and neg < n:\n        # Move the positive pointer to the next positive number\n        while pos < n and arr[pos] >= 0:\n            pos += 1\n        # Move the negative pointer to the next negative number\n        while neg < n and arr[neg] < 0:\n            neg += 1\n        \n        # If both pointers are within bounds, swap the elements\n        if pos < n and neg < n:\n            arr[pos], arr[neg] = arr[neg], arr[pos]\n            pos += 1\n            neg += 1\n    \n    return arr"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    # Initialize the sum\n    res = 0\n    \n    # Iterate over the tuple\n    for i in range(0, len(test_tuple), 2):\n        # Add the current element to the sum\n        res += test_tuple[i]\n    \n    return res"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    # Initialize a list to store the minimum number of squares for each number up to n\n    dp = [float('inf')] * (n + 1)\n    \n    # Base case: 0 can be represented by 0 squares\n    dp[0] = 0\n    \n    # Iterate through each number from 1 to n\n    for i in range(1, n + 1):\n        # Check all possible square numbers less than or equal to i\n        for j in range(1, int(i**0.5) + 1):\n            # Update the dp array with the minimum number of squares\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n    \n    # Return the minimum number of squares for n\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    # Initialize a dictionary to store the count of each word\n    word_count = {}\n    \n    # Iterate over each string in the list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # If the word is already in the dictionary, increment its count\n            if word in word_count:\n                word_count[word] += 1\n            # If the word is not in the dictionary, add it with a count of 1\n            else:\n                word_count[word] = 1\n    \n    # Find the word with the maximum count\n    max_word = max(word_count, key=word_count.get)\n    \n    # Return the word with the maximum count\n    return max_word"}
{"id": "316_0", "code": "def check_isosceles(x, y, z):\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"id": "317_0", "code": "def rotate_left(list1, m, n):\n    # Calculate the effective rotation needed\n    effective_rotation = (m + n) % len(list1)\n    \n    # Perform the rotation\n    rotated_list = list1[effective_rotation:] + list1[:effective_rotation]\n    \n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(list):\n    count = 0\n    for num in list:\n        if num < 0:\n            count += 1\n    return count"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Find all three, four, and five-character words using regex\n    words = re.findall(r'\\b\\w{3,5}\\b', text)\n    return words"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "321_0", "code": "def char_frequency(str1):\n    # Initialize an empty dictionary to store character frequencies\n    frequency = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in frequency:\n            frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            frequency[char] = 1\n    \n    # Return the dictionary containing character frequencies\n    return frequency"}
{"id": "322_0", "code": "def Sort(sub_li):\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li"}
{"id": "323_0", "code": "def check_Validity(a, b, c):\n    # Check if the sum of any two sides is greater than the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False"}
{"id": "324_0", "code": "def ap_sum(a,n,d):\n    # Calculate the sum of the arithmetic progression\n    return (n/2) * (2*a + (n-1)*d)"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    # Define a list of months with 28 days\n    months_with_28_days = [\"February\"]\n    \n    # Check if the given month name is in the list\n    if monthname1 in months_with_28_days:\n        return True\n    else:\n        return False"}
{"id": "326_0", "code": "def text_match_word(text):\n    import re\n    pattern = r'\\b\\w+\\b\\W*$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    # Initialize a dictionary to store the frequency of each divisor\n    divisor_count = {}\n    \n    # Iterate through all numbers from x to y\n    for num in range(x, y + 1):\n        # Find all divisors of the current number\n        for i in range(1, num + 1):\n            if num % i == 0:\n                # Increment the count of the divisor in the dictionary\n                if i in divisor_count:\n                    divisor_count[i] += 1\n                else:\n                    divisor_count[i] = 1\n    \n    # Find the divisor with the maximum count\n    max_divisor = None\n    max_count = 0\n    for divisor, count in divisor_count.items():\n        if count > max_count:\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    # Filter out non-positive numbers\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Sort the positive numbers\n    positive_nums.sort()\n    \n    # Sum the first three numbers\n    return sum(positive_nums[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    # Convert the set to a list\n    lst = list(s)\n    # Sort the list\n    lst.sort()\n    # Convert the sorted list to a tuple\n    t = tuple(lst)\n    return t"}
{"id": "331_0", "code": "def find_minimum_range(lists):\n    # Initialize variables to store the minimum range and the corresponding range\n    min_range = float('inf')\n    min_range_start = 0\n    min_range_end = 0\n    \n    # Get the number of lists and the maximum length of the lists\n    num_lists = len(lists)\n    max_length = max(len(lst) for lst in lists)\n    \n    # Iterate over all possible starting points of the range\n    for start in range(max_length):\n        # Initialize variables to store the current range and the corresponding range\n        current_range = float('inf')\n        current_range_start = start\n        current_range_end = start\n        \n        # Iterate over all possible ending points of the range\n        for end in range(start, max_length):\n            # Check if the current range includes at least one element from each list\n            if all(start <= i <= end for lst in lists for i in lst):\n                # Update the minimum range if the current range is smaller\n                if end - start < min_range:\n                    min_range = end - start\n                    min_range_start = current_range_start\n                    min_range_end = current_range_end\n                # Update the current range\n                current_range = end - start\n                current_range_start = start\n                current_range_end = end\n    \n    # Return the minimum range and the corresponding range\n    return min_range, (min_range_start, min_range_end)"}
{"id": "332_0", "code": "def dig_let(s):\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n, m):\n    count = 0\n    for i in range(n, m + 1):\n        if i % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    # Check if the list has at least two elements\n    if len(nums) < 2:\n        return \"The list must contain at least two elements.\"\n    \n    # Calculate the difference between consecutive numbers\n    differences = [nums[i] - nums[i-1] for i in range(1, len(nums))]\n    \n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    if k == 0 or k == n:\n        return 1\n    return zigzag(n-1, k-1) + zigzag(n-1, k)"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    # Calculate the number of squares of each size\n    total_squares = 0\n    for size in range(1, min(m, n) + 1):\n        # Number of squares of size 'size' in a rectangle of size 'm' x 'n'\n        num_squares_of_size = (m - size + 1) * (n - size + 1)\n        total_squares += num_squares_of_size\n    return total_squares"}
{"id": "337_0", "code": "def find_ways(M):\n    # Initialize a list to store the number of ways for each prefix sum\n    ways = [0] * (M + 1)\n    # There is one way to have a prefix sum of 0 (doing nothing)\n    ways[0] = 1\n    # Iterate over each possible value in M\n    for value in M:\n        # Update the ways list for each prefix sum\n        for i in range(M, value - 1, -1):\n            ways[i] += ways[i - value]\n    # Return the number of ways to have a prefix sum of M\n    return ways[M]"}
{"id": "338_0", "code": "def check(string):\n    # Check if the string contains only '0' and '1'\n    if all(char in '01' for char in string):\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    # Initialize the minimum length to the length of the string\n    min_length = len(s)\n    \n    # Iterate over each character in the string\n    for char in set(s):\n        # Remove all occurrences of the current character\n        new_s = s.replace(char, '')\n        \n        # Update the minimum length if the new string is shorter\n        if len(new_s) < min_length:\n            min_length = len(new_s)\n    \n    return min_length"}
{"id": "340_0", "code": "def first_Element(arr, n, k):\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through the array to count the frequency of each element\n    for i in range(n):\n        if arr[i] in frequency:\n            frequency[arr[i]] += 1\n        else:\n            frequency[arr[i]] = 1\n    \n    # Iterate through the array again to find the first element occurring k times\n    for i in range(n):\n        if frequency[arr[i]] == k:\n            return arr[i]\n    \n    # If no element occurs k times, return -1\n    return -1"}
{"id": "341_0", "code": "def unique_Characters(str):\n    # Create a set to store unique characters\n    char_set = set()\n    \n    # Iterate over each character in the string\n    for char in str:\n        # If the character is already in the set, return False\n        if char in char_set:\n            return False\n        # Add the character to the set\n        char_set.add(char)\n    \n    # If no duplicates were found, return True\n    return True"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    # Check if the list is empty or n is out of range\n    if not list1 or n < 0 or n >= len(list1[0]):\n        return list1\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over each row in the list\n    for row in list1:\n        # Create a new row by excluding the nth column\n        new_row = [row[i] for i in range(len(row)) if i != n]\n        # Append the new row to the result list\n        result.append(new_row)\n    \n    return result"}
{"id": "343_0", "code": "def tn_ap(a,n,d):\n    tn = a + (n-1)*d\n    return tn"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    # Calculate the area of the circle\n    area = math.pi * radius ** 2\n    \n    # The number of rectangles that can fit in the circle is approximately the area of the circle\n    # Since each rectangle has an area of 1 (assuming unit length sides), the number of rectangles is the area of the circle\n    num_rectangles = area\n    \n    return num_rectangles"}
{"id": "345_0", "code": "def find_angle(a, b):\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    c = 180 - (a + b)\n    return c"}
{"id": "346_0", "code": "def find_max(test_list):\n    # Initialize the maximum element with the first element of the tuple\n    max_element = test_list[0]\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Update max_element if the current tuple's element is greater\n        if tup > max_element:\n            max_element = tup\n    \n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    return list(map(lambda x, y: x % y, nums1, nums2))"}
{"id": "348_0", "code": "def Check_Solution(a,b,c):\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is non-negative\n    if discriminant < 0:\n        return False\n    \n    # Calculate the two roots using the quadratic formula\n    root1 = (-b + (discriminant**0.5)) / (2*a)\n    root2 = (-b - (discriminant**0.5)) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False"}
{"id": "349_0", "code": "def get_carol(n):\n    # Calculate the Carol number using the formula\n    carol_number = (2 ** n - 1) ** 2 - 2\n    return carol_number"}
{"id": "350_0", "code": "def remove_empty(list1):\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    # Initialize a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences of each number\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the number with the maximum occurrences\n    max_num = None\n    max_count = 0\n    for num, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_num = num\n    \n    return max_num"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    # Use list comprehension to add K to each element in the tuple\n    res = tuple(x + K for x in test_list)\n    return res"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(str):\n    # Initialize counters for both possible alternating sequences\n    count1 = 0  # For \"010101...\"\n    count2 = 0  # For \"101010...\"\n    \n    # Iterate through the string to count flips for both sequences\n    for i in range(len(str)):\n        if i % 2 == 0:\n            # For \"010101...\", the current character should be '0'\n            if str[i] != '0':\n                count1 += 1\n            # For \"101010...\", the current character should be '1'\n            if str[i] != '1':\n                count2 += 1\n        else:\n            # For \"010101...\", the current character should be '1'\n            if str[i] != '1':\n                count1 += 1\n            # For \"101010...\", the current character should be '0'\n            if str[i] != '0':\n                count2 += 1\n    \n    # Return the minimum of the two counts\n    return min(count1, count2)"}
{"id": "354_0", "code": "def count_Digit(n):\n    # Convert the number to a string to easily count the digits\n    n_str = str(n)\n    # Return the length of the string, which is the number of digits\n    return len(n_str)"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    if len(list_nums) < 2:\n        return None  # Not enough elements to form a pair\n\n    max_product = float('-inf')\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product"}
{"id": "356_0", "code": "def is_tree_balanced(root):\n    if not root:\n        return True\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    if abs(left_height - right_height) > 1:\n        return False\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\ndef get_height(node):\n    if not node:\n        return 0\n    return 1 + max(get_height(node.left), get_height(node.right))"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    # Repeat the tuple N times\n    result = test_tup * N\n    return result"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l, w, h):\n    # Calculate the lateral surface area of a cuboid\n    lateral_surface_area = 2 * h * (l + w)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    # Extract the float element from the tuple\n    float_element = price[1]\n    \n    # Sort the tuple based on the float element\n    sorted_price = sorted(price, key=lambda x: x[1])\n    \n    return sorted_price"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    if left_element > right_element:\n        return left_element\n    mid = (left_element + right_element) // 2\n    if A[mid] == mid:\n        return smallest_missing(A, mid + 1, right_element)\n    else:\n        return smallest_missing(A, left_element, mid - 1)"}
{"id": "361_0", "code": "def heap_assending(nums):\n    import heapq\n    # Convert the list into a heap\n    heapq.heapify(nums)\n    # Extract elements from the heap in sorted order\n    sorted_nums = [heapq.heappop(nums) for _ in range(len(nums))]\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(l, w, h):\n    return l * w * h"}
{"id": "363_0", "code": "def permute_string(str):\n    if len(str) == 0:\n        return ['']\n    else:\n        permutations = []\n        for i in range(len(str)):\n            char = str[i]\n            remaining_str = str[:i] + str[i+1:]\n            for perm in permute_string(remaining_str):\n                permutations.append(char + perm)\n        return permutations"}
{"id": "364_0", "code": "def round_num(n, m):\n    return round(n / m) * m"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for ele in test_tup:\n        if ele in count_dict:\n            count_dict[ele] += 1\n        else:\n            count_dict[ele] = 1\n    \n    # Create a new list to store the result\n    result = []\n    for ele in test_tup:\n        if count_dict[ele] == 1:\n            result.append(ele)\n        else:\n            result.append('custom_value')  # Replace duplicates with 'custom_value'\n    \n    return tuple(result)"}
{"id": "366_0", "code": "def remove_Char(s,c):\n    return s.replace(c, \"\")"}
{"id": "367_0", "code": "def move_first(test_list):\n    # Check if the list is empty\n    if not test_list:\n        return []\n    \n    # Get the last element of the list\n    last_element = test_list[-1]\n    \n    # Remove the last element from the list\n    test_list.pop()\n    \n    # Insert the last element at the beginning of the list\n    test_list.insert(0, last_element)\n    \n    return test_list"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    # Calculate the surface area of a cuboid\n    surface_area = 2 * (l * w + w * h + h * l)\n    return surface_area"}
{"id": "369_0", "code": "def multi_list(rownum,colnum):\n    return [[0 for x in range(colnum)] for y in range(rownum)]"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    # Sort the list of lists based on the specified index\n    sorted_list = sorted(list_data, key=lambda x: x[index_no])\n    return sorted_list"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    left, right = 0, len(A) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if A[mid] > A[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    # Initialize a variable to store the result\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(32):\n        # Check if the current bit position is even\n        if i % 2 == 0:\n            # Toggle the bit at the current position\n            result ^= (1 << i)\n    \n    # Return the result\n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n, arr):\n    if n == 0:\n        return 0\n    smallest = arr[0]\n    count = 1\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            count = 1\n        elif arr[i] == smallest:\n            count += 1\n    return count"}
{"id": "374_0", "code": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)"}
{"id": "375_0", "code": "def swap_count(s):\n    stack = []\n    swaps = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps"}
{"id": "376_0", "code": "def even_or_odd(N):\n    # Convert the hexadecimal number to an integer\n    num = int(N, 16)\n    \n    # Check if the number is even or odd\n    if num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    power = 0\n    while (2 ** power) <= n:\n        power += 1\n    return 2 ** (power - 1)"}
{"id": "378_0", "code": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"id": "379_0", "code": "def add_string(list, string):\n    result = []\n    for item in list:\n        result.append(string + item)\n    return result"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    # Check if all lists have the same length\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Create a nested dictionary\n    nested_dict = {}\n    for i in range(len(l1)):\n        nested_dict[l1[i]] = {l2[i]: l3[i]}\n    \n    return nested_dict"}
{"id": "381_0", "code": "def get_max_sum(n):\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    # Convert the tuple to a set to remove duplicates\n    unique_elements = set(test_tup)\n    \n    # Compare the length of the set with the original tuple\n    if len(unique_elements) == len(test_tup):\n        return True\n    else:\n        return False"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate through the string to count occurrences of each character\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first non-repeated character\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    # Use regex to check if the string starts and ends with the same character\n    pattern = r'^([a-zA-Z])\\1$'\n    match = re.match(pattern, string)\n    if match:\n        return True\n    else:\n        return False"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    # Sort the numbers\n    sorted_numbers = sorted([a, b, c])\n    # Return the middle number\n    return sorted_numbers[1]"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Perform bitwise XOR operation on each pair of elements\n        res.append(test_tup1[i] ^ test_tup2[i])\n    \n    # Return the resulting list\n    return res"}
{"id": "389_0", "code": "def extract_freq(test_list):\n    # Initialize an empty dictionary to store the frequency of tuples\n    freq_dict = {}\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[tup] = 1\n    \n    # Return the dictionary containing the frequency of each tuple\n    return freq_dict"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the first tuple\n    for sub1 in test_tup1:\n        # Initialize an empty list to store the results for the current sub-tuple\n        sub_res = []\n        \n        # Iterate over the elements of the second tuple\n        for sub2 in test_tup2:\n            # Perform element-wise addition and append to the sub_result list\n            sub_res.append(sub1 + sub2)\n        \n        # Append the sub_result list to the result list\n        res.append(sub_res)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(res)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    # Base cases\n    if r == 0 or r == n:\n        return 1\n    if r > n:\n        return 0\n    \n    # Initialize result\n    res = 1\n    \n    # Calculate nCr % p\n    for i in range(r):\n        res = (res * (n - i)) % p\n        res = (res * pow(i + 1, p - 2, p)) % p\n    \n    return res"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    # Define the regex pattern for a valid URL\n    pattern = re.compile(\n        r'^(https?:\\/\\/)?'  # optional http or https\n        r'www\\.'            # www.\n        r'[a-zA-Z0-9.-]+'    # domain name\n        r'\\.[a-zA-Z]{2,}'    # top-level domain\n        r'(\\/[^\\s]*)?$'      # optional path\n    )\n    # Check if the string matches the pattern\n    return bool(pattern.match(str))"}
{"id": "393_0", "code": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    # Check if tuple1 is a subset of tuplex\n    return tuple1 in tuplex"}
{"id": "395_0", "code": "def find_Parity(x):\n    # Initialize the parity to 0\n    parity = 0\n    \n    # Loop through each bit of the number\n    while x:\n        # XOR the parity with the least significant bit of x\n        parity ^= x & 1\n        # Right shift x by 1 to process the next bit\n        x >>= 1\n    \n    # Return the final parity\n    return parity"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    \n    # Find the first digit from the right that is smaller than the digit immediately to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the largest possible\n    if i == -1:\n        return -1\n    \n    # Find the smallest digit to the right of the found digit that is larger than it\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Sort the digits to the right of the found digit in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n    \n    # Convert the list of digits back to a number\n    return int(''.join(digits))"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    # Your code here"}
{"id": "398_0", "code": "def min_product_tuple(list1):\n    min_product = float('inf')\n    for pair in list1:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    # Initialize the minimum value with the first element of the list\n    min_val = listval[0]\n    \n    # Iterate through the list to find the minimum value\n    for val in listval:\n        if val < min_val:\n            min_val = val\n    \n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    # Use regex to find all occurrences of '_[a-z]' and replace them with the uppercase version of the following letter\n    return re.sub(r'_([a-z])', lambda match: match.group(1).upper(), word)"}
{"id": "401_0", "code": "def remove_odd(l):\n    return [x for x in l if x % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    # Check if the list is empty or n is out of range\n    if not list1 or n < 0 or n >= len(list1):\n        return None\n    # Return the nth element of the list\n    return list1[n]"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    # Check if any element of list1 is in list2\n    return any(item in list2 for item in list1)"}
{"id": "404_0", "code": "def max_Product(arr):\n    if len(arr) < 2:\n        return \"Array must contain at least two elements\"\n    \n    # Initialize the maximum and minimum products\n    max_product = arr[0] * arr[1]\n    min_product = arr[0] * arr[1]\n    result = arr[0] * arr[1]\n    \n    for i in range(2, len(arr)):\n        # If the current element is positive, swap max_product and min_product\n        if arr[i] > 0:\n            max_product, min_product = max_product * arr[i], min_product * arr[i]\n        else:\n            # If the current element is negative, swap max_product and min_product\n            max_product, min_product = min_product * arr[i], max_product * arr[i]\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: if n is less than or equal to 3, return n itself\n    if n <= 3:\n        return n\n    \n    # Recursive case: divide n into three parts and sum them up\n    # The maximum sum is achieved by dividing n into three parts as evenly as possible\n    # and summing them up\n    return n - 1 + breakSum(n - 1) + breakSum(n - 2) + breakSum(n - 3)"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize an empty dictionary to store the first elements of each tuple\n    first_elements = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Check if the first element of the tuple is already in the dictionary\n        if tup[0] in first_elements:\n            # If it is, append the current tuple to the list of tuples for that first element\n            first_elements[tup[0]].append(tup)\n        else:\n            # If it is not, create a new list with the current tuple and add it to the dictionary\n            first_elements[tup[0]] = [tup]\n    \n    # Return the dictionary containing the first elements and their corresponding tuples\n    return first_elements"}
{"id": "407_0", "code": "def Find_Max(lst):\n    max_length = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_sublist = sublist\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    return total_sum * len(list1)"}
{"id": "409_0", "code": "def cube_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    # Initialize an empty string to store the concatenated result\n    res = \"\"\n    # Iterate over each element in the tuple\n    for ele in test_tup:\n        # Concatenate the current element to the result string\n        res += str(ele)\n    # Return the concatenated result\n    return res"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i**3\n    return total / n"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    # Create a table to store results of subproblems\n    max_gold = [[0 for x in range(n)] for y in range(m)]\n    \n    # Process all rows from bottom to top\n    for i in range(m-1, -1, -1):\n        # Process all columns from left to right\n        for j in range(n):\n            # If it's the last column, the gold collected is the gold at that cell\n            if j == n-1:\n                max_gold[i][j] = gold[i][j]\n            # If it's the last row, the gold collected is the gold at that cell\n            elif i == m-1:\n                max_gold[i][j] = gold[i][j]\n            # If it's not the last row or column, the gold collected is the gold at that cell plus the maximum of the gold collected from the cells below and to the right\n            else:\n                max_gold[i][j] = gold[i][j] + max(max_gold[i+1][j], max_gold[i+1][j+1], max_gold[i][j+1])\n    \n    # The maximum gold collected is the maximum value in the first column of the table\n    return max(max_gold[i][0] for i in range(m))"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    # Initialize an empty list to store the rear index elements\n    result = []\n    \n    # Iterate over each string in the tuple\n    for string in test_tuple:\n        # Check if the string is not empty\n        if string:\n            # Append the last character of the string to the result list\n            result.append(string[-1])\n    \n    # Return the list of rear index elements\n    return result"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\n\ndef change_date_format(dt):\n    # Use regex to find the date pattern yyyy-mm-dd\n    match = re.search(r'(\\d{4})-(\\d{2})-(\\d{2})', dt)\n    if match:\n        # Extract the year, month, and day\n        year, month, day = match.groups()\n        # Return the date in dd-mm-yyyy format\n        return f\"{day}-{month}-{year}\"\n    else:\n        # Return the original date if no match is found\n        return dt"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if both elements are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Append the elementwise AND of the tuples to the result list\n            res.append(tuple(a & b for a, b in zip(test_tup1[i], test_tup2[i])))\n        else:\n            # If not both are tuples, append the elementwise AND of the elements\n            res.append(test_tup1[i] & test_tup2[i])\n    \n    # Return the result list\n    return res"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    # Calculate the directrix using the formula: x = -b / (2a)\n    directrix = -b / (2 * a)\n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    # Convert both lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there is any intersection between the two sets\n    if set1.intersection(set2):\n        return True\n    else:\n        return False"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    for element in arr:\n        if element >= number:\n            return False\n    return True"}
{"id": "423_0", "code": "def text_match_one(text):\n    # Use regular expression to find the pattern\n    pattern = 'ab+'\n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return \"Match found!\"\n    else:\n        return \"No match found.\""}
{"id": "424_0", "code": "def last_Digit(n):\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for num in list1:\n        if num < 0:\n            print(num)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over each character in the input string\n    for char in str1:\n        # Check if the character is even (i.e., its ASCII value is even)\n        if ord(char) % 2 == 0:\n            # If even, append it to the result string\n            result += char\n    # Return the result string with odd characters removed\n    return result"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    res = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                res += 1\n    return res"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    # Convert each integer in the list to a string\n    str_list = [str(i) for i in L]\n    # Join the string representations of the integers into a single string\n    combined_str = ''.join(str_list)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    # Define a regular expression pattern to match adverbs\n    adverb_pattern = r'\\b\\w+ly\\b'\n    \n    # Use re.finditer to find all matches of the adverb pattern in the text\n    adverbs = re.finditer(adverb_pattern, text)\n    \n    # Create a list to store the positions of the adverbs\n    adverb_positions = []\n    \n    # Iterate over the matches and store their positions\n    for match in adverbs:\n        start = match.start()\n        end = match.end()\n        adverb_positions.append((start, end))\n    \n    return adverb_positions"}
{"id": "430_0", "code": "def surfacearea_cube(l):\n    return 6 * l ** 2"}
{"id": "431_0", "code": "def positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count"}
{"id": "432_0", "code": "def largest_neg(list1):\n    largest = None\n    for num in list1:\n        if num < 0:\n            if largest is None or num > largest:\n                largest = num\n    return largest"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    # Use list comprehension to trim each tuple by K\n    res = [tuple(ele[K:]) for ele in test_list]\n    return res"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    # Initialize an empty list to store the results\n    res = []\n    \n    # Iterate over the range of the length of the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index of both tuples\n        res.append(test_tup1[i] * test_tup2[i])\n    \n    # Convert the list to a tuple and return it\n    return tuple(res)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    # Initialize a dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in count_dict:\n            count_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[element] = 1\n    \n    # Initialize a list to store the result\n    result = []\n    \n    # Iterate over each element in the tuple\n    for element in tup:\n        # If the element is in the dictionary, append its count to the result list\n        if element in count_dict:\n            result.append(count_dict[element])\n        # If the element is not in the dictionary, append 0 to the result list\n        else:\n            result.append(0)\n    \n    # Return the result list\n    return result"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"id": "437_0", "code": "def cal_sum(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    else:\n        p0, p1, p2 = 3, 5, 8\n        sum_perrin = 13\n        for i in range(3, n):\n            p_next = p0 + p1\n            sum_perrin += p_next\n            p0, p1, p2 = p1, p2, p_next\n        return sum_perrin"}
{"id": "438_0", "code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the lengths of the sides of the triangle\n    side1 = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    side2 = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    side3 = ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5\n    \n    # Check the triangle inequality theorem\n    if side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1:\n        return True\n    else:\n        return False"}
{"id": "439_0", "code": "def extract_string(str, l):\n    return str[:l]"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    # Use regex to replace all whitespace characters with an empty string\n    return re.sub(r'\\s+', '', text1)"}
{"id": "441_0", "code": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    import re\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    reversed_list = []\n    for string in stringlist:\n        reversed_list.append(string[::-1])\n    return reversed_list"}
{"id": "446_0", "code": "def Find_Min(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n\n    min_length = float('inf')  # Initialize min_length to infinity\n    min_sublist = None  # Initialize min_sublist to None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(l, b):\n    return l * b"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    # Use regex to find all uppercase substrings and replace them with an empty string\n    return re.sub(r'[A-Z]+', '', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count"}
{"id": "451_0", "code": "def combinations_list(list1):\n    def backtrack(start, path):\n        # Add the current path to the result\n        result.append(path)\n        # Iterate over the remaining elements\n        for i in range(start, len(list1)):\n            # Include the current element in the path\n            backtrack(i + 1, path + [list1[i]])\n    \n    result = []\n    backtrack(0, [])\n    return result"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    # Check if the dictionary is empty\n    if not dict:\n        return True\n    \n    # Get the first value in the dictionary\n    first_value = next(iter(dict.values()))\n    \n    # Compare each value in the dictionary with the first value\n    for value in dict.values():\n        if value != first_value:\n            return False\n    \n    return True"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    # Create a new dictionary to store non-empty items\n    new_dict = {}\n    # Iterate over the items in the input dictionary\n    for key, value in dict1.items():\n        # Check if the value is not empty\n        if value:\n            # Add the key-value pair to the new dictionary\n            new_dict[key] = value\n    # Return the new dictionary with empty items removed\n    return new_dict"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    if n == 1:\n        return 0\n    if arr[0] > arr[1]:\n        return 0\n    if arr[n-1] > arr[n-2]:\n        return n-1\n    low = 1\n    high = n-2\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > arr[mid-1] and arr[mid] > arr[mid+1]:\n            return mid\n        elif arr[mid] < arr[mid-1]:\n            high = mid - 1\n        else:\n            low = mid + 1"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    # Initialize an empty string to store the octal number\n    octalNum = \"\"\n    \n    # Loop until the decimal number is reduced to 0\n    while deciNum > 0:\n        # Get the remainder when the decimal number is divided by 8\n        remainder = deciNum % 8\n        \n        # Prepend the remainder to the octal number string\n        octalNum = str(remainder) + octalNum\n        \n        # Divide the decimal number by 8\n        deciNum = deciNum // 8\n    \n    # Return the octal number string\n    return octalNum"}
{"id": "457_0", "code": "def max_product(arr, n):\n    # Initialize the dp array where dp[i] will store the maximum product of increasing subsequence ending at index i\n    dp = [1] * n\n    \n    # Iterate through each element in the array\n    for i in range(1, n):\n        # Iterate through all previous elements\n        for j in range(i):\n            # If the current element is greater than the previous element, update the dp array\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # The maximum product of increasing subsequence will be the maximum value in the dp array\n    return max(dp)"}
{"id": "458_0", "code": "def max_profit(price, k):\n    n = len(price)\n    if n < 2 or k == 0:\n        return 0\n    \n    # Create a DP table to store the maximum profit\n    dp = [[0] * (k + 1) for _ in range(n)]\n    \n    # Fill the DP table\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            # Calculate the maximum profit by either buying or not buying\n            dp[i][j] = max(dp[i - 1][j], price[i] - price[i - 1] + dp[i - 1][j - 1])\n    \n    return dp[n - 1][k]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    res = tuple(a + b for a, b in zip(test_tup[0], test_tup[1]))\n    return res"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    # Initialize the result to 1\n    result = 1\n    \n    # Iterate over each element in the array\n    for i in range(lens):\n        # Multiply the current result by the current element modulo n\n        result = (result * arr[i]) % n\n    \n    # Return the final result\n    return result"}
{"id": "461_0", "code": "def check_Consecutive(l):\n    if len(l) < 2:\n        return False\n    l.sort()\n    for i in range(1, len(l)):\n        if l[i] != l[i-1] + 1:\n            return False\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    # Convert lists to sets to remove duplicates and allow for intersection\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a tuple\n    result = tuple(intersection)\n    \n    return result"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    return str1.replace(ch,newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    # Sort the dictionary by value in descending order\n    sorted_dict = dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    if not nums:\n        return 0\n    return max(nums) + min(nums)"}
{"id": "466_0", "code": "def is_lower(string):\n    return string.islower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    # Use a list comprehension to filter out lowercase characters\n    result = ''.join([char for char in str1 if not char.islower()])\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    # Convert the number to a string to easily access the first character\n    n_str = str(n)\n    # Return the first character of the string, which is the first digit\n    return n_str[0]"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    # Initialize a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Initialize variables to store the maximum frequency and the corresponding character\n    max_freq = 0\n    max_char = ''\n    \n    # Iterate over the dictionary to find the character with the maximum frequency\n    for char, freq in char_count.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_char = char\n    \n    # Return the character with the maximum frequency\n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    # Base case: if sum is 0, then answer is true\n    if sum == 0:\n        return True\n    # Base case: if no items left or sum becomes negative, then answer is false\n    if n == 0 or sum < 0:\n        return False\n    # If last element is greater than sum, then ignore it\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    # Check if sum can be achieved by including or excluding the last element\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    # Use regex to find sequences of one upper case letter followed by lower case letters\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "472_0", "code": "def first_Factorial_Divisible_Number(x):\n    factorial = 1\n    n = 1\n    while True:\n        factorial *= n\n        if factorial % x == 0:\n            return n\n        n += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    # Use list comprehension to filter out matching tuples\n    res = [ele for ele in test_list1 if ele not in test_list2]\n    return res"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    # Initialize the largest palindrome to 0\n    largest_palindrome = 0\n    \n    # Iterate through each number in the array\n    for num in A:\n        # Convert the number to a string\n        num_str = str(num)\n        \n        # Check if the number is a palindrome\n        if num_str == num_str[::-1]:\n            # Update the largest palindrome if the current number is greater\n            largest_palindrome = max(largest_palindrome, num)\n    \n    # Return the largest palindrome found\n    return largest_palindrome"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate the binomial coefficient\n    binom_coeff = math.comb(n, k)\n    \n    # Calculate the probability of k successes in n trials\n    probability = binom_coeff * (p ** k) * ((1 - p) ** (n - k))\n    \n    return probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    # Sort the list of tuples based on the last element of each tuple\n    sorted_tup = sorted(tup, key=lambda x: x[-1])\n    return sorted_tup"}
{"id": "477_0", "code": "def area_pentagon(a):\n    import math\n    return (5 * a ** 2) / (4 * math.tan(math.pi / 5))"}
{"id": "478_0", "code": "def frequency_Of_Largest(n, arr):\n    if n == 0:\n        return 0\n    max_value = max(arr)\n    frequency = arr.count(max_value)\n    return frequency"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    res = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j][::-1]:\n                res.append((test_list[i], test_list[j]))\n    return res"}
{"id": "480_0", "code": "def sum_gp(a,n,r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r**n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    # Initialize the start and end pointers\n    start = 0\n    end = len(item_list) - 1\n    \n    # Loop until the start pointer is less than or equal to the end pointer\n    while start <= end:\n        # Calculate the middle index\n        mid = (start + end) // 2\n        \n        # Check if the middle element is the item we are looking for\n        if item_list[mid] == item:\n            return mid  # Return the index of the item\n        # If the item is greater than the middle element, search in the right half\n        elif item_list[mid] < item:\n            start = mid + 1\n        # If the item is less than the middle element, search in the left half\n        else:\n            end = mid - 1\n    \n    # If the item is not found, return -1\n    return -1"}
{"id": "482_0", "code": "def calculate_polygons(startx, starty, endx, endy, radius):\n    # Initialize an empty list to store the polygons\n    polygons = []\n    \n    # Calculate the number of hexagons in the x and y directions\n    num_hexes_x = int((endx - startx) / (radius * 2 * (3 ** 0.5)))\n    num_hexes_y = int((endy - starty) / (radius * 2 * (3 ** 0.5)))\n    \n    # Calculate the center of the grid\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n    \n    # Calculate the angle between hexagons\n    angle = 60 * (3 ** 0.5)\n    \n    # Iterate over the grid\n    for i in range(num_hexes_y):\n        for j in range(num_hexes_x):\n            # Calculate the x and y coordinates of the hexagon\n            x = center_x + j * radius * 2 * (3 ** 0.5) * (1 - (i % 2) * 0.5)\n            y = center_y + i * radius * 2 * (3 ** 0.5) * (1 - (i % 2) * 0.5) * (3 ** 0.5)\n            \n            # Calculate the coordinates of the hexagon's vertices\n            vertices = [\n                (x, y),\n                (x + radius * 2 * (3 ** 0.5), y),\n                (x + radius * 2 * (3 ** 0.5) * (1 - (i % 2) * 0.5), y + radius * 2 * (3 ** 0.5) * (3 ** 0.5)),\n                (x, y + radius * 2 * (3 ** 0.5) * (3 ** 0.5)),\n                (x - radius * 2 * (3 ** 0.5) * (1 - (i % 2) * 0.5), y + radius * 2 * (3 ** 0.5) * (3 ** 0.5)),\n                (x - radius * 2 * (3 ** 0.5), y)\n            ]\n            \n            # Add the hexagon's vertices to the polygons list\n            polygons.append(vertices)\n    \n    # Return the list of polygons\n    return polygons"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    # Initialize the result variable\n    res = 0\n    \n    # Iterate over the binary tuple\n    for i, bit in enumerate(test_tup):\n        # Shift the result to the left by 1\n        res <<= 1\n        # Add the current bit to the result\n        res += bit\n    \n    return res"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    # Use regex to find all lowercase letters and replace them with an empty string\n    return re.sub(r'[a-z]', '', str1)"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    # Use heapq.nsmallest to find the n smallest elements\n    smallest_nums = heapq.nsmallest(n, nums)\n    return smallest_nums"}
{"id": "486_0", "code": "def surfacearea_cone(r,h):\n    import math\n    # Calculate the slant height of the cone\n    l = math.sqrt(r**2 + h**2)\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + l)\n    return surface_area"}
{"id": "487_0", "code": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x"}
{"id": "488_0", "code": "def diameter_circle(r):\n    return 2 * r"}
{"id": "489_0", "code": "def concatenate_elements(list):\n    return ''.join(list)"}
{"id": "490_0", "code": "def num_comm_div(x,y):\n    # Initialize the count of common divisors\n    count = 0\n    \n    # Iterate through all numbers from 1 to the minimum of x and y\n    for i in range(1, min(x, y) + 1):\n        # Check if both x and y are divisible by i\n        if x % i == 0 and y % i == 0:\n            # Increment the count if both conditions are met\n            count += 1\n    \n    # Return the total count of common divisors\n    return count"}
{"id": "491_0", "code": "def find(n, m):\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    total = 0\n    for i in range(len(nums) - 1):\n        total += nums[i] + nums[i + 1]\n    return total"}
{"id": "493_0", "code": "def sum_Of_Series(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Add the cube of the current number to the total sum\n        total_sum += i ** 3\n    \n    # Return the total sum\n    return total_sum"}
{"id": "494_0", "code": "def re_order(A):\n    # Initialize a pointer for the position where the next non-zero element should be placed\n    next_non_zero = 0\n    \n    # Iterate through the array\n    for i in range(len(A)):\n        # If the current element is non-zero\n        if A[i] != 0:\n            # Swap the current element with the element at the next_non_zero position\n            A[next_non_zero], A[i] = A[i], A[next_non_zero]\n            # Move the next_non_zero pointer to the next position\n            next_non_zero += 1\n    \n    # Return the modified array\n    return A"}
{"id": "495_0", "code": "def permutation_coefficient(n, k):\n    # Initialize the result\n    result = 1\n    \n    # Calculate the permutation coefficient using the formula\n    for i in range(k):\n        result *= (n - i)\n    \n    return result"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    # Initialize an empty list to store the filtered words\n    filtered_list = []\n    \n    # Iterate over each word in the input list\n    for word in list1:\n        # Check if the word is not in the list of words to remove\n        if word not in removewords:\n            # If the word is not in the list of words to remove, add it to the filtered list\n            filtered_list.append(word)\n    \n    # Return the filtered list\n    return filtered_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    # Find common elements between the two lists\n    common_elements = set(l1) & set(l2)\n    \n    # Check if the common elements are in the same order in both lists\n    for element in common_elements:\n        if l1.index(element) != l2.index(element):\n            return False\n    \n    return True"}
{"id": "498_0", "code": "def average_Odd(n):\n    sum_odd = 0\n    count_odd = 0\n    for i in range(1, n+1, 2):\n        sum_odd += i\n        count_odd += 1\n    if count_odd == 0:\n        return 0\n    return sum_odd / count_odd"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    if k == 0:\n        return 0\n    n = len(arr)\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(k, arr[i] - 1, -1):\n            dp[j] += dp[j - arr[i]]\n    return dp[k]"}

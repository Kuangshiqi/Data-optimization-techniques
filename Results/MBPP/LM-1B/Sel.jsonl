{"id": "0_0", "code": "def remove_Occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        s (str): The input string.\n        ch (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence of the character\n    idx1 = s.find(ch)\n    # If the character is not found, return the original string\n    if idx1 == -1:\n        return s\n    # Find the index of the last occurrence of the character\n    idx2 = s.rfind(ch)\n    # If the character is not found, return the original string\n    if idx2 == -1:\n        return s\n    # Remove the first and last occurrence of the character\n    return s[:idx1] + s[idx2 + 1:]"}
{"id": "1_0", "code": "import numpy as np\n\ndef sort_matrix(M):\n    # Convert the matrix to a numpy array\n    M = np.array(M)\n    \n    # Calculate the sum of each row\n    row_sums = np.sum(M, axis=1)\n    \n    # Sort the rows based on their sums\n    sorted_rows = np.sort(row_sums)\n    \n    # Convert the sorted rows back to a list and return\n    return sorted_rows.tolist()"}
{"id": "2_0", "code": "import collections\nfrom collections import Counter\n\ndef count_common(words):\n    \"\"\"\n    Counts the most common words in a dictionary.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        dict: A dictionary with words as keys and their frequencies as values.\n    \"\"\"\n    # Convert the list of words to a set to remove duplicates\n    unique_words = set(words)\n    \n    # Count the frequency of each word\n    word_freq = Counter(unique_words)\n    \n    # Return the word frequencies as a dictionary\n    return dict(word_freq)"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    \"\"\"\n    Calculates the volume of a triangular prism.\n\n    Parameters:\n    l (float): The length of the base of the prism.\n    b (float): The base of the triangular prism.\n    h (float): The height of the prism.\n\n    Returns:\n    float: The volume of the prism.\n    \"\"\"\n    # Calculate the area of the base\n    base_area = 0.5 * b * l\n    \n    # Calculate the volume of the prism\n    volume = base_area * h\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of substrings separated by lowercase letters.\n    \"\"\"\n    result = []\n    current_substring = \"\"\n    for char in text:\n        if char.islower():\n            current_substring += char\n        elif current_substring:\n            result.append(current_substring)\n            current_substring = \"\"\n    if current_substring:\n        result.append(current_substring)\n    return result"}
{"id": "5_0", "code": "def text_lowercase_underscore(text):\n    \"\"\"\n    Generate a sequence of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A sequence of lowercase letters joined with an underscore.\n    \"\"\"\n    return '_'.join(text.lower())"}
{"id": "6_0", "code": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    a (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    # Check if the input is a positive number\n    if a <= 0:\n        raise ValueError(\"The length of a side must be a positive number.\")\n\n    # Calculate the perimeter\n    perimeter = 4 * a\n\n    return perimeter"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The original string.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters from second_string removed.\n    \"\"\"\n    # Convert second_string to a set for efficient lookups\n    second_set = set(second_string)\n    \n    # Initialize an empty list to store the characters that are not in second_set\n    result = []\n    \n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is not in second_set\n        if char not in second_set:\n            # Append the character to the result list\n            result.append(char)\n    \n    # Join the characters in the result list into a string\n    result_str = ''.join(result)\n    \n    # Return the modified string\n    return result_str"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"}
{"id": "9_0", "code": "def is_woodall(x):\n    \"\"\"\n    Checks if the given number is a woodball.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a woodball, False otherwise.\n    \"\"\"\n    # Define the woodball numbers\n    woodball_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319,"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    \"\"\"\n    Generate multiples of n for m number of times.\n\n    Args:\n        m (int): The number of times to generate multiples.\n        n (int): The number for which multiples are generated.\n\n    Returns:\n        list: A list of multiples of n.\n    \"\"\"\n    return [i * n for i in range(1, m + 1)]"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Add the element to the current sum\n            current_sum += element\n            \n            # Update the maximum sum if the current sum is greater\n            max_sum = max(max_sum, current_sum)\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    Convert a binary number to its decimal equivalent.\n\n    Args:\n        binary (str): A binary number as a string.\n\n    Returns:\n        int: The decimal equivalent of the binary number.\n\n    Raises:\n        ValueError: If the input string is not a valid binary number.\n    \"\"\"\n    # Check if the input string is a valid binary number\n    if not set(binary).issubset({'0', '1'}):\n        raise ValueError(\"Invalid binary number\")\n\n    # Convert the binary string to decimal using Python's built-in int function\n    decimal = int(binary, 2)\n\n    return decimal"}
{"id": "14_0", "code": "def find_product(arr, n):\n    \"\"\"\n    This function finds the product of non-repeated elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The product of non-repeated elements in the array.\n    \"\"\"\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize the product variable to 1\n    product = 1\n\n    # Iterate through the dictionary and multiply the elements\n    for key, value in freq_dict.items():\n        if value == 1:\n            product *= key\n\n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    \"\"\"\n    Checks if the given tuple list has all K elements.\n\n    Args:\n        test_list (list): The input list of tuples.\n        K (int): The number of elements to check for.\n\n    Returns:\n        bool: True if the list has all K elements, False otherwise.\n    \"\"\"\n    return len(test_list) == K"}
{"id": "16_0", "code": "def remove(lst):\n    return [s.replace('0', '') for s in lst]"}
{"id": "17_0", "code": "import math\n\ndef binomial_Coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k)\n    \n    Parameters:\n    n (int): The total number of items\n    k (int): The number of items to choose\n    \n    Returns:\n    int: The binomial coefficient (n choose k)\n    \"\"\"\n    # Check if k is greater than n - k\n    if k > n - k:\n        raise ValueError(\"k cannot be greater than n - k\")\n    \n    # Calculate the binomial coefficient using math.comb\n    return math.comb(n, k)"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    \"\"\"\n    This function finds the element occurring odd number of times in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    arr_size (int): The size of the input array.\n\n    Returns:\n    int: The index of the element occurring odd number of times.\n    \"\"\"\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(arr_size):\n        # If the element is already in the dictionary, increment its count\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize the count of elements with odd frequency\n    odd_count = 0\n    # Iterate over the dictionary to find the elements with odd frequency\n    for key, value in freq_dict.items():\n        # If the frequency of the element is odd, increment the odd count\n        if value % 2 != 0:\n            odd_count += 1\n\n    # Return the index of the element with odd frequency\n    return odd_count"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    \"\"\"\n    Counts all substrings in the given string s that start and end with the same character.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of substrings with equal ending characters.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "import heapq\nfrom collections import Counter\n\ndef func(nums, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers.\n\n    Args:\n    nums (list): A list of sorted and distinct integers.\n    k (int): The number of top integers to find.\n\n    Returns:\n    list: A list of the top k integers that occur most frequently.\n    \"\"\"\n    # Count the frequency of each integer\n    count = Counter(nums)\n    \n    # Create a max heap to store the integers and their frequencies\n    max_heap = []\n    for num, freq in count.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(max_heap, (-freq, num))\n    \n    # Pop the top k integers from the heap\n    result = []\n    for _ in range(k):\n        # Get the integer with the highest frequency\n        freq, num = heapq.heappop(max_heap)\n        # Add the integer to the result list\n        result.append(num)\n    \n    return result"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    \"\"\"\n    This function finds the largest prime factor of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The largest prime factor of the input number.\n\n    Raises:\n    ValueError: If the input number is less than 2.\n    \"\"\"\n\n    # Check if the input number is less than 2\n    if n < 2:\n        raise ValueError(\"Input number must be greater than or equal to 2.\")\n\n    # Initialize the largest prime factor\n    max_prime_factor = 1\n\n    # Iterate from 2 to the square root of the number\n    for i in range(2, int(n ** 0.5) + 1):\n        # Check if the current number is a factor of the number\n        while n % i == 0:\n            # Update the largest prime factor\n            max_prime_factor = i\n            # Divide the number by the current factor\n            n = n // i\n\n    # If the remaining number is greater than 1, it is a prime factor\n    if n > 1:\n        max_prime_factor = n\n\n    return max_prime_factor"}
{"id": "22_0", "code": "def decimal_to_binary(N):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Args:\n        N (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary representation of the input decimal number.\n    \"\"\"\n    if N == 0:\n        return '0'\n    binary = ''\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar, N):\n    \"\"\"\n    Find the missing number in a sorted array.\n\n    Parameters:\n    ar (list): A sorted list of integers.\n    N (int): The length of the list.\n\n    Returns:\n    int: The missing number in the list.\n    \"\"\"\n    # Calculate the sum of the first N natural numbers\n    sum_of_natural_numbers = N * (N + 1) // 2\n\n    # Calculate the sum of the first N natural numbers in the array\n    sum_of_array = sum(ar)\n\n    # The missing number is the difference between the two sums\n    return sum_of_natural_numbers - sum_of_array"}
{"id": "24_0", "code": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n\n    Args:\n        n (int): The position of the rectangular number to find.\n\n    Returns:\n        int: The n-th rectangular number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n\n    # Initialize the first rectangular number\n    rect_num = 1\n\n    # Generate the rectangular numbers\n    while True:\n        # Calculate the next rectangular number\n        rect_num += n\n\n        # If the next rectangular number is greater than n, break the loop\n        if rect_num > n:\n            break\n\n        # Increment n for the next iteration\n        n -= 1\n\n    return rect_num"}
{"id": "25_0", "code": "def find_Nth_Digit(p,q,N):\n    # Convert both numbers to fractions\n    from fractions import Fraction\n    frac_p = Fraction(p).limit_denominator()\n    frac_q = Fraction(q).limit_denominator()\n\n    # Find the least common multiple of the denominators\n    lcm = frac_p.denominator * frac_q.denominator // gcd(frac_p.denominator, frac_q.denominator)\n\n    # Convert the fractions to integers\n    frac_p_int = int(frac_p.numerator * (lcm // frac_p.denominator))\n    frac_q_int = int(frac_q.numerator * (lcm // frac_q.denominator))\n\n    # Find the nth digit\n    nth_digit = frac_p_int % lcm\n    if nth_digit < 10:\n        return nth_digit\n    else:\n        return nth_digit % 10\n\n# Define the gcd function\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Test the function\nprint(find_Nth_Digit(1, 2, 3))  # Output: 1\nprint(find_Nth_Digit(1, 2, 4))  # Output: 2\nprint(find_Nth_Digit(1, 2, 5))  # Output: 1"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a given mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing integers and strings.\n\n    Returns:\n        list: A sorted list of integers and strings.\n    \"\"\"\n    # Separate integers and strings into different lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort integers and strings separately\n    integers.sort()\n    strings.sort()\n\n    # Combine the sorted lists\n    sorted_list = integers + strings\n\n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Initialize variables\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through the list\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return the result\n    return even_count, odd_count"}
{"id": "28_0", "code": "def rearange_string(S):\n    \"\"\"\n    Rearrange the letters in the string so that two adjacent characters are different.\n\n    Args:\n        S (str): The input string.\n\n    Returns:\n        bool: True if the string can be rearranged, False otherwise.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n    for char in S:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Check if the string can be rearranged\n    for i in range(len(S) - 1):\n        if S[i] == S[i + 1] and freq[S[i]] > 1:\n            return False\n\n    return True"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    \"\"\"\n    This function calculates the frequency of elements in a given list of lists.\n\n    Args:\n        nums (list): A list of lists containing elements.\n\n    Returns:\n        dict: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq = Counter(flat_list)\n    \n    return dict(freq)"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr, n):\n    \"\"\"\n    This function calculates the sum of repeated elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The sum of repeated elements in the array.\n    \"\"\"\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize the sum of repeated elements\n    repeated_sum = 0\n\n    # Iterate through the dictionary and add the repeated elements to the sum\n    for key, value in freq_dict.items():\n        if value > 1:\n            repeated_sum += key * value\n\n    return repeated_sum"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    pattern = r\"([a-z]+)_([a-z]+)\"\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    \"\"\"\n    Returns a string that matches the beginning of the input text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A string that matches the beginning of the input text.\n    \"\"\"\n    return text[:len(text)]  # Return the first 'len(text)' characters of the input text"}
{"id": "34_0", "code": "import math\n\ndef get_gcd(l):\n    \"\"\"\n    This function calculates the greatest common divisor (gcd) of the given array elements.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        int: The greatest common divisor of the given array elements.\n    \"\"\"\n    # Check if the list is empty\n    if not l:\n        return 0\n\n    # Initialize the gcd with the first element of the list\n    gcd = l[0]\n\n    # Iterate over the rest of the list\n    for num in l[1:]:\n        # Update the gcd using the Euclidean algorithm\n        gcd = math.gcd(gcd, num)\n\n    return gcd"}
{"id": "35_0", "code": "def test_distinct(data):\n    \"\"\"\n    This function checks whether all the numbers in the given list are different from each other.\n\n    Args:\n        data (list): A list of numbers.\n\n    Returns:\n        bool: True if all numbers are different, False otherwise.\n    \"\"\"\n    return len(set(data)) == len(data)"}
{"id": "36_0", "code": "import math\n\ndef compute_Last_Digit(A, B):\n    \"\"\"\n    This function calculates the last digit of the factorial of A when it divides the factorial of B.\n\n    Args:\n        A (int): The number for which the factorial is to be calculated.\n        B (int): The number for which the factorial is to be calculated.\n\n    Returns:\n        int: The last digit of the factorial of A when it divides the factorial of B.\n    \"\"\"\n    # Calculate the factorial of A\n    A_factorial = math.factorial(A)\n    \n    # Calculate the factorial of B\n    B_factorial = math.factorial(B)\n    \n    # Calculate the remainder of A_factorial divided by B_factorial\n    remainder = A_factorial % B_factorial\n    \n    # Return the last digit of the remainder\n    return remainder % 10\n\n# Example usage:\nprint(compute_Last_Digit(5, 10))  # Output: 5\nprint(compute_Last_Digit(7, 11))  # Output: 7"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all odd bits set.\n    \"\"\"\n    # Create a mask to get the odd bits\n    mask = 0xAAAAAAAA  # 11111111111111111111111111111111\n\n    # Use the mask to set the odd bits\n    result = n\n    while mask != 0:\n        result ^= mask\n        mask = (mask << 1) | 1\n\n    return result"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extract every first or specified element from a given two-dimensional list.\n\n    Args:\n        nums (list): A two-dimensional list of elements.\n        N (int): The index of the first element to extract.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    # Check if N is within the bounds of the list\n    if N < 0 or N >= len(nums):\n        raise ValueError(\"N is out of bounds\")\n\n    # Extract the specified element(s) from the list\n    return [nums[i] for i in range(N, len(nums))]"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=len)"}
{"id": "40_0", "code": "def check_equilateral(x, y, z):\n    \"\"\"\n    This function checks if a triangle is equilateral or not.\n\n    Args:\n        x (float): The length of the first side of the triangle.\n        y (float): The length of the second side of the triangle.\n        z (float): The length of the third side of the triangle.\n\n    Returns:\n        bool: True if the triangle is equilateral, False otherwise.\n    \"\"\"\n    # Check if the sides are equal\n    if x == y and x == z and y == z:\n        return True\n    else:\n        return False\n\n# Example usage:\nprint(check_equilateral(3, 4, 5))  # Output: True\nprint(check_equilateral(3, 4, 6))  # Output: False"}
{"id": "41_0", "code": "def parallelogram_area(b, h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    if len(str) < 2:\n        return False\n    return str[0] == str[-1]"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    # Find the maximum element in the list\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count = [0] * (max_element + 1)\n    \n    # Count the occurrence of each element in the list\n    for num in my_list:\n        count[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, max_element + 1):\n        count[i] += count[i - 1]\n    \n    # Build the output array\n    output = [0] * len(my_list)\n    \n    # Build the output array by placing each element at its correct position\n    for num in my_list:\n        output[count[num] - 1] = num\n        count[num] -= 1\n    \n    return output"}
{"id": "44_0", "code": "def tn_gp(a, n, r):\n    \"\"\"\n    Calculate the nth term of a geometric progression.\n\n    Parameters:\n    a (float): The first term of the geometric progression.\n    n (int): The term number to calculate.\n    r (float): The common ratio of the geometric progression.\n\n    Returns:\n    float: The nth term of the geometric progression.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    if r == 1:\n        return a\n    return a * (r ** (n - 1))"}
{"id": "45_0", "code": "def check(n):\n    \"\"\"\n    Checks if a given number is one less than twice its reverse.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily reverse it\n    str_n = str(n)\n    \n    # Reverse the string\n    reversed_str_n = str_n[::-1]\n    \n    # Check if the number is one less than twice its reverse\n    return str_n == str(n*2 - 1)"}
{"id": "46_0", "code": "def find_Max_Num(arr, n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Join the array into a string\n    max_num_str = ''.join(arr)\n    # Convert the string into an integer\n    max_num = int(max_num_str)\n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x, y):\n    \"\"\"\n    Checks whether the given two integers have opposite sign or not.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        bool: True if the integers have opposite sign, False otherwise.\n    \"\"\"\n    return x * y < 0"}
{"id": "48_0", "code": "def is_octagonal(n):\n    \"\"\"\n    Checks if a number is an octagonal number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is an octagonal number, False otherwise.\n    \"\"\"\n    return n % 16 == 0"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    \"\"\"\n    This function finds the maximum length of the subsequence with difference between adjacent elements \n    for the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the input array.\n\n    Returns:\n    int: The maximum length of the subsequence with difference between adjacent elements.\n    \"\"\"\n    # Initialize a list to store the length of the longest subsequence ending at each position\n    dp = [1] * n\n\n    # Initialize the maximum length of the subsequence\n    max_len = 1\n\n    # Iterate over the array\n    for i in range(1, n):\n        # For each element, check all previous elements\n        for j in range(i):\n            # If the difference between the current element and the previous element is less than or equal to 1\n            if abs(arr[i] - arr[j]) <= 1:\n                # Update the length of the longest subsequence ending at the current position\n                dp[i] = max(dp[i], dp[j] + 1)\n\n        # Update the maximum length of the subsequence\n        max_len = max(max_len, dp[i])\n\n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s, n):\n    \"\"\"\n    Counts the number of substrings in the given string s with the sum of digits equal to their length.\n\n    Args:\n        s (str): The input string.\n        n (int): The length of the substrings.\n\n    Returns:\n        int: The number of substrings with the sum of digits equal to their length.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            # Calculate the sum of digits\n            digit_sum = sum(int(digit) for digit in s[i:j])\n            # Check if the sum of digits is equal to the length of the substring\n            if digit_sum == j - i:\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n        xs (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"Input list is empty\")\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    \"\"\"\n    This function calculates the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n        int: The maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    # Initialize the maximum difference and the minimum value\n    max_diff = float('-inf')\n    min_val = float('inf')\n\n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Calculate the difference between the first and second elements of the tuple\n        diff = tup[0] - tup[1]\n        \n        # Update the maximum difference if the current difference is larger\n        max_diff = max(max_diff, diff)\n        \n        # Update the minimum value if the current difference is smaller\n        min_val = min(min_val, diff)\n\n    # Return the maximum difference\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    \"\"\"\n    Sorts a list of tuples based on the first element of each tuple.\n\n    Args:\n        subjectmarks (list): A list of tuples, where each tuple contains a subject name and a mark.\n\n    Returns:\n        list: A sorted list of tuples based on the first element of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[0])"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    \"\"\"\n    This function calculates the sum of a list of numbers using recursion.\n\n    Args:\n        data_list (list): A list of numbers.\n\n    Returns:\n        int: The sum of the numbers in the list.\n    \"\"\"\n    # Base case: If the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: Add the first element of the list to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    \"\"\"\n    Counts the number of positive numbers in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The number of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"id": "56_0", "code": "def bell_number(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return n + bell_number(n - 1)"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    n = len(A)\n    for i in range(n - 1):\n        if A[i] > A[i + 1]:\n            return False\n    return True"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    \"\"\"\n    Checks if a given sublist is present in the list.\n\n    Args:\n        l (list): The main list to be searched.\n        s (list): The sublist to be searched for.\n\n    Returns:\n        bool: True if the sublist is found, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not l:\n        return False\n\n    # Check if the sublist is empty\n    if not s:\n        return True\n\n    # Check if the sublist is present in the list\n    for i in range(len(l)):\n        if l[i:i+len(s)] == s:\n            return True\n\n    # If the sublist is not found, return False\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    # Check if the input is a list of tuples\n    if not isinstance(Input, list) or not all(isinstance(x, tuple) for x in Input):\n        raise ValueError(\"Input must be a list of tuples\")\n\n    # Check if the length of the tuples is equal\n    if len(set(map(len, Input))) != 1:\n        return False\n\n    # Check if all tuples have equal length\n    for tup in Input:\n        if len(tup) != len(set(map(len, Input))):\n            return False\n\n    return True"}
{"id": "60_0", "code": "def comb_sort(nums):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(nums) // 2\n\n    # Loop until the gap size is 1\n    while gap > 0:\n        # Iterate over the list with the gap size\n        for i in range(gap, len(nums)):\n            # Store the current element\n            temp = nums[i]\n\n            # Initialize the index for the previous element\n            j = i\n\n            # Shift elements to the right until we find the correct position\n            while j >= gap and nums[j - gap] > temp:\n                nums[j] = nums[j - gap]\n                j -= gap\n\n            # Place the current element at its correct position\n            nums[j] = temp\n\n        # Reduce the gap size by half\n        gap //= 2\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    \"\"\"\n    Checks whether the given number can be represented as difference of two squares or not.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        bool: True if the number can be represented as difference of two squares, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            j = n // i\n            if i**2 - j**2 == n:\n                return True\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    \"\"\"\n    Splits the given string with multiple delimiters by using regex.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        list: A list of strings, each representing a split content.\n    \"\"\"\n    # Define the regex pattern\n    pattern = r'(\\w+|\\w+\\s+|\\w+\\s+|\\w+\\s+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+|\\w+"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks whether the given colors follow the sequence given in the patterns array.\n\n    Args:\n        colors (list): A list of colors.\n        patterns (list): A list of patterns.\n\n    Returns:\n        bool: True if the colors follow the sequence, False otherwise.\n    \"\"\"\n    # Check if the lengths of the colors and patterns arrays are equal\n    if len(colors) != len(patterns):\n        return False\n\n    # Check if the first element of the colors array is equal to the first element of the patterns array\n    if colors[0] != patterns[0]:\n        return False\n\n    # Check if the rest of the elements in the colors array are equal to the rest of the elements in the patterns array\n    for i in range(1, len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n\n    # If all checks pass, return True\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    \"\"\"\n    Find tuples in the given list where all elements are divisible by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The divisor.\n\n    Returns:\n        list: A list of tuples where all elements are divisible by K.\n    \"\"\"\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return result"}
{"id": "65_0", "code": "def count_Squares(m,n):\n    # Initialize count of squares\n    count = 0\n    \n    # Check if the rectangle is a square\n    if m == n:\n        # If it's a square, count the number of squares\n        count = m ** 2\n    else:\n        # If it's not a square, count the number of squares in each row and column\n        for i in range(m):\n            for j in range(n):\n                count += 1\n        # Add the number of squares in the last row and column\n        count += m - 1\n        count += n - 1\n    \n    return count"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number to a string\n    str_n = str(n)\n    \n    # Initialize variables to store the sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each character in the string\n    for char in str_n:\n        # Convert the character back to an integer\n        digit = int(char)\n        \n        # Check if the digit is even or odd\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n    \n    # Return True if the difference between the sums is 0, False otherwise\n    return even_sum - odd_sum == 0"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    \"\"\"\n    Counts the number of integers with an odd number of set bits in their binary representation.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The number of integers with an odd number of set bits.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        binary = format(i, 'b')\n        if binary.count('1') % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    return len(s)"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    Args:\n        n (int): The position of the tetrahedral number to calculate.\n\n    Returns:\n        int: The nth tetrahedral number.\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    # Loop through the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Add the current number to the result\n        result += i\n    # Return the final result\n    return result"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple containing the elements of both tuples.\n    The beginning of the generated content is as follows:\n    (test_tup1[0], test_tup2[0], test_tup1[1], test_tup2[1], ..., test_tup1[-1], test_tup2[-1])\n    \"\"\"\n    return (test_tup1[0], test_tup2[0],) + (test_tup1[1:], test_tup2[1:])"}
{"id": "71_0", "code": "import math\n\ndef volume_sphere(r):\n    \"\"\"\n    Calculate the volume of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    # Check if the radius is negative\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    # Calculate the volume using the formula V = (4/3)πr³\n    volume = (4/3) * math.pi * (r ** 3)\n\n    return volume"}
{"id": "72_0", "code": "def get_Char(strr):\n    \"\"\"\n    This function generates a character by adding all the characters of the given string.\n    \n    Parameters:\n    strr (str): The input string.\n    \n    Returns:\n    str: The generated character.\n    \"\"\"\n    # Initialize the result character\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in strr:\n        # Add the character to the result\n        result += char\n    \n    # Return the generated character\n    return result"}
{"id": "73_0", "code": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is a sequence of numbers generated by\n    the following recurrence relation:\n    a_n = 2a_{n-1} + 1\n    a_1 = 1\n\n    Args:\n        n (int): The position of the number in the sequence.\n\n    Returns:\n        int: The n-th number in the sequence.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return 2 * sequence(n - 1) + 1"}
{"id": "74_0", "code": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    Args:\n    n (int): The position of the centered hexagonal number.\n\n    Returns:\n    int: The nth centered hexagonal number.\n    \"\"\"\n    # Initialize the first hexagonal number\n    hex_num = 1\n    \n    # Calculate the nth centered hexagonal number\n    for i in range(1, n):\n        # Calculate the current hexagonal number\n        hex_num = hex_num * (2 * i - 1) + 1\n    \n    return hex_num"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merge three dictionaries into a single expression.\n\n    Args:\n        dict1 (dict): The first dictionary to merge.\n        dict2 (dict): The second dictionary to merge.\n        dict3 (dict): The third dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from the input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n\n    # Iterate over the key-value pairs in the first dictionary\n    for key, value in dict1.items():\n        # Add the key-value pair to the merged dictionary\n        merged_dict[key] = value\n\n    # Iterate over the key-value pairs in the second dictionary\n    for key, value in dict2.items():\n        # Add the key-value pair to the merged dictionary, overwriting any existing value\n        merged_dict[key] = value\n\n    # Iterate over the key-value pairs in the third dictionary\n    for key, value in dict3.items():\n        # Add the key-value pair to the merged dictionary, overwriting any existing value\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    freq_dict = {}\n    for item in list1:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"id": "78_0", "code": "def closest_num(N):\n    \"\"\"\n    Returns the closest smaller number than N.\n\n    Args:\n        N (int): The input number.\n\n    Returns:\n        int: The closest smaller number than N.\n    \"\"\"\n    if N <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    if N == 1:\n        return 0\n    if N == 2:\n        return 1\n    if N == 3:\n        return 2\n    if N == 4:\n        return 3\n    if N == 5:\n        return 4\n    if N == 6:\n        return 5\n    if N == 7:\n        return 6\n    if N == 8:\n        return 7\n    if N == 9:\n        return 8\n    if N == 10:\n        return 9\n    if N == 11:\n        return 10\n    if N == 12:\n        return 11\n    if N == 13:\n        return 12\n    if N == 14:\n        return 13\n    if N == 15:\n        return 14\n    if N == 16:\n        return 15\n    if N == 17:\n        return 16\n    if N == 18:\n        return 17\n    if N == 19:\n        return 18\n    if N == 20:\n        return 19\n    if N == 21:\n        return 20\n    if N == 22:\n        return 21\n    if N == 23:\n        return 22\n    if N == 24:\n        return 23\n    if N == 25:\n        return 24\n    if N == 26:\n        return 25\n    if N == 27:\n        return 26\n    if N == 28:\n        return 27\n    if N == 29:\n        return 28\n    if N == 30:\n        return 29\n    if N == 31:\n        return 30\n    if N == 32:\n        return 31\n    if N == 33:\n        return 32\n    if N == 34:\n        return 33\n    if N == 35:\n        return 34\n    if N == 36:\n        return 35\n    if N == 37:\n        return 36\n    if N == 38:\n        return 37\n    if N == 39:\n        return 38\n    if N == 40:\n        return 39\n    if N == 41:\n        return 40\n    if N == 42:\n        return 41\n    if N == 43:\n        return 42\n    if N == 44:\n        return 43\n    if N == 45:\n        return 44\n    if N == 46:\n        return 45\n    if N == 47:\n        return 46\n    if N == 48:\n        return 47\n    if N == 49:\n        return 48\n    if N == 50:\n        return 49\n    if N == 51:\n        return 50\n    if N == 52:\n        return 51\n    if N == 53:\n        return 52\n    if N == 54:\n        return 53\n    if N == 55:\n        return 54\n    if N == 56:\n        return 55\n    if N == 57:\n        return 56\n    if N == 58:\n        return 57\n    if N == 59:\n        return 58\n    if N == 60:\n        return 59\n    if N == 61:\n        return 60\n    if N == 62:\n        return 61\n    if N == 63:\n        return 62\n    if N == 64:\n        return 63\n    if N == 65:\n        return 64\n    if N == 66:\n        return 65\n    if N == 67:\n        return 66\n    if N == 68:\n        return 67\n    if N == 69:\n        return 68\n    if N == 70:\n        return 69\n    if N == 71:\n        return 70\n    if N == 72:\n        return 71\n    if N == 73:\n        return 72\n    if N == 74:\n        return 73\n    if N == 75:\n        return 74\n    if N == 76:\n        return 75\n    if N == 77:\n        return 76\n    if N == 78:\n        return 77\n    if N == 79:\n        return 78\n    if N == 80:\n        return 79\n    if N"}
{"id": "79_0", "code": "def len_log(lst):\n    \"\"\"\n    This function calculates the length of the longest word in a given list.\n\n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        int: The length of the longest word in the list.\n    \"\"\"\n    # Split the list into words\n    words = lst.split()\n\n    # Initialize the maximum length to 0\n    max_len = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # If the word is not empty\n        if word:\n            # Update the maximum length\n            max_len = max(max_len, len(word))\n\n    # Return the maximum length\n    return max_len"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    \"\"\"\n    Checks if a given substring is present in a list of strings.\n\n    Args:\n        str1 (list): A list of strings.\n        sub_str (str): The substring to be searched.\n\n    Returns:\n        bool: True if the substring is found, False otherwise.\n    \"\"\"\n    # Convert the list of strings to a set for efficient lookups\n    str_set = set(str1)\n    \n    # Check if the substring is present in the set\n    return sub_str in str_set"}
{"id": "81_0", "code": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Check if the number is odd\n    if n % 2 != 0:\n        return False\n\n    # Check if the number is even\n    if n % 2 == 0:\n        return True\n\n    # If the number is neither odd nor even, it's not undulating\n    return False"}
{"id": "82_0", "code": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Args:\n        a (float): The base number.\n        b (int): The exponent.\n\n    Returns:\n        float: The result of 'a' to the power 'b'.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, int):\n        raise TypeError(\"Both 'a' and 'b' must be numbers.\")\n    if b < 0:\n        return 1 / power(a, -b)\n    elif b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    # Initialize minimum index and minimum value\n    min_index = float('inf')\n    min_value = float('inf')\n\n    # Iterate through the list\n    for i, value in enumerate(test_list):\n        # Check if the value is less than the current minimum\n        if value < min_value:\n            # Update the minimum index and value\n            min_index = i\n            min_value = value\n\n    # Return the minimum index and value\n    return min_index, min_value"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    \"\"\"\n    This function finds the minimum length of a sublist in a given list.\n\n    Args:\n        lst (list): A list of elements.\n\n    Returns:\n        int: The minimum length of a sublist in the given list.\n    \"\"\"\n    if not lst:\n        return 0\n\n    min_length = float('inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            sub_list = lst[i:j]\n            if len(sub_list) < min_length:\n                min_length = len(sub_list)\n\n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    # Initialize a dictionary to store the frequency of each element in the list\n    freq_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in list1:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in freq_dict:\n                freq_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                freq_dict[element] = 1\n    \n    # Return the dictionary with the frequency count of each element\n    return freq_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary equivalent.\n\n    Args:\n        n (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary equivalent of the input decimal number.\n    \"\"\"\n    # Convert the decimal number to binary using built-in bin() function\n    binary = bin(n)[2:]  # Remove the '0b' prefix\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    def is_palindrome_in_range(start, end):\n        for i in range(start, end):\n            if is_palindrome(i):\n                return i\n        return None\n\n    def is_palindrome_in_range_recursive(start, end, memo):\n        if start > end:\n            return None\n        if start == end:\n            return start\n        if memo[start][end] is not None:\n            return memo[start][end]\n        if is_palindrome(start + 1, end):\n            memo[start][end] = start + 1\n            return memo[start][end]\n        memo[start][end] = is_palindrome_in_range_recursive(start + 1, end - 1, memo)\n        return memo[start][end]\n\n    start = 0\n    end = num\n    while True:\n        mid = (start + end) // 2\n        if is_palindrome_in_range_recursive(start, mid, memo):\n            return mid\n        start = mid + 1"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The position of the element to find.\n\n    Returns:\n    int: The kth element in the array.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of bounds\")\n\n    # Use the built-in sorted function to find the kth element\n    return sorted(arr)[k - 1]"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    \"\"\"\n    Convert snake case string to camel case string.\n\n    Args:\n        word (str): The snake case string to be converted.\n\n    Returns:\n        str: The camel case string.\n    \"\"\"\n    # Split the word into words based on the underscore character\n    words = word.split(\"_\")\n\n    # Capitalize the first letter of each word except the first word\n    camel_case_words = [words[0].capitalize()] + [word.capitalize() for word in words[1:]]\n\n    # Join the words back into a single string\n    camel_case_word = \"\".join(camel_case_words)\n\n    return camel_case_word"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    Parameters:\n    n (int): The number of vertices in the graph.\n    m (int): The number of edges in the graph.\n    \n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    # Initialize the Eulerian number\n    euler_num = 0\n    \n    # Calculate the Eulerian number\n    for i in range(n):\n        # For each vertex, add the number of edges incident on it\n        euler_num += m - (n - i) * (n - i - 1) // 2\n    \n    return euler_num"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    # Use lambda function to sort each sublist\n    sorted_list = list(map(lambda x: sorted(x, key=lambda y: y[0]), input_list))\n    return sorted_list"}
{"id": "94_0", "code": "def count(lst):\n    \"\"\"\n    Counts the number of true booleans in the given list.\n\n    Args:\n        lst (list): A list of boolean values.\n\n    Returns:\n        int: The number of true booleans in the list.\n    \"\"\"\n    return sum(1 for elem in lst if elem)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    \"\"\"\n    This function adds the given list to the given tuples.\n\n    Args:\n        test_list (list): The list to be added to the tuples.\n        test_tup (tuple): The tuple to which the list will be added.\n\n    Returns:\n        list: The updated list of tuples.\n    \"\"\"\n    # Convert the tuples to lists\n    test_list = list(test_list)\n    test_tup = list(test_tup)\n\n    # Add the list to the tuples\n    test_list.extend(test_tup)\n    test_tup.extend(test_list)\n\n    # Return the updated list of tuples\n    return test_list, test_tup"}
{"id": "96_0", "code": "def count_Hexadecimal(L, R):\n    \"\"\"\n    Counts the number of hexadecimal numbers within a given range.\n\n    Args:\n        L (int): The lower bound of the range (inclusive).\n        R (int): The upper bound of the range (inclusive).\n\n    Returns:\n        int: The number of hexadecimal numbers within the given range.\n    \"\"\"\n    count = 0\n    for i in range(L, R + 1):\n        if isinstance(i, int) and i >= 0 and i <= 255:\n            count += 1\n    return count"}
{"id": "97_0", "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a min heap with the first element of each list\n    min_heap = [(num1, 0), (num2, 1), (num3, 2)]\n    # Heapify the min heap\n    heapq.heapify(min_heap)\n    # Initialize the result list\n    result = []\n    # While the min heap is not empty\n    while min_heap:\n        # Get the smallest element from the min heap\n        val, idx = heapq.heappop(min_heap)\n        # Append the smallest element to the result list\n        result.append(val)\n        # If the index is not the last element in its list\n        if idx < len(num1):\n            # Push the next element from the same list into the min heap\n            heapq.heappush(min_heap, (num1[idx], idx + 1))\n    # Return the result list\n    return result"}
{"id": "98_0", "code": "def odd_Equivalent(s, n):\n    # Initialize count of rotations\n    count = 0\n    \n    # Loop through the string\n    for i in range(len(s)):\n        # Check if the current character is odd\n        if s[i] % 2 != 0:\n            # Increment the count\n            count += 1\n            \n            # Check if the count is equal to n\n            if count == n:\n                # Return the result\n                return s[i]\n    \n    # If no rotation is found, return None\n    return None"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    \"\"\"\n    Extract the ranges that are missing from the given list with the given start range and end range values.\n\n    Args:\n        test_list (list): The input list of tuples containing start and end values.\n        strt_val (int): The start value of the range.\n        stop_val (int): The end value of the range.\n\n    Returns:\n        list: A list of tuples containing the start and end values of the missing ranges.\n    \"\"\"\n    missing_ranges = []\n    for start, end in test_list:\n        if start < strt_val and end > stop_val:\n            missing_ranges.append((start, end))\n    return missing_ranges"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    \"\"\"\n    This function finds common elements in given nested lists.\n\n    Args:\n        nestedlist (list): A list containing nested lists.\n\n    Returns:\n        list: A list of common elements in the nested lists.\n    \"\"\"\n    def recursive_search(nestedlist):\n        \"\"\"\n        This is a helper function to perform recursive search in the nested list.\n\n        Args:\n            nestedlist (list): A list containing nested lists.\n\n        Returns:\n            list: A list of common elements in the nested lists.\n        \"\"\"\n        common = []\n        for element in nestedlist:\n            if isinstance(element, list):\n                common.extend(recursive_search(element))\n            elif element in common:\n                common.append(element)\n        return common\n\n    return recursive_search(nestedlist)\n\n# Example usage:\nnestedlist = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nprint(common_in_nested_lists(nestedlist))  # Output: [2, 3, 4]"}
{"id": "101_0", "code": "import math\n\ndef perimeter(diameter, height):\n    \"\"\"\n    Calculate the perimeter of a cylinder.\n\n    Parameters:\n    diameter (float): The diameter of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The perimeter of the cylinder.\n    \"\"\"\n    # Calculate the radius\n    radius = diameter / 2\n\n    # Calculate the perimeter\n    perimeter = 2 * math.pi * radius + 2 * math.pi * radius\n\n    return perimeter\n\n# Example usage\ndiameter = 10\nheight = 5\nperimeter = perimeter(diameter, height)\nprint(f\"The perimeter of the cylinder is {perimeter:.2f}\")"}
{"id": "102_0", "code": "def check_integer(text):\n    \"\"\"\n    Checks if a string represents an integer or not.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        # Attempt to convert the string to an integer\n        int(text)\n        return True\n    except ValueError:\n        # If a ValueError is raised, the string does not represent an integer\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    freq_dict = {}\n    for item in test_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    \"\"\"\n    Checks whether all dictionaries in a list are empty or not.\n\n    Args:\n        list1 (list): A list of dictionaries.\n\n    Returns:\n        bool: True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    return all(not any(d.items() for d in list1))"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    \"\"\"\n    Convert a tuple of positive integers into an integer.\n\n    Args:\n        nums (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The integer representation of the input tuple.\n\n    Raises:\n        ValueError: If the input tuple contains non-positive integers.\n    \"\"\"\n    # Check if all elements in the tuple are positive integers\n    if not all(isinstance(num, int) and num > 0 for num in nums):\n        raise ValueError(\"Input tuple must contain only positive integers.\")\n\n    # Convert the tuple to an integer using the built-in int function\n    return int(nums[0])"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    \"\"\"\n    Convert all possible convertible elements in the list to float.\n\n    Args:\n        test_list (list): A list of elements that may contain convertible elements.\n\n    Returns:\n        list: A list of elements that can be converted to float.\n    \"\"\"\n    # Initialize an empty list to store the float elements\n    float_list = []\n\n    # Iterate over each element in the test list\n    for element in test_list:\n        # Check if the element is a convertible element (i.e., it can be converted to float)\n        if isinstance(element, (int, float)):\n            # If it is, append it to the float list\n            float_list.append(element)\n        else:\n            # If it's not, try to convert it to a float\n            try:\n                # Attempt to convert the element to a float\n                float_list.append(float(element))\n            except ValueError:\n                # If the conversion fails, append the original element to the float list\n                float_list.append(element)\n\n    # Return the list of float elements\n    return float_list"}
{"id": "107_0", "code": "def string_to_list(string):\n    \"\"\"\n    Convert a string to a list.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of characters in the input string.\n    \"\"\"\n    return list(string)"}
{"id": "108_0", "code": "def search(arr, n):\n    \"\"\"\n    This function finds the element that appears only once in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of elements.\n    n (int): The number of elements in the array.\n\n    Returns:\n    int: The index of the element that appears only once in the array.\n    \"\"\"\n    # Initialize the left and right pointers\n    left, right = 0, n - 1\n\n    # Traverse the array from both ends\n    while left <= right:\n        # Calculate the mid index\n        mid = (left + right) // 2\n\n        # If the middle element is equal to the last element\n        if arr[mid] == arr[n - 1]:\n            # If the middle element is equal to the first element\n            if mid == 0 or arr[mid - 1] != arr[n - 1]:\n                # Return the index of the middle element\n                return mid\n            # If the middle element is not equal to the first element\n            else:\n                # Move the left pointer to the right\n                left = mid + 1\n        # If the middle element is less than the last element\n        elif arr[mid] < arr[n - 1]:\n            # Move the left pointer to the right\n            left = mid + 1\n        # If the middle element is greater than the last element\n        else:\n            # Move the right pointer to the left\n            right = mid - 1\n\n    # If no element appears only once\n    return -1"}
{"id": "109_0", "code": "def max_product_tuple(lst):\n    \"\"\"\n    This function finds the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        int: The maximum product from the pairs of tuples.\n    \"\"\"\n    # Initialize max_product and min_product variables\n    max_product = float('-inf')\n    min_product = float('inf')\n\n    # Iterate over each tuple in the list\n    for tup in lst:\n        # Unpack the tuple into two variables\n        a, b = tup\n\n        # Update max_product and min_product if necessary\n        max_product = max(max_product, a * b)\n        min_product = min(min_product, a * b)\n\n    # Return the maximum product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    # Iterate through the array\n    for i in range(n - 2):\n        # Initialize two pointers\n        left, right = i + 1, n - 1\n        # Iterate until the two pointers meet\n        while left < right:\n            # Calculate the current sum\n            current_sum = A[i] + A[left] + A[right]\n            # If the current sum is equal to the given sum, increment the count\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            # If the current sum is less than the given sum, move the left pointer to the right\n            elif current_sum < sum:\n                left += 1\n            # If the current sum is greater than the given sum, move the right pointer to the left\n            else:\n                right -= 1\n    # Return the count\n    return count"}
{"id": "111_0", "code": "def smartNumber(n):\n    \"\"\"\n    Generates the nth smart number.\n\n    A smart number is a number that is equal to the sum of its digits.\n\n    Args:\n        n (int): The position of the smart number to generate.\n\n    Returns:\n        int: The nth smart number.\n    \"\"\"\n    # Initialize the smart number\n    smart_num = 0\n\n    # Loop through each digit of the number\n    for digit in range(1, n + 1):\n        # Convert the digit to a string to easily access each digit\n        digit_str = str(digit)\n        # Add the digit to the smart number\n        smart_num += int(digit_str)\n\n    # Return the nth smart number\n    return smart_num"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to the specified limit.\n\n    Args:\n        limit (int): The upper limit for the amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers.\n    \"\"\"\n    amicable_numbers = []\n    for num in range(1, limit + 1):\n        # Check if the number is amicable\n        if is_amicable(num, limit):\n            amicable_numbers.append(num)\n    return sum(amicable_numbers)\n\ndef is_amicable(num, limit):\n    \"\"\"\n    Checks if a number is amicable.\n\n    Args:\n        num (int): The number to check.\n        limit (int): The upper limit.\n\n    Returns:\n        bool: True if the number is amicable, False otherwise.\n    \"\"\"\n    # Initialize the sum of the amicable numbers\n    total = 0\n    # Iterate over all numbers from 1 to the limit\n    for i in range(1, limit + 1):\n        # Check if the current number is a multiple of the previous number\n        if i * i == num:\n            # If it is, add the number to the sum\n            total += num\n    # Return True if the sum is equal to the limit, False otherwise\n    return total == limit\n\n# Example usage:\nprint(amicable_numbers_sum(1000))"}
{"id": "113_0", "code": "import math\n\ndef angle_complex(a, b):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    # Calculate the magnitude of the complex number\n    magnitude = math.sqrt(a**2 + b**2)\n\n    # Calculate the angle using the arctangent function\n    angle = math.atan2(b, a)\n\n    return angle\n\n# Example usage:\nprint(angle_complex(3, 4))  # Output: 0.9272952180016122"}
{"id": "114_0", "code": "def find_length(string, n):\n    \"\"\"\n    This function finds the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\n    Args:\n        string (str): The input binary string.\n        n (int): The length of the sub-string.\n\n    Returns:\n        int: The maximum difference between the number of 0s and number of 1s in any sub-string.\n    \"\"\"\n    max_diff = 0\n    for i in range(len(string) - n + 1):\n        count_0 = string[i].count('0')\n        count_1 = string[i + n].count('1')\n        diff = abs(count_0 - count_1)\n        max_diff = max(max_diff, diff)\n    return max_diff"}
{"id": "115_0", "code": "def sum(a, b):\n    \"\"\"\n    This function calculates the sum of common divisors of two given numbers.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The sum of common divisors of a and b.\n    \"\"\"\n    # Initialize the sum of common divisors to 0\n    common_divisor_sum = 0\n\n    # Iterate over all numbers from 1 to the smaller of a and b\n    for i in range(1, min(a, b) + 1):\n        # Check if i is a divisor of both a and b\n        if a % i == 0 and b % i == 0:\n            # If i is a common divisor, add it to the sum\n            common_divisor_sum += i\n\n    # Return the sum of common divisors\n    return common_divisor_sum"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    # Initialize result variable\n    result = 0\n    \n    # Loop through each digit of x and y\n    for i in range(max(len(str(x)), len(str(y)))): \n        # Add the product of the current digits to the result\n        result += x * y * (10 ** i)\n    \n    return result"}
{"id": "117_0", "code": "def long_words(n, str):\n    \"\"\"\n    Returns a list of words that are longer than n from the given list of words.\n\n    Args:\n        n (int): The length of the words to be shortlisted.\n        str (list): The list of words.\n\n    Returns:\n        list: A list of words that are longer than n.\n    \"\"\"\n    # Convert the input list to a set for efficient lookups\n    word_set = set(str)\n\n    # Use list comprehension to generate the list of long words\n    long_words = [word for word in word_set if len(word) > n]\n\n    return long_words"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    \"\"\"\n    This function generates a magic square and checks if it's valid.\n\n    Args:\n    my_matrix (list): A 2D list representing the magic square.\n\n    Returns:\n    bool: True if the magic square is valid, False otherwise.\n    \"\"\"\n    # Check if the input is a 2D list\n    if not isinstance(my_matrix, list) or not all(isinstance(row, list) for row in my_matrix):\n        return False\n\n    # Check if the input is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the sum of each row is equal to the sum of each column\n    for row in my_matrix:\n        if sum(row) != sum(my_matrix[0]):\n            return False\n\n    # Check if the sum of each diagonal is equal to the sum of the other diagonal\n    for i in range(len(my_matrix)):\n        if my_matrix[i][i] != my_matrix[i][len(my_matrix) - i - 1]:\n            return False\n\n    return True"}
{"id": "119_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum frequency.\n    \"\"\"\n    # Create a dictionary to store the frequency of each item\n    freq_dict = {}\n    for num in nums:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the maximum frequency\n    max_freq = max(freq_dict.values())\n\n    # Find the item with maximum frequency\n    max_item = [key for key, value in freq_dict.items() if value == max_freq]\n\n    return max_item[0]"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    str1 = str1.replace(' ', '')  # remove spaces\n    str1 = str1.lower()  # convert to lowercase\n    str1 = ''.join([char for char in str1 if char in vowels])  # remove vowels\n    str1 = str1[::-1]  # reverse the string\n    str1 = ''.join([char for char in str1 if char in vowels])  # remove vowels\n    return str1"}
{"id": "121_0", "code": "def tup_string(tup1):\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(lambda x: x if x < 0 else 0 for x in nums)"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    \"\"\"\n    Checks whether the last element of given array is even or odd after performing an operation p times.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The number of operations to be performed.\n    p (int): The number of times the operation is performed.\n\n    Returns:\n    bool: True if the last element is even after p operations, False otherwise.\n    \"\"\"\n    # Perform the operation p times\n    for _ in range(p):\n        # Get the last element of the array\n        last_element = arr[-1]\n        \n        # Check if the last element is even or odd\n        if last_element % 2 == 0:\n            # If the last element is even, return True\n            return True\n        else:\n            # If the last element is odd, return False\n            return False\n\n    # If the operation is not performed for all n times, return False\n    return False"}
{"id": "124_0", "code": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    Args:\n        n (int): The position of the hexagonal number to calculate.\n\n    Returns:\n        int: The nth hexagonal number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    else:\n        return n * (2 * n - 1)"}
{"id": "125_0", "code": "def cal_electbill(units):\n    \"\"\"\n    Calculate electricity bill.\n\n    Parameters:\n    units (float): The amount of electricity consumed in units.\n\n    Returns:\n    float: The electricity bill.\n    \"\"\"\n    # Define the electricity rate per unit\n    electricity_rate = 0.10  # dollars per unit\n\n    # Calculate the electricity bill\n    bill = units * electricity_rate\n\n    return bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    \"\"\"\n    This function calculates the ratio of zeroes in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of zeroes in the array.\n    \"\"\"\n    # Initialize count of zeroes\n    zero_count = 0\n\n    # Iterate through the array\n    for num in nums:\n        # Check if the number is zero\n        if num == 0:\n            # Increment the count of zeroes\n            zero_count += 1\n\n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n\n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Initialize a variable to store the result\n    result = False\n\n    # Iterate over all possible powers of 2\n    for i in range(32):\n        # Calculate the current power of 2\n        power_of_two = 2 ** i\n\n        # Check if the current power of 2 is less than or equal to the input number\n        if power_of_two > n:\n            break\n\n        # Check if the difference between the input number and the current power of 2 is also a power of 2\n        if n - power_of_two >= 0 and (n - power_of_two) & (n - power_of_two - 1) == 0:\n            result = True\n            break\n\n    return result"}
{"id": "128_0", "code": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Calculate the circumference of a circle.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    \"\"\"\n    Extract elements that occur singly in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of elements that occur singly in the given tuple list.\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n\n    # Iterate over each tuple in the test list\n    for tup in test_list:\n        # Check if the tuple has only one element\n        if len(tup) == 1:\n            # Append the element to the extracted_elements list\n            extracted_elements.append(tup[0])\n\n    # Return the extracted_elements list\n    return extracted_elements"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    \"\"\"\n    Sorts a list of elements using pancake sort.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        # Find the largest element in the unsorted part of the list\n        max_idx = i\n        for j in range(i + 1, n):\n            if nums[j] > nums[max_idx]:\n                max_idx = j\n\n        # If the largest element is not at the beginning of the unsorted part,\n        # we need to move it to the beginning of the unsorted part\n        if max_idx != i:\n            # Find the largest element in the unsorted part of the list\n            max_idx = i\n            for j in range(i + 1, n):\n                if nums[j] > nums[max_idx]:\n                    max_idx = j\n\n            # Swap the largest element with the first element of the unsorted part\n            nums[i], nums[max_idx] = nums[max_idx], nums[i]\n\n            # If the largest element is not at the beginning of the unsorted part,\n            # we need to move it to the beginning of the unsorted part\n            if max_idx != i:\n                # Find the largest element in the unsorted part of the list\n                max_idx = i\n                for j in range(i + 1, n):\n                    if nums[j] > nums[max_idx]:\n                        max_idx = j\n\n                # Swap the largest element with the first element of the unsorted part\n                nums[i], nums[max_idx] = nums[max_idx], nums[i]\n\n    return nums"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the same pair in three given lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        int: The number of same pairs in the three lists.\n    \"\"\"\n    # Initialize a counter for the same pairs\n    same_pairs = 0\n\n    # Iterate over the elements of the first list\n    for i in list1:\n        # Iterate over the elements of the second list\n        for j in list2:\n            # Check if the current pair is the same as the pair in the third list\n            if i == j and i in list3:\n                # If it is, increment the counter\n                same_pairs += 1\n\n    # Return the total number of same pairs\n    return same_pairs"}
{"id": "132_0", "code": "def find_lists(Input):\n    # Initialize a counter for the number of lists\n    count = 0\n    \n    # Iterate over the tuple\n    for item in Input:\n        # Check if the item is a list\n        if isinstance(item, list):\n            # Increment the counter\n            count += 1\n    \n    # Return the count\n    return count"}
{"id": "133_0", "code": "def sum_Pairs(arr, n):\n    # Initialize the sum of absolute differences\n    total_sum = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # Iterate over the array starting from the next index\n        for j in range(i + 1, n):\n            # Calculate the absolute difference\n            diff = abs(arr[i] - arr[j])\n            # Add the difference to the total sum\n            total_sum += diff\n    \n    # Return the total sum\n    return total_sum\n\n# Example usage:\narr = [1, 2, 3, 4, 5]\nn = len(arr)\nprint(sum_Pairs(arr, n))  # Output: 10"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    \"\"\"\n    This function calculates the maximum absolute difference between any two elements in an array.\n\n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The size of the input list.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    # Initialize the minimum and maximum values\n    min_val = float('inf')\n    max_val = float('-inf')\n\n    # Iterate through the array to find the minimum and maximum values\n    for num in arr:\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n\n    # Calculate the absolute difference between the minimum and maximum values\n    abs_diff = max_val - min_val\n\n    return abs_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    return sum(ord(c) for c in str1)"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    \"\"\"\n    Find the maximum total path sum in the given triangle.\n\n    Args:\n    tri (list): A list of lists representing the triangle.\n    m (int): The number of rows in the triangle.\n    n (int): The number of columns in the triangle.\n\n    Returns:\n    int: The maximum total path sum in the triangle.\n    \"\"\"\n    # Initialize the maximum path sum\n    max_sum = float('-inf')\n\n    # Iterate over each row in the triangle\n    for row in tri:\n        # Initialize the current row sum\n        curr_sum = 0\n\n        # Iterate over each element in the row\n        for i in range(m):\n            # Add the current element to the current row sum\n            curr_sum += row[i]\n\n            # Update the maximum path sum if the current row sum is greater\n            max_sum = max(max_sum, curr_sum)\n\n            # If the current row sum exceeds the maximum path sum, break the loop\n            if curr_sum > max_sum:\n                break\n\n    # Return the maximum path sum\n    return max_sum"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    \"\"\"\n    This function generates two parts of a number such that the sum of digits is maximum.\n    \n    Parameters:\n    N (int): The input number.\n    \n    Returns:\n    tuple: A tuple containing two parts of the number.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_N = str(N)\n    \n    # Initialize two variables to store the maximum sum and the corresponding parts\n    max_sum = 0\n    max_parts = None\n    \n    # Iterate over all possible lengths of the first part\n    for i in range(1, len(str_N) + 1):\n        # Calculate the sum of digits for the current length\n        sum_i = sum(int(digit) for digit in str_N[:i])\n        \n        # If the sum is greater than the current maximum, update the maximum\n        if sum_i > max_sum:\n            max_sum = sum_i\n            max_parts = (str_N[:i], str_N[i:])\n    \n    # Return the two parts with the maximum sum\n    return max_parts"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    \"\"\"\n    This function generates the longest subsequence in the given array such that the difference between adjacent elements is one.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    list: The longest subsequence with a difference of one between adjacent elements.\n    \"\"\"\n    # Initialize a 2D array to store the longest subsequence ending at each position\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize a 2D array to store the previous element in the longest subsequence ending at each position\n    prev = [[None] * n for _ in range(n)]\n    \n    # Initialize the maximum length of the subsequence and its ending position\n    max_len = 0\n    max_end = 0\n    \n    # Fill the dp and prev arrays using dynamic programming\n    for i in range(n):\n        for j in range(i):\n            # If the difference between the current elements is one, update the dp and prev arrays\n            if abs(arr[i] - arr[j]) == 1:\n                if dp[i][j] + 1 > dp[i][max_end]:\n                    dp[i][max_end] = dp[i][j] + 1\n                    prev[i][max_end] = j\n                elif dp[i][j] + 1 == dp[i][max_end]:\n                    prev[i][max_end] = max(prev[i][max_end], j)\n    \n    # Reconstruct the longest subsequence from the prev array\n    subseq = []\n    i, j = max_end, n - 1\n    while i >= 0 and j >= 0:\n        if prev[i][j] is not None:\n            subseq.append(arr[i])\n            i = prev[i][j]\n        else:\n            j -= 1\n    \n    # Return the longest subsequence in the correct order\n    return subseq[::-1]\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(arr)\nprint(longest_subseq_with_diff_one(arr, n))  # Output: [1, 2, 3, 4, 5]"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    \"\"\"\n    Checks if the given number is present in the infinite sequence.\n\n    Args:\n        a (int): The first number in the sequence.\n        b (int): The second number in the sequence.\n        c (int): The third number in the sequence.\n\n    Returns:\n        bool: True if the given number is present in the sequence, False otherwise.\n    \"\"\"\n    # Generate the infinite sequence\n    sequence = [a, b, c]\n    # Check if the given number is present in the sequence\n    return a in sequence"}
{"id": "140_0", "code": "def is_coprime(x, y):\n    \"\"\"\n    Checks whether two numbers are co-prime or not.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        bool: True if the numbers are co-prime, False otherwise.\n    \"\"\"\n    # Check if x and y are positive integers\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both inputs must be positive.\")\n\n    # Calculate the greatest common divisor (GCD)\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Check if the GCD is 1\n    return gcd(x, y) == 1"}
{"id": "141_0", "code": "def merge_sort(x):\n    # Base case: If the array has one or zero elements, it is already sorted\n    if len(x) <= 1:\n        return x\n\n    # Find the middle index of the array\n    mid = len(x) // 2\n\n    # Divide the array into two halves\n    left_half = x[:mid]\n    right_half = x[mid:]\n\n    # Recursively sort the two halves\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the two sorted halves\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    # Initialize an empty list to store the merged result\n    merged = []\n\n    # Initialize indices for the left and right halves\n    left_index = 0\n    right_index = 0\n\n    # Merge the two halves\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    # Append any remaining elements from the left and right halves\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculate the vertex of a parabola given its coefficients.\n\n    Parameters:\n    a (float): The coefficient of the x^2 term.\n    b (float): The coefficient of the x term.\n    c (float): The constant term.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the vertex.\n    \"\"\"\n    # Calculate the x-coordinate of the vertex using the formula -b / (2a)\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex using the formula c / (4a)\n    y_vertex = c / (4 * a)\n    \n    return x_vertex, y_vertex"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extract every specified element from a given two dimensional list.\n\n    Args:\n        nums (list): A two dimensional list of elements.\n        N (int): The number of elements to extract.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        return []\n\n    # Check if the number of elements to extract is valid\n    if N > len(nums):\n        raise ValueError(\"Number of elements to extract is greater than the number of elements in the list.\")\n\n    # Extract the specified elements\n    extracted_elements = [nums[i][j] for i in range(N) for j in range(len(nums[i]))]\n\n    return extracted_elements"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    Toggles all even bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all even bits toggled.\n    \"\"\"\n    result = 0\n    while n:\n        # Get the last bit of n\n        last_bit = n & 1\n        # Toggle the last bit\n        result |= 1 << last_bit\n        # Remove the last bit from n\n        n >>= 1\n    return result"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    \"\"\"\n    Convert a tuple of string values to a tuple of integer values.\n\n    Args:\n        tuple_str (tuple): A tuple of string values.\n\n    Returns:\n        tuple: A tuple of integer values.\n    \"\"\"\n    return tuple(int(val) for val in tuple_str)"}
{"id": "146_0", "code": "def encode_list(list1):\n    \"\"\"\n    This function encodes a list into a string using run-length encoding.\n\n    Args:\n        list1 (list): The list to be encoded.\n\n    Returns:\n        str: The encoded string.\n    \"\"\"\n    encoded_str = \"\"\n    count_dict = {}\n\n    # Iterate over the list\n    for item in list1:\n        # If the item is already in the dictionary, increment its count\n        if item in count_dict:\n            count_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[item] = 1\n\n    # Iterate over the dictionary items\n    for key, value in count_dict.items():\n        # Append the key and value to the encoded string\n        encoded_str += str(key) + str(value)\n\n    return encoded_str"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    \"\"\"\n    This function calculates the minimum number of operations required to make all elements in the array equal.\n    \n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The size of the input list.\n    k (int): The number of operations required to make all elements equal.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    \n    # Calculate the median of the array\n    median = sorted(arr)[n // 2]\n    \n    # Initialize the count of operations\n    ops = 0\n    \n    # Iterate over the array\n    for num in arr:\n        # Calculate the absolute difference between the current number and the median\n        diff = abs(num - median)\n        \n        # Add the difference to the count of operations\n        ops += diff\n    \n    # Return the minimum number of operations required\n    return ops"}
{"id": "148_0", "code": "def month_season(month, days):\n    # Define a dictionary to map month and day to season\n    season_map = {\n        1: 3,  # January\n        2: 4,  # February\n        3: 5,  # March\n        4: 6,  # April\n        5: 7,  # May\n        6: 8,  # June\n        7: 9,  # July\n        8: 10,  # August\n        9: 11,  # September\n        10: 12,  # October\n        11: 1,  # November\n        12: 2  # December\n    }\n\n    # Check if the month is valid\n    if month not in season_map:\n        print(\"Invalid month\")\n        return\n\n    # Get the season for the given month and day\n    season = season_map[month]\n\n    # Print the season\n    print(f\"The season for the given month and day is {season}.\")\n\n# Test the function\nmonth_season(3, 15)  # March 15"}
{"id": "149_0", "code": "def solution(a, b, n):\n    \"\"\"\n    Finds x and y that satisfies ax + by = n.\n\n    Args:\n        a (float): Coefficient of x\n        b (float): Coefficient of y\n        n (float): Constant term\n\n    Returns:\n        tuple: (x, y) that satisfies ax + by = n\n    \"\"\"\n    # Calculate determinant\n    det = a * b - n\n\n    # If determinant is zero, there is no solution\n    if det == 0:\n        return None\n\n    # Calculate x and y using Cramer's rule\n    x = n / det\n    y = n / det\n\n    return x, y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    \"\"\"\n    Removes all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The list from which elements are to be removed.\n        list2 (list): The list containing elements to be removed.\n\n    Returns:\n        list: The modified list1 with elements from list2 removed.\n    \"\"\"\n    # Convert list2 to a set for efficient lookups\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements from list1\n    # that are present in set2\n    return [element for element in list1 if element not in set2]\n\n# Example usage:\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [2, 4]\nprint(remove_elements(list1, list2))  # Output: [1, 3, 5]"}
{"id": "151_0", "code": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0)\n    \n    Parameters:\n    n (int): The upper limit of the series\n    \n    Returns:\n    int: The sum of the positive integers in the series\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        if i >= n:\n            break\n        total += i\n    return total"}
{"id": "152_0", "code": "import math\n\ndef area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (float): The number of sides of the polygon.\n    l (float): The length of each side of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the number of sides is valid\n    if s <= 0:\n        raise ValueError(\"The number of sides must be a positive integer.\")\n\n    # Calculate the area using the formula: (n * s * l) / (4 * tan(π/n))\n    area = (s * l) / (4 * math.tan(math.pi / s))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    # Function to calculate sum of divisors\n    def sum_of_divisors(n):\n        sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                sum += i\n                if i != n // i:\n                    sum += n // i\n        return sum\n\n    # Check if sum of divisors are same\n    sum1 = sum_of_divisors(num1)\n    sum2 = sum_of_divisors(num2)\n    return sum1 == sum2"}
{"id": "154_0", "code": "def count_char_position(str1):\n    # Convert the string to lowercase\n    str1 = str1.lower()\n    \n    # Initialize an empty dictionary to store the count of characters at the same position\n    char_count = {}\n    \n    # Iterate over the string\n    for i in range(len(str1)):\n        # Get the character at the current position\n        char = str1[i]\n        \n        # Check if the character is an English alphabet\n        if char.isalpha():\n            # If the character is already in the dictionary, increment its count\n            if char in char_count:\n                char_count[char] += 1\n            # If the character is not in the dictionary, add it with a count of 1\n            else:\n                char_count[char] = 1\n    \n    # Return the dictionary with the count of characters at the same position\n    return char_count"}
{"id": "155_0", "code": "def find_even_Pair(A, N):\n    \"\"\"\n    This function counts the pairs with xor as an even number.\n\n    Parameters:\n    A (list): A list of integers\n    N (int): The number of pairs to generate\n\n    Returns:\n    int: The number of pairs with xor as an even number\n    \"\"\"\n    # Initialize count of pairs with even xor\n    count = 0\n\n    # Iterate over all pairs of elements in A\n    for i in range(len(A)):\n        for j in range(i + 1, len(A)):\n            # Check if the xor of the pair is even\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n\n    return count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    power = 1\n    while power < n:\n        power *= 2\n    return power"}
{"id": "157_0", "code": "def frequency(a,x):\n    freq = {}\n    for i in a:\n        if i == x:\n            freq[i] = freq.get(i,0) + 1\n    return freq"}
{"id": "158_0", "code": "def get_pell(n):\n    \"\"\"\n    Calculate the nth Pell number.\n\n    Args:\n        n (int): The index of the Pell number to calculate.\n\n    Returns:\n        int: The nth Pell number.\n    \"\"\"\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    \"\"\"\n    This function calculates the sum of numbers in a list between the specified indices.\n    \n    Parameters:\n    list1 (list): The input list of numbers.\n    m (int): The starting index of the range.\n    n (int): The ending index of the range.\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    # Check if the range is valid\n    if m < 0 or n >= len(list1) or m > n:\n        raise ValueError(\"Invalid range\")\n    \n    # Slice the list to get the desired range\n    range_list = list1[m:n+1]\n    \n    # Calculate the sum of the range\n    total_sum = sum(range_list)\n    \n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # Calculate the perimeter of the pentagon\n    perimeter = 5 * a\n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 's':\n            count += 1\n    return count"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(c for c in text if c.isalnum() or c.isspace())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    \"\"\"\n    Group a sequence of key-value pairs into a dictionary of lists.\n\n    Args:\n        l (list): A list of tuples containing key-value pairs.\n\n    Returns:\n        dict: A dictionary where each key is a unique key from the input list and each value is a list of corresponding values.\n    \"\"\"\n    result = {}\n    for pair in l:\n        key, value = pair\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result"}
{"id": "164_0", "code": "def is_valid_parenthese(str1):\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"id": "165_0", "code": "def perimeter_triangle(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle.\n\n    Args:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of side c.\n\n    Returns:\n        float: The perimeter of the triangle.\n    \"\"\"\n    # Check if the input values are valid\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All side lengths must be positive numbers.\")\n\n    # Calculate the perimeter\n    perimeter = a + b + c\n\n    return perimeter"}
{"id": "166_0", "code": "import math\nfrom itertools import combinations\n\ndef answer(L, R):\n    # Define a helper function to calculate LCM\n    def lcm(a, b):\n        return abs(a*b) // math.gcd(a, b)\n\n    # Generate all pairs of numbers\n    pairs = list(combinations(range(1, L+1), 2))\n\n    # Filter pairs based on the condition\n    valid_pairs = [(a, b) for a, b in pairs if lcm(a, b) >= L and lcm(a, b) <= R]\n\n    # Return the first pair that satisfies the condition\n    for pair in valid_pairs:\n        if pair[0] != pair[1]:\n            return pair\n    return None"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for literals in a given text.\n\n    Args:\n        patterns (list): A list of literal strings to search for.\n        text (str): The text to search in.\n\n    Returns:\n        list: A list of tuples containing the literal strings and their corresponding positions in the text.\n    \"\"\"\n    # Initialize an empty list to store the results\n    results = []\n\n    # Iterate over each pattern\n    for pattern in patterns:\n        # Initialize a flag to check if the pattern is found\n        found = False\n\n        # Iterate over each character in the text\n        for i, char in enumerate(text):\n            # Check if the pattern matches the text at the current position\n            if pattern == text[i:i+len(pattern)]:\n                # If the pattern is found, add the result to the list\n                results.append((pattern, i))\n                # Set the flag to True\n                found = True\n                # Break the loop as we have found the pattern\n                break\n\n        # If the pattern is not found, add a message to the list\n        if not found:\n            results.append((pattern, -1))\n\n    # Return the list of results\n    return results"}
{"id": "168_0", "code": "def is_num_keith(x):\n    \"\"\"\n    Checks if the given number is a Keith number.\n\n    A Keith number is a number that can be expressed as the sum of two squares.\n\n    Parameters:\n    x (int): The number to check.\n\n    Returns:\n    bool: True if the number is a Keith number, False otherwise.\n    \"\"\"\n    # Initialize a list to store the squares of numbers from 1 to sqrt(x)\n    squares = [i**2 for i in range(1, int(x**0.5) + 1)]\n\n    # Check if the number is a Keith number\n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            if squares[i] + squares[j] == x:\n                return True\n\n    return False"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    \"\"\"\n    Calculate the distance between two points on the surface of the Earth using latitude and longitude.\n\n    Parameters:\n    slat (float): The latitude of the first point in degrees.\n    slon (float): The longitude of the first point in degrees.\n    elat (float): The latitude of the second point in degrees.\n    elon (float): The longitude of the second point in degrees.\n\n    Returns:\n    float: The distance between the two points in kilometers.\n    \"\"\"\n    # Convert the latitude and longitude from degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n\n    # Calculate the differences between the latitudes and longitudes\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n\n    # Calculate the Haversine formula\n    a = math.sin(dlat / 2) ** 2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Calculate the radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate the distance\n    distance = R * c\n\n    return distance\n\n# Example usage:\nprint(distance_lat_long(52.5200, 13.4050, 48.8566, 2.3522))"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    # Check if the input array is empty\n    if not arr:\n        return \"\"\n\n    # Sort the array\n    arr.sort()\n\n    # Initialize the prefix as an empty string\n    prefix = \"\"\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is equal to the previous one, add it to the prefix\n        if i == 0 or arr[i] == arr[i - 1]:\n            prefix += arr[i]\n        # If the current element is not equal to the previous one, break the loop\n        else:\n            break\n\n    return prefix"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    # Find uppercase letters\n    uppercase = re.findall(r'[A-Z]', string)\n    \n    # Find lowercase letters\n    lowercase = re.findall(r'[a-z]', string)\n    \n    # Find special characters\n    special_chars = re.findall(r'[^A-Za-z0-9]', string)\n    \n    # Find numeric values\n    numeric = re.findall(r'\\d', string)\n    \n    return uppercase, lowercase, special_chars, numeric"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    \"\"\"\n    Counts all distinct pairs in an array with a difference of k.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the array.\n        k (int): The difference between the pairs.\n\n    Returns:\n        int: The number of distinct pairs with a difference of k.\n    \"\"\"\n    # Sort the array\n    arr.sort()\n\n    # Initialize two pointers, one at the start and one at the end of the array\n    left = 0\n    right = n - 1\n\n    # Initialize a set to store unique pairs\n    pairs = set()\n\n    # Traverse the array using two pointers\n    while left < right:\n        # Calculate the sum of the elements at the current pointers\n        current_sum = arr[left] + arr[right]\n\n        # If the sum is equal to 2 * k, add the pair to the set and move both pointers\n        if current_sum == 2 * k:\n            pairs.add((arr[left], arr[right]))\n            left += 1\n            right -= 1\n        # If the sum is less than 2 * k, move the left pointer to the right\n        elif current_sum < 2 * k:\n            left += 1\n        # If the sum is greater than 2 * k, move the right pointer to the left\n        else:\n            right -= 1\n\n    # Return the number of distinct pairs\n    return len(pairs)"}
{"id": "173_0", "code": "def greater_specificnum(lst, num):\n    \"\"\"\n    This function finds all the values in a list that are greater than a specified number.\n\n    Args:\n        lst (list): The list to search in.\n        num (int): The number to compare against.\n\n    Returns:\n        list: A list of values in the list that are greater than the specified number.\n    \"\"\"\n    return [value for value in lst if value > num]"}
{"id": "174_0", "code": "import math\n\ndef parabola_focus(a, b, c):\n    \"\"\"\n    Calculate the focus of a parabola given its equation in the form y = ax^2 + bx + c.\n\n    Parameters:\n    a (float): coefficient of x^2 term\n    b (float): coefficient of x term\n    c (float): constant term\n\n    Returns:\n    tuple: (focus_x, focus_y)\n    \"\"\"\n    # Calculate the focus of the parabola\n    focus_x = -b / (2 * a)\n    focus_y = c / (4 * a)\n\n    return focus_x, focus_y"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    # Compile regex patterns\n    regex_patterns = [re.compile(pattern) for pattern in patterns]\n    \n    # Search for literals in text\n    for pattern in regex_patterns:\n        matches = pattern.findall(text)\n        print(f\"Literal '{pattern.group(0)}' found: {matches}\")\n    \n    return regex_patterns"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Initialize a 2D array to store the lengths of common subsequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # Reconstruct the longest common subsequence from the dp array\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if X[i - 1] == Y[j - 1]:\n            lcs.append(X[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Return the longest common subsequence in the correct order\n    return \"\".join(reversed(lcs))"}
{"id": "177_0", "code": "import math\n\ndef prod_Square(n):\n    \"\"\"\n    Checks whether the given number can be represented by product of two squares or not.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        bool: True if the number can be represented by product of two squares, False otherwise.\n    \"\"\"\n    # Check if n is less than 0\n    if n < 0:\n        return False\n\n    # Check if n is even\n    if n % 2 == 0:\n        return True\n\n    # Check if n is a perfect square\n    sqrt_n = math.sqrt(n)\n    if sqrt_n == int(sqrt_n):\n        return True\n\n    # Check if n is a perfect square of a prime number\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i ** 2) == 0:\n            return True\n\n    # If none of the above conditions are met, return False\n    return False"}
{"id": "178_0", "code": "def first_Missing_Positive(arr, n):\n    \"\"\"\n    This function generates a list of n positive numbers and returns the first missing positive number.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The number of positive numbers to generate.\n\n    Returns:\n    int: The first missing positive number.\n    \"\"\"\n    # Create a set to store the generated numbers\n    num_set = set()\n    # Initialize the count of generated numbers\n    count = 0\n    # Iterate over the range of n\n    for i in range(n):\n        # Generate a number and add it to the set\n        num_set.add(i)\n        # If the number is not in the set, return it\n        if i not in num_set:\n            return i\n        # Increment the count\n        count += 1\n    # If all numbers are in the set, return the last generated number\n    return count"}
{"id": "179_0", "code": "def count_Intgral_Points(x1,y1,x2,y2):\n    \"\"\"\n    Counts the number of integral points that lie inside a square.\n\n    Args:\n        x1 (int): The x-coordinate of the top-left corner of the square.\n        y1 (int): The y-coordinate of the top-left corner of the square.\n        x2 (int): The x-coordinate of the bottom-right corner of the square.\n        y2 (int): The y-coordinate of the bottom-right corner of the square.\n\n    Returns:\n        int: The number of integral points that lie inside the square.\n    \"\"\"\n    # Calculate the side length of the square\n    side_length = abs(x2 - x1)\n\n    # Initialize a counter for integral points\n    integral_points = 0\n\n    # Iterate over all possible integral points\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            # Check if the point is integral\n            if x % 2 == 0 and y % 2 == 0:\n                integral_points += 1\n\n    return integral_points"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    monthdays = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return monthdays.get(monthname3, 'Invalid month name')"}
{"id": "181_0", "code": "def check_String(str):\n    if not str:\n        return False\n    for char in str:\n        if not (char.isalpha() or char.isdigit()):\n            return False\n    return True"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    \"\"\"\n    Removes duplicates from a given tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        tuple: The tuple with duplicates removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for item in test_tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)"}
{"id": "183_0", "code": "def octal_to_decimal(n):\n    \"\"\"\n    Convert octal number to decimal number.\n\n    Parameters:\n    n (int): The octal number to be converted.\n\n    Returns:\n    int: The decimal equivalent of the input octal number.\n\n    Raises:\n    ValueError: If the input octal number is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input octal number must be a non-negative integer.\")\n\n    # Convert octal to decimal using built-in int function with base 8\n    decimal = int(n, 8)\n\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    # Check if the array is sorted\n    if arr != sorted(arr):\n        raise ValueError(\"The array is not sorted\")\n\n    # Check if the array length is less than 2\n    if n < 2:\n        raise ValueError(\"The array length is less than 2\")\n\n    # Find the first position of the element\n    for i in range(n):\n        if arr[i] == x:\n            return i\n    return -1"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    \"\"\"\n    Removes all tuples with length K from the input list.\n\n    Args:\n        test_list (list): The input list of tuples.\n        K (int): The length of the tuples to be removed.\n\n    Returns:\n        list: The modified list with tuples of length K removed.\n    \"\"\"\n    return [t for t in test_list if len(t) != K]"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the exponentiation of two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple for exponentiation.\n        test_tup2 (tuple): The second tuple for exponentiation.\n\n    Returns:\n        tuple: The result of the exponentiation of the two tuples.\n    \"\"\"\n    # Convert tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n\n    # Perform exponentiation\n    result = 1\n    for i in range(len(list1)):\n        result *= list1[i]**list2[i]\n\n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a, b):\n    # Define the ellipse equation\n    ellipse_equation = lambda x: a * x**2 + b * x + b**2 - a**2 - b**2\n    \n    # Find the vertex of the ellipse\n    vertex_x = -b / (2 * a)\n    vertex_y = a * vertex_x**2 + b * vertex_x + b**2 / 4\n    \n    # Find the maximum x value of the triangle\n    max_x = vertex_x + a\n    \n    # Find the maximum y value of the triangle\n    max_y = vertex_y + b\n    \n    # Find the minimum x value of the triangle\n    min_x = vertex_x - a\n    \n    # Find the minimum y value of the triangle\n    min_y = vertex_y - b\n    \n    # Check if the triangle is valid\n    if min_x < 0 or max_x > 1 or min_y < 0 or max_y > 1:\n        return None\n    \n    # Calculate the area of the triangle\n    area = 0.5 * abs(max_x * (max_y - min_y) + max_y * (max_x - min_x) + min_x * (max_y - min_x))\n    \n    return area\n\n# Example usage:\nprint(largest_triangle(1, 1))"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 less than or equal to the given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The highest power of 2 less than or equal to the given number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2"}
{"id": "189_0", "code": "def position_max(list1):\n    \"\"\"\n    Find all index positions of the maximum values in a given list.\n\n    Args:\n        list1 (list): The input list.\n\n    Returns:\n        list: A list of index positions of the maximum values.\n    \"\"\"\n    max_val = max(list1)\n    max_pos = [i for i, val in enumerate(list1) if val == max_val]\n    return max_pos"}
{"id": "190_0", "code": "def chkList(lst):\n    return len(set(lst)) == len(lst)"}
{"id": "191_0", "code": "def remove_even(str1):\n    \"\"\"\n    This function removes even characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with even characters removed.\n    \"\"\"\n    return ''.join([c for c in str1 if c not in '02468'])"}
{"id": "192_0", "code": "def hamming_Distance(n1, n2):\n    \"\"\"\n    This function calculates the Hamming distance between two integers.\n\n    Args:\n        n1 (int): The first integer.\n        n2 (int): The second integer.\n\n    Returns:\n        int: The Hamming distance between n1 and n2.\n    \"\"\"\n    # Convert the integers to binary strings\n    bin_n1 = bin(n1)[2:]  # Remove the '0b' prefix\n    bin_n2 = bin(n2)[2:]  # Remove the '0b' prefix\n\n    # Initialize the Hamming distance to 0\n    distance = 0\n\n    # Iterate over the characters in the binary strings\n    for bit1, bit2 in zip(bin_n1, bin_n2):\n        # If the bits are different, increment the Hamming distance\n        if bit1 != bit2:\n            distance += 1\n\n    return distance"}
{"id": "193_0", "code": "def count(s, c):\n    \"\"\"\n    Counts the occurrence of a given character in a string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to be searched.\n\n    Returns:\n        int: The number of occurrences of the character in the string.\n    \"\"\"\n    return s.count(c)"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    \"\"\"\n    This function finds the inversions of tuple elements in the given tuple list.\n\n    Args:\n        test_tup (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples containing the inversions of tuple elements.\n    \"\"\"\n    inversions = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i][0] > test_tup[j][0]:\n                inversions.append((test_tup[i], test_tup[j]))\n    return inversions"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    \"\"\"\n    This function concatenates adjacent elements in a tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        tuple: The tuple with adjacent elements concatenated.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    # Check if the tuple has at least two elements\n    if len(test_tup) < 2:\n        raise ValueError(\"Tuple must have at least two elements.\")\n\n    # Initialize an empty list to store the concatenated elements\n    concatenated_list = []\n\n    # Iterate over the tuple\n    for i in range(len(test_tup)):\n        # Check if the current element is the last element in the tuple\n        if i == len(test_tup) - 1:\n            # If it is, append it to the list as is\n            concatenated_list.append(test_tup[i])\n        else:\n            # If it's not, append the current element to the list\n            concatenated_list.append(test_tup[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(concatenated_list)"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    \"\"\"\n    This function generates the longest repeating subsequence in a given string.\n    \n    Parameters:\n    str (str): The input string.\n    \n    Returns:\n    str: The longest repeating subsequence.\n    \"\"\"\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    max_len = 0\n    max_subseq = \"\"\n    \n    # Initialize the first row and column of the dp table\n    for i in range(n):\n        dp[i][i] = 1\n        max_len = 1\n        max_subseq = str[i]\n        \n    # Fill the dp table in a bottom-up manner\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            # If the current subsequence is not empty\n            if dp[i + 1][j - 1] != 0:\n                # If the current subsequence is longer than the previous longest subsequence\n                if length > max_len:\n                    max_len = length\n                    max_subseq = str[i:j + 1]\n                    \n            # If the current subsequence is empty, try all possible subsequences\n            if dp[i][j] == 0:\n                for k in range(i + 1, j):\n                    dp[i][j] = 1 + dp[i][k] + dp[k + 1][j]\n                    if dp[i][j] > max_len:\n                        max_len = dp[i][j]\n                        max_subseq = str[i:j + 1]\n    \n    return max_subseq\n\n# Example usage\nprint(find_longest_repeating_subseq(\"abcabc\"))  # Output: \"abc\"\nprint(find_longest_repeating_subseq(\"abcabcabc\"))  # Output: \"abcabc\""}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    pattern = r'^\\d+(\\.\\d+)?$'\n    return bool(re.match(pattern, num))"}
{"id": "198_0", "code": "import heapq\n\ndef heap_replace(heap, a):\n    # Check if the heap is empty\n    if not heap:\n        return\n\n    # Get the smallest element from the heap\n    smallest = heapq.heappop(heap)\n\n    # Insert the new item into the heap\n    heapq.heappush(heap, a)\n\n    return heap"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    # Define the set of allowed characters\n    allowed_chars = set('abcdefghijklmnopqrstuvwxyz0123456789')\n    \n    # Define the set of characters to check against\n    specific_chars = set('abcdefghijklmnopqrstuvwxyz0123456789')\n    \n    # Check if the string contains only allowed characters\n    if not set(string).issubset(allowed_chars) or set(string).issubset(specific_chars):\n        return False\n    else:\n        return True"}
{"id": "200_0", "code": "def count_Num(n):\n    \"\"\"\n    Counts numbers whose oth and nth bits are set.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        int: The count of numbers whose oth and nth bits are set.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i & j == i and j & n == j:\n                count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of fourth power of n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers.\n\n    Returns:\n        int: The sum of fourth power of n natural numbers.\n    \"\"\"\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Loop through each natural number from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the fourth power of the current number\n        fourth_power = i ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenates two string tuples into a single string.\n\n    Args:\n        test_tup1 (tuple): The first string tuple.\n        test_tup2 (tuple): The second string tuple.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n\n    # Concatenate the lists\n    concatenated_list = list1 + list2\n\n    # Convert the list back to a tuple\n    concatenated_tuple = tuple(concatenated_list)\n\n    # Convert the tuple to a string\n    concatenated_str = ''.join(concatenated_tuple)\n\n    return concatenated_str"}
{"id": "203_0", "code": "import math\n\ndef degree_radian(radian):\n    \"\"\"\n    Convert radians to degrees.\n\n    Args:\n        radian (float): The angle in radians.\n\n    Returns:\n        float: The angle in degrees.\n    \"\"\"\n    return radian * 180 / math.pi"}
{"id": "204_0", "code": "def decode_list(alist):\n    \"\"\"\n    Decodes a run-length encoded given list.\n\n    Args:\n        alist (list): The list to be decoded.\n\n    Returns:\n        list: The decoded list.\n    \"\"\"\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        if alist[i] == 0:\n            decoded_list.append(alist[i + 1])\n            i += 1\n        else:\n            decoded_list.append(alist[i])\n            i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    \"\"\"\n    Checks if list1 is a subset of list2.\n\n    Args:\n        list1 (list): The list to check.\n        list2 (list): The list to check against.\n\n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    def is_subset(sublist, list2):\n        \"\"\"\n        Checks if a sublist is a subset of another list.\n\n        Args:\n            sublist (list): The sublist to check.\n            list2 (list): The list to check against.\n\n        Returns:\n            bool: True if the sublist is a subset of the list, False otherwise.\n        \"\"\"\n        # Check if sublist is empty\n        if not sublist:\n            return True\n\n        # Check if sublist is a subset of list2\n        for item in sublist:\n            if item not in list2:\n                return False\n            list2 = list2.replace(item, '', 1)\n        return True\n\n    # Check if list1 is a subset of list2\n    return is_subset(list1, list2)"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    \"\"\"\n    This function finds the first repeated character in a given string.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        str: The first repeated character in the string. If no repeated character is found, returns None.\n    \"\"\"\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return None"}
{"id": "207_0", "code": "def min_Operations(A, B):\n    \"\"\"\n    This function calculates the minimum number of operations required to make two numbers equal.\n    \n    Parameters:\n    A (int): The first number.\n    B (int): The second number.\n    \n    Returns:\n    int: The minimum number of operations required to make two numbers equal.\n    \"\"\"\n    # Calculate the absolute difference between A and B\n    diff = abs(A - B)\n    \n    # The minimum number of operations is the minimum of the absolute difference and the number of digits in A and B\n    return min(diff, max(len(str(A)), len(str(B))))"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    \"\"\"\n    Extract the maximum and minimum k elements from a given tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n        K (int): The number of elements to extract.\n\n    Returns:\n        tuple: A tuple containing the maximum and minimum k elements.\n    \"\"\"\n    # Check if K is greater than the length of the tuple\n    if K > len(test_tup):\n        raise ValueError(\"K cannot be greater than the length of the tuple\")\n\n    # Extract the k elements\n    k_elements = test_tup[:K]\n\n    # Find the maximum and minimum k elements\n    max_k_element = max(k_elements)\n    min_k_element = min(k_elements)\n\n    return max_k_element, min_k_element"}
{"id": "209_0", "code": "def replace_max_specialchar(text, n):\n    \"\"\"\n    Replace maximum n occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        text (str): The input text.\n        n (int): The maximum number of occurrences.\n\n    Returns:\n        str: The modified text with maximum n occurrences replaced.\n    \"\"\"\n    # Initialize counters for spaces, commas, and dots\n    space_count = 0\n    comma_count = 0\n    dot_count = 0\n\n    # Initialize the result string\n    result = \"\"\n\n    # Iterate over each character in the text\n    for char in text:\n        # Check if the character is a space, comma, or dot\n        if char in [' ', ',', '.']:\n            # Increment the corresponding counter\n            if char == ' ':\n                space_count += 1\n            elif char == ',':\n                comma_count += 1\n            elif char == '.':\n                dot_count += 1\n            # Append the character to the result string\n            result += char\n        else:\n            # If the character is not a special character, append it to the result string\n            result += char\n\n    # Calculate the maximum number of occurrences of spaces, commas, and dots\n    max_count = min(space_count, min(comma_count, dot_count))\n\n    # Replace the maximum number of occurrences with a colon\n    for i in range(max_count):\n        result = result[:i] + ':' + result[i:]\n\n    return result"}
{"id": "210_0", "code": "def first_even(nums):\n    \"\"\"\n    Find the first even number in a given list of numbers.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The first even number in the list. If no even number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    \"\"\"\n    This function checks if all the elements in a tuple have same data type.\n\n    Args:\n        test_tuple (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if all elements have same data type, False otherwise.\n    \"\"\"\n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Iterate over the rest of the tuple\n    for element in test_tuple[1:]:\n        # If the type of the current element is different from the first type, return False\n        if type(element) != first_type:\n            return False\n    \n    # If the function hasn't returned False, all elements have same data type\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    # Check if the array is empty\n    if n == 0:\n        return False\n\n    # Check if the array is sorted\n    if arr != sorted(arr):\n        return False\n\n    # Find the majority element\n    count = 0\n    for i in range(n):\n        if arr[i] == x:\n            count += 1\n        if count > n // 2:\n            break\n    else:\n        return x\n\n    # Check if the majority element is the actual majority element\n    for i in range(n):\n        if arr[i] == x:\n            return True\n    return False"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    \"\"\"\n    Counts the number of set bits in a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number of set bits in the input number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr,low,high):\n    if low == high:\n        return arr[low]\n    else:\n        mid = (low + high) // 2\n        if arr[mid] > arr[high]:\n            return find_Min(arr, low, mid - 1)\n        else:\n            return find_Min(arr, mid + 1, high)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    \"\"\"\n    This function removes characters from the input string which have odd index values.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The modified string with characters having odd index values removed.\n    \"\"\"\n    return ''.join([c for i, c in enumerate(str) if i % 2 == 0])"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    if a <= b <= c:\n        return a\n    elif b <= a <= c:\n        return b\n    else:\n        return c"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    \"\"\"\n    Checks whether all bits are set in the given range.\n\n    Args:\n        n (int): The number of bits.\n        l (int): The lower bound of the range (inclusive).\n        r (int): The upper bound of the range (inclusive).\n\n    Returns:\n        bool: True if all bits are set, False otherwise.\n    \"\"\"\n    # Calculate the number of bits in the range\n    num_bits = r - l + 1\n\n    # Check if the number of bits is even\n    if num_bits % 2 != 0:\n        return False\n\n    # Check if all bits are set\n    for i in range(num_bits):\n        if (n >> i) & 1:\n            return False\n\n    return True"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    # Separate negative and positive elements\n    negative = [x for x in arr if x < 0]\n    positive = [x for x in arr if x >= 0]\n\n    # Combine the two lists\n    result = negative + positive\n\n    # Sort the combined list\n    result.sort()\n\n    # Return the result\n    return result"}
{"id": "219_0", "code": "def replace_blank(str1, char):\n    \"\"\"\n    Replace blank spaces in a string with any character.\n\n    Args:\n        str1 (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return str1.replace(' ', char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    \"\"\"\n    Find the maximum sum in the given right triangle of numbers.\n\n    Parameters:\n    tri (list): A list of numbers representing the right triangle.\n    n (int): The number of elements in the triangle.\n\n    Returns:\n    int: The maximum sum in the triangle.\n    \"\"\"\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the triangle\n    for num in tri:\n        # Update the current sum\n        current_sum += num\n\n        # Update the maximum sum if necessary\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"}
{"id": "221_0", "code": "import heapq\n\ndef larg_nnum(list1, n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n\n    Args:\n        list1 (list): The input dataset.\n        n (int): The number of largest items to return.\n\n    Returns:\n        list: A list of the n largest items in the dataset.\n    \"\"\"\n    # Use heapq.nlargest to get the n largest items\n    return heapq.nlargest(n, list1)\n\n# Example usage:\ndata = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nn = 5\nprint(larg_nnum(data, n))  # Output: [100, 90, 80, 70, 60]"}
{"id": "222_0", "code": "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    # Calculate the lateral surface area using the formula: 2 * pi * r * h\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n\n# Example usage:\nr = 5  # radius of the cylinder\nh = 10  # height of the cylinder\nprint(lateralsuface_cylinder(r, h))  # Output: 314.1592653589793"}
{"id": "223_0", "code": "def volume_cube(length):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Args:\n        length (float): The length of the cube.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return length ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all even bits set.\n    \"\"\"\n    # Initialize the result with the input number\n    result = n\n\n    # Loop through each bit in the number\n    while n > 0:\n        # Check if the least significant bit is even\n        if n & 1:\n            # If it's even, set the least significant bit to 1\n            result |= 1 << (n & 31)\n        # Move to the next bit\n        n >>= 1\n\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Initialize a list to store the number of triangles for each sub-triangle\n    dp = [0]*(N+1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    \n    # Generate the list of dp values\n    for i in range(3, N+1):\n        dp[i] = 0\n        for j in range(1, min(i//2, K)+1):\n            dp[i] += dp[i-j*2]\n    \n    # Return the maximum number of triangles\n    return max(dp[N:])"}
{"id": "226_0", "code": "def check_occurences(test_list):\n    \"\"\"\n    This function checks the occurrences of records which occur similar times in the given tuples.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains a key-value pair.\n\n    Returns:\n        dict: A dictionary where the keys are the keys from the tuples and the values are the counts of occurrences.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts of occurrences\n    counts = {}\n\n    # Iterate over each tuple in the test list\n    for tup in test_list:\n        # Iterate over each key-value pair in the tuple\n        for key, value in tup:\n            # If the key is already in the counts dictionary, increment its count\n            if key in counts:\n                counts[key] += 1\n            # If the key is not in the counts dictionary, add it with a count of 1\n            else:\n                counts[key] = 1\n\n    # Return the counts dictionary\n    return counts"}
{"id": "227_0", "code": "def number_of_substrings(str):\n    \"\"\"\n    Counts the number of non-empty substrings of a given string.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        int: The number of non-empty substrings.\n    \"\"\"\n    n = len(str)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + (str[i] != str[i - 1])\n    return sum(dp)"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function generates all possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.\n\n    Args:\n        m (int): The upper limit of the next element.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        total = 0\n        for i in range(1, m):\n            total += get_total_number_of_sequences(m, n - 1)\n        return total"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the list with another list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element with.\n\n    Returns:\n        list: The modified list with the last element replaced.\n    \"\"\"\n    # Check if list1 is a list\n    if not isinstance(list1, list):\n        raise TypeError(\"list1 must be a list\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list1 is not empty\n    if len(list1) == 0:\n        raise ValueError(\"list1 cannot be empty\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2 cannot be empty\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"list2 must be a list\")\n\n    # Check if list2 is not empty\n    if len(list2) == 0:\n        raise ValueError(\"list2"}
{"id": "230_0", "code": "import numpy as np\n\ndef array_3d(m,n,o):\n    # Create a 3D array with zeros\n    arr = np.zeros((m,n,o))\n    \n    # Fill the array with '*'\n    arr[:] = '*'\n    \n    return arr"}
{"id": "231_0", "code": "def count_charac(str1):\n    return len(str1)"}
{"id": "232_0", "code": "def sort_on_occurence(lst):\n    # Sort the list based on the occurrence of first element of tuples\n    return sorted(lst, key=lambda x: x[0], reverse=True)"}
{"id": "233_0", "code": "import math\n\ndef next_Perfect_Square(N):\n    \"\"\"\n    Find the next perfect square greater than a given number.\n\n    Args:\n        N (int): The given number.\n\n    Returns:\n        int: The next perfect square greater than N.\n    \"\"\"\n    # Calculate the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # Calculate the next perfect square by rounding up the square root\n    next_perfect_square = math.ceil(sqrt_N) ** 2\n    \n    return next_perfect_square\n\n# Example usage:\nN = 16\nprint(next_Perfect_Square(N))  # Output: 25"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    \"\"\"\n    This function finds the maximum sum of bi-tonic sub-sequence for the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the input array.\n\n    Returns:\n    int: The maximum sum of bi-tonic sub-sequence.\n    \"\"\"\n    # Initialize a 2D array to store the maximum sum of bi-tonic sub-sequence.\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first row and column of the 2D array.\n    for i in range(n):\n        dp[i][i] = arr[i]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + arr[j]\n\n    # Fill the rest of the 2D array.\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length - 1\n            dp[i][j] = max(dp[i][j-1], dp[i+1][j], dp[i][j-1] + arr[j])\n\n    # Return the maximum sum of bi-tonic sub-sequence.\n    return max(dp[i][n-1] for i in range(n))\n\n# Example usage:\narr = [1, 2, 3, 4, 5]\nn = len(arr)\nprint(max_sum(arr, n))  # Output: 15"}
{"id": "235_0", "code": "import math\n\ndef babylonian_squareroot(number):\n    \"\"\"\n    Compute the square root of a number using the Babylonian method.\n\n    Args:\n        number (float): The number for which to compute the square root.\n\n    Returns:\n        float: The square root of the input number.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input number must be non-negative.\")\n\n    # Initialize the first guess\n    guess = number / 2.0\n\n    # Repeat the process until the guess is good enough\n    while True:\n        better_guess = (guess + number / guess) / 2.0\n        if abs(guess - better_guess) < 1e-9:\n            return better_guess\n        guess = better_guess\n\n# Example usage:\nprint(babylonian_squareroot(16))  # Output: 4.0\nprint(babylonian_squareroot(25))  # Output: 5.0"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    lps = [0] * n\n    i, j = 0, 1\n\n    # Initialize lps array\n    while i < n:\n        if str[i] == str[j]:\n            lps[i] = j + 1\n            i += 1\n            j += 1\n        elif j == 0:\n            i += 1\n        else:\n            j = lps[j - 1]\n    \n    # Find the maximum length of the palindrome\n    max_len = 0\n    for i in range(n):\n        if lps[i] > max_len:\n            max_len = lps[i]\n    \n    return max_len"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1.\n\n    Args:\n        n (int): The number of terms in the harmonic series.\n\n    Returns:\n        float: The harmonic sum of n-1.\n    \"\"\"\n    harmonic_sum = 0\n    for i in range(1, n):\n        harmonic_sum += 1 / i\n    return harmonic_sum"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    return list(set(array_nums1) & set(array_nums2))"}
{"id": "239_0", "code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        x (any): The element to count.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(x)"}
{"id": "240_0", "code": "def insert_element(list, element):\n    \"\"\"\n    Inserts an element before each element of a list.\n\n    Args:\n        list (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The modified list with the element inserted before each element.\n    \"\"\"\n    return [element] + list"}
{"id": "241_0", "code": "import cmath\nimport math\n\ndef convert(numbers):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Parameters:\n    numbers (list): A list of complex numbers.\n\n    Returns:\n    list: A list of tuples containing the magnitude and angle of each complex number in polar coordinates.\n    \"\"\"\n    polar_numbers = []\n    for num in numbers:\n        # Calculate the magnitude (r) and angle (theta) of the complex number\n        r = abs(num)\n        theta = cmath.phase(num)\n        \n        # Append the polar coordinates to the list\n        polar_numbers.append((r, theta))\n    \n    return polar_numbers\n\n# Example usage:\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]\npolar_numbers = convert(numbers)\nprint(polar_numbers)"}
{"id": "242_0", "code": "def count_integer(lst1):\n    \"\"\"\n    Counts the number of integers in a given list.\n\n    Args:\n        lst1 (list): A list of integers.\n\n    Returns:\n        int: The number of integers in the list.\n    \"\"\"\n    return sum(1 for num in lst1 if isinstance(num, int))"}
{"id": "243_0", "code": "def words_ae(text):\n    \"\"\"\n    Find all words starting with 'a' or 'e' in a given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of words starting with 'a' or 'e'.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if word[0].lower() in ['a', 'e']]"}
{"id": "244_0", "code": "import itertools\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Generate all combinations of colours with repetitions.\n\n    Parameters:\n    l (list): List of colours.\n    n (int): Number of colours to choose.\n\n    Returns:\n    list: List of combinations with repetitions.\n    \"\"\"\n    # Check if the number of colours to choose is less than 1\n    if n < 1:\n        raise ValueError(\"Number of colours to choose must be at least 1\")\n\n    # Check if the number of colours to choose is greater than the number of colours\n    if n > len(l):\n        raise ValueError(\"Number of colours to choose cannot be greater than the number of colours\")\n\n    # Generate all combinations with repetitions\n    combinations = list(itertools.product(l, repeat=n))\n\n    return combinations\n\n# Example usage:\nl = ['red', 'green', 'blue']\nn = 2\ncombinations = combinations_colors(l, n)\nprint(combinations)"}
{"id": "245_0", "code": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        int: The number of prime numbers less than n.\n    \"\"\"\n    # Initialize a boolean array, prime, of size n+1\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n\n    # Count the number of prime numbers less than n\n    count = sum(1 for p in range(2, n) if prime[p])\n\n    return count"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    # Swap the values of a and b\n    a, b = b, a\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    return sum(1 for num in array_nums if num % 2 != 0)"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Sort the tuples in ascending order\n    test_tup1 = sorted(test_tup1)\n    test_tup2 = sorted(test_tup2)\n\n    # Initialize variables to store the maximum values\n    max1 = test_tup1[0]\n    max2 = test_tup2[0]\n\n    # Iterate through the tuples to find the maximum values\n    for i in range(len(test_tup1)):\n        for j in range(len(test_tup2)):\n            if test_tup1[i] > max1:\n                max1 = test_tup1[i]\n            if test_tup2[j] > max2:\n                max2 = test_tup2[j]\n\n    # Return the maximum values\n    return max1, max2"}
{"id": "249_0", "code": "import random\nimport math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n\n# Example usage:\nprint(newman_prime(10))  # Output: 541"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function performs mathematical division operation across the given tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple to be divided.\n        test_tup2 (tuple): The second tuple to be divided.\n\n    Returns:\n        tuple: A tuple containing the result of the division operation and the remainder.\n    \"\"\"\n    # Perform mathematical division operation\n    result = test_tup1[0] / test_tup2[0]\n    remainder = test_tup1[0] % test_tup2[0]\n\n    # Return the result and the remainder\n    return result, remainder"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    \"\"\"\n    Splits a given list into two parts where the length of the first part of the list is given.\n\n    Args:\n        list1 (list): The input list to be split.\n        L (int): The desired length of the first part.\n\n    Returns:\n        tuple: A tuple containing two lists. The first list contains the first part of the input list, \n               and the second list contains the second part of the input list.\n    \"\"\"\n    # Calculate the length of the first part\n    first_part_length = len(list1) - L\n\n    # If the length of the first part is less than or equal to 0, return the original list and an empty list\n    if first_part_length <= 0:\n        return list1, []\n\n    # Slice the list to get the first part\n    first_part = list1[:first_part_length]\n\n    # Slice the list to get the second part\n    second_part = list1[first_part_length:]\n\n    # Return the two parts\n    return first_part, second_part"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into one.\n\n    Args:\n        d1 (dict): The first dictionary to merge.\n        d2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from both input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n\n    # Copy all key-value pairs from the first dictionary into the merged dictionary\n    for key, value in d1.items():\n        merged_dict[key] = value\n\n    # Copy all key-value pairs from the second dictionary into the merged dictionary\n    for key, value in d2.items():\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Args:\n        h_age (int): The dog's height in inches.\n\n    Returns:\n        int: The dog's age in dog's years.\n    \"\"\"\n    # Convert height from inches to feet\n    h_feet = h_age / 12\n\n    # Calculate the dog's age in dog's years\n    h_years = h_feet / 4\n\n    return h_years"}
{"id": "254_0", "code": "def list_split(S, step):\n    \"\"\"\n    Splits a list into chunks of size step.\n\n    Args:\n        S (list): The input list to be split.\n        step (int): The size of each chunk.\n\n    Returns:\n        list: A list of chunks.\n    \"\"\"\n    return [S[i:i+step] for i in range(0, len(S), step)]"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): Length of the cube.\n\n    Returns:\n    float: Lateral surface area of the cube.\n    \"\"\"\n    # Calculate the lateral surface area of the cube\n    lateral_surface_area = 4 * (l ** 2)\n    return lateral_surface_area"}
{"id": "256_0", "code": "def square_Sum(n):\n    \"\"\"\n    Calculate the sum of squares of the first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to sum.\n\n    Returns:\n        int: The sum of squares of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum of squares\n    sum_of_squares = 0\n\n    # Loop through each odd number from 1 to n\n    for i in range(1, n + 1):\n        # Check if the number is odd\n        if i % 2 != 0:\n            # Add the square of the number to the sum\n            sum_of_squares += i ** 2\n\n    # Return the sum of squares\n    return sum_of_squares"}
{"id": "257_0", "code": "import random\n\ndef find_star_num(n):\n    \"\"\"\n    Generates the nth star number.\n\n    Args:\n        n (int): The position of the star number to generate.\n\n    Returns:\n        int: The nth star number.\n    \"\"\"\n    # Initialize the first star number\n    star_num = 1\n\n    # Generate the nth star number\n    for i in range(1, n):\n        # Calculate the next star number\n        star_num = (star_num * 2 + 1) // 2\n\n    return star_num"}
{"id": "258_0", "code": "def ascii_value(k):\n    \"\"\"\n    Returns the ASCII value of a character.\n\n    Args:\n        k (str): The character for which the ASCII value is to be found.\n\n    Returns:\n        int: The ASCII value of the character.\n    \"\"\"\n    return ord(k)"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr, n):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in the given array.\n\n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The length of the array.\n\n    Returns:\n    int: The sum of even numbers at even positions.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the array with index and value\n    for i, num in enumerate(arr):\n        # Check if the index is even and the number is even\n        if i % 2 == 0 and num % 2 == 0:\n            # Add the number to the sum\n            total_sum += num\n    \n    # Return the sum\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of fifth power of first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers.\n\n    Returns:\n    int: The sum of fifth power of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Loop through each even number from 2 to n\n    for i in range(2, n + 1, 2):\n        # Calculate the fifth power of the current even number\n        fifth_power = i ** 5\n        \n        # Add the fifth power to the total sum\n        total_sum += fifth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    \"\"\"\n    Extracts the rear element from a list of tuples records.\n\n    Args:\n        test_list (list): A list of tuples containing data.\n\n    Returns:\n        tuple: The extracted rear element.\n    \"\"\"\n    # Check if the list is empty\n    if not test_list:\n        return None\n\n    # Check if the list contains only tuples\n    if not all(isinstance(item, tuple) for item in test_list):\n        raise ValueError(\"The input list must contain only tuples.\")\n\n    # Extract the last element of the list\n    last_element = test_list[-1]\n\n    # Check if the last element is a tuple\n    if not isinstance(last_element, tuple):\n        raise ValueError(\"The last element must be a tuple.\")\n\n    # Return the extracted rear element\n    return last_element"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function subtracts the contents of one tuple with corresponding index of other tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: The result of subtraction.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the tuples\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append to the result list\n        result.append(test_tup1[i] - test_tup2[i])\n\n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "263_0", "code": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculate the sum of even index binomial coefficients.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The sum of even index binomial coefficients.\n\n    Raises:\n        ValueError: If n is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize the sum of binomial coefficients\n    sum = 0\n\n    # Iterate over the range from 0 to n\n    for i in range(n + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Calculate the binomial coefficient using the formula\n            sum += math.comb(i, i // 2)\n\n    return sum"}
{"id": "264_0", "code": "def get_Position(a,n,m):\n    # Check if the array is empty\n    if n == 0:\n        return -1\n    \n    # Check if the array is not empty and the length of the array is less than or equal to m\n    if n <= m:\n        return -1\n    \n    # Check if the array is not empty and the length of the array is greater than m\n    if n > m:\n        return -1\n    \n    # Check if the array is not empty and the length of the array is greater than 0\n    if n > 0:\n        # Find the position of the last removed element\n        position = n - 1\n        while position >= 0 and a[position] == a[n - 1]:\n            position -= 1\n        return position\n    else:\n        return -1"}
{"id": "265_0", "code": "import math\n\ndef volume_cylinder(r, h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Check if the radius and height are valid\n    if r <= 0 or h <= 0:\n        raise ValueError(\"Radius and height must be greater than zero.\")\n\n    # Calculate the volume using the formula V = πr^2h\n    volume = math.pi * (r ** 2) * h\n    return volume\n\n# Example usage:\nprint(volume_cylinder(5, 10))  # Output: 785.3981633974483"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    \"\"\"\n    Filter a dictionary based on values.\n\n    Args:\n        dict (dict): The dictionary to be filtered.\n        n (int): The value to filter by.\n\n    Returns:\n        dict: The filtered dictionary.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value == n}"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    \"\"\"\n    This function takes a tuple as input and returns the count of elements that occur before the record in the tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        int: The count of elements that occur before the record in the tuple.\n    \"\"\"\n    # Initialize a dictionary to store the count of elements\n    count_dict = {}\n\n    # Iterate over the tuple\n    for i, element in enumerate(test_tup):\n        # If the element is already in the dictionary, increment its count\n        if element in count_dict:\n            count_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[element] = 1\n\n    # Find the element with the minimum count\n    min_count = min(count_dict.values())\n    min_element = [key for key, value in count_dict.items() if value == min_count]\n\n    # Return the count of the element with the minimum count\n    return min_count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    return n**2 == 6*n + 1"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    \"\"\"\n    Searches for an element in a given list using sequential search.\n\n    Args:\n        dlist (list): The list to be searched.\n        item: The element to be searched for.\n\n    Returns:\n        int: The index of the element if found, -1 otherwise.\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    \"\"\"\n    Checks if the elements of a given list are unique or not.\n\n    Args:\n        test_list (list): The list to be checked.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    \"\"\"\n    This function takes two lists as input and returns a new list containing the elements that are present in both lists.\n    \n    Args:\n        nums1 (list): The first list.\n        nums2 (list): The second list.\n    \n    Returns:\n        list: A new list containing the elements that are present in both lists.\n    \"\"\"\n    return list(map(lambda x: x if x in nums2 else None, nums1))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number to a string\n    str_n = str(n)\n    \n    # Initialize a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each character in the string\n    for char in str_n:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Convert the character to an integer\n            digit = int(char)\n            \n            # Check if the frequency of the digit is less than or equal to the digit itself\n            if digit in freq and freq[digit] + 1 <= digit:\n                # Increment the frequency of the digit\n                freq[digit] += 1\n            else:\n                # Add the digit to the frequency dictionary with a frequency of 1\n                freq[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, freq in freq.items():\n        if freq > digit:\n            return False\n    \n    # If all checks pass, return True\n    return True"}
{"id": "273_0", "code": "def check_element(list, element):\n    \"\"\"\n    Checks whether all items in the list are equal to the given string.\n\n    Args:\n        list (list): The list to be checked.\n        element (str): The string to be compared with the list items.\n\n    Returns:\n        bool: True if all items in the list are equal to the given string, False otherwise.\n    \"\"\"\n    return all(item == element for item in list)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    \"\"\"\n    Generate a string that matches a given text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A generated string that matches the input text.\n    \"\"\"\n    # Initialize an empty string to store the generated content\n    content = \"\"\n\n    # Check if the input text starts with 'a'\n    if text.startswith('a'):\n        # If it does, append 'b' to the content string three times\n        content += 'b' * 3\n    else:\n        # If it doesn't, append 'b' to the content string twice\n        content += 'b' * 2\n\n    # Return the generated content\n    return content"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    \"\"\"\n    This function finds the largest sum of contiguous array in the modified array \n    which is formed by repeating the given array k times.\n\n    Parameters:\n    a (list): The input array.\n    n (int): The length of the input array.\n    k (int): The number of times the array is repeated.\n\n    Returns:\n    int: The largest sum of contiguous array in the modified array.\n    \"\"\"\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Calculate the sum of the input array\n    total_sum = sum(a)\n\n    # Repeat the array k times\n    for _ in range(k):\n        # Update the current sum\n        current_sum = sum(a[:n])\n\n        # Update the maximum sum\n        max_sum = max(max_sum, current_sum)\n\n    # Return the maximum sum\n    return max_sum"}
{"id": "276_0", "code": "def square_Sum(n):\n    \"\"\"\n    Calculate the sum of squares of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to sum.\n\n    Returns:\n        int: The sum of squares of first n even natural numbers.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n\n    # Loop through even numbers from 2 to n (inclusive)\n    for i in range(2, n + 1, 2):\n        # Calculate square of current number and add to total sum\n        total_sum += i ** 2\n\n    return total_sum"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    \"\"\"\n    This function counts array elements having modular inverse under given prime number p equal to itself.\n\n    Parameters:\n    arr (list): The input array.\n    N (int): The modulus.\n    P (int): The prime number.\n\n    Returns:\n    int: The count of array elements having modular inverse under given prime number p equal to itself.\n    \"\"\"\n    # Initialize count of elements with modular inverse\n    count = 0\n\n    # Iterate over the array\n    for num in arr:\n        # Check if the number has modular inverse\n        if pow(num, P - 2, N) == 1:\n            # Increment the count\n            count += 1\n\n    # Return the count\n    return count"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Define a list of months with their corresponding number of days\n    months = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n\n    # Initialize a counter for odd days\n    odd_days = 0\n\n    # Iterate over each month in the given year\n    for month in months:\n        # Check if the month is a leap year\n        if (N % 4 == 0 and N % 100 != 0) or (N % 400 == 0):\n            # If the month is a leap year, increment the counter by 1\n            odd_days += 1\n        else:\n            # If the month is not a leap year, check if the day is odd\n            for day in range(1, months[month] + 1):\n                # If the day is odd, increment the counter\n                if day % 2 != 0:\n                    odd_days += 1\n                    # Break the loop to move to the next month\n                    break\n\n    # Return the total number of odd days\n    return odd_days"}
{"id": "279_0", "code": "def max_length(list1):\n    \"\"\"\n    This function generates a list of lists with maximum length.\n    \n    Parameters:\n    list1 (list): The input list.\n    \n    Returns:\n    list: A list of lists with maximum length.\n    \"\"\"\n    # Initialize the maximum length and the result list\n    max_len = 0\n    result = []\n    \n    # Iterate over the input list\n    for i in range(len(list1)):\n        # Check if the current sublist is longer than the max_len\n        if len(list1[i]) > max_len:\n            # Update max_len and reset the result list\n            max_len = len(list1[i])\n            result = [list1[i]]\n        # If the current sublist is not longer than max_len, add it to the result list\n        elif len(list1[i]) == max_len:\n            result.append(list1[i])\n    \n    return result"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    \"\"\"\n    This function calculates the number of ways to paint a fence with n posts and k colors\n    such that at most 2 adjacent posts have the same color.\n\n    Parameters:\n    n (int): The number of posts on the fence.\n    k (int): The number of colors available.\n\n    Returns:\n    int: The number of ways to paint the fence.\n    \"\"\"\n    # Base cases\n    if n == 1:\n        return 1 if k == 1 else 0\n    if n == 2:\n        return k\n\n    # Initialize a list to store the number of ways for each number of posts\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = k\n\n    # Fill up the dp table\n    for i in range(3, n + 1):\n        # If the current post is the same color as the previous one, \n        # we can either paint it with the same color as the previous one or \n        # paint it with a different color\n        if i == 3:\n            dp[i] = dp[i - 1] + dp[i - 2]\n        # If the current post is different from the previous one, \n        # we can only paint it with a different color\n        else:\n            dp[i] = dp[i - 1]\n\n    # The number of ways to paint the fence is stored in the last element of the dp table\n    return dp[n]"}
{"id": "281_0", "code": "def find(n, m):\n    if n == 0:\n        return \"Error: Division by zero is not allowed\"\n    elif m == 0:\n        return \"Error: Division by zero is not allowed\"\n    elif n < 0 and m > 0:\n        return \"Error: Division by zero is not allowed\"\n    elif n > 0 and m < 0:\n        return -n / m\n    else:\n        return n / m"}
{"id": "282_0", "code": "def otherside_rightangle(w,h):\n    # Calculate the third side of the right angled triangle\n    c = (w**2 + h**2)**0.5\n    return c"}
{"id": "283_0", "code": "def max_val(lstval):\n    \"\"\"\n    This function finds the maximum value in a given heterogeneous list.\n\n    Parameters:\n    lstval (list): A heterogeneous list containing different data types.\n\n    Returns:\n    The maximum value in the list.\n    \"\"\"\n    return max(lstval)"}
{"id": "284_0", "code": "def sum_div(number):\n    \"\"\"\n    Returns the sum of all divisors of a number.\n\n    Args:\n        number (int): The number for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of all divisors of the number.\n    \"\"\"\n    divisors = [i for i in range(1, number + 1) if number % i == 0]\n    return sum(divisors)"}
{"id": "285_0", "code": "def get_Inv_Count(arr, n):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the input array.\n\n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    # Initialize the inversion count to 0\n    inv_count = 0\n\n    # Iterate through the array from the first element to the second last element\n    for i in range(n - 1):\n        # Iterate through the array from the first element to the second last element\n        for j in range(i + 1, n):\n            # Check if the current element is greater than the next element\n            if arr[i] > arr[j]:\n                # Increment the inversion count\n                inv_count += 1\n\n    # Return the inversion count\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    \"\"\"\n    This function takes a nested list as input and returns a flattened list.\n    \n    Args:\n        list1 (list): The input list to be flattened.\n    \n    Returns:\n        list: A flattened list of all elements from the input list.\n    \"\"\"\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    \"\"\"\n    This function finds the nested list elements which are present in another list.\n\n    Args:\n        l1 (list): The list to search for nested elements.\n        l2 (list): The list to search in.\n\n    Returns:\n        list: A list of nested list elements that are present in l2.\n    \"\"\"\n    # Initialize an empty list to store the intersection\n    intersection = []\n\n    # Iterate over each element in l1\n    for elem in l1:\n        # Check if the element is a list\n        if isinstance(elem, list):\n            # If the element is a list, recursively call the function\n            # and extend the intersection list with the result\n            intersection.extend(intersection_nested_lists(elem, l2))\n        else:\n            # If the element is not a list, check if it's in l2\n            if elem in l2:\n                # If the element is in l2, add it to the intersection list\n                intersection.append(elem)\n\n    # Return the intersection list\n    return intersection"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n        stdata (list): A list of tuples.\n\n    Returns:\n        int: The maximum aggregate.\n    \"\"\"\n    # Initialize the maximum aggregate to negative infinity\n    max_ag = float('-inf')\n\n    # Iterate over each tuple in the list\n    for tup in stdata:\n        # Calculate the aggregate for the current tuple\n        ag = sum(tup)\n\n        # Update the maximum aggregate if the current aggregate is larger\n        max_ag = max(max_ag, ag)\n\n    # Return the maximum aggregate\n    return max_ag"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    \"\"\"\n    This function generates all binary sequences of length 2n and counts the number of sequences \n    where the sum of the first n bits is the same as the sum of the last n bits.\n\n    Parameters:\n    n (int): The length of the binary sequence.\n\n    Returns:\n    int: The count of binary sequences where the sum of the first n bits is the same as the sum of the last n bits.\n    \"\"\"\n    # Initialize a list to store the count of binary sequences for each length\n    count = [0] * (n + 1)\n    # Initialize a list to store the binary sequences\n    seqs = []\n\n    # Base case: there is only one way to generate a binary sequence of length 0\n    count[0] = 1\n    seqs.append([0])\n\n    # Generate binary sequences of length 1\n    for i in range(1, n + 1):\n        # Initialize a list to store the count of binary sequences for each length\n        count2 = [0] * (i + 1)\n        # Initialize a list to store the binary sequences\n        seqs2 = []\n\n        # Base case: there is only one way to generate a binary sequence of length 1\n        count2[0] = 1\n        seqs2.append([0])\n\n        # Generate binary sequences of length 2\n        for j in range(1, i + 1):\n            # Calculate the sum of the first j bits\n            sum_first_j_bits = sum(int(digit) for digit in bin(j)[2:])\n            # Calculate the sum of the last i - j bits\n            sum_last_i_j_bits = sum(int(digit) for digit in bin(i - j)[2:])\n            # If the sums are equal, add the sequence to the list\n            if sum_first_j_bits == sum_last_i_j_bits:\n                count2[j] = count2[j - 1] + count2[j - 1]\n                seqs2.append([j, sum_first_j_bits, sum_last_i_j_bits])\n\n        # Update the count and the list of sequences\n        for k in range(i, 0, -1):\n            count[k] = count[k - 1] + count2[k]\n            seqs[k] = seqs[k - 1] + seqs2[k]\n\n    # Return the count of binary sequences where the sum of the first n bits is the same as the sum of the last n bits\n    return count[n]"}
{"id": "290_0", "code": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n        d (dict): The dictionary to calculate the depth for.\n\n    Returns:\n        int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    def _dict_depth(d, current_depth=0):\n        if not isinstance(d, dict):\n            return current_depth\n        for key, value in d.items():\n            return _dict_depth(value, current_depth + 1)\n    return _dict_depth(d)"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    \"\"\"\n    This function generates the most significant bit number which is also a set bit.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    int: The most significant bit number which is also a set bit.\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    \n    # Loop through each bit position from most significant to least significant\n    for i in range(n.bit_length()):\n        # Check if the current bit is set\n        if (n & (1 << i)) != 0:\n            # If the bit is set, add the corresponding bit position to the result\n            result |= 1 << i\n    \n    # Return the result\n    return result"}
{"id": "292_0", "code": "def solve(a, n):\n    # Initialize a dictionary to store the inversion count\n    inversion_count = {}\n    \n    # Iterate over the array\n    for i in range(n):\n        for j in range(i+1, n):\n            # Check if the current pair is an inversion\n            if a[i] > a[j]:\n                # Increment the inversion count\n                inversion_count[(i, j)] = inversion_count.get((i, j), 0) + 1\n            # Check if the current pair is a reverse inversion\n            if a[j] < a[i]:\n                # Increment the inversion count\n                inversion_count[(j, i)] = inversion_count.get((j, i), 0) + 1\n    \n    # Check if the inversion count is the same for both types\n    inversion_type1 = inversion_count.get((1, n), 0)\n    inversion_type2 = inversion_count.get((n, 1), 0)\n    \n    # Return True if the inversion counts are the same, False otherwise\n    return inversion_type1 == inversion_type2"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    # Check if the index is within the bounds of the array\n    if index < 0 or index >= len(arr):\n        return None\n\n    # Calculate the effective rotation\n    effective_rotation = rotations % len(arr)\n\n    # Calculate the new index\n    new_index = (index + effective_rotation) % len(arr)\n\n    # Return the element at the new index\n    return arr[new_index]"}
{"id": "294_0", "code": "def start_withp(words):\n    \"\"\"\n    Returns a list of words that start with the letter 'p'.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        list: A list of words that start with the letter 'p'.\n    \"\"\"\n    return [word for word in words if word.lower().startswith('p')]"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    \"\"\"\n    This function calculates the maximum sum of increasing subsequence \n    from prefix till ith index and including a given kth element which \n    is after i, i.e., k > i.\n\n    Parameters:\n    a (list): The input list of numbers.\n    n (int): The size of the input list.\n    index (int): The index of the given kth element.\n    k (int): The given kth element.\n\n    Returns:\n    int: The maximum sum of increasing subsequence.\n    \"\"\"\n    # Initialize a list to store the maximum sum of increasing subsequence \n    # ending at each index from 0 to n-1.\n    dp = [0] * (n + 1)\n    dp[0] = 0  # The maximum sum of increasing subsequence ending at index 0 is 0.\n\n    # Iterate over the list from index 1 to n.\n    for i in range(1, n + 1):\n        # For each element, calculate the maximum sum of increasing subsequence \n        # ending at index i by considering the maximum sum of increasing \n        # subsequence ending at index i-1 and the maximum sum of increasing \n        # subsequence ending at index i-1 + the current element.\n        dp[i] = max(dp[i - 1], dp[i - 1] + a[i - 1])\n\n    # Find the maximum sum of increasing subsequence ending at index k.\n    max_sum = dp[k]\n\n    # Find the maximum sum of increasing subsequence ending at index k + 1.\n    max_sum_increasing_subseq = dp[k + 1]\n\n    # Return the maximum sum of increasing subsequence.\n    return max_sum + max_sum_increasing_subseq"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\n    return tuplex[:m] + \":\" + tuplex[m:n]"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    \"\"\"\n    Find the specified number of largest products from two given lists.\n\n    Args:\n    nums1 (list): The first list of numbers.\n    nums2 (list): The second list of numbers.\n    N (int): The number of largest products to find.\n\n    Returns:\n    list: A list of the N largest products from the two input lists.\n    \"\"\"\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize an empty list to store the products\n    products = []\n\n    # Iterate over the two lists\n    for num1 in nums1:\n        for num2 in nums2:\n            # Calculate the product and append it to the list\n            products.append(num1 * num2)\n\n    # Sort the list of products in descending order\n    products.sort(reverse=True)\n\n    # Return the N largest products\n    return products[:N]"}
{"id": "298_0", "code": "def maximum(a, b):\n    \"\"\"\n    Returns the maximum of two numbers.\n\n    Args:\n        a (int or float): The first number.\n        b (int or float): The second number.\n\n    Returns:\n        int or float: The maximum of a and b.\n    \"\"\"\n    return max(a, b)"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    \"\"\"\n    Converts a given string to a tuple.\n\n    Args:\n        str1 (str): The input string to be converted.\n\n    Returns:\n        tuple: A tuple containing the input string.\n    \"\"\"\n    return (str1,)\n\n# Example usage:\nprint(string_to_tuple(\"Hello, World!\"))"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    \"\"\"\n    Set the left most unset bit in a binary number.\n\n    Args:\n        n (int): The binary number.\n\n    Returns:\n        int: The binary number with the left most unset bit set.\n    \"\"\"\n    # Convert the binary number to a list of bits\n    bits = list(str(n).replace('0', 'b').replace('1', 'b+'))\n\n    # Initialize the left most unset bit position\n    left_most_unset_bit = 0\n\n    # Iterate over the bits from right to left\n    for i in range(len(bits) - 1, -1, -1):\n        # If the current bit is unset, set it to 1\n        if bits[i] == 'b':\n            bits[i] = '1'\n            left_most_unset_bit = i\n            break\n\n    # Convert the list of bits back to a binary number\n    result = ''.join(bits)\n\n    return int(result, 2)"}
{"id": "301_0", "code": "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    r (float): The radius of the cone's base.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    # Calculate the volume using the formula V = (1/3)πr^2h\n    volume = (1/3) * math.pi * (r ** 2) * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    \"\"\"\n    This function calculates the maximum sum of a rectangular grid of dimension 2 x n\n    such that no two chosen numbers are adjacent.\n\n    Parameters:\n    grid (list): A 2D list representing the rectangular grid.\n    n (int): The number of rows in the grid.\n\n    Returns:\n    int: The maximum sum of a rectangular grid with no adjacent numbers.\n    \"\"\"\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n\n    # Iterate over all possible rectangular sub-grids\n    for i in range(n):\n        for j in range(i, n):\n            # Initialize the sum of the current sub-grid as 0\n            subgrid_sum = 0\n\n            # Iterate over all possible sub-grids within the current sub-grid\n            for k in range(i, j + 1):\n                for m in range(k, j + 1):\n                    # Add the current number to the sum of the sub-grid\n                    subgrid_sum += grid[i][k] + grid[k][m]\n\n            # Update the maximum sum if the current sum is greater\n            max_sum = max(max_sum, subgrid_sum)\n\n    # Return the maximum sum\n    return max_sum"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    words = str.split()\n    max_len = 0\n    for word in words:\n        if word.lstrip().lower() == word:\n            if len(word) > max_len:\n                max_len = len(word)\n    return max_len"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    \"\"\"\n    Find the index of the last occurrence of a given number in a sorted array.\n\n    Args:\n        A (list): A sorted list of numbers.\n        x (int): The number to find.\n\n    Returns:\n        int: The index of the last occurrence of x in A. If x is not found, returns -1.\n    \"\"\"\n    low, high = 0, len(A) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            # If x is found, check if it's the last occurrence\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            # If x is not the last occurrence, move the search space to the left half\n            else:\n                high = mid - 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"id": "306_0", "code": "def modified_encode(alist):\n    encoded_list = []\n    for i in range(len(alist)):\n        if alist[i] != 0:\n            encoded_list.append(alist[i])\n            if i < len(alist) - 1:\n                encoded_list.append(alist[i + 1])\n    return encoded_list"}
{"id": "307_0", "code": "def max_volume(s):\n    \"\"\"\n    Calculate the maximum volume of a cuboid with given sum of sides.\n\n    Parameters:\n    s (list): A list of three integers representing the sum of the lengths of the three sides of the cuboid.\n\n    Returns:\n    int: The maximum volume of the cuboid.\n\n    Raises:\n    ValueError: If the input list does not contain exactly three integers.\n    \"\"\"\n\n    # Check if the input list contains exactly three integers\n    if len(s) != 3 or not all(isinstance(side, int) for side in s):\n        raise ValueError(\"Input list must contain exactly three integers\")\n\n    # Sort the list of sides in ascending order\n    s.sort()\n\n    # Calculate the maximum volume\n    max_volume = s[0] * s[1] * s[2]\n\n    return max_volume"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    # Define the regex pattern\n    pattern = r'\\b\\w{5}\\b'\n    # Find all matches\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    \"\"\"\n    Calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers.\n\n    Returns:\n        int: The difference between the two sums.\n    \"\"\"\n    # Calculate the sum of squared first n natural numbers\n    sum_squared = sum(i**2 for i in range(1, n+1))\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum = sum(i**2 for i in range(1, n+1))\n    \n    # Return the difference between the two sums\n    return squared_sum - sum_squared"}
{"id": "310_0", "code": "def find_demlo(s):\n    \"\"\"\n    This function generates a random number between 1 and 1000.\n    The number is then converted to a string and the first letter of the string is capitalized.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to uppercase.\n    The first letter of the string is then converted to title case.\n    The first letter of the string is"}
{"id": "311_0", "code": "def position_min(list1):\n    min_val = min(list1)\n    min_index = list1.index(min_val)\n    return [min_index]"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    \"\"\"\n    Re-arrange the given array in alternating positive and negative items.\n\n    Args:\n        arr (list): The input array.\n        n (int): The number of positive and negative items in the array.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    # Initialize two pointers, one at the beginning and one at the end of the array\n    left = 0\n    right = len(arr) - 1\n\n    # Initialize two lists to store positive and negative items\n    pos = []\n    neg = []\n\n    # Iterate through the array\n    while left <= right:\n        # If the left pointer is within the array bounds and the item at the left pointer is positive\n        if left <= right and arr[left] > 0:\n            # Add the positive item to the positive list\n            pos.append(arr[left])\n            # Move the left pointer to the right\n            left += 1\n        # If the right pointer is within the array bounds and the item at the right pointer is negative\n        elif left <= right and arr[right] < 0:\n            # Add the negative item to the negative list\n            neg.append(arr[right])\n            # Move the right pointer to the left\n            right -= 1\n        # If the left pointer is within the array bounds and the item at the left pointer is negative\n        elif left <= right and arr[left] < 0:\n            # Add the negative item to the negative list\n            neg.append(arr[left])\n            # Move the left pointer to the right\n            left += 1\n        # If the left pointer is within the array bounds and the item at the left pointer is positive\n        elif left <= right and arr[left] > 0:\n            # Add the positive item to the positive list\n            pos.append(arr[left])\n            # Move the left pointer to the right\n            left += 1\n        # If the right pointer is within the array bounds and the item at the right pointer is positive\n        elif left <= right and arr[right] > 0:\n            # Add the positive item to the positive list\n            pos.append(arr[right])\n            # Move the right pointer to the left\n            right -= 1\n\n    # Combine the positive and negative lists to get the rearranged array\n    return pos + neg"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    \"\"\"\n    Extract the sum of alternate chains of tuples.\n\n    Args:\n        test_tuple (tuple): A tuple containing tuples.\n\n    Returns:\n        int: The sum of alternate chains of tuples.\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n\n    # Iterate over the tuple with index\n    for i, tup in enumerate(test_tuple):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Add the tuple to the sum\n            total_sum += tup\n\n    # Return the sum\n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    \"\"\"\n    This function finds the minimum number of squares whose sum is equal to a given number.\n\n    Args:\n        n (int): The target sum.\n\n    Returns:\n        int: The minimum number of squares whose sum is equal to the target sum.\n    \"\"\"\n    # Initialize a list to store the minimum number of squares for each sum from 1 to n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0  # Base case: 0 squares needed to sum up to 0\n\n    # Iterate over each possible sum from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each possible square size from 1 to the square root of i\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current square size is less than or equal to i\n            if j * j <= i:\n                # Update the minimum number of squares for the current sum\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n\n    # Return the minimum number of squares for the target sum\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    \"\"\"\n    Returns the word with the most occurrences in the given list of strings.\n\n    Args:\n        test_list (list): A list of strings.\n\n    Returns:\n        str: The word with the most occurrences.\n    \"\"\"\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    \n    # Iterate over each string in the list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Iterate over each word in the string\n        for word in words:\n            # If the word is already in the dictionary, increment its count\n            if word in word_freq:\n                word_freq[word] += 1\n            # If the word is not in the dictionary, add it with a count of 1\n            else:\n                word_freq[word] = 1\n    \n    # Find the word with the maximum frequency\n    most_common_word = max(word_freq, key=word_freq.get)\n    \n    return most_common_word"}
{"id": "316_0", "code": "def check_isosceles(x, y, z):\n    # Check if the sides of the triangle are equal\n    if x == y and y == z:\n        print(\"The triangle is isosceles.\")\n    elif x == y or x == z or y == z:\n        print(\"The triangle is not isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"id": "317_0", "code": "def rotate_left(list1,m,n):\n    # Check if the number of items to be rotated is greater than the length of the list\n    if m > len(list1):\n        return list1\n    # Check if the number of items to be rotated is greater than the length of the list\n    if n > len(list1):\n        return list1\n    # Rotate the list to the left\n    rotated_list = list1[-m:] + list1[:-m]\n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    \"\"\"\n    Counts the number of negative numbers in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The number of negative numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num < 0)"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Define the regex pattern\n    pattern = r'\\b\\w{3,5}\\b'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    \"\"\"\n    Counts the number of unset bits in a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number of unset bits in the input number.\n    \"\"\"\n    # Initialize the count of unset bits\n    unset_bits = 0\n\n    # Iterate over each bit in the binary representation of the number\n    while n:\n        # Check if the least significant bit is unset\n        if n & 1:\n            # If it is, increment the count of unset bits\n            unset_bits += 1\n        # Right shift the number to move to the next bit\n        n >>= 1\n\n    # Return the total count of unset bits\n    return unset_bits"}
{"id": "321_0", "code": "def char_frequency(str1):\n    \"\"\"\n    This function counts the frequency of each character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"}
{"id": "322_0", "code": "def Sort(sub_li):\n    # Check if the input list is empty\n    if not sub_li:\n        return sub_li\n\n    # Sort the list based on the second element of each sublist\n    sub_li.sort(key=lambda x: x[1])\n\n    # Return the sorted list\n    return sub_li"}
{"id": "323_0", "code": "def check_Validity(a, b, c):\n    \"\"\"\n    This function checks whether a triangle is valid or not.\n\n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n\n    Returns:\n    bool: True if the triangle is valid, False otherwise.\n    \"\"\"\n    # Check if the input values are valid\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n\n    # Check if the square of the longest side is less than the sum of the squares of the other two sides\n    if a**2 + b**2 <= c**2 or b**2 + c**2 <= a**2 or c**2 + a**2 <= b**2:\n        return False\n\n    # If all conditions are met, the triangle is valid\n    return True\n\n# Example usage:\nprint(check_Validity(3, 4, 5))  # True\nprint(check_Validity(1, 2, 3))  # False"}
{"id": "324_0", "code": "def ap_sum(a, n, d):\n    \"\"\"\n    Calculate the sum of an arithmetic progression.\n\n    Parameters:\n    a (int): The first term of the progression.\n    n (int): The number of terms in the progression.\n    d (int): The common difference of the progression.\n\n    Returns:\n    int: The sum of the arithmetic progression.\n    \"\"\"\n    # Check if the input values are valid\n    if a <= 0 or n <= 0 or d <= 0:\n        raise ValueError(\"All input values must be positive.\")\n\n    # Calculate the sum using the formula: n/2 * (2a + (n-1)*d)\n    sum = n / 2 * (2 * a + (n - 1) * d)\n\n    return sum"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    monthnum = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return monthnum.get(monthname1, 0)"}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    \"\"\"\n    Matches a word at the end of a string, with optional punctuation.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        str: The matched word with optional punctuation.\n    \"\"\"\n    # Remove leading and trailing whitespace\n    text = text.strip()\n\n    # Remove punctuation\n    text = re.sub(r'[^\\w\\s]', '', text)\n\n    # Split the string into words\n    words = text.split()\n\n    # Find the last word\n    last_word = words[-1]\n\n    # Check if the last word ends with a punctuation mark\n    if not last_word[-1].isalpha():\n        # If it does, remove the punctuation mark\n        last_word = last_word[:-1]\n\n    # Return the matched word\n    return last_word"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    \"\"\"\n    Counts the number of substrings with same first and last characters.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of substrings with same first and last characters.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    \"\"\"\n    This function finds the maximum occurring divisor in an interval.\n\n    Parameters:\n    x (int): The start of the interval.\n    y (int): The end of the interval.\n\n    Returns:\n    int: The maximum occurring divisor in the interval.\n    \"\"\"\n    # Initialize the maximum divisor\n    max_divisor = 0\n\n    # Iterate over all numbers from x to y\n    for i in range(x, y + 1):\n        # Check if i is a divisor of both x and y\n        if x % i == 0 and y % i == 0:\n            # Update the maximum divisor\n            max_divisor = max(max_divisor, i)\n\n    return max_divisor"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # Find the three smallest numbers\n    three_smallest = sorted_lst[:3]\n    \n    # Calculate the sum of the three smallest numbers\n    total = sum(three_smallest)\n    \n    return total"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    \"\"\"\n    Convert a set into an ordered tuple.\n\n    Args:\n        s (set): The input set.\n\n    Returns:\n        tuple: An ordered tuple representation of the input set.\n    \"\"\"\n    return tuple(sorted(s))"}
{"id": "331_0", "code": "def find_minimum_range(list1, list2, list3):\n    # Sort the lists\n    list1.sort()\n    list2.sort()\n    list3.sort()\n\n    # Initialize the minimum range\n    min_range = float('inf')\n    min_range_start = 0\n    min_range_end = 0\n\n    # Iterate through the sorted lists\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                # Check if the current elements are in the same list\n                if list1[i] == list2[j] == list3[k]:\n                    # Update the minimum range\n                    min_range = min(min_range, list1[i] - list3[k])\n                    min_range_start = min(min_range_start, list1[i])\n                    min_range_end = max(min_range_end, list3[k])\n\n    return min_range, min_range_start, min_range_end"}
{"id": "332_0", "code": "def dig_let(s):\n    \"\"\"\n    Calculate the number of digits and letters in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        tuple: A tuple containing the number of digits and letters in the string.\n    \"\"\"\n    # Initialize counters for digits and letters\n    digits = 0\n    letters = 0\n\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digits += 1\n        # Check if the character is a letter\n        elif char.isalpha():\n            letters += 1\n\n    # Return the counts as a tuple\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n, m):\n    \"\"\"\n    This function counts the number of odd squares in a given range.\n\n    Parameters:\n    n (int): The start of the range.\n    m (int): The end of the range.\n\n    Returns:\n    int: The number of odd squares in the given range.\n    \"\"\"\n    count = 0\n    for i in range(n, m+1):\n        if i**0.5 % 2 != 0:\n            count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    \"\"\"\n    This function calculates the difference between two consecutive numbers in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of differences between consecutive numbers in the input list.\n    \"\"\"\n    differences = []\n    for i in range(1, len(nums)):\n        differences.append(nums[i] - nums[i-1])\n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    \"\"\"\n    Generates a sequence of numbers from 1 to n, alternating between increasing and decreasing order.\n\n    Args:\n        n (int): The number of terms in the sequence.\n        k (int): The number of terms to increase before decreasing.\n\n    Returns:\n        list: A list of numbers from 1 to n, alternating between increasing and decreasing order.\n    \"\"\"\n    result = []\n    for i in range(n):\n        if i % 2 == 0:\n            result.append(i)\n        else:\n            result.append(n - i)\n    return result"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if i == j:\n                count += 1\n    return count"}
{"id": "337_0", "code": "def find_ways(M):\n    \"\"\"\n    Count sequences of given length having non-negative prefix sums that can be generated by given values.\n\n    Args:\n    M (list): A list of integers representing the given values.\n\n    Returns:\n    int: The number of sequences of given length that can be generated.\n    \"\"\"\n    n = len(M)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i][j + 1] = dp[i - 1][j] + dp[i - j][j]\n            if j >= 0 and M[i - 1] - M[j - 1] >= 0:\n                dp[i][j + 1] += dp[i - 1][j - 1]\n    return dp[n][n]"}
{"id": "338_0", "code": "def check(string):\n    if string[0] == '0' or string[0] == '1':\n        return True\n    else:\n        return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    \"\"\"\n    This function minimizes the length of a given string by removing one character at a time.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The minimized string.\n    \"\"\"\n    # Initialize the minimum length and the result string\n    min_len = float('inf')\n    result = s\n    \n    # Iterate over all possible characters to remove\n    for i in range(len(s)):\n        # Create a copy of the string with the current character removed\n        temp = s[:i] + s[i+1:]\n        \n        # Check if the length of the temporary string is less than the minimum length\n        if len(temp) < min_len:\n            # Update the minimum length and the result string\n            min_len = len(temp)\n            result = temp\n    \n    return result"}
{"id": "340_0", "code": "def first_Element(arr, n, k):\n    \"\"\"\n    This function finds the first element occurring k times in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The number of occurrences.\n\n    Returns:\n    int: The first element occurring k times in the array.\n    \"\"\"\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over the array and count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Iterate over the array again to find the first element occurring k times\n    for num in arr:\n        if count_dict[num] == k:\n            return num\n    \n    # If no element occurs k times, return None\n    return None"}
{"id": "341_0", "code": "def unique_Characters(str):\n    \"\"\"\n    Checks whether all characters in a given string are unique.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        bool: True if all characters are unique, False otherwise.\n    \"\"\"\n    return len(str) == len(set(str))"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    \"\"\"\n    Removes a specified column from a given nested list.\n\n    Args:\n        list1 (list): The input list.\n        n (int): The column index to be removed.\n\n    Returns:\n        list: The modified list with the specified column removed.\n    \"\"\"\n    if not list1:\n        return list1\n    if n < 0 or n >= len(list1):\n        raise ValueError(\"Column index out of range\")\n    return [item for i, item in enumerate(list1) if i != n]"}
{"id": "343_0", "code": "def tn_ap(a, n, d):\n    \"\"\"\n    Calculate the nth term of an arithmetic progression.\n\n    Parameters:\n    a (float): The first term of the progression.\n    n (int): The term number to calculate.\n    d (float): The common difference of the progression.\n\n    Returns:\n    float: The nth term of the progression.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    if d == 0:\n        raise ValueError(\"d cannot be zero.\")\n    if n == 1:\n        return a\n    else:\n        return a + (n - 1) * d"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    \"\"\"\n    Counts the number of rectangles in a circle of radius r.\n\n    Args:\n        radius (float): The radius of the circle.\n\n    Returns:\n        int: The number of rectangles in the circle.\n    \"\"\"\n    # Calculate the number of rectangles\n    num_rectangles = 0\n    for x in range(-radius, radius + 1):\n        for y in range(-radius, radius + 1):\n            # Check if the point (x, y) is inside the circle\n            if x ** 2 + y ** 2 <= radius ** 2:\n                num_rectangles += 1\n    return num_rectangles"}
{"id": "345_0", "code": "import math\n\ndef find_angle(a, b):\n    \"\"\"\n    Calculate the third angle of a triangle given two angles.\n\n    Args:\n        a (float): The first angle in degrees.\n        b (float): The second angle in degrees.\n\n    Returns:\n        float: The third angle in degrees.\n    \"\"\"\n    # Convert angles from degrees to radians\n    a_rad = math.radians(a)\n    b_rad = math.radians(b)\n\n    # Calculate the third angle using the sum of angles in a triangle\n    c_rad = math.pi - a_rad - b_rad\n\n    # Convert the third angle back to degrees\n    c_deg = math.degrees(c_rad)\n\n    return c_deg\n\n# Example usage:\nprint(find_angle(60, 30))  # Output: 90.0"}
{"id": "346_0", "code": "def find_max(test_list):\n    \"\"\"\n    This function finds the maximum element of all the given tuple records.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n        tuple: A tuple containing the maximum element of all the given tuple records.\n    \"\"\"\n    # Check if the input list is empty\n    if not test_list:\n        return None\n\n    # Initialize the maximum element with the first element of the first tuple\n    max_element = test_list[0][0]\n\n    # Iterate over the rest of the tuples in the list\n    for tup in test_list[1:]:\n        # Check if the current tuple has more elements than the current maximum\n        if len(tup) > 1:\n            # Update the maximum element if the current tuple's first element is greater\n            max_element = max(max_element, tup[0])\n\n    # Return the maximum element\n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    # Define a lambda function to calculate the modulo division\n    mod_div = lambda x, y: x % y\n    \n    # Use map to apply the lambda function to each element in the lists\n    result = list(map(mod_div, nums1, nums2))\n    \n    return result"}
{"id": "348_0", "code": "import math\n\ndef Check_Solution(a, b, c):\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is positive, zero or negative\n    if discriminant > 0:\n        # Two distinct real roots\n        if b == 0:\n            return \"The equation has two distinct real roots.\"\n        else:\n            return \"The equation has two distinct real roots.\"\n    elif discriminant == 0:\n        # One repeated real root\n        if a == 0:\n            return \"The equation has one repeated real root.\"\n        else:\n            return \"The equation has one repeated real root.\"\n    else:\n        # Two equal real roots\n        if a == 0:\n            return \"The equation has two equal real roots.\"\n        else:\n            return \"The equation has two equal real roots.\"\n\n# Test the function\nprint(Check_Solution(1, 2, 1))  # Expected output: The equation has two equal real roots.\nprint(Check_Solution(1, 2, 3))  # Expected output: The equation has two distinct real roots.\nprint(Check_Solution(1, 2, 4))  # Expected output: The equation has one repeated real root."}
{"id": "349_0", "code": "def get_carol(n):\n    \"\"\"\n    Returns the nth Carol number.\n\n    The Carol numbers are a sequence of numbers that are one less than the sum of all the positive integers up to n.\n    For example, the 1st Carol number is 1, the 2nd is 3, the 3rd is 6, and so on.\n\n    Args:\n        n (int): The position of the Carol number to generate.\n\n    Returns:\n        int: The nth Carol number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1) // 2"}
{"id": "350_0", "code": "def remove_empty(list1):\n    \"\"\"\n    Removes empty lists from a given list of lists.\n\n    Args:\n        list1 (list): The input list of lists.\n\n    Returns:\n        list: The input list with empty lists removed.\n    \"\"\"\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum occurrences in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum occurrences.\n    \"\"\"\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum occurrences\n    max_item = max(count_dict, key=count_dict.get)\n\n    return max_item"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    \"\"\"\n    This function adds k elements to each element in the tuple.\n\n    Args:\n        test_list (list): The input list.\n        K (int): The number of elements to add.\n\n    Returns:\n        list: The modified list with k elements added to each element.\n    \"\"\"\n    # Check if the input list is empty\n    if not test_list:\n        return test_list\n\n    # Calculate the number of elements to add\n    num_to_add = len(test_list) - 1\n\n    # Add k elements to each element in the tuple\n    result = [element + K for element in test_list]\n\n    return result"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(s):\n    flips = 0\n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] == '0':\n                flips += 1\n            else:\n                flips += 2\n        else:\n            if s[i] == '1':\n                flips += 1\n            else:\n                flips += 2\n    return flips"}
{"id": "354_0", "code": "def count_Digit(n):\n    count = 0\n    while n > 0:\n        count += n % 10\n        n = n // 10\n    return count"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    \"\"\"\n    This function calculates the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        list_nums (list): A list of integers.\n\n    Returns:\n        int: The largest product of the pair of adjacent elements.\n    \"\"\"\n    if len(list_nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(list_nums) - 1):\n        # Calculate the product of the current element and the next element\n        product = list_nums[i] * list_nums[i + 1]\n        # Update the maximum product if the current product is larger\n        max_product = max(max_product, product)\n\n    return max_product"}
{"id": "356_0", "code": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef is_tree_balanced(root):\n    \"\"\"\n    Checks if a binary tree is balanced or not.\n\n    Args:\n    root (TreeNode): The root of the binary tree.\n\n    Returns:\n    bool: True if the binary tree is balanced, False otherwise.\n    \"\"\"\n    def check_balance(node):\n        # Base case: An empty tree is balanced\n        if node is None:\n            return True\n\n        # Check if the tree is balanced recursively\n        if not check_balance(node.left) or not check_balance(node.right):\n            return False\n\n        # Check if the tree is balanced by comparing the absolute difference of the heights\n        return abs(node.left_height - node.right_height) <= 1\n\n    # Calculate the height of the tree\n    node_height = 0\n    def calculate_height(node):\n        nonlocal node_height\n        if node is None:\n            return 0\n        node_height += 1\n        return max(calculate_height(node.left), calculate_height(node.right)) + 1\n\n    # Calculate the height of the tree\n    node_height = calculate_height(root)\n\n    # Check if the tree is balanced\n    return check_balance(root)"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    \"\"\"\n    Repeats the given tuple n times.\n\n    Args:\n        test_tup (tuple): The tuple to be repeated.\n        N (int): The number of times to repeat the tuple.\n\n    Returns:\n        tuple: The repeated tuple.\n    \"\"\"\n    return tuple(test_tup for _ in range(N))"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l, w, h):\n    \"\"\"\n    Calculate the lateral surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: lateral surface area of the cuboid\n    \"\"\"\n    # Calculate the lateral surface area\n    lateral_surface_area = 2 * (l * w + w * h + h * l)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    \"\"\"\n    Sort a tuple by its float element.\n\n    Args:\n        price (tuple): A tuple containing a float and a string.\n\n    Returns:\n        tuple: A sorted tuple with the float element first.\n    \"\"\"\n    return tuple(sorted(price, key=lambda x: x[1]))"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    \"\"\"\n    Find the smallest missing element in a sorted array.\n\n    Args:\n        A (list): A sorted list of elements.\n        left_element (int): The smallest element in the list.\n        right_element (int): The largest element in the list.\n\n    Returns:\n        int: The smallest missing element in the list.\n    \"\"\"\n    # Initialize the left and right pointers\n    left = 0\n    right = len(A) - 1\n\n    # Traverse the list from both ends\n    while left <= right:\n        # If the current element is equal to the left element, move the left pointer\n        if A[left] == left_element:\n            left += 1\n        # If the current element is equal to the right element, move the right pointer\n        elif A[right] == right_element:\n            right -= 1\n        # If the current element is greater than the left element, the smallest missing element is the right element\n        elif A[right] < A[left]:\n            return right_element\n        # If the current element is less than the left element, the smallest missing element is the right element plus one\n        else:\n            return right_element + 1\n\n    # If the right pointer is equal to the left pointer, it means all elements are present in the list\n    return left_element"}
{"id": "361_0", "code": "import heapq\n\ndef heap_assending(nums):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements in ascending order.\n    \"\"\"\n    # Convert the list into a heap\n    heapq.heapify(nums)\n\n    # Initialize an empty list to store the sorted elements\n    sorted_nums = []\n\n    # While the heap is not empty\n    while nums:\n        # Extract the smallest element from the heap\n        smallest = heapq.heappop(nums)\n\n        # Add the smallest element to the sorted list\n        sorted_nums.append(smallest)\n\n    # Return the sorted list\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(l, w, h):\n    \"\"\"\n    Calculate the volume of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: volume of the cuboid\n    \"\"\"\n    return l * w * h"}
{"id": "363_0", "code": "import itertools\n\ndef permute_string(str):\n    # Convert the string to a list of characters\n    chars = list(str)\n    \n    # Use itertools.permutations to generate all permutations\n    perms = itertools.permutations(chars)\n    \n    # Convert the permutations back to a string\n    perms_str = ''.join(perms)\n    \n    # Print the result\n    print(perms_str)"}
{"id": "364_0", "code": "def round_num(n, m):\n    \"\"\"\n    Rounds the given number to the nearest multiple of a specific number.\n\n    Args:\n        n (int): The number to be rounded.\n        m (int): The multiple to which the number should be rounded.\n\n    Returns:\n        int: The rounded number.\n    \"\"\"\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is 0, the number is already a multiple of m\n    if remainder == 0:\n        return n\n    \n    # Otherwise, round n down to the nearest multiple of m\n    else:\n        return n - remainder"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    seen = set()\n    result = []\n    for item in test_tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result"}
{"id": "366_0", "code": "def remove_char(s, c):\n    \"\"\"\n    Removes all occurrences of a character from a given string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to be removed.\n\n    Returns:\n        str: The modified string with all occurrences of the character removed.\n    \"\"\"\n    return s.replace(c, '')"}
{"id": "367_0", "code": "def move_first(test_list):\n    \"\"\"\n    Shifts the last element to the first position in the given list.\n\n    Args:\n        test_list (list): The input list.\n\n    Returns:\n        list: The modified list with the last element moved to the first position.\n    \"\"\"\n    if len(test_list) == 0:\n        return test_list\n    elif len(test_list) == 1:\n        return test_list\n    else:\n        return test_list[:-1] + [test_list[-1]] + test_list[-2:]"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    Calculate the surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: surface area of the cuboid\n    \"\"\"\n    # Calculate the surface area of the cuboid\n    surface_area = 2 * (l * w + w * h + l * h)\n    return surface_area"}
{"id": "369_0", "code": "import numpy as np\n\ndef multi_list(rownum, colnum):\n    # Initialize an empty 2D list\n    result = []\n    # Loop through each row\n    for i in range(rownum):\n        # Loop through each column\n        for j in range(colnum):\n            # Append the current element to the result list\n            result.append([i, j])\n    # Convert the result list to a numpy array\n    return np.array(result)"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists by a given index of the inner list.\n\n    Args:\n        list_data (list): The input list of lists.\n        index_no (int): The index of the inner list to sort by.\n\n    Returns:\n        list: The sorted list of lists.\n    \"\"\"\n    # Check if the input list is empty\n    if not list_data:\n        return list_data\n\n    # Get the inner list at the specified index\n    inner_list = list_data[0][index_no]\n\n    # Check if the inner list is empty\n    if not inner_list:\n        return list_data\n\n    # Sort the inner list\n    inner_list.sort()\n\n    # Recursively sort the outer list\n    return [inner_list] + index_on_inner_list(list_data[1:], index_no)"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    \"\"\"\n    Find the number of rotations in a circularly sorted array.\n\n    Args:\n    A (list): A list of integers representing a circularly sorted array.\n\n    Returns:\n    int: The number of rotations in the array.\n    \"\"\"\n    n = len(A)\n    # Find the index of the minimum element\n    min_idx = A.index(min(A))\n    # Calculate the number of rotations\n    rotations = (n - min_idx) % n\n    return rotations"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    Toggles all odd bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all odd bits toggled.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the binary string\n    for bit in bin_n:\n        # If the bit is '1', toggle it\n        if bit == '1':\n            result += '1'\n        # If the bit is '0', keep it as is\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer\n    result = int(result, 2)\n    \n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Sort the array in ascending order\n    arr.sort()\n    # Initialize the minimum value and its frequency\n    min_val = arr[0]\n    min_freq = 1\n    # Iterate through the array to find the frequency of the smallest value\n    for i in range(1, len(arr)):\n        if arr[i] == min_val:\n            min_freq += 1\n        else:\n            # Update the minimum value and its frequency\n            min_val = arr[i]\n            min_freq = 1\n    return min_freq"}
{"id": "374_0", "code": "def get_perrin(n):\n    \"\"\"\n    Returns the nth Pernin number.\n\n    Args:\n        n (int): The position of the Pernin number to be found.\n\n    Returns:\n        int: The nth Pernin number.\n    \"\"\"\n    # Base case: if n is 0, return 0\n    if n == 0:\n        return 0\n    # Recursive case: return 2 * get_perrin(n - 1) + n\n    else:\n        return 2 * get_perrin(n - 1) + n"}
{"id": "375_0", "code": "def swap_count(s):\n    \"\"\"\n    Calculate the minimum number of swaps required for bracket balancing in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of swaps required for bracket balancing.\n    \"\"\"\n    n = len(s)\n    balance = 0\n    for i in range(n):\n        if s[i] == '(':\n            balance += 1\n        elif s[i] == ')':\n            balance -= 1\n        if balance < 0:\n            balance = 0\n    return balance"}
{"id": "376_0", "code": "def even_or_odd(N):\n    if N % 2 == 0:\n        return \"The hexadecimal number is even.\"\n    else:\n        return \"The hexadecimal number is odd.\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    Returns the highest power of 2 that is less than or equal to n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2"}
{"id": "378_0", "code": "def find_lucas(n):\n    \"\"\"\n    Returns the nth Lucas number.\n\n    Args:\n        n (int): The position of the Lucas number to find.\n\n    Returns:\n        int: The nth Lucas number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b"}
{"id": "379_0", "code": "def add_string(list, string):\n    \"\"\"\n    Inserts a given string at the beginning of all items in a list.\n\n    Args:\n        list (list): The input list.\n        string (str): The string to be inserted.\n\n    Returns:\n        list: The modified list with the string inserted at the beginning.\n    \"\"\"\n    # Check if the input list is empty\n    if not list:\n        return list\n\n    # Use list comprehension to create a new list with the string inserted at the beginning\n    return [string] + list"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    Convert more than one list to nested dictionary.\n\n    Args:\n        l1 (list): The first list to convert.\n        l2 (list): The second list to convert.\n        l3 (list): The third list to convert.\n\n    Returns:\n        dict: A nested dictionary containing the converted lists.\n    \"\"\"\n    # Initialize an empty dictionary to store the result\n    result = {}\n\n    # Iterate over the elements of the first list\n    for i, elem in enumerate(l1):\n        # If the element is a list, recursively call the function\n        if isinstance(elem, list):\n            result[i] = convert_list_dictionary(elem, l2, l3)\n        # If the element is a dictionary, add it to the result\n        elif isinstance(elem, dict):\n            result[i] = elem\n        # If the element is not a list or dictionary, add it to the result as is\n        else:\n            result[i] = elem\n\n    # Return the resulting dictionary\n    return result"}
{"id": "381_0", "code": "def get_max_sum(n):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Base case: If n is 1, return 1\n    if n == 1:\n        return 1\n    \n    # Initialize the maximum sum\n    max_sum = 1\n    \n    # Calculate the maximum sum for n/2, n/3, n/4, and n/5\n    max_sum_1 = get_max_sum(n // 2)\n    max_sum_2 = get_max_sum(n // 3)\n    max_sum_3 = get_max_sum(n // 4)\n    max_sum_4 = get_max_sum(n // 5)\n    \n    # Update the maximum sum\n    max_sum = max(max_sum, max_sum_1 + max_sum_2 + max_sum_3 + max_sum_4)\n    \n    return max_sum"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=lambda x: len(x))"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    \"\"\"\n    Checks if the given tuple is distinct or not.\n\n    Args:\n        test_tup (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    for char in str1:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Find the first non-repeating character\n    for char in str1:\n        if char_frequency[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    \"\"\"\n    Checks whether the given string starts and ends with the same character or not using regex.\n\n    Args:\n        string (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string starts and ends with the same character, False otherwise.\n    \"\"\"\n    # Define the regex pattern\n    pattern = r'^[a-zA-Z]([a-zA-Z])*$'\n\n    # Check if the string matches the pattern\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    # Sort the numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Calculate the median\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers)//2 - 1] + numbers[len(numbers)//2]) / 2\n    else:\n        median = numbers[len(numbers)//2]\n    \n    return median"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    \"\"\"\n    Compute the sum of digits of each number in the given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of sums of digits of each number in the input list.\n    \"\"\"\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the bitwise XOR operation across two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple to perform the XOR operation on.\n        test_tup2 (tuple): The second tuple to perform the XOR operation on.\n\n    Returns:\n        tuple: A new tuple containing the result of the XOR operation.\n    \"\"\"\n    # Convert tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the elements of the lists\n    for i in range(len(list1)):\n        # Perform the XOR operation on the current elements\n        result.append(list1[i] ^ list2[i])\n\n    # Convert the result list back to a tuple\n    result = tuple(result)\n\n    return result"}
{"id": "389_0", "code": "def extract_freq(test_list):\n    # Convert the list to a set to remove duplicates\n    unique_tuples = set(tuple(sorted(t)) for t in test_list)\n    \n    # Use a dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over the unique tuples and count their frequency\n    for t in unique_tuples:\n        if t in freq_dict:\n            freq_dict[t] += 1\n        else:\n            freq_dict[t] = 1\n    \n    # Convert the dictionary back to a list of tuples\n    freq_list = list(freq_dict.items())\n    \n    return freq_list"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function adds elements of two nested tuples element-wise.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: The result of the element-wise addition of the two input tuples.\n    \"\"\"\n    # Check if both inputs are tuples\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples.\")\n\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Add the elements of the current tuple elements-wise\n        result.append(test_tup1[i] + test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "def ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p using the formula: ncr%p = n! / (r! * (n-r)!)\n    \"\"\"\n    # Initialize the result\n    result = 1\n    \n    # Compute the factorial of n and r\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            result = (result * i * j) % p\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv = pow(r, -1, p)\n    \n    # Compute the modular inverse of (n-r)\n    n_r_inv = pow(n-r, -1, p)\n    \n    # Compute the modular inverse of n\n    n_inv = pow(n, -1, p)\n    \n    # Compute the modular inverse of r\n    r_inv"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    pattern = r\"^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$\"\n    return bool(re.match(pattern, str))"}
{"id": "393_0", "code": "def minimum(a, b):\n    \"\"\"\n    Returns the minimum of two numbers.\n\n    Args:\n        a (int or float): The first number.\n        b (int or float): The second number.\n\n    Returns:\n        int or float: The minimum of a and b.\n    \"\"\"\n    return min(a, b)"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    Checks whether an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be checked.\n        tuple1 (tuple): The tuple to be searched in.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return tuplex in tuple1"}
{"id": "395_0", "code": "def find_Parity(x):\n    \"\"\"\n    This function calculates the parity of a given number.\n\n    Parameters:\n    x (int): The number for which the parity is to be calculated.\n\n    Returns:\n    int: The parity of the given number.\n    \"\"\"\n    # Check if the number is even or odd\n    if x % 2 == 0:\n        return 0  # Even number\n    else:\n        return 1  # Odd number"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n    \n    # Join the sorted digits to form a string\n    bigger = ''.join(map(str, digits))\n    \n    # Convert the string back to an integer\n    bigger = int(bigger)\n    \n    return bigger"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    \"\"\"\n    Find k number of pairs which consist of one element from the first array and one element from the second array.\n\n    Args:\n    nums1 (list): The first array.\n    nums2 (list): The second array.\n    k (int): The number of pairs to generate.\n\n    Returns:\n    list: A list of tuples, where each tuple contains a pair of elements from the two arrays.\n    \"\"\"\n    # Sort both arrays\n    nums1.sort()\n    nums2.sort()\n\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate over the first array\n    for num1 in nums1:\n        # Iterate over the second array\n        for num2 in nums2:\n            # Check if the current pair is valid (i.e., num1 < num2)\n            if num1 < num2:\n                # Add the pair to the list\n                pairs.append((num1, num2))\n\n    # Return the list of pairs\n    return pairs"}
{"id": "398_0", "code": "def min_product_tuple(lst):\n    \"\"\"\n    This function finds the minimum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        int: The minimum product from the pairs of tuples.\n    \"\"\"\n    min_product = float('inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            product = lst[i][0] * lst[j][0]\n            min_product = min(min_product, product)\n    return min_product"}
{"id": "399_0", "code": "def min_val(listval):\n    # Check if the list is empty\n    if not listval:\n        return None\n\n    # Initialize the minimum value with the first element of the list\n    min_val = listval[0]\n\n    # Iterate over the list to find the minimum value\n    for val in listval:\n        if val < min_val:\n            min_val = val\n\n    return min_val"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    # Use regex to match snake case\n    match = re.match(r'^([a-z]+)([a-z]+)*$', word)\n    if match:\n        # Split the match into words\n        words = match.group(1) + match.group(2) + match.group(3) + ...\n        # Capitalize the first letter of each word except the first one\n        camel_case = words[0] + ''.join(word.capitalize() for word in words[1:])\n        return camel_case\n    else:\n        return word"}
{"id": "401_0", "code": "def remove_odd(l):\n    \"\"\"\n    Removes odd numbers from a given list.\n\n    Args:\n        l (list): The input list.\n\n    Returns:\n        list: The list with odd numbers removed.\n    \"\"\"\n    return [x for x in l if x % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    \"\"\"\n    Extract the nth element from a given list of tuples.\n\n    Args:\n        list1 (list): A list of tuples.\n        n (int): The index of the element to extract.\n\n    Returns:\n        tuple: The nth element of the list.\n\n    Raises:\n        ValueError: If n is less than 1 or greater than the length of the list.\n    \"\"\"\n    if n < 1 or n > len(list1):\n        raise ValueError(\"n is out of range\")\n\n    return list1[n-1]"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    \"\"\"\n    Checks whether the value exists in a sequence or not.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        bool: True if the value exists in list1, False otherwise.\n    \"\"\"\n    # Convert both lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Check if the value exists in set1\n    return set1.intersection(set2).issubset(set1)"}
{"id": "404_0", "code": "def max_product(arr):\n    \"\"\"\n    This function finds the pair of numbers in the given array with the highest product.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        tuple: A tuple containing the pair of numbers with the highest product.\n    \"\"\"\n    if len(arr) < 2:\n        return None\n\n    # Initialize max_product and min_product variables\n    max_product = float('-inf')\n    min_product = float('inf')\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Calculate the product of the current pair\n            product = arr[i] * arr[j]\n\n            # Update max_product and min_product if necessary\n            if product > max_product:\n                max_product = product\n                min_product = product\n            elif product < min_product:\n                min_product = product\n\n    # Return the pair with the highest product\n    if max_product == float('-inf'):\n        return None\n    else:\n        return (min_product, max_product)\n\n# Example usage\narr = [10, 5, 2, 6, 9]\nresult = max_product(arr)\nif result is not None:\n    print(f\"The pair with the highest product is {result[0]} and {result[1]}\")\nelse:\n    print(\"No pair found with the highest product.\")"}
{"id": "405_0", "code": "def breakSum(n):\n    # Base case: If n is 0, return 0\n    if n == 0:\n        return 0\n    \n    # Recursive case: If n is greater than 0, return the maximum of two options:\n    # 1. n - 1 + breakSum(n - 1)\n    # 2. n + breakSum(n - 1)\n    # We choose the option that has the maximum sum\n    return max(breakSum(n - 1) + n, breakSum(n - 1))"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize an empty list to store the tuples\n    result = []\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Check if the tuple is not empty\n        if tup:\n            # Append the tuple to the result list\n            result.append(tup)\n    \n    # Return the result list\n    return result"}
{"id": "407_0", "code": "def Find_Max(lst):\n    \"\"\"\n    Find the sublist with maximum length in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The sublist with maximum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    max_len = 0\n    max_sublist = []\n\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            if len(sublist) > max_len:\n                max_len = len(sublist)\n                max_sublist = sublist\n\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    print(\"Total sum:\", total_sum)\n    print(\"Length of the list:\", len(list1))\n    print(\"Total sum multiplied by the length of the list:\", total_sum * len(list1))"}
{"id": "409_0", "code": "def cube_Sum(n):\n    \"\"\"\n    Calculate the sum of cubes of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers.\n\n    Returns:\n        int: The sum of cubes of first n even natural numbers.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Loop through each even number from 2 to n\n    for i in range(2, n + 1, 2):\n        # Calculate cube of current number and add to sum\n        total_sum += i ** 3\n    \n    # Return the final sum\n    return total_sum"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    \"\"\"\n    Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    delimiter = ','\n    return delimiter.join(map(str, test_tup))"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of the first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        float: The average of cubes of the first n natural numbers.\n    \"\"\"\n    # Initialize sum and count variables\n    total_sum = 0\n    count = 0\n\n    # Calculate the sum of cubes of the first n natural numbers\n    for i in range(1, n + 1):\n        total_sum += i ** 3\n        count += 1\n\n    # Calculate the average\n    average = total_sum / count\n\n    return average"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    \"\"\"\n    This function calculates the maximum gold that can be obtained from a gold mine with m gold bars, n gold bars, and a gold bar per unit of time.\n\n    Parameters:\n    gold (int): The number of gold bars available.\n    m (int): The number of gold bars that can be mined per unit of time.\n    n (int): The number of gold bars that can be mined per unit of time.\n\n    Returns:\n    int: The maximum gold that can be obtained.\n    \"\"\"\n    # Calculate the maximum gold that can be obtained by mining all gold bars\n    max_gold = gold * m * n\n\n    # Calculate the maximum gold that can be obtained by mining all gold bars in the same time period\n    max_gold_in_time = gold * m * n\n\n    # Return the maximum of the two values\n    return max(max_gold, max_gold_in_time)"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    \"\"\"\n    Extract the rear index element of each string in the given tuple.\n\n    Args:\n        test_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of rear index elements.\n    \"\"\"\n    return [s[-1] for s in test_tuple]"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list1 (list): The input list.\n        x (any): The element to search for.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == x:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\nfrom datetime import datetime\n\ndef change_date_format(dt):\n    # Define the regex pattern\n    pattern = r'\\d{4}-\\d{2}-\\d{2}'\n    \n    # Replace the regex pattern with the desired format\n    new_date = re.sub(pattern, lambda x: x.group(0).zfill(2), dt.strftime('%d-%m-%Y'))\n    \n    return new_date"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple containing the elementwise and tuples from the input tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple to be processed.\n        test_tup2 (tuple): The second tuple to be processed.\n\n    Returns:\n        tuple: A new tuple containing the elementwise and tuples from the input tuples.\n    \"\"\"\n    # Extract the elementwise and tuples from the input tuples\n    elementwise = tuple(map(lambda x, y: x and y, test_tup1, test_tup2))\n    tuples = tuple(map(lambda x, y: x and y, test_tup1, test_tup2))\n\n    # Combine the elementwise and tuples into a single tuple\n    result = elementwise + tuples\n\n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola.\n\n    Parameters:\n    a (float): The coefficient of the x^2 term.\n    b (float): The coefficient of the x term.\n    c (float): The constant term.\n\n    Returns:\n    str: The equation of the directrix.\n    \"\"\"\n    # Calculate the focal length\n    focal_length = abs(c) / (a ** 0.5)\n\n    # Calculate the directrix\n    if a == 0:\n        directrix = \"x = 0\"\n    elif b == 0:\n        directrix = \"y = 0\"\n    else:\n        directrix = f\"x = -{focal_length}\"\n\n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2))"}
{"id": "421_0", "code": "import math\n\ndef median_trapezium(base1, base2, height):\n    \"\"\"\n    Calculate the median of a trapezium.\n\n    Parameters:\n    base1 (float): The length of the first base of the trapezium.\n    base2 (float): The length of the second base of the trapezium.\n    height (float): The height of the trapezium.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    # Calculate the average of the bases\n    avg_bases = (base1 + base2) / 2\n\n    # Calculate the median of the trapezium\n    median = (avg_bases + height) / 2\n\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    \"\"\"\n    Checks whether the entered number is greater than the elements of the given array.\n\n    Args:\n        arr (list): A list of numbers.\n        number (int): The number to be checked.\n\n    Returns:\n        bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num < number for num in arr)"}
{"id": "423_0", "code": "def text_match_one(text):\n    \"\"\"\n    Generate a string that matches a string that has an a followed by one or more b's.\n    \n    Args:\n        text (str): The input string.\n    \n    Returns:\n        str: A generated string that matches the input string.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Initialize a counter to count the number of 'a's\n    a_count = 0\n    \n    # Iterate over each character in the input string\n    for char in text:\n        # If the character is 'a', increment the counter\n        if char == 'a':\n            a_count += 1\n        # If the character is 'b', append the current result to the result string\n        elif char == 'b':\n            result += \"b\" * a_count\n        # If the character is not 'a' or 'b', append the current result to the result string\n        else:\n            result += char\n    \n    # Return the generated string\n    return result"}
{"id": "424_0", "code": "def last_Digit(n):\n    \"\"\"\n    This function finds the last digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The last digit of the input number.\n    \"\"\"\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for i in list1:\n        if i < 0:\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    \"\"\"\n    This function removes all odd characters from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all odd characters removed.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each character in the input string\n    for char in str1:\n        # Check if the character is an odd number (1, 3, 5, 7, 9)\n        if int(char) % 2 != 0:\n            # If the character is odd, append it to the result string\n            result += char\n\n    # Return the result string\n    return result"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    \"\"\"\n    Counts the number of bidirectional tuple pairs in a list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        int: The number of bidirectional tuple pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            # Check if the tuple is bidirectional\n            if (test_list[i] == test_list[j]) and (test_list[j] == test_list[i]):\n                count += 1\n    return count"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    \"\"\"\n    Convert a list of multiple integers into a single integer.\n\n    Args:\n        L (list): A list of integers.\n\n    Returns:\n        int: The sum of all integers in the list.\n    \"\"\"\n    return sum(L)"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    Find all adverbs and their positions in a given sentence.\n\n    Args:\n        text (str): The input sentence.\n\n    Returns:\n        dict: A dictionary containing the adverbs and their positions.\n    \"\"\"\n    # Define a list of common adverbs\n    adverbs = ['fast', 'slow', 'loud', 'quiet', 'high', 'low', 'big', 'small', 'long', 'short', 'deep', 'shallow', 'clear', 'dark', 'bright', 'heavy', 'light', 'old', 'new', 'old', 'new', 'old', 'new']\n\n    # Initialize an empty dictionary to store the adverbs and their positions\n    adverb_positions = {}\n\n    # Use regular expression to find all words that are followed by an adverb\n    words = re.findall(r'\\b\\w+\\b(?=\\s*[a-z])', text)\n    for word in words:\n        # Check if the word is an adverb\n        if word in adverbs:\n            # Find the position of the adverb in the sentence\n            position = text.find(word)\n            # Store the adverb and its position in the dictionary\n            adverb_positions[word] = position\n\n    return adverb_positions\n\n# Example usage:\ntext = \"The fast runner was very loud and clear. The slow runner was very quiet and deep.\"\nprint(find_adverb_position(text))"}
{"id": "430_0", "code": "def surfacearea_cube(length):\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Args:\n        length (float): The length of the cube.\n\n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    # Calculate the surface area of the cube\n    surface_area = 6 * (length ** 2)\n    return surface_area"}
{"id": "431_0", "code": "def positive_count(nums):\n    \"\"\"\n    This function calculates the ratio of positive numbers in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of positive numbers in the list.\n    \"\"\"\n    positive_nums = [num for num in nums if num > 0]\n    return len(positive_nums) / len(nums) if positive_nums else 0"}
{"id": "432_0", "code": "def largest_neg(list1):\n    # Check if the list is empty\n    if not list1:\n        return None\n\n    # Find the largest negative number\n    largest = -1\n    for num in list1:\n        if num < 0 and num > largest:\n            largest = num\n\n    return largest"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    \"\"\"\n    Trim each tuple in the given list by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to trim from the beginning of each tuple.\n\n    Returns:\n        list: A new list with trimmed tuples.\n    \"\"\"\n    return [tuple(t[:K]) for t in test_list]"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index-wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index-wise multiplication.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices and elements of the first tuple\n    for i, (x, y) in enumerate(zip(test_tup1, test_tup2)):\n        # Multiply the elements at the current index and append to the result list\n        result.append(x * y)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements of list in a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        lst (list): The list to search for.\n\n    Returns:\n        dict: A dictionary where the keys are the elements of the list and the values are their occurrences in the tuple.\n    \"\"\"\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n\n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the element is in the tuple\n        if element in tup:\n            # If the element is already in the dictionary, increment its count\n            if element in occurrences:\n                occurrences[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                occurrences[element] = 1\n\n    # Return the dictionary of occurrences\n    return occurrences"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return [lambda x: x**3 for x in nums]"}
{"id": "437_0", "code": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of perrin numbers.\n\n    Args:\n        n (int): The number of perrin numbers to calculate.\n\n    Returns:\n        int: The sum of perrin numbers.\n    \"\"\"\n    # Initialize the sum of perrin numbers\n    total_sum = 0\n\n    # Calculate the sum of perrin numbers\n    for i in range(1, n + 1):\n        # Calculate the perrin number\n        perrin_num = 0\n        for j in range(1, i + 1):\n            perrin_num += (2 * j - 1) ** (i - 1) / (2 * j - 1)\n        # Add the perrin number to the sum\n        total_sum += perrin_num\n\n    return total_sum"}
{"id": "438_0", "code": "import math\n\ndef check_Triangle(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Check whether a triangle is valid or not given 3 points.\n\n    Args:\n        x1 (float): x-coordinate of the first point.\n        y1 (float): y-coordinate of the first point.\n        x2 (float): x-coordinate of the second point.\n        y2 (float): y-coordinate of the second point.\n        x3 (float): x-coordinate of the third point.\n        y3 (float): y-coordinate of the third point.\n\n    Returns:\n        bool: True if the triangle is valid, False otherwise.\n    \"\"\"\n\n    # Calculate the lengths of the sides\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the triangle is valid\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n\n    # Check if the triangle is equilateral\n    if a == b == c:\n        return True\n\n    # Check if the triangle is isosceles\n    if a == b or b == c or a == c:\n        return True\n\n    # Check if the triangle is right-angled\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or a**2 + c**2 == b**2:\n        return True\n\n    # If none of the above conditions are met, the triangle is invalid\n    return False\n\n# Example usage:\nprint(check_Triangle(0, 0, 3, 0, 3, 4))  # True\nprint(check_Triangle(0, 0, 3, 0, 0, 4))  # False"}
{"id": "439_0", "code": "def extract_string(str, l):\n    \"\"\"\n    Extract specified size of strings from a given list of string values.\n\n    Parameters:\n    str (str): The string to extract from the list.\n    l (list): The list of string values.\n\n    Returns:\n    list: A list of extracted strings.\n    \"\"\"\n    # Check if the input string is in the list\n    if str in l:\n        # Extract the specified size of strings\n        return [s for s in l if s.startswith(str)]\n    else:\n        # Return an empty list if the string is not found\n        return []"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)"}
{"id": "441_0", "code": "def loss_amount(actual_cost, sale_amount):\n    \"\"\"\n    This function calculates the loss amount if the given amount has loss.\n\n    Args:\n        actual_cost (float): The actual cost of the item.\n        sale_amount (float): The sale amount of the item.\n\n    Returns:\n        float: The loss amount if the sale amount is less than the actual cost, otherwise None.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return sale_amount - actual_cost\n    else:\n        return None"}
{"id": "442_0", "code": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The sum of even factors of the input number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    even_sum = 0\n\n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if i is even\n            if i % 2 == 0:\n                # Add i to the sum of even factors\n                even_sum += i\n\n    # Return the sum of even factors\n    return even_sum"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    \"\"\"\n    This function generates a text that matches a word containing 'z'.\n    \n    Parameters:\n    text (str): The input text.\n    \n    Returns:\n    str: The generated text.\n    \"\"\"\n    # Initialize an empty string to store the generated text\n    generated_text = \"\"\n    \n    # Initialize a counter to keep track of the number of 'z' characters\n    z_count = 0\n    \n    # Iterate over each character in the input text\n    for char in text:\n        # If the character is 'z', increment the counter\n        if char == 'z':\n            z_count += 1\n        # If the character is not 'z', add it to the generated text\n        else:\n            generated_text += char\n    \n    # If the counter is greater than 1, add 'z' to the generated text\n    if z_count > 1:\n        generated_text += 'z'\n    \n    # Return the generated text\n    return generated_text"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif monthnum2 in [4, 6, 9, 11]:\n        return False\n    else:\n        return \"Invalid month number\""}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    \"\"\"\n    Reverses the order of the strings in a given list.\n\n    Args:\n        stringlist (list): A list of strings.\n\n    Returns:\n        list: A new list with the strings in reverse order.\n    \"\"\"\n    return [s[::-1] for s in stringlist]"}
{"id": "446_0", "code": "def Find_Min(lst):\n    \"\"\"\n    This function finds the sublist with the minimum length in a given list.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The sublist with the minimum length.\n    \"\"\"\n    # Check if the input list is empty\n    if not lst:\n        return []\n\n    # Initialize the minimum length and the corresponding sublist\n    min_len = float('inf')\n    min_sublist = []\n\n    # Iterate over the list to find the sublist with the minimum length\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check if the current sublist is shorter than the minimum length\n            if len(lst[i]) < min_len:\n                min_len = len(lst[i])\n                min_sublist = lst[i]\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The area of the rectangle.\n    \"\"\"\n    return length * width"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    # Remove uppercase substrings from the input string\n    return re.sub(r'([A-Z])', r'\\1', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    \"\"\"\n    Counts the number of upper case characters in a given string.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        int: The number of upper case characters in the string.\n    \"\"\"\n    return sum(1 for c in str if c.isupper())"}
{"id": "451_0", "code": "import itertools\n\ndef combinations_list(list1):\n    \"\"\"\n    Generate all possible combinations of the elements of a given list.\n\n    Args:\n        list1 (list): The input list.\n\n    Returns:\n        list: A list of tuples, where each tuple is a combination of elements from the input list.\n    \"\"\"\n    # Use itertools.combinations to generate all possible combinations\n    return list(itertools.combinations(list1, len(list1)))"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    \"\"\"\n    This function finds the maximum product subarray of the given array.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The maximum product subarray.\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        # If the current element is negative, swap max_product and min_product\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        # Update max_product and min_product\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        # Update the result\n        result = max(result, max_product)\n\n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    \"\"\"\n    Checks if all values in a dictionary are the same.\n\n    Args:\n        dict (dict): The dictionary to check.\n        n (int): The number of values to check.\n\n    Returns:\n        bool: True if all values are the same, False otherwise.\n    \"\"\"\n    # Check if the input is a dictionary\n    if not isinstance(dict, dict):\n        raise TypeError(\"Input must be a dictionary\")\n\n    # Check if the number of values to check is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Number of values to check must be a positive integer\")\n\n    # Get the values from the dictionary\n    values = dict.values()\n\n    # Check if all values are the same\n    return len(set(values)) == 1"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    \"\"\"\n    Drops empty items from a given dictionary.\n\n    Args:\n        dict1 (dict): The input dictionary.\n\n    Returns:\n        dict: The dictionary with empty items removed.\n    \"\"\"\n    # Create a new dictionary to store the non-empty items\n    new_dict = {}\n\n    # Iterate over the items in the input dictionary\n    for key, value in dict1.items():\n        # Check if the value is not empty\n        if value:\n            # Add the key-value pair to the new dictionary\n            new_dict[key] = value\n\n    # Return the new dictionary\n    return new_dict"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    \"\"\"\n    This function finds the peak element in the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    \n    Returns:\n    int: The index of the peak element in the array.\n    \"\"\"\n    # Initialize the low and high pointers\n    low = 0\n    high = n - 1\n    \n    # Continue the search until the low and high pointers meet\n    while low < high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is greater than the next element, the peak must be on the right side\n        if arr[mid] > arr[mid + 1]:\n            # Move the high pointer to the left\n            high = mid\n        # If the middle element is less than or equal to the next element, the peak must be on the left side\n        else:\n            # Move the low pointer to the right\n            low = mid + 1\n    \n    # Return the index of the peak element\n    return low\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(arr)\npeak_index = find_peak(arr, n)\nprint(\"Peak element index:\", peak_index)"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    octal = oct(deciNum)[2:]  # Remove '0o' prefix\n    return octal"}
{"id": "457_0", "code": "def max_product(arr, n):\n    \"\"\"\n    This function finds the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\n    Parameters:\n    arr (list): The input array of integers.\n    n (int): The length of the input array.\n\n    Returns:\n    int: The maximum product of an increasing subsequence.\n    \"\"\"\n    # Initialize the maximum product and the current product\n    max_product = 0\n    current_product = 1\n\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is greater than the current product, update the current product\n        if arr[i] > current_product:\n            current_product = arr[i]\n        # If the current element is less than the current product, update the maximum product\n        elif arr[i] < current_product:\n            max_product = max(max_product, current_product)\n            current_product = arr[i]\n\n    # Update the maximum product one last time\n    max_product = max(max_product, current_product)\n\n    return max_product"}
{"id": "458_0", "code": "def max_profit(price, k):\n    \"\"\"\n    This function calculates the maximum profit that can be earned from a maximum of k stock transactions.\n\n    Parameters:\n    price (list): A list of stock prices\n    k (int): The maximum number of stock transactions\n\n    Returns:\n    int: The maximum profit that can be earned\n    \"\"\"\n    if k == 0 or len(price) < 2:\n        return 0\n\n    # Initialize a 2D array to store the maximum profit for each subproblem\n    dp = [[0] * len(price) for _ in range(k + 1)]\n\n    # Iterate over each transaction\n    for i in range(1, k + 1):\n        # Initialize the maximum profit for the current transaction\n        max_profit_so_far = -price[0]\n\n        # Iterate over each stock price\n        for j in range(1, len(price)):\n            # Update the maximum profit for the current transaction\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_profit_so_far)\n\n            # Update the maximum profit so far\n            max_profit_so_far = max(max_profit_so_far, dp[i - 1][j] - price[j])\n\n    # Return the maximum profit for the last transaction\n    return dp[k][-1]"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    \"\"\"\n    This function takes a tuple of tuples as input and returns a new tuple containing the pairwise addition of the elements of the input tuple.\n\n    Args:\n        test_tup (tuple): A tuple of tuples.\n\n    Returns:\n        tuple: A new tuple containing the pairwise addition of the elements of the input tuple.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the input tuple\n    for tup in test_tup:\n        # Iterate over each element in the current tuple\n        for elem in tup:\n            # Append the element to the result list\n            result.append(elem)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    \"\"\"\n    This function calculates the remainder of array multiplication divided by n.\n\n    Parameters:\n    arr (list): The input array\n    lens (int): The length of the array\n    n (int): The divisor\n\n    Returns:\n    int: The remainder of the array multiplication divided by n\n    \"\"\"\n    # Calculate the product of the array\n    product = 1\n    for num in arr:\n        product *= num\n\n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n\n    return remainder"}
{"id": "461_0", "code": "def check_Consecutive(lst):\n    \"\"\"\n    Checks if the given list contains consecutive numbers.\n\n    Args:\n        lst (list): The input list to be checked.\n\n    Returns:\n        bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return False\n\n    for i in range(len(lst) - 1):  # Iterate over the list\n        if lst[i] + 1 != lst[i + 1]:  # Check if the current number and the next number are not consecutive\n            return False\n\n    return True  # If no consecutive numbers are found, return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    \"\"\"\n    This function finds the tuple intersection of elements in the given tuple list \n    irrespective of their order.\n\n    Args:\n        test_list1 (list): The first tuple list.\n        test_list2 (list): The second tuple list.\n\n    Returns:\n        list: A list of tuples that are common to both input lists.\n    \"\"\"\n    # Convert the input lists to sets for efficient lookup\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the intersection back to a list of tuples\n    result = list(intersection)\n\n    return result"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    \"\"\"\n    Replace characters in a string.\n\n    Args:\n        str1 (str): The original string.\n        ch (str): The character to be replaced.\n        newch (str): The character to replace with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return str1.replace(ch, newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    # Sort the dictionary by value\n    sorted_dict = dict1.copy()\n    sorted_dict = dict(sorted(sorted_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    \"\"\"\n    This function calculates the sum of the largest and smallest value in a given array.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        return 0\n\n    # Find the smallest and largest values in the list\n    smallest = nums[0]\n    largest = nums[-1]\n\n    # Calculate the sum of the smallest and largest values\n    return smallest + largest"}
{"id": "466_0", "code": "def is_lower(string):\n    return string.lower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    \"\"\"\n    Removes all lowercase substrings from a given string.\n\n    Args:\n        str1 (str): The input string.\n\n    Returns:\n        str: The modified string with all lowercase substrings removed.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over the input string\n    for i in range(len(str1)):\n        # Check if the current character is not lowercase\n        if str1[i].isupper():\n            # If it's not lowercase, append it to the result\n            result += str1[i]\n\n    # Return the modified string\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    # Convert the number to a string\n    str_n = str(n)\n    \n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If negative, remove the negative sign\n        str_n = str_n[1:]\n    \n    # Check if the number is zero\n    if str_n == '0':\n        # If zero, return 0\n        return 0\n    \n    # Find the first digit\n    first_digit = str_n[0]\n    \n    # Return the first digit\n    return first_digit"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    \"\"\"\n    This function finds the maximum occurring character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The character with the maximum occurrence in the string.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_frequency, key=char_frequency.get)\n    \n    return max_char"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    dp = [False] * (sum + 1)\n    dp[0] = True\n    for num in set:\n        for i in range(sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[sum]"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)"}
{"id": "472_0", "code": "import math\n\ndef first_Factorial_Divisible_Number(x):\n    \"\"\"\n    This function finds the first natural number whose factorial is divisible by x.\n\n    Args:\n        x (int): The number by which the factorial of the input number should be divisible.\n\n    Returns:\n        int: The first natural number whose factorial is divisible by x.\n    \"\"\"\n    i = 1\n    while True:\n        factorial = math.factorial(i)\n        if factorial % x == 0:\n            return i\n        i += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    \"\"\"\n    Removes matching tuples from two input lists.\n\n    Args:\n        test_list1 (list): The first list.\n        test_list2 (list): The second list.\n\n    Returns:\n        list: The modified list with matching tuples removed.\n    \"\"\"\n    # Convert the input lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Use set difference to remove matching tuples\n    result = set1 - set2\n\n    # Convert the result back to a list\n    result = list(result)\n\n    return result"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    \"\"\"\n    This function generates the largest palindromic number in the given array.\n    \n    Parameters:\n    A (list): The input list of integers.\n    n (int): The length of the input list.\n    \n    Returns:\n    int: The largest palindromic number in the given array.\n    \"\"\"\n    \n    # Initialize the maximum palindromic number\n    max_palindrome = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # Check if the current number is a palindrome\n        if is_palindrome(A[i]):\n            # Update the maximum palindromic number\n            max_palindrome = max(max_palindrome, A[i])\n    \n    # Return the maximum palindromic number\n    return max_palindrome\n\ndef is_palindrome(num):\n    \"\"\"\n    This function checks if a given number is a palindrome.\n    \n    Parameters:\n    num (int): The input number.\n    \n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    \n    # Convert the number to a string\n    str_num = str(num)\n    \n    # Compare the string with its reverse\n    return str_num == str_num[::-1]\n\n# Example usage\nA = [1, 2, 3, 4, 5]\nn = len(A)\nprint(largest_palindrome(A, n))  # Output: 5"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Compute binomial probability for the given number.\n\n    Parameters:\n    n (int): The total number of trials.\n    k (int): The number of successful trials.\n    p (float): The probability of success in each trial.\n\n    Returns:\n    float: The binomial probability.\n    \"\"\"\n    # Calculate the binomial coefficient using math.comb\n    binomial_coefficient = math.comb(n, k)\n    \n    # Calculate the probability of success and failure\n    success_probability = p ** k\n    failure_probability = (1 - p) ** (n - k)\n    \n    # Calculate the binomial probability\n    binomial_probability = binomial_coefficient * success_probability * failure_probability\n    \n    return binomial_probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    return tuple(sorted(tup, key=lambda x: x[-1]))"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a pentagon given the length of its side.\n\n    Parameters:\n    a (float): The length of the side of the pentagon.\n\n    Returns:\n    float: The area of the pentagon.\n    \"\"\"\n    # Calculate the area using the formula: (5 * a^2) / 4\n    area = (5 * a**2) / 4\n    return area\n\n# Example usage:\nside_length = 10\narea = area_pentagon(side_length)\nprint(f\"The area of the pentagon with side length {side_length} is {area}\")"}
{"id": "478_0", "code": "def frequency_Of_Largest(n,arr):\n    # Check if the input array is empty\n    if n == 0:\n        return 0\n\n    # Initialize the maximum frequency and the index of the maximum frequency\n    max_freq = 0\n    max_freq_index = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Check if the current element is greater than the maximum frequency\n        if arr[i] > max_freq:\n            # Update the maximum frequency and its index\n            max_freq = arr[i]\n            max_freq_index = i\n\n    # Return the maximum frequency\n    return max_freq"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    \"\"\"\n    Extract all pairs of symmetric elements from a given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples containing symmetric pairs.\n    \"\"\"\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i][0] == test_list[j][1] and test_list[i][1] == test_list[j][0]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a, n, r):\n    \"\"\"\n    Calculate the sum of a geometric progression series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The number of terms in the series.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The sum of the geometric progression series.\n    \"\"\"\n    # Check if the series is valid\n    if r == 1:\n        return a * n\n    elif r < 0:\n        raise ValueError(\"The common ratio cannot be negative.\")\n    elif r == 0 or r == 1:\n        return a * n\n\n    # Calculate the sum using the formula for the sum of a geometric progression\n    sum_gp = a * (1 - r ** n) / (1 - r)\n    return sum_gp"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    low = 0\n    high = len(item_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"id": "482_0", "code": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    \"\"\"\n    Calculate a grid of hexagon coordinates.\n\n    Args:\n        startx (float): The x-coordinate of the starting point.\n        starty (float): The y-coordinate of the starting point.\n        endx (float): The x-coordinate of the ending point.\n        endy (float): The y-coordinate of the ending point.\n        radius (float): The radius of the hexagon.\n\n    Returns:\n        list of lists: A list of lists containing 6 tuples of x, y point coordinates.\n    \"\"\"\n    # Calculate the angle between the start and end points\n    angle = math.atan2(endy - starty, endx - startx)\n\n    # Calculate the number of hexagons\n    num_hexagons = int((endx - startx) / (2 * math.sqrt(3) / 6))\n\n    # Initialize the list of hexagons\n    hexagons = []\n\n    # Calculate the x and y coordinates of each hexagon\n    for i in range(num_hexagons):\n        # Calculate the x coordinate of the current hexagon\n        x = startx + i * (endx - startx) / num_hexagons\n\n        # Calculate the y coordinate of the current hexagon\n        y = starty + i * (endy - starty) / num_hexagons\n\n        # Append the hexagon coordinates to the list\n        hexagons.append([(x, y), (x + math.sqrt(3) / 2, y + math.sqrt(3) / 2), (x + math.sqrt(3) / 2, y - math.sqrt(3) / 2), (x, y - math.sqrt(3) / 2), (x + math.sqrt(3) / 2, y - math.sqrt(3) / 2), (x + math.sqrt(3) / 2, y + math.sqrt(3) / 2)])\n\n    return hexagons"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    \"\"\"\n    Convert a binary tuple to an integer.\n\n    Args:\n        test_tup (tuple): A binary tuple.\n\n    Returns:\n        int: The integer equivalent of the binary tuple.\n\n    Raises:\n        ValueError: If the input tuple is not a binary tuple.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise ValueError(\"Input must be a tuple\")\n\n    # Check if the tuple contains only binary digits\n    if not all(bit in '01' for bit in test_tup):\n        raise ValueError(\"Input tuple must contain only binary digits\")\n\n    # Convert the tuple to an integer\n    return int(''.join(test_tup), 2)"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    # Define the regex pattern\n    pattern = r'(?<!\\w)\\w{2,}\\w(?!\\w)'\n    \n    # Use the regex to replace substrings\n    result = re.sub(pattern, '', str1)\n    \n    return result"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    This function generates the smallest integers from a given list of numbers using heap queue algorithm.\n\n    Args:\n    nums (list): A list of integers.\n    n (int): The number of smallest integers to generate.\n\n    Returns:\n    list: A list of the smallest integers from the input list.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        return []\n\n    # Create a min heap\n    min_heap = []\n\n    # Push the first 'n' elements of the list into the min heap\n    for i in range(n):\n        heapq.heappush(min_heap, nums[i])\n\n    # Extract the smallest element from the min heap 'n' times\n    smallest = []\n    while len(min_heap) > 0:\n        smallest.append(heapq.heappop(min_heap))\n\n    return smallest"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r, h):\n    \"\"\"\n    Calculate the surface area of a cone.\n\n    Parameters:\n    r (float): The radius of the base of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The surface area of the cone.\n    \"\"\"\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n\n    return surface_area\n\n# Example usage:\nr = 5\nh = 10\nprint(surfacearea_cone(r, h))"}
{"id": "487_0", "code": "import math\n\ndef gcd(x, y):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two positive integers.\n\n    Args:\n        x (int): The first positive integer.\n        y (int): The second positive integer.\n\n    Returns:\n        int: The GCD of x and y.\n    \"\"\"\n    while y:\n        x, y = y, x % y\n    return x"}
{"id": "488_0", "code": "import math\n\ndef diameter_circle(r):\n    \"\"\"\n    Calculate the diameter of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The diameter of the circle.\n    \"\"\"\n    # Check if the radius is negative\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    # Calculate the diameter using the formula: diameter = 2 * radius\n    diameter = 2 * r\n\n    return diameter"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    \"\"\"\n    Concatenates all elements of the given list into a string.\n\n    Args:\n        lst (list): The list of elements to be concatenated.\n\n    Returns:\n        str: A string containing all elements of the input list.\n    \"\"\"\n    return ''.join(map(str, lst))"}
{"id": "490_0", "code": "def num_comm_div(x, y):\n    \"\"\"\n    This function finds the common divisor between two numbers.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        int: The common divisor of x and y.\n    \"\"\"\n    # Check if y is zero to avoid division by zero error\n    if y == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    # Use the Euclidean algorithm to find the GCD\n    while y != 0:\n        x, y = y, x % y\n\n    return x"}
{"id": "491_0", "code": "def find(n, m):\n    \"\"\"\n    This function calculates the remainder of two numbers.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The remainder of n divided by m.\n    \"\"\"\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    \"\"\"\n    This function adds consecutive numbers of a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of numbers with consecutive additions.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(nums[i] + result[-1])\n    return result"}
{"id": "493_0", "code": "def sum_of_series(n):\n    \"\"\"\n    This function calculates the sum of the first n natural numbers cubed.\n\n    Args:\n        n (int): The number of natural numbers to sum.\n\n    Returns:\n        int: The sum of the first n natural numbers cubed.\n    \"\"\"\n    # Initialize the sum variable\n    total = 0\n    \n    # Loop through each natural number from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number\n        cube = i ** 3\n        \n        # Add the cube to the total sum\n        total += cube\n    \n    # Return the total sum\n    return total"}
{"id": "494_0", "code": "def re_order(A):\n    \"\"\"\n    Reorders the input array A such that all zeroes are moved to the end.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        list: The reordered array.\n    \"\"\"\n    # Separate non-zero elements from zeroes\n    non_zero = [x for x in A if x != 0]\n    zeroes = [x for x in A if x == 0]\n\n    # Combine non-zero elements and zeroes\n    result = non_zero + zeroes\n\n    return result"}
{"id": "495_0", "code": "import math\n\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient of given p(n, k).\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    float: The permutation coefficient.\n    \"\"\"\n    # Calculate the permutation coefficient using the formula: p(n, k) = n! / (n-k)!\n    coefficient = math.factorial(n) / math.factorial(n-k)\n    return coefficient\n\n# Example usage:\nn = 10  # Total number of items\nk = 3   # Number of items to choose\nprint(permutation_coefficient(n, k))  # Output: 0.037"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    \"\"\"\n    Removes specific words from a given list.\n\n    Args:\n        list1 (list): The original list of words.\n        removewords (list): The list of words to be removed.\n\n    Returns:\n        list: The modified list with the specified words removed.\n    \"\"\"\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    \n    # Use a list comprehension to filter out the words to be removed\n    filtered_list = [word for word in list1 if word not in set1]\n    \n    return filtered_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    \"\"\"\n    Checks if the common elements between two given lists are in the same order.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        bool: True if the common elements are in the same order, False otherwise.\n    \"\"\"\n    # Convert the lists to sets for efficient lookup\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Check if the sets are equal\n    return set1 == set2"}
{"id": "498_0", "code": "def average_Odd(n):\n    \"\"\"\n    Calculate the average of odd numbers till a given odd number.\n\n    Args:\n        n (int): The given odd number.\n\n    Returns:\n        float: The average of odd numbers till n.\n    \"\"\"\n    # Initialize the sum of odd numbers\n    odd_sum = 0\n\n    # Initialize the counter for odd numbers\n    odd_count = 0\n\n    # Loop till n\n    while n > 0:\n        # Check if n is odd\n        if n % 2 != 0:\n            # Add n to the sum\n            odd_sum += n\n            # Increment the counter\n            odd_count += 1\n        # Decrement n\n        n -= 1\n\n    # Calculate the average\n    average = odd_sum / odd_count\n\n    return average"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(k + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            elif arr[i - 1] * j < k:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][k]"}

{"id": "0_0", "code": "def remove_Occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        s (str): The input string.\n        ch (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the index of the first occurrence of the character\n    idx1 = s.find(ch)\n    # If the character is not found, return the original string\n    if idx1 == -1:\n        return s\n    # Find the index of the last occurrence of the character\n    idx2 = s.rfind(ch)\n    # If the character is not found, return the original string\n    if idx2 == -1:\n        return s\n    # Remove the first and last occurrence of the character\n    return s[:idx1] + s[idx2 + 1:]"}
{"id": "1_0", "code": "def sort_matrix(M):\n    # Check if the input matrix is empty\n    if not M:\n        return M\n\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in M]\n\n    # Sort the rows based on their sums\n    sorted_rows = sorted(zip(row_sums, M), key=lambda x: x[0])\n\n    # Combine the sorted rows back into a matrix\n    sorted_matrix = [list(row) for row in sorted_rows]\n\n    return sorted_matrix"}
{"id": "2_0", "code": "import collections\nfrom collections import Counter\n\ndef count_common(words):\n    # Remove punctuation and convert to lower case\n    words = [''.join(e for e in word if e.isalnum()) for word in words]\n    words = [word.lower() for word in words]\n\n    # Count the frequency of each word\n    word_freq = Counter(words)\n\n    # Find the most common word\n    most_common_word = word_freq.most_common(1)[0]\n\n    return most_common_word"}
{"id": "3_0", "code": "def find_Volume(l, b, h):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    l (float): length of the base of the prism\n    b (float): base width of the prism\n    h (float): height of the prism\n\n    Returns:\n    float: volume of the prism\n    \"\"\"\n    # Calculate the area of the base\n    base_area = 0.5 * l * b\n    \n    # Calculate the volume\n    volume = base_area * h\n    \n    return volume"}
{"id": "4_0", "code": "def split_lowerstring(text):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of substrings separated by lowercase letters.\n    \"\"\"\n    result = []\n    current_substring = \"\"\n    for char in text:\n        if char.islower():\n            current_substring += char\n        elif current_substring:\n            result.append(current_substring)\n            current_substring = \"\"\n    if current_substring:\n        result.append(current_substring)\n    return result"}
{"id": "5_0", "code": "def text_lowercase_underscore(text):\n    \"\"\"\n    Generate a sequence of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A sequence of lowercase letters joined with an underscore.\n    \"\"\"\n    return '_'.join(text.lower())"}
{"id": "6_0", "code": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    a (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * a"}
{"id": "7_0", "code": "def remove_dirty_chars(string, second_string):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The original string.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters from second_string removed.\n    \"\"\"\n    # Convert second_string to a set for efficient lookups\n    second_set = set(second_string)\n    \n    # Initialize an empty list to store the characters that are not in second_string\n    result = []\n    \n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is not in second_set\n        if char not in second_set:\n            # Append the character to the result list\n            result.append(char)\n    \n    # Join the characters in the result list into a string\n    result_str = ''.join(result)\n    \n    # Return the modified string\n    return result_str"}
{"id": "8_0", "code": "def test_duplicate(arraynums):\n    return len(set(arraynums)) != len(arraynums)"}
{"id": "9_0", "code": "def is_woodall(x):\n    \"\"\"\n    Checks if the given number is a woodball.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a woodball, False otherwise.\n    \"\"\"\n    # Check if the number is a woodball\n    return x % 3 == 0"}
{"id": "10_0", "code": "def multiples_of_num(m, n):\n    \"\"\"\n    Generate multiples of n up to m.\n\n    Args:\n        m (int): The upper limit of multiples.\n        n (int): The number for which multiples are generated.\n\n    Returns:\n        list: A list of multiples of n up to m.\n    \"\"\"\n    return [i * n for i in range(1, m + 1)]"}
{"id": "11_0", "code": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None"}
{"id": "12_0", "code": "def maximum_Sum(list1):\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list1:\n        # Update the current sum\n        current_sum += sublist[0]\n        \n        # Update the maximum sum if the current sum is greater\n        max_sum = max(max_sum, current_sum)\n        \n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    # Return the maximum sum\n    return max_sum"}
{"id": "13_0", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    Convert a binary number to its decimal equivalent.\n\n    Args:\n        binary (str): A binary number as a string.\n\n    Returns:\n        int: The decimal equivalent of the binary number.\n\n    Raises:\n        ValueError: If the input string is not a valid binary number.\n    \"\"\"\n    # Check if the input string is a valid binary number\n    if not set(binary).issubset({'0', '1'}):\n        raise ValueError(\"Invalid binary number\")\n\n    # Convert the binary string to decimal using built-in int function\n    decimal = int(binary, 2)\n\n    return decimal"}
{"id": "14_0", "code": "def find_product(arr, n):\n    # Initialize a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through the array and update the frequency dictionary\n    for i in range(n):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n    \n    # Initialize the product variable to 1\n    product = 1\n    \n    # Iterate through the frequency dictionary and multiply the elements\n    for key, value in freq_dict.items():\n        product *= key\n    \n    return product"}
{"id": "15_0", "code": "def check_k_elements(test_list, K):\n    \"\"\"\n    Checks if the given tuple list has all k elements.\n\n    Args:\n        test_list (list): The input list of tuples.\n        K (int): The number of elements to check for.\n\n    Returns:\n        bool: True if the list has all k elements, False otherwise.\n    \"\"\"\n    # Check if the length of the list is equal to K\n    if len(test_list) != K:\n        return False\n\n    # Check if all elements in the list are tuples\n    if not all(isinstance(x, tuple) for x in test_list):\n        return False\n\n    # Check if all elements in the list are of the same type\n    if not all(isinstance(x, type(test_list[0])) for x in test_list):\n        return False\n\n    # Check if all elements in the list are of the same type\n    return True"}
{"id": "16_0", "code": "def remove(lst):\n    return [s.replace('0', '') for s in lst]"}
{"id": "17_0", "code": "import math\n\ndef binomial_Coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k) using the math library.\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    float: The binomial coefficient (n choose k).\n    \"\"\"\n    # Check if k is greater than n - k\n    if k > n - k:\n        raise ValueError(\"k cannot be greater than n - k\")\n    \n    # Calculate the binomial coefficient using the math library\n    return math.comb(n, k)\n\n# Example usage:\nn = 5\nk = 3\nprint(f\"The binomial coefficient (n choose k) is: {binomial_Coeff(n, k)}\")"}
{"id": "18_0", "code": "def get_Odd_Occurrence(arr, arr_size):\n    \"\"\"\n    This function finds the element occurring odd number of times in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    arr_size (int): The size of the input array.\n\n    Returns:\n    int: The index of the element occurring odd number of times.\n    \"\"\"\n    # Initialize a dictionary to store the frequency of each element\n    freq_dict = {}\n\n    # Iterate over the array to count the frequency of each element\n    for i in range(arr_size):\n        if arr[i] in freq_dict:\n            freq_dict[arr[i]] += 1\n        else:\n            freq_dict[arr[i]] = 1\n\n    # Initialize a variable to store the index of the element occurring odd number of times\n    odd_occurrence_index = -1\n\n    # Iterate over the frequency dictionary to find the element occurring odd number of times\n    for key, value in freq_dict.items():\n        if value % 2 != 0:\n            odd_occurrence_index = key\n            break\n\n    return odd_occurrence_index"}
{"id": "19_0", "code": "def count_Substring_With_Equal_Ends(s):\n    \"\"\"\n    Counts all the substrings starting and ending with same characters.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of substrings with equal ending characters.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "20_0", "code": "import heapq\nfrom collections import Counter\n\ndef func(nums, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers.\n\n    Args:\n    nums (list): A list of sorted and distinct integers.\n    k (int): The number of top integers to find.\n\n    Returns:\n    list: A list of the top k integers that occur most frequently.\n    \"\"\"\n    # Count the frequency of each integer\n    freq = Counter(nums)\n    \n    # Create a max heap to store the integers and their frequencies\n    max_heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(max_heap, (-count, num))\n    \n    # Pop the top k integers from the heap\n    result = []\n    for _ in range(k):\n        # Get the integer with the highest frequency\n        _, num = heapq.heappop(max_heap)\n        result.append(num)\n    \n    return result"}
{"id": "21_0", "code": "def max_Prime_Factors(n):\n    \"\"\"\n    This function finds the largest prime factor of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The largest prime factor of the input number.\n\n    Raises:\n    ValueError: If the input number is less than 2.\n    \"\"\"\n\n    # Check if the input number is less than 2\n    if n < 2:\n        raise ValueError(\"Input number must be greater than or equal to 2.\")\n\n    # Initialize the largest prime factor\n    max_prime_factor = 1\n\n    # Iterate from 2 to the square root of the number\n    for i in range(2, int(n ** 0.5) + 1):\n        # Check if the current number is a factor of the number\n        while n % i == 0:\n            # Update the largest prime factor\n            max_prime_factor = i\n            # Divide the number by the current factor\n            n = n // i\n\n    # If the remaining number is greater than 1, it is a prime factor\n    if n > 1:\n        max_prime_factor = n\n\n    return max_prime_factor"}
{"id": "22_0", "code": "def decimal_to_binary(N):\n    \"\"\"\n    Converts a decimal number to binary number.\n\n    Args:\n        N (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary representation of the input decimal number.\n\n    Raises:\n        ValueError: If the input decimal number is negative.\n    \"\"\"\n    if N < 0:\n        raise ValueError(\"Input decimal number cannot be negative.\")\n\n    # Convert decimal to binary using built-in bin() function\n    binary = bin(N)[2:]\n\n    return binary"}
{"id": "23_0", "code": "def find_missing(ar, N):\n    \"\"\"\n    Find the missing number in a sorted array.\n\n    Parameters:\n    ar (list): A sorted list of integers.\n    N (int): The length of the array.\n\n    Returns:\n    int: The missing number in the array.\n    \"\"\"\n    # Calculate the sum of the first N natural numbers\n    sum_natural_numbers = N * (N + 1) // 2\n\n    # Calculate the sum of the first N natural numbers in the array\n    sum_array = sum(ar)\n\n    # The missing number is the difference between the two sums\n    return sum_natural_numbers - sum_array"}
{"id": "24_0", "code": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n\n    Args:\n        n (int): The position of the rectangular number to find.\n\n    Returns:\n        int: The n-th rectangular number.\n    \"\"\"\n    # Initialize the first rectangular number\n    rect_num = 1\n\n    # Initialize the current rectangular number\n    curr_num = 1\n\n    # Loop until we find the n-th rectangular number\n    while True:\n        # Check if the current rectangular number is the n-th\n        if curr_num == n:\n            return rect_num\n        # If not, increment the current rectangular number\n        curr_num += 1\n        # If the current rectangular number exceeds the n-th, break the loop\n        if curr_num > n:\n            break\n        # Increment the current rectangular number\n        rect_num += 1"}
{"id": "25_0", "code": "def find_Nth_Digit(p,q,N):\n    # Convert the fractions to decimal\n    d1 = decimal.Decimal(p) / decimal.Decimal(q)\n    # Convert the decimal to string\n    d = str(d1)\n    # Find the nth digit\n    if N > len(d):\n        return \"N is larger than the number of digits\"\n    else:\n        return d[N-1]"}
{"id": "26_0", "code": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a given mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing integers and strings.\n\n    Returns:\n        list: A sorted list of integers and strings.\n    \"\"\"\n    # Separate integers and strings into different lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the integers and strings separately\n    integers.sort()\n    strings.sort()\n\n    # Combine the sorted integers and strings\n    sorted_list = integers + strings\n\n    return sorted_list"}
{"id": "27_0", "code": "def div_even_odd(list1):\n    # Initialize variables\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through the list\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return the division of even and odd count\n    return even_count / odd_count"}
{"id": "28_0", "code": "def rearange_string(S):\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n    for char in S:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Check if the string can be rearranged\n    for i in range(len(S) - 1):\n        if S[i] == S[i + 1] and S[i] in freq:\n            return False\n        elif S[i] in freq and S[i + 1] in freq:\n            freq[S[i]] -= 1\n            freq[S[i + 1]] -= 1\n        else:\n            return False\n\n    return True"}
{"id": "29_0", "code": "from collections import Counter\n\ndef freq_element(nums):\n    \"\"\"\n    This function calculates the frequency of elements in a given list of lists.\n    \n    Args:\n        nums (list): A list of lists containing integers.\n    \n    Returns:\n        dict: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in nums for num in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq = Counter(flat_list)\n    \n    return dict(freq)"}
{"id": "30_0", "code": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"id": "31_0", "code": "def find_Sum(arr, n):\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        # Check if the element is repeated\n        if arr[i] in arr[:i]:\n            # Add the repeated element to the sum\n            total_sum += arr[i]\n    \n    # Return the sum\n    return total_sum"}
{"id": "32_0", "code": "import re\n\ndef text_match(text):\n    pattern = r\"([a-z]+)_([a-z]+)\"\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "33_0", "code": "def text_match_string(text):\n    \"\"\"\n    Returns a string that matches the beginning of the input text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A string that matches the beginning of the input text.\n    \"\"\"\n    return text[:len(text)]  # Return the first 'len(text)' characters of the input text"}
{"id": "34_0", "code": "import math\n\ndef get_gcd(l):\n    \"\"\"\n    This function calculates the greatest common divisor (gcd) of the given array elements.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        int: The greatest common divisor of the given array elements.\n    \"\"\"\n    # Check if the list is empty\n    if not l:\n        return 0\n\n    # Initialize the gcd with the first element of the list\n    gcd = l[0]\n\n    # Iterate over the rest of the list\n    for num in l[1:]:\n        # Update the gcd using the Euclidean algorithm\n        gcd = math.gcd(gcd, num)\n\n    return gcd"}
{"id": "35_0", "code": "def test_distinct(data):\n    return len(set(data)) != len(data)"}
{"id": "36_0", "code": "import math\n\ndef compute_Last_Digit(A, B):\n    \"\"\"\n    This function calculates the last digit when the factorial of A divides the factorial of B.\n\n    Parameters:\n    A (int): The first number.\n    B (int): The second number.\n\n    Returns:\n    int: The last digit of the division of A! by B!.\n    \"\"\"\n    # Calculate the factorial of A and B\n    A_factorial = math.factorial(A)\n    B_factorial = math.factorial(B)\n\n    # Check if B is 0\n    if B == 0:\n        return 0\n\n    # Calculate the remainder of A! divided by B!\n    remainder = A_factorial % B_factorial\n\n    # Return the last digit of the remainder\n    return remainder % 10"}
{"id": "37_0", "code": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all odd bits set.\n    \"\"\"\n    # Create a mask with all bits set to 0\n    mask = 0xffffffff\n    \n    # Iterate over each bit in the number\n    for i in range(32):\n        # If the bit is odd, set it to 1\n        if (n & 1) != 0:\n            mask |= 1 << i\n    \n    # Return the number with all odd bits set\n    return mask"}
{"id": "38_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extract every first or specified element from a given two-dimensional list.\n\n    Args:\n        nums (list): A two-dimensional list of elements.\n        N (int): The index of the element to be extracted.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    # Check if N is within the bounds of the list\n    if N < 0 or N >= len(nums):\n        raise ValueError(\"N is out of bounds\")\n\n    # Extract the specified element\n    return [nums[0][N]] if N == 0 else [nums[0][N-1]] + [nums[0][N]]"}
{"id": "39_0", "code": "def min_length_list(input_list):\n    return min(input_list, key=len)"}
{"id": "40_0", "code": "def check_equilateral(x, y, z):\n    \"\"\"\n    This function checks if a triangle is equilateral or not.\n\n    Args:\n        x (float): The length of the first side of the triangle.\n        y (float): The length of the second side of the triangle.\n        z (float): The length of the third side of the triangle.\n\n    Returns:\n        bool: True if the triangle is equilateral, False otherwise.\n    \"\"\"\n    # Check if the sides are equal\n    if x == y == z:\n        return True\n    else:\n        return False\n\n# Example usage:\nprint(check_equilateral(3, 4, 5))  # Output: True\nprint(check_equilateral(3, 4, 6))  # Output: False"}
{"id": "41_0", "code": "def parallelogram_area(b, h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"id": "42_0", "code": "def check_Equality(str):\n    if len(str) < 2:\n        return False\n    return str[0] == str[-1]"}
{"id": "43_0", "code": "def counting_sort(my_list):\n    # Find the maximum element in the list\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrence of each element in the list\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, max_element + 1):\n        count_array[i] += count_array[i - 1]\n    \n    # Build the output array\n    output_array = [0] * len(my_list)\n    \n    # Place the elements in the output array\n    for num in my_list:\n        output_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return output_array"}
{"id": "44_0", "code": "def tn_gp(a, n, r):\n    \"\"\"\n    Calculate the nth term of a geometric progression.\n\n    Parameters:\n    a (float): The first term of the geometric progression.\n    n (int): The term number to calculate.\n    r (float): The common ratio of the geometric progression.\n\n    Returns:\n    float: The nth term of the geometric progression.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    if r == 1:\n        return a\n    else:\n        return a * (r ** (n - 1))"}
{"id": "45_0", "code": "def check(n):\n    rev = int(str(n)[::-1])\n    return rev == 2 * n - 1"}
{"id": "46_0", "code": "def find_Max_Num(arr, n):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Join the array into a string\n    max_num_str = ''.join(arr)\n    # Convert the string into an integer\n    max_num = int(max_num_str)\n    return max_num"}
{"id": "47_0", "code": "def opposite_Signs(x, y):\n    \"\"\"\n    This function checks whether the given two integers have opposite sign or not.\n\n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n\n    Returns:\n    bool: True if the integers have opposite sign, False otherwise.\n    \"\"\"\n    return x * y < 0"}
{"id": "48_0", "code": "def is_octagonal(n):\n    \"\"\"\n    Checks if a number is an octagonal number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is an octagonal number, False otherwise.\n    \"\"\"\n    return n % 16 == 0"}
{"id": "49_0", "code": "def max_len_sub(arr, n):\n    \"\"\"\n    This function finds the maximum length of the subsequence with difference between adjacent elements for the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the input array.\n\n    Returns:\n    int: The maximum length of the subsequence with difference between adjacent elements.\n    \"\"\"\n    # Initialize a list to store the length of the longest subsequence ending at each position\n    dp = [1] * n\n\n    # Initialize the maximum length of the subsequence\n    max_len = 1\n\n    # Iterate over the array\n    for i in range(1, n):\n        # For each element, compare it with all previous elements\n        for j in range(i):\n            # If the difference between the current element and the previous element is less than or equal to 1\n            if abs(arr[i] - arr[j]) <= 1:\n                # Update the length of the longest subsequence ending at the current position\n                dp[i] = max(dp[i], dp[j] + 1)\n\n        # Update the maximum length of the subsequence\n        max_len = max(max_len, dp[i])\n\n    return max_len"}
{"id": "50_0", "code": "def count_Substrings(s, n):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substr = s[i:j]\n            if sum(int(digit) for digit in substr) == len(substr):\n                count += 1\n    return count"}
{"id": "51_0", "code": "def smallest_num(xs):\n    return min(xs)"}
{"id": "52_0", "code": "def max_difference(test_list):\n    \"\"\"\n    This function calculates the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples containing pairs of numbers.\n\n    Returns:\n        int: The maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    # Sort the list of tuples based on the first element of each tuple\n    test_list.sort(key=lambda x: x[0])\n    \n    # Initialize the maximum difference and the minimum difference\n    max_diff = float('-inf')\n    min_diff = float('inf')\n    \n    # Iterate over the sorted list of tuples\n    for i in range(len(test_list) - 1):\n        # Calculate the difference between the current pair and the next pair\n        diff = test_list[i+1][0] - test_list[i][0]\n        \n        # Update the maximum difference if the current difference is larger\n        max_diff = max(max_diff, diff)\n        \n        # Update the minimum difference if the current difference is smaller\n        min_diff = min(min_diff, diff)\n    \n    # Return the maximum difference\n    return max_diff"}
{"id": "53_0", "code": "def subject_marks(subjectmarks):\n    # Sort the list of tuples based on the first element of each tuple\n    subjectmarks.sort(key=lambda x: x[0])\n    return subjectmarks"}
{"id": "54_0", "code": "def recursive_list_sum(data_list):\n    if len(data_list) == 0:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])"}
{"id": "55_0", "code": "def pos_count(lst):\n    \"\"\"\n    Counts the number of positive numbers in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The number of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"id": "56_0", "code": "def bell_number(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return n + bell_number(n - 1)"}
{"id": "57_0", "code": "def is_Monotonic(A):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    n = len(A)\n    # Check if the array is monotonic\n    for i in range(n - 1):\n        if A[i] > A[i + 1]:\n            return False\n    return True"}
{"id": "58_0", "code": "def is_sublist(l, s):\n    \"\"\"\n    Checks if a given sublist is present in the list.\n\n    Args:\n        l (list): The main list to search in.\n        s (list): The sublist to search for.\n\n    Returns:\n        bool: True if the sublist is found, False otherwise.\n    \"\"\"\n    # Check if the sublist is empty\n    if not s:\n        return True\n\n    # Check if the sublist is present in the list\n    for i in range(len(l)):\n        if l[i:i+len(s)] == s:\n            return True\n\n    # If the sublist is not found, return False\n    return False"}
{"id": "59_0", "code": "def get_equal(Input, k):\n    # Check if the input is a tuple\n    if not isinstance(Input, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    \n    # Check if the length of the tuple is equal to k\n    if len(Input) != k:\n        return False\n    \n    # Check if all elements in the tuple are of the same type\n    if len(set(type(x) for x in Input)) > 1:\n        return False\n    \n    # Check if all elements in the tuple are of the same type\n    if len(set(type(x) for x in Input)) == 1:\n        return True\n    \n    # If none of the above conditions are met, return False\n    return False"}
{"id": "60_0", "code": "def comb_sort(nums):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(nums) // 2\n\n    # Loop until the gap size is 1\n    while gap > 0:\n        # Initialize the swapped flag\n        swapped = False\n\n        # Iterate over the gap size\n        for i in range(gap):\n            # If the current element is greater than the next element, swap them\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                swapped = True\n\n        # If no swaps were made, the list is already sorted\n        if not swapped:\n            break\n\n        # Reduce the gap size by half\n        gap //= 2\n\n    return nums"}
{"id": "61_0", "code": "def dif_Square(n):\n    \"\"\"\n    Checks whether the given number can be represented as difference of two squares or not.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as difference of two squares, False otherwise.\n    \"\"\"\n    # Check if the number is negative\n    if n < 0:\n        return False\n\n    # Check if the number is even\n    if n % 2 == 0:\n        return True\n\n    # Check if the number is a perfect square\n    sqrt_n = int(n ** 0.5)\n    if sqrt_n * sqrt_n == n:\n        return True\n\n    # Check if the number is a difference of two squares\n    for i in range(1, sqrt_n + 1):\n        if i * i == n - i * i:\n            return True\n\n    return False"}
{"id": "62_0", "code": "import re\n\ndef multiple_split(text):\n    \"\"\"\n    Splits the given string with multiple delimiters by using regex.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        list: A list of strings, each representing a split content.\n    \"\"\"\n    # Define the regex pattern\n    pattern = r\"(\\w+|[^a-zA-Z0-9\\s]|[^a-zA-Z0-9\\s\\w])\"\n\n    # Split the text using the regex pattern\n    split_content = re.split(pattern, text)\n\n    # Remove empty strings from the list\n    split_content = [s for s in split_content if s]\n\n    return split_content"}
{"id": "63_0", "code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks whether the given colors follow the sequence given in the patterns array.\n\n    Args:\n        colors (list): A list of colors.\n        patterns (list): A list of patterns.\n\n    Returns:\n        bool: True if the colors follow the sequence, False otherwise.\n    \"\"\"\n    # Check if the lengths of the colors and patterns lists are equal\n    if len(colors) != len(patterns):\n        return False\n\n    # Check if the first element of the colors list is equal to the first element of the patterns list\n    if colors[0] != patterns[0]:\n        return False\n\n    # Check if the last element of the colors list is equal to the last element of the patterns list\n    if colors[-1] != patterns[-1]:\n        return False\n\n    # Check if the colors list is a permutation of the patterns list\n    for color, pattern in zip(colors, patterns):\n        if color != pattern:\n            return False\n\n    return True"}
{"id": "64_0", "code": "def find_tuples(test_list, K):\n    \"\"\"\n    This function finds tuples in the given list which have all elements divisible by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The divisor.\n\n    Returns:\n        list: A list of tuples which have all elements divisible by K.\n    \"\"\"\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return result"}
{"id": "65_0", "code": "def count_Squares(m,n):\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if i == j:\n                count += 1\n    return count"}
{"id": "66_0", "code": "def is_Diff(n):\n    # Convert the number to a string\n    str_n = str(n)\n    \n    # Initialize variables to store the sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each character in the string\n    for char in str_n:\n        # Convert the character back to an integer\n        digit = int(char)\n        \n        # Check if the digit is even or odd\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n    \n    # Return True if the difference between the sums is 0, False otherwise\n    return even_sum - odd_sum == 0"}
{"id": "67_0", "code": "def count_With_Odd_SetBits(n):\n    \"\"\"\n    Counts the number of integers with odd number of set bits.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The number of integers with odd number of set bits.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        # Check if the number of set bits is odd\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count"}
{"id": "68_0", "code": "def word_len(s):\n    return len(s)"}
{"id": "69_0", "code": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    Args:\n        n (int): The position of the tetrahedral number to calculate.\n\n    Returns:\n        int: The nth tetrahedral number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    if n == 0:\n        return 0\n    return n * (n + 1) * (n + 2) // 6"}
{"id": "70_0", "code": "def zip_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function zips two tuples together.\n\n    Args:\n        test_tup1 (tuple): The first tuple to be zipped.\n        test_tup2 (tuple): The second tuple to be zipped.\n\n    Returns:\n        tuple: A new tuple containing the zipped elements of test_tup1 and test_tup2.\n    \"\"\"\n    # Use the built-in zip function to iterate over the elements of both tuples in parallel\n    zipped_tup = tuple(zip(test_tup1, test_tup2))\n    return zipped_tup"}
{"id": "71_0", "code": "import math\n\ndef volume_sphere(r):\n    \"\"\"\n    Calculate the volume of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    # Check if the radius is negative\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    # Calculate the volume using the formula (4/3) * Ï€ * r^3\n    volume = (4/3) * math.pi * (r ** 3)\n\n    return volume"}
{"id": "72_0", "code": "def get_Char(strr):\n    \"\"\"\n    This function generates a character by adding all the characters of the given string.\n    \n    Parameters:\n    strr (str): The input string.\n    \n    Returns:\n    str: The generated character.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the input string\n    for char in strr:\n        # Convert the character to its ASCII value\n        ascii_val = ord(char)\n        \n        # Add the ASCII value to the result string\n        result += chr(ascii_val + 1)\n    \n    # Return the generated character\n    return result"}
{"id": "73_0", "code": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the newman conway sequence.\n\n    Args:\n        n (int): The position of the number in the sequence.\n\n    Returns:\n        int: The n-th number in the sequence.\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n\n    # Recursive case\n    else:\n        return sequence(n-1) + sequence(n-2) + sequence(n-3)"}
{"id": "74_0", "code": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"id": "75_0", "code": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    Args:\n        n (int): The position of the centered hexagonal number.\n\n    Returns:\n        int: The nth centered hexagonal number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    else:\n        return n * (3 * n - 1) // 2"}
{"id": "76_0", "code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merge three dictionaries into a single expression.\n\n    Args:\n        dict1 (dict): The first dictionary to merge.\n        dict2 (dict): The second dictionary to merge.\n        dict3 (dict): The third dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all the key-value pairs from the input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n\n    # Iterate over the key-value pairs in the first dictionary\n    for key, value in dict1.items():\n        # Add the key-value pair to the merged dictionary\n        merged_dict[key] = value\n\n    # Iterate over the key-value pairs in the second dictionary\n    for key, value in dict2.items():\n        # Add the key-value pair to the merged dictionary, overwriting any existing key\n        merged_dict[key] = value\n\n    # Iterate over the key-value pairs in the third dictionary\n    for key, value in dict3.items():\n        # Add the key-value pair to the merged dictionary, overwriting any existing key\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict"}
{"id": "77_0", "code": "def freq_count(list1):\n    freq_dict = {}\n    for item in list1:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"id": "78_0", "code": "def closest_num(N):\n    \"\"\"\n    This function finds the closest smaller number than N.\n\n    Parameters:\n    N (int): The input number.\n\n    Returns:\n    int: The closest smaller number than N.\n    \"\"\"\n    if N <= 0:\n        raise ValueError(\"Input number should be greater than 0.\")\n    if N == 1:\n        return 0\n    if N == 2:\n        return 1\n    if N == 3:\n        return 2\n    if N == 4:\n        return 3\n    if N == 5:\n        return 4\n    if N == 6:\n        return 5\n    if N == 7:\n        return 6\n    if N == 8:\n        return 7\n    if N == 9:\n        return 8\n    if N == 10:\n        return 9\n    if N == 11:\n        return 10\n    if N == 12:\n        return 11\n    if N == 13:\n        return 12\n    if N == 14:\n        return 13\n    if N == 15:\n        return 14\n    if N == 16:\n        return 15\n    if N == 17:\n        return 16\n    if N == 18:\n        return 17\n    if N == 19:\n        return 18\n    if N == 20:\n        return 19\n    if N == 21:\n        return 20\n    if N == 22:\n        return 21\n    if N == 23:\n        return 22\n    if N == 24:\n        return 23\n    if N == 25:\n        return 24\n    if N == 26:\n        return 25\n    if N == 27:\n        return 26\n    if N == 28:\n        return 27\n    if N == 29:\n        return 28\n    if N == 30:\n        return 29\n    if N == 31:\n        return 30\n    if N == 32:\n        return 31\n    if N == 33:\n        return 32\n    if N == 34:\n        return 33\n    if N == 35:\n        return 34\n    if N == 36:\n        return 35\n    if N == 37:\n        return 36\n    if N == 38:\n        return 37\n    if N == 39:\n        return 38\n    if N == 40:\n        return 39\n    if N == 41:\n        return 40\n    if N == 42:\n        return 41\n    if N == 43:\n        return 42\n    if N == 44:\n        return 43\n    if N == 45:\n        return 44\n    if N == 46:\n        return 45\n    if N == 47:\n        return 46\n    if N == 48:\n        return 47\n    if N == 49:\n        return 48\n    if N == 50:\n        return 49\n    if N == 51:\n        return 50\n    if N == 52:\n        return 51\n    if N == 53:\n        return 52\n    if N == 54:\n        return 53\n    if N == 55:\n        return 54\n    if N == 56:\n        return 55\n    if N == 57:\n        return 56\n    if N == 58:\n        return 57\n    if N == 59:\n        return 58\n    if N == 60:\n        return 59\n    if N == 61:\n        return 60\n    if N == 62:\n        return 61\n    if N == 63:\n        return 62\n    if N == 64:\n        return 63\n    if N == 65:\n        return 64\n    if N == 66:\n        return 65\n    if N == 67:\n        return 66\n    if N == 68:\n        return 67\n    if N == 69:\n        return 68\n    if N == 70:\n        return 69\n    if N == 71:\n        return 70\n    if N == 72:\n        return 71\n    if N == 73:\n        return 72\n    if N == 74:\n        return 73\n    if N == 75:\n        return 74\n    if N == 76:\n        return 75\n    if N == 77:\n        return 76\n    if N == 78:\n        return 77\n    if N == 79:\n        return 78\n    if N == 80:\n        return 79"}
{"id": "79_0", "code": "def len_log(lst):\n    \"\"\"\n    This function calculates the length of the longest word in a given list.\n\n    Parameters:\n    lst (list): A list of words.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Remove leading and trailing whitespaces from each word\n    lst = [word.strip() for word in lst]\n    \n    # Split the list into words\n    words = lst\n    \n    # Use the max function with a custom key to find the longest word\n    longest_word = max(words, key=len)\n    \n    # Return the length of the longest word\n    return len(longest_word)"}
{"id": "80_0", "code": "def find_substring(str1, sub_str):\n    \"\"\"\n    This function checks if a given substring is present in a list of strings.\n\n    Parameters:\n    str1 (list): A list of strings\n    sub_str (str): The substring to be searched\n\n    Returns:\n    bool: True if the substring is found, False otherwise\n    \"\"\"\n    # Convert the list of strings to a set for efficient lookups\n    str_set = set(str1)\n    \n    # Check if the substring is present in the set\n    return sub_str in str_set"}
{"id": "81_0", "code": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Check if the number is odd\n    if n % 2 != 0:\n        return False\n\n    # Check if the number is even\n    if n % 2 == 0:\n        return True\n\n    # If the number is odd and even, it's not undulating\n    return False"}
{"id": "82_0", "code": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Args:\n        a (float): The base number.\n        b (int): The exponent.\n\n    Returns:\n        float: The result of 'a' to the power 'b'.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, int):\n        raise TypeError(\"Both 'a' and 'b' must be numbers.\")\n    if b < 0:\n        return 1 / power(a, -b)\n    elif b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)"}
{"id": "83_0", "code": "def index_minimum(test_list):\n    \"\"\"\n    Extract the index minimum value record from the given tuples.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples containing the index minimum value record.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the list with enumerate to get both index and value\n    for index, value in enumerate(test_list):\n        # Check if the value is a tuple\n        if isinstance(value, tuple):\n            # Check if the tuple has at least two elements\n            if len(value) >= 2:\n                # Extract the minimum value from the tuple\n                min_value = min(value)\n                # Append the tuple with the minimum value to the result list\n                result.append((index, min_value))\n    \n    # Return the result list\n    return result"}
{"id": "84_0", "code": "def Find_Min_Length(lst):\n    \"\"\"\n    This function finds the minimum length of a sublist in a given list.\n\n    Args:\n        lst (list): A list of elements.\n\n    Returns:\n        int: The minimum length of a sublist in the given list.\n    \"\"\"\n    min_length = float('inf')  # Initialize minimum length as infinity\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            sub_list = lst[i:j]  # Generate a sublist\n            if len(sub_list) < min_length:  # Check if the length of the sublist is less than the current minimum length\n                min_length = len(sub_list)  # Update the minimum length\n    return min_length"}
{"id": "85_0", "code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"id": "86_0", "code": "def frequency_lists(list1):\n    # Initialize a dictionary to store the frequency of each element in the list\n    freq_dict = {}\n    \n    # Iterate over each sublist in the list\n    for sublist in list1:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in freq_dict:\n                freq_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                freq_dict[element] = 1\n    \n    # Return the dictionary with the frequency count of each element\n    return freq_dict"}
{"id": "87_0", "code": "def multiply_num(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)"}
{"id": "88_0", "code": "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to its binary equivalent.\n\n    Args:\n        n (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary equivalent of the input decimal number.\n    \"\"\"\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"}
{"id": "89_0", "code": "def next_smallest_palindrome(num):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    def is_palindrome_palindrome(n):\n        return is_palindrome(is_palindrome(n))\n\n    def is_palindrome_square(n):\n        return is_palindrome(str(n**2))\n\n    def is_palindrome_cube(n):\n        return is_palindrome(str(n**3))\n\n    def is_palindrome_fourth_power(n):\n        return is_palindrome(str(n**4))\n\n    def is_palindrome_nth_power(n, k):\n        return is_palindrome(str(n**k))\n\n    def is_palindrome_nth_power_of_two(n, k):\n        return is_palindrome(str(n**(2**k)))\n\n    def is_palindrome_nth_power_of_three(n, k):\n        return is_palindrome(str(n**(3**k)))\n\n    def is_palindrome_nth_power_of_five(n, k):\n        return is_palindrome(str(n**(5**k)))\n\n    def is_palindrome_nth_power_of_six(n, k):\n        return is_palindrome(str(n**(6**k)))\n\n    def is_palindrome_nth_power_of_seven(n, k):\n        return is_palindrome(str(n**(7**k)))\n\n    def is_palindrome_nth_power_of_eight(n, k):\n        return is_palindrome(str(n**(8**k)))\n\n    def is_palindrome_nth_power_of_nine(n, k):\n        return is_palindrome(str(n**(9**k)))\n\n    def is_palindrome_nth_power_of_ten(n, k):\n        return is_palindrome(str(n**(10**k)))\n\n    def is_palindrome_nth_power_of_eleven(n, k):\n        return is_palindrome(str(n**(11**k)))\n\n    def is_palindrome_nth_power_of_twelve(n, k):\n        return is_palindrome(str(n**(12**k)))\n\n    def is_palindrome_nth_power_of_thirteen(n, k):\n        return is_palindrome(str(n**(13**k)))\n\n    def is_palindrome_nth_power_of_fourteen(n, k):\n        return is_palindrome(str(n**(14**k)))\n\n    def is_palindrome_nth_power_of_fifteen(n, k):\n        return is_palindrome(str(n**(15**k)))\n\n    def is_palindrome_nth_power_of_sixteen(n, k):\n        return is_palindrome(str(n**(16**k)))\n\n    def is_palindrome_nth_power_of_seventeen(n, k):\n        return is_palindrome(str(n**(17**k)))\n\n    def is_palindrome_nth_power_of_eighteen(n, k):\n        return is_palindrome(str(n**(18**k)))\n\n    def is_palindrome_nth_power_of_nineteen(n, k):\n        return is_palindrome(str(n**(19**k)))\n\n    def is_palindrome_nth_power_of_twenty(n, k):\n        return is_palindrome(str(n**(20**k)))\n\n    def is_palindrome_nth_power_of_twentyone(n, k):\n        return is_palindrome(str(n**(21**k)))\n\n    def is_palindrome_nth_power_of_twentytwo(n, k):\n        return is_palindrome(str(n**(22**k)))\n\n    def is_palindrome_nth_power_of_twentythree(n, k):\n        return is_palindrome(str(n**(23**k)))\n\n    def is_palindrome_nth_power_of_twentyfour(n, k):\n        return is_palindrome(str(n**(24**k)))\n\n    def is_palindrome_nth_power_of_twentyfive(n, k):\n        return is_palindrome(str(n**(25**k)))\n\n    def is_palindrome_nth_power_of_twentysix(n, k):\n        return is_palindrome(str(n**(26**k)))\n\n    def is_palindrome_nth_power_of_twentyseven(n, k):\n        return is_palindrome(str(n**(27**k)))\n\n    def is_palindrome_nth_power_of_twentyeight(n, k):\n        return is_palindrome(str(n**(28**k)))\n\n    def is_palindrome_nth_power_of_twenty-nine(n, k):\n        return is_palindrome(str(n**(29**k)))\n\n    def is_palindrome_nth_power_of_thirty(n, k):\n        return is_palindrome(str(n**(30**k)))\n\n    def is_palindrome_nth_power_of_thirtyone(n, k):\n        return is_palindrome(str(n**(31**k)))\n\n    def is_palindrome_nth_power_of_thirtytwo(n, k):\n        return is_palindrome(str(n**(32**k)))\n\n    def is_palindrome_nth_power_of_thirtythree(n, k):\n        return is_palindrome(str(n**(33**k)))\n\n    def is_palindrome_nth_power_of_thirtyfour(n, k):\n        return is_palindrome(str(n**(34**k)))\n\n    def is_palindrome_nth_power_of_thirtyfive(n, k):\n        return is_palindrome(str(n**(35**k)))\n\n    def is_palindrome_nth_power_of_thirtysix(n, k):\n        return is_palindrome(str(n**(36**k)))"}
{"id": "90_0", "code": "def kth_element(arr, n, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The index of the element to find (1-indexed).\n\n    Returns:\n    int: The kth element in the array.\n    \"\"\"\n    # Check if k is within the bounds of the array\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of bounds\")\n\n    # Use the formula for the kth element in an array\n    # The formula is: k = n * i + j\n    # where i is the index of the first element in the array\n    # and j is the index of the element we want to find\n    i = 0\n    j = 0\n    while j < n:\n        # Calculate the index of the element we want to find\n        # using the formula\n        index = n * i + j\n        # If the calculated index is equal to k, return the element\n        if index == k:\n            return arr[j]\n        # If the calculated index is less than k, increment j\n        elif index < k:\n            j += 1\n        # If the calculated index is greater than k, increment i\n        else:\n            i += 1\n    # If the loop completes without finding the kth element, raise an error\n    raise ValueError(\"k is out of bounds\")"}
{"id": "91_0", "code": "def snake_to_camel(word):\n    \"\"\"\n    Convert snake case string to camel case string.\n\n    Args:\n        word (str): The snake case string to be converted.\n\n    Returns:\n        str: The camel case string.\n    \"\"\"\n    # Split the word into words based on the underscore character\n    words = word.split(\"_\")\n\n    # Capitalize the first letter of each word except the first word\n    camel_case_words = [words[0].capitalize()] + [word.capitalize() for word in words[1:]]\n\n    # Join the words back into a single string\n    camel_case_word = \"\".join(camel_case_words)\n\n    return camel_case_word"}
{"id": "92_0", "code": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    Parameters:\n    n (int): The number of vertices in the graph.\n    m (int): The number of edges in the graph.\n    \n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    # Initialize the Eulerian number\n    euler_num = 0\n    \n    # Calculate the Eulerian number\n    for i in range(n):\n        # For each vertex, add the number of edges incident on it\n        euler_num += m - (n - i - 1)\n    \n    return euler_num"}
{"id": "93_0", "code": "def sort_sublists(input_list):\n    return [sorted(sublist) for sublist in input_list]"}
{"id": "94_0", "code": "def count(lst):\n    \"\"\"\n    Counts the number of true booleans in a given list.\n\n    Args:\n        lst (list): A list of boolean values.\n\n    Returns:\n        int: The number of true booleans in the list.\n    \"\"\"\n    return sum(1 for value in lst if value)"}
{"id": "95_0", "code": "def add_lists(test_list, test_tup):\n    \"\"\"\n    This function adds the given list to the given tuples.\n\n    Args:\n        test_list (list): The list to be added to the tuples.\n        test_tup (tuple): The tuple to which the list will be added.\n\n    Returns:\n        list: The updated list with the tuples.\n    \"\"\"\n    # Convert the tuples to lists\n    test_list = list(test_list)\n    test_tup = list(test_tup)\n\n    # Add the list to the tuples\n    test_list.extend(test_tup)\n\n    # Return the updated list\n    return test_list"}
{"id": "96_0", "code": "def count_Hexadecimal(L, R):\n    \"\"\"\n    Counts the number of hexadecimal numbers within a given range.\n\n    Args:\n        L (int): The lower bound of the range (inclusive).\n        R (int): The upper bound of the range (inclusive).\n\n    Returns:\n        int: The number of hexadecimal numbers within the given range.\n    \"\"\"\n    # Initialize a counter variable\n    count = 0\n\n    # Iterate over the range\n    for i in range(L, R + 1):\n        # Convert the integer to a hexadecimal string\n        hex_str = hex(i)[2:]\n\n        # Check if the hexadecimal string is a valid hexadecimal number\n        if len(hex_str) == 2 and all(c in '0123456789abcdefABCDEF' for c in hex_str):\n            # Increment the counter\n            count += 1\n\n    # Return the count\n    return count"}
{"id": "97_0", "code": "import heapq\nfrom collections import deque\n\ndef merge_sorted_list(num1, num2, num3):\n    # Create a min heap with the first element of each list\n    min_heap = [(num1, 0), (num2, 1), (num3, 2)]\n    # Initialize the result list\n    result = []\n    # Initialize the index\n    index = 0\n    # Initialize the heap size\n    heap_size = 0\n\n    while heap_size > 0:\n        # Get the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Append the smallest element to the result list\n        result.append(smallest[0])\n        # Increment the index\n        index += 1\n        # If the index is less than the length of the list, add the next element to the heap\n        if index < len(smallest[1]):\n            heapq.heappush(min_heap, (smallest[1][index], index))\n            # Increment the heap size\n            heap_size += 1\n    # Return the result list\n    return result"}
{"id": "98_0", "code": "def odd_Equivalent(s, n):\n    \"\"\"\n    This function generates a binary string with n rotations of the input string s.\n    The beginning of the generated content is as follows:\n    s + (n-1) 0's\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Loop through the input string s\n    for i in range(len(s)):\n        # Append the current character to the result string\n        result += s[i]\n        \n        # If the current character is '0', append a '0' to the result string\n        if s[i] == '0':\n            result += '0'\n    \n    # Append (n-1) 0's to the result string\n    result += '0' * (n - 1)\n    \n    # Return the result string\n    return result"}
{"id": "99_0", "code": "def extract_missing(test_list, strt_val, stop_val):\n    \"\"\"\n    Extract the ranges that are missing from the given list with the given start range and end range values.\n\n    Args:\n        test_list (list): The input list of numbers.\n        strt_val (int): The start range value.\n        stop_val (int): The end range value.\n\n    Returns:\n        list: A list of tuples containing the missing ranges.\n    \"\"\"\n    missing_ranges = []\n    for i in range(len(test_list)):\n        if test_list[i] < strt_val or test_list[i] > stop_val:\n            missing_ranges.append((i, i + 1))\n    return missing_ranges"}
{"id": "100_0", "code": "def common_in_nested_lists(nestedlist):\n    \"\"\"\n    This function finds common elements in given nested lists.\n\n    Args:\n        nestedlist (list): A list of lists containing elements of different data types.\n\n    Returns:\n        list: A list of common elements found in the nested lists.\n    \"\"\"\n    def recursive_search(lst):\n        result = []\n        for item in lst:\n            if isinstance(item, list):\n                result.extend(recursive_search(item))\n            elif item in result:\n                result.append(item)\n        return result\n\n    return recursive_search(nestedlist)\n\n# Example usage:\nnested_list = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nprint(common_in_nested_lists(nested_list))  # Output: [2, 3, 4]"}
{"id": "101_0", "code": "import math\n\ndef perimeter(diameter, height):\n    \"\"\"\n    Calculate the perimeter of a cylinder.\n\n    Parameters:\n    diameter (float): The diameter of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The perimeter of the cylinder.\n    \"\"\"\n    # Calculate the radius\n    radius = diameter / 2\n\n    # Calculate the perimeter\n    perimeter = 2 * math.pi * radius + 2 * math.pi * radius\n\n    return perimeter\n\n# Example usage:\ndiameter = 10  # in cm\nheight = 20  # in cm\nperimeter = perimeter(diameter, height)\nprint(f\"The perimeter of the cylinder is {perimeter:.2f} cm\")"}
{"id": "102_0", "code": "def check_integer(text):\n    \"\"\"\n    Checks if a string represents an integer or not.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        # Attempt to convert the string to an integer\n        int(text)\n        return True\n    except ValueError:\n        # If a ValueError is raised, the string does not represent an integer\n        return False"}
{"id": "103_0", "code": "def assign_freq(test_list):\n    freq_dict = {}\n    for item in test_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"id": "104_0", "code": "def empty_dit(list1):\n    for d in list1:\n        if d:\n            return False\n    return True"}
{"id": "105_0", "code": "def tuple_to_int(nums):\n    \"\"\"\n    Convert a tuple of positive integers into an integer.\n\n    Args:\n        nums (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The integer representation of the input tuple.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result = result * 10 + num\n    return result"}
{"id": "106_0", "code": "def list_to_float(test_list):\n    \"\"\"\n    Converts all elements in the list to float.\n\n    Args:\n        test_list (list): The list to be converted.\n\n    Returns:\n        list: The list with all elements converted to float.\n    \"\"\"\n    return [float(element) for element in test_list]"}
{"id": "107_0", "code": "def string_to_list(string):\n    \"\"\"\n    Convert a string to a list.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of characters in the input string.\n    \"\"\"\n    return list(string)"}
{"id": "108_0", "code": "def search(arr, n):\n    \"\"\"\n    This function finds the element that appears only once in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    n (int): The number of elements in the array.\n\n    Returns:\n    int: The element that appears only once in the array.\n    \"\"\"\n    # Initialize two pointers, one at the start and one at the end of the array\n    left, right = 0, n - 1\n\n    # Continue the search until the two pointers meet\n    while left <= right:\n        # Calculate the middle index\n        mid = (left + right) // 2\n\n        # If the middle element is equal to the last element, the single element must be at the left end\n        if arr[mid] == arr[n - 1]:\n            left = mid + 1\n        # If the middle element is less than the last element, the single element must be at the right end\n        elif arr[mid] < arr[n - 1]:\n            left = mid + 1\n        # If the middle element is greater than the last element, the single element must be at the left end\n        else:\n            right = mid - 1\n\n    # Return the element that appears only once\n    return arr[left]"}
{"id": "109_0", "code": "def max_product_tuple(lst1):\n    \"\"\"\n    This function finds the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        lst1 (list): A list of tuples.\n\n    Returns:\n        int: The maximum product from the pairs of tuples.\n    \"\"\"\n    # Initialize max_product and min_product to negative infinity\n    max_product = float('-inf')\n    min_product = float('inf')\n\n    # Iterate over each tuple in the list\n    for tup in lst1:\n        # Unpack the tuple into two variables\n        a, b = tup\n\n        # Update max_product and min_product if necessary\n        max_product = max(max_product, a * b)\n        min_product = min(min_product, a * b)\n\n    # Return the maximum product\n    return max_product"}
{"id": "110_0", "code": "def check_triplet(A, n, sum, count):\n    # Sort the array\n    A.sort()\n    # Iterate through the array\n    for i in range(n - 2):\n        # Initialize two pointers\n        left, right = i + 1, n - 1\n        # Iterate until the two pointers meet\n        while left < right:\n            # Calculate the current sum\n            current_sum = A[i] + A[left] + A[right]\n            # If the current sum is equal to the given sum, increment the count\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            # If the current sum is less than the given sum, move the left pointer to the right\n            elif current_sum < sum:\n                left += 1\n            # If the current sum is greater than the given sum, move the right pointer to the left\n            else:\n                right -= 1\n    # Return the count\n    return count"}
{"id": "111_0", "code": "def smartNumber(n):\n    \"\"\"\n    Generate the nth smart number.\n\n    A smart number is a number that is equal to the sum of its digits.\n\n    Args:\n        n (int): The position of the smart number to generate.\n\n    Returns:\n        int: The nth smart number.\n    \"\"\"\n    # Initialize the number to 0\n    num = 0\n\n    # Loop through each digit of the number\n    for i in range(n):\n        # Add the current digit to the number\n        num += int(digit)\n\n    # Return the nth smart number\n    return num"}
{"id": "112_0", "code": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to the specified limit.\n\n    Args:\n        limit (int): The upper limit for the amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers.\n    \"\"\"\n    amicable_numbers = []\n    for num in range(1, limit + 1):\n        # Check if the number is amicable\n        if is_amicable(num, limit):\n            amicable_numbers.append(num)\n    return sum(amicable_numbers)\n\ndef is_amicable(num, limit):\n    \"\"\"\n    Checks if a number is amicable.\n\n    Args:\n        num (int): The number to check.\n        limit (int): The upper limit.\n\n    Returns:\n        bool: True if the number is amicable, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, limit + 1):\n        if i != num and is_amicable(i, num):\n            count += 1\n    return count == 2\n\n# Example usage:\nlimit = 100\nresult = amicable_numbers_sum(limit)\nprint(f\"The sum of all amicable numbers from 1 to {limit} is: {result}\")"}
{"id": "113_0", "code": "import math\n\ndef angle_complex(a, b):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    # Calculate the magnitude of the complex number\n    magnitude = math.sqrt(a**2 + b**2)\n    \n    # Calculate the angle using the arctangent function\n    angle = math.atan2(b, a)\n    \n    return angle\n\n# Example usage:\nprint(angle_complex(3, 4))  # Output: 0.9272952180016122"}
{"id": "114_0", "code": "def find_length(string, n):\n    \"\"\"\n    This function finds the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\n    Args:\n        string (str): The binary string.\n        n (int): The length of the sub-string.\n\n    Returns:\n        int: The maximum difference between the number of 0s and number of 1s in any sub-string.\n    \"\"\"\n    max_diff = 0\n    for i in range(len(string) - n + 1):\n        count_0 = string[i].count('0')\n        count_1 = string[i].count('1')\n        diff = abs(count_0 - count_1)\n        max_diff = max(max_diff, diff)\n    return max_diff"}
{"id": "115_0", "code": "def sum(a, b):\n    # Initialize the sum of common divisors\n    common_divisor_sum = 0\n    \n    # Iterate over all numbers from 1 to min(a, b)\n    for i in range(1, min(a, b) + 1):\n        # Check if i is a divisor of both a and b\n        if a % i == 0 and b % i == 0:\n            # Add i to the sum of common divisors\n            common_divisor_sum += i\n    \n    # Return the sum of common divisors\n    return common_divisor_sum"}
{"id": "116_0", "code": "def multiply_int(x, y):\n    # Initialize result variable\n    result = 0\n    \n    # Loop through each digit of y\n    for i in range(len(str(y))):\n        # Multiply result by 10 and add the current digit of y\n        result = result * 10 + y[i]\n    \n    # Multiply result by x\n    result = result * x\n    \n    return result"}
{"id": "117_0", "code": "def long_words(n, str):\n    \"\"\"\n    Returns a list of words that are longer than n from the given list of words.\n\n    Args:\n        n (int): The length threshold.\n        str (list): The list of words.\n\n    Returns:\n        list: A list of words that are longer than n.\n    \"\"\"\n    return [word for word in str if len(word) > n]"}
{"id": "118_0", "code": "def magic_square_test(my_matrix):\n    \"\"\"\n    This function generates a magic square using a given 2D list.\n    \n    Args:\n    my_matrix (list): A 2D list representing the magic square.\n    \n    Returns:\n    list: A 2D list representing the generated magic square.\n    \"\"\"\n    # Check if the input is a 2D list\n    if not isinstance(my_matrix, list) or not all(isinstance(row, list) for row in my_matrix):\n        raise ValueError(\"Input must be a 2D list\")\n    \n    # Check if the input list has the same number of rows and columns\n    if len(my_matrix) != len(my_matrix[0]):\n        raise ValueError(\"Input list must have the same number of rows and columns\")\n    \n    # Check if the input list is empty\n    if not my_matrix:\n        return []\n    \n    # Calculate the size of the magic square\n    size = len(my_matrix)\n    \n    # Initialize the magic square with zeros\n    magic_square = [[0 for _ in range(size)] for _ in range(size)]\n    \n    # Fill the magic square with numbers from 1 to size^2\n    for i in range(size):\n        for j in range(size):\n            magic_square[i][j] = i * size + j + 1\n    \n    return magic_square"}
{"id": "119_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The item with maximum frequency.\n    \"\"\"\n    # Create a dictionary to store the frequency of each item\n    freq_dict = {}\n    for num in nums:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the item with maximum frequency\n    max_freq = max(freq_dict.values())\n    max_item = [key for key, value in freq_dict.items() if value == max_freq]\n\n    return max_item[0] if max_item else None"}
{"id": "120_0", "code": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    str1 = str1.replace(' ', '')  # remove spaces\n    str1 = str1.lower()  # convert to lowercase\n    str1 = ''.join([char for char in str1 if char in vowels])  # remove vowels\n    str1 = str1[::-1]  # reverse the string\n    str1 = ''.join([char for char in str1 if char in vowels])  # remove vowels\n    return str1"}
{"id": "121_0", "code": "def tup_string(tup1):\n    return str(tup1)"}
{"id": "122_0", "code": "def sum_negativenum(nums):\n    return sum(lambda x: x if x < 0 else 0 for x in nums)"}
{"id": "123_0", "code": "def check_last(arr, n, p):\n    \"\"\"\n    This function checks whether the last element of given array is even or odd after performing an operation p times.\n\n    Parameters:\n    arr (list): The input array\n    n (int): The number of operations\n    p (int): The number of times the operation is performed\n\n    Returns:\n    bool: True if the last element is even or odd after p operations, False otherwise\n    \"\"\"\n    # Perform the operation p times\n    for _ in range(p):\n        # Get the last element of the array\n        last_element = arr[-1]\n        \n        # Check if the last element is even or odd\n        if last_element % 2 == 0:\n            return True\n        else:\n            return False\n\n    # If p is greater than the length of the array, return False\n    return False"}
{"id": "124_0", "code": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    Args:\n        n (int): The position of the hexagonal number to calculate.\n\n    Returns:\n        int: The nth hexagonal number.\n    \"\"\"\n    # Base case: 1 is the 1st hexagonal number\n    if n == 1:\n        return 1\n    # Recursive case: n is the 2nd hexagonal number\n    elif n == 2:\n        return 1 + 1\n    # Recursive case: n is the nth hexagonal number\n    else:\n        return n * (2 * n - 1) // 2"}
{"id": "125_0", "code": "def cal_electbill(units):\n    # Define the electricity rates\n    electricity_rates = {\n        'per_unit': 0.05,\n        'per_hour': 0.10,\n        'per_day': 0.20,\n        'per_month': 0.30\n    }\n\n    # Calculate the total electricity bill\n    total_bill = units * electricity_rates['per_unit']\n\n    # Calculate the total electricity bill for the month\n    total_monthly_bill = total_bill * electricity_rates['per_month']\n\n    return total_bill, total_monthly_bill"}
{"id": "126_0", "code": "def zero_count(nums):\n    \"\"\"\n    This function calculates the ratio of zeroes in an array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of zeroes in the array.\n    \"\"\"\n    # Initialize count of zeroes\n    zero_count = 0\n\n    # Iterate through the array\n    for num in nums:\n        # Check if the number is zero\n        if num == 0:\n            # Increment the count of zeroes\n            zero_count += 1\n\n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n\n    return ratio"}
{"id": "127_0", "code": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Initialize the power of 2 to 0\n    power_of_two = 0\n\n    # Loop until the number becomes 0\n    while n > 0:\n        # If the number is not 0, subtract 1 from it\n        if n % 2 != 0:\n            n -= 1\n        # If the number is 0, return True\n        if n == 0:\n            return True\n        # Increment the power of 2\n        power_of_two += 1\n\n    # If the loop ends without returning True, return False\n    return False"}
{"id": "128_0", "code": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Calculate the circumference of a circle.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * r"}
{"id": "129_0", "code": "def extract_singly(test_list):\n    \"\"\"\n    Extract elements that occur singly in the given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of elements that occur singly in the given tuple list.\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n\n    # Iterate over each tuple in the test list\n    for tup in test_list:\n        # Check if the tuple has only one element\n        if len(tup) == 1:\n            # Append the single element to the extracted elements list\n            extracted_elements.append(tup[0])\n\n    # Return the extracted elements list\n    return extracted_elements"}
{"id": "130_0", "code": "def pancake_sort(nums):\n    \"\"\"\n    Sorts a list of elements using pancake sort.\n\n    Args:\n    nums (list): A list of elements to be sorted.\n\n    Returns:\n    list: The sorted list of elements.\n    \"\"\"\n    # Initialize the stack\n    stack = []\n    # Iterate through the list\n    for i in range(len(nums)):\n        # Find the index of the maximum element\n        max_idx = nums.index(max(nums[:i+1]))\n        # If the maximum element is not at the current index, push it to the stack\n        if max_idx != i:\n            stack.append(max_idx)\n        # Push the current index to the stack\n        stack.append(i)\n    # Pop the stack and append the remaining elements to the result\n    result = []\n    while stack:\n        max_idx = stack.pop()\n        result.append(nums[max_idx])\n        # If the maximum element is not at the current index, push it to the stack\n        if max_idx != max_idx - 1:\n            stack.append(max_idx - 1)\n    # Append the remaining elements to the result\n    result.extend(nums[stack])\n    return result"}
{"id": "131_0", "code": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the same pair in three given lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        int: The number of same pairs in the three lists.\n    \"\"\"\n    # Initialize a counter for the same pairs\n    same_pairs = 0\n\n    # Iterate over the elements of the first list\n    for i in list1:\n        # Iterate over the elements of the second list\n        for j in list2:\n            # Check if the current pair is in the third list\n            if i in list3 and j in list3:\n                # If the pair is in the third list, increment the counter\n                same_pairs += 1\n\n    # Return the total number of same pairs\n    return same_pairs"}
{"id": "132_0", "code": "def find_lists(Input):\n    # Initialize a counter for the number of lists\n    count = 0\n    \n    # Initialize a flag to check if the tuple is empty\n    is_empty = True\n    \n    # Iterate over the tuple\n    for i in Input:\n        # Check if the current element is a list\n        if isinstance(i, list):\n            # Increment the counter\n            count += 1\n            # Set the flag to False\n            is_empty = False\n        else:\n            # Set the flag to True\n            is_empty = True\n    \n    # Return the count and the flag\n    return count, is_empty"}
{"id": "133_0", "code": "def sum_Pairs(arr, n):\n    # Initialize sum of absolute differences\n    total_sum = 0\n    \n    # Iterate over all pairs of elements\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate absolute difference\n            diff = abs(arr[i] - arr[j])\n            # Add to total sum\n            total_sum += diff\n            \n    return total_sum"}
{"id": "134_0", "code": "def max_Abs_Diff(arr, n):\n    \"\"\"\n    This function calculates the maximum absolute difference between any two elements in an array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    # Initialize the minimum and maximum values\n    min_val = float('inf')\n    max_val = float('-inf')\n\n    # Iterate through the array to find the minimum and maximum values\n    for num in arr:\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n\n    # Calculate the absolute difference between the minimum and maximum values\n    abs_diff = max_val - min_val\n\n    return abs_diff"}
{"id": "135_0", "code": "def ascii_value_string(str1):\n    return sum(ord(c) for c in str1)"}
{"id": "136_0", "code": "def max_path_sum(tri, m, n):\n    \"\"\"\n    Find the maximum total path sum in the given triangle.\n\n    Args:\n    tri (list): A list of lists representing the triangle.\n    m (int): The number of rows in the triangle.\n    n (int): The number of columns in the triangle.\n\n    Returns:\n    int: The maximum total path sum in the triangle.\n    \"\"\"\n    # Initialize the maximum path sum\n    max_sum = float('-inf')\n\n    # Iterate over each row in the triangle\n    for row in tri:\n        # Initialize the maximum path sum for the current row\n        row_max_sum = float('-inf')\n        # Iterate over each column in the current row\n        for col in row:\n            # Update the maximum path sum for the current column\n            row_max_sum = max(row_max_sum, col)\n        # Update the maximum path sum for the entire row\n        max_sum = max(max_sum, row_max_sum + tri[row.index(max(row_max_sum, key=abs))][col])\n\n    # Return the maximum path sum\n    return max_sum"}
{"id": "137_0", "code": "def sum_digits_twoparts(N):\n    \"\"\"\n    Divide a number into two parts such that the sum of digits is maximum.\n\n    Args:\n        N (int): The input number.\n\n    Returns:\n        tuple: A tuple containing two integers representing the two parts of the number.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    str_N = str(N)\n    \n    # Initialize variables to store the maximum sum and the corresponding parts\n    max_sum = 0\n    part1, part2 = 0, 0\n    \n    # Iterate over all possible splits of the number\n    for i in range(1, len(str_N)):\n        for j in range(i + 1, len(str_N) + 1):\n            # Calculate the sum of digits for the current split\n            sum1 = sum(int(digit) for digit in str_N[:i])\n            sum2 = sum(int(digit) for digit in str_N[i:j])\n            \n            # Update the maximum sum and the corresponding parts if necessary\n            if sum1 + sum2 > max_sum:\n                max_sum = sum1 + sum2\n                part1, part2 = sum1, sum2\n    \n    # Return the two parts of the number\n    return part1, part2"}
{"id": "138_0", "code": "def longest_subseq_with_diff_one(arr, n):\n    \"\"\"\n    This function generates the longest subsequence in the given array such that the difference between adjacent elements is one.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    list: The longest subsequence with a difference of one between adjacent elements.\n    \"\"\"\n    # Initialize a 2D array to store the longest subsequence ending at each position\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize a 2D array to store the previous element in the longest subsequence ending at each position\n    prev = [[None] * n for _ in range(n)]\n    \n    # Initialize the maximum length of the subsequence and its ending position\n    max_len = 0\n    max_end = 0\n    \n    # Fill the dp and prev arrays using dynamic programming\n    for i in range(n):\n        for j in range(i):\n            # If the difference between the current elements is one, update the dp and prev arrays\n            if abs(arr[i] - arr[j]) == 1:\n                if dp[i][j] + 1 > dp[i][max_end]:\n                    dp[i][max_end] = dp[i][j] + 1\n                    prev[i][max_end] = j\n                elif dp[i][j] + 1 == dp[i][max_end]:\n                    prev[i][max_end] = max(prev[i][max_end], j)\n    \n    # Reconstruct the longest subsequence from the prev array\n    subseq = []\n    i, j = max_end, n - 1\n    while i >= 0 and j >= 0:\n        if prev[i][j] is not None:\n            subseq.append(arr[i])\n            i = prev[i][j]\n        else:\n            j -= 1\n    \n    # Return the longest subsequence in the correct order\n    return subseq[::-1]\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(arr)\nprint(longest_subseq_with_diff_one(arr, n))  # Output: [1, 2, 3, 4, 5]"}
{"id": "139_0", "code": "def does_Contain_B(a, b, c):\n    # Generate infinite sequence\n    sequence = [a, b, c]\n    while True:\n        next_value = sequence[-1] + sequence[-2] + sequence[-3]\n        if next_value in sequence:\n            return True\n        else:\n            sequence.append(next_value)\n    return False"}
{"id": "140_0", "code": "import math\n\ndef is_coprime(x, y):\n    \"\"\"\n    Checks whether two numbers are co-prime or not.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        bool: True if the numbers are co-prime, False otherwise.\n    \"\"\"\n    # Check if x and y are positive integers\n    if not isinstance(x, int) or not isinstance(y, int) or x <= 0 or y <= 0:\n        raise ValueError(\"Both x and y must be positive integers.\")\n\n    # Check if x and y are co-prime\n    if math.gcd(x, y) != 1:\n        return False\n    else:\n        return True\n\n# Example usage:\nprint(is_coprime(10, 15))  # Returns: True\nprint(is_coprime(10, 20))  # Returns: False"}
{"id": "141_0", "code": "def merge_sort(x):\n    # Base case: If the array has only one element, it is already sorted\n    if len(x) <= 1:\n        return x\n\n    # Find the middle index of the array\n    mid = len(x) // 2\n\n    # Divide the array into two halves\n    left_half = x[:mid]\n    right_half = x[mid:]\n\n    # Recursively sort the two halves\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the two sorted halves\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    # Merge smaller elements first\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    # If there are remaining elements in either half, append them to the merged list\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged"}
{"id": "142_0", "code": "def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculate the vertex of a parabola given its coefficients a, b, and c.\n\n    The vertex of a parabola in the form ax^2 + bx + c is given by:\n    x = -b / (2a)\n\n    Parameters:\n    a (float): coefficient of x^2\n    b (float): coefficient of x\n    c (float): constant term\n\n    Returns:\n    float: x-coordinate of the vertex\n    \"\"\"\n    return -b / (2 * a)"}
{"id": "143_0", "code": "def specified_element(nums, N):\n    \"\"\"\n    Extract every specified element from a given two dimensional list.\n\n    Args:\n        nums (list): A two dimensional list of elements.\n        N (int): The number of elements to extract.\n\n    Returns:\n        list: A list of extracted elements.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        return []\n\n    # Check if the number of elements to extract is valid\n    if N > len(nums):\n        raise ValueError(\"Number of elements to extract is greater than the number of elements in the list.\")\n\n    # Extract the specified elements\n    extracted_elements = [nums[i][j] for i in range(N) for j in range(len(nums[i]))]\n\n    return extracted_elements"}
{"id": "144_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    Toggles all even bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all even bits toggled.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the binary string\n    for bit in bin_n:\n        # If the bit is '0', toggle it to '1' and add it to the result\n        if bit == '0':\n            result += '1'\n        # If the bit is '1', add it to the result as is\n        else:\n            result += bit\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)"}
{"id": "145_0", "code": "def tuple_int_str(tuple_str):\n    \"\"\"\n    Convert a tuple of string values to a tuple of integer values.\n\n    Args:\n        tuple_str (tuple): A tuple of string values.\n\n    Returns:\n        tuple: A tuple of integer values.\n    \"\"\"\n    # Initialize an empty list to store the integer values\n    int_list = []\n    \n    # Iterate over each string value in the tuple\n    for string in tuple_str:\n        # Try to convert the string to an integer\n        try:\n            # Append the integer value to the list\n            int_list.append(int(string))\n        except ValueError:\n            # If the conversion fails, print an error message\n            print(f\"Error: '{string}' is not a valid integer.\")\n    \n    # Convert the list to a tuple and return it\n    return tuple(int_list)"}
{"id": "146_0", "code": "def encode_list(list1):\n    \"\"\"\n    This function encodes a list into a string using run-length encoding.\n\n    Args:\n        list1 (list): The input list to be encoded.\n\n    Returns:\n        str: The encoded string.\n    \"\"\"\n    encoded_str = \"\"\n    count_dict = {}\n\n    # Iterate over the list\n    for item in list1:\n        # If the item is already in the dictionary, increment its count\n        if item in count_dict:\n            count_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[item] = 1\n\n    # Iterate over the dictionary and append the encoded string\n    for key, value in count_dict.items():\n        encoded_str += str(key) + str(value)\n\n    return encoded_str"}
{"id": "147_0", "code": "def min_Ops(arr, n, k):\n    \"\"\"\n    This function calculates the minimum number of operations required to make all elements in the array equal.\n    \n    Parameters:\n    arr (list): The input array of numbers.\n    n (int): The size of the array.\n    k (int): The number of operations required to make all elements equal.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    # Calculate the median of the array\n    median = sorted(arr)[n // 2]\n    \n    # Initialize the total operations\n    total_ops = 0\n    \n    # Calculate the operations required to make all elements equal to the median\n    for num in arr:\n        total_ops += abs(num - median)\n    \n    # Calculate the remaining operations required to make all elements equal to the median\n    remaining_ops = k - total_ops\n    \n    # If there are remaining operations, calculate the number of operations required to make all elements equal to the median\n    if remaining_ops > 0:\n        # Calculate the number of operations required to make all elements equal to the median\n        ops_to_median = remaining_ops // (n // 2)\n        # Calculate the number of operations required to make all elements equal to the median\n        ops_to_median += remaining_ops % (n // 2)\n        # Return the total operations\n        return total_ops + ops_to_median\n    else:\n        # Return the total operations\n        return total_ops"}
{"id": "148_0", "code": "def month_season(month, days):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return \"Summer\"\n    elif month in [4, 6, 9, 11]:\n        return \"Autumn\"\n    elif month in [2]:\n        return \"Winter\"\n    else:\n        return \"Invalid month\""}
{"id": "149_0", "code": "def solution(a, b, n):\n    \"\"\"\n    Find x and y that satisfies ax + by = n.\n\n    Args:\n        a (float): Coefficient of x\n        b (float): Coefficient of y\n        n (float): Constant term\n\n    Returns:\n        tuple: (x, y) that satisfies ax + by = n\n    \"\"\"\n    # Calculate determinant\n    det = a * b - n\n\n    # If determinant is zero, there is no solution\n    if det == 0:\n        return None\n\n    # Calculate x and y\n    x = n / det\n    y = -a * x / b\n\n    return x, y"}
{"id": "150_0", "code": "def remove_elements(list1, list2):\n    \"\"\"\n    Removes all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The list from which elements are to be removed.\n        list2 (list): The list containing elements to be removed.\n\n    Returns:\n        list: The modified list1 with elements from list2 removed.\n    \"\"\"\n    return [element for element in list1 if element not in list2]"}
{"id": "151_0", "code": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0)\n    \n    Parameters:\n    n (int): The upper limit of the series\n    \n    Returns:\n    int: The sum of the positive integers in the series\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        if i >= n:\n            break\n        total += i\n    return total"}
{"id": "152_0", "code": "import math\n\ndef area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (float): The number of sides of the polygon.\n    l (float): The length of each side of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the number of sides is valid\n    if s < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n\n    # Calculate the area using the formula: (n * s * l^2) / (4 * tan(Ï€/n))\n    area = (s * l**2) / (4 * math.tan(math.pi/s))\n    return area"}
{"id": "153_0", "code": "def areEquivalent(num1, num2):\n    # Function to calculate sum of divisors\n    def sum_of_divisors(n):\n        sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                sum += i\n                if i != n // i:\n                    sum += n // i\n        return sum\n\n    # Check if sum of divisors are same\n    sum1 = sum_of_divisors(num1)\n    sum2 = sum_of_divisors(num2)\n    return sum1 == sum2"}
{"id": "154_0", "code": "def count_char_position(str1):\n    # Convert the string to lowercase\n    str1 = str1.lower()\n    \n    # Initialize an empty dictionary to store the count of characters at the same position\n    char_count = {}\n    \n    # Iterate over the characters in the string\n    for i in range(len(str1)):\n        # Get the character at the current position\n        char = str1[i]\n        \n        # Check if the character is an English alphabet\n        if char.isalpha():\n            # Get the ASCII value of the character\n            ascii_val = ord(char)\n            \n            # Check if the character is at the same position in the string\n            if i + 1 in char_count:\n                # Increment the count of the character at the same position\n                char_count[i + 1] += 1\n            else:\n                # Add the character to the dictionary with a count of 1\n                char_count[i + 1] = 1\n    \n    # Return the dictionary with the count of characters at the same position\n    return char_count"}
{"id": "155_0", "code": "def find_even_Pair(A, N):\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count"}
{"id": "156_0", "code": "def next_Power_Of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    power = 1\n    while power < n:\n        power *= 2\n    return power"}
{"id": "157_0", "code": "def frequency(a, x):\n    frequency_dict = {}\n    for i in a:\n        if i == x:\n            frequency_dict[i] = frequency_dict.get(i, 0) + 1\n    return frequency_dict"}
{"id": "158_0", "code": "def get_pell(n):\n    \"\"\"\n    Calculate the nth Pell number.\n\n    Args:\n        n (int): The index of the Pell number to calculate.\n\n    Returns:\n        int: The nth Pell number.\n    \"\"\"\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b"}
{"id": "159_0", "code": "def sum_range_list(list1, m, n):\n    \"\"\"\n    This function calculates the sum of numbers in a list between the specified indices.\n\n    Args:\n        list1 (list): The input list of numbers.\n        m (int): The starting index of the range (inclusive).\n        n (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the specified range.\n    \"\"\"\n    # Check if the range is valid\n    if m >= n:\n        raise ValueError(\"Invalid range. Starting index should be less than ending index.\")\n\n    # Slice the list to get the desired range\n    range_list = list1[m:n+1]\n\n    # Calculate the sum of the numbers in the range\n    total_sum = sum(range_list)\n\n    return total_sum"}
{"id": "160_0", "code": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # Calculate the perimeter of the pentagon\n    perimeter = 5 * a\n    return perimeter"}
{"id": "161_0", "code": "def count_occurance(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 's':\n            count += 1\n    return count"}
{"id": "162_0", "code": "def remove_splchar(text):\n    return ''.join(c for c in text if c.isalnum() or c.isspace())"}
{"id": "163_0", "code": "def group_keyvalue(l):\n    \"\"\"\n    This function groups a sequence of key-value pairs into a dictionary of lists.\n\n    Args:\n        l (list): A list of tuples containing key-value pairs.\n\n    Returns:\n        dict: A dictionary where each key is a unique key from the input list and each value is a list of corresponding values.\n    \"\"\"\n    result = {}\n    for pair in l:\n        key, value = pair\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result"}
{"id": "164_0", "code": "def is_valid_parenthese(str1):\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"id": "165_0", "code": "def perimeter_triangle(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle.\n\n    Args:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of side c.\n\n    Returns:\n        float: The perimeter of the triangle.\n    \"\"\"\n    # Check if the input values are valid\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All sides of the triangle must be positive numbers.\")\n\n    # Calculate the perimeter\n    perimeter = a + b + c\n\n    return perimeter"}
{"id": "166_0", "code": "import math\nfrom itertools import combinations\n\ndef answer(L, R):\n    # Define a helper function to calculate LCM\n    def lcm(a, b):\n        return abs(a*b) // math.gcd(a, b)\n\n    # Generate all possible pairs of numbers\n    pairs = list(combinations(range(1, L+1), 2))\n\n    # Filter pairs based on the condition\n    valid_pairs = [pair for pair in pairs if lcm(pair[0], pair[1]) > L and lcm(pair[0], pair[1]) < R]\n\n    # If no valid pairs are found, return None\n    if not valid_pairs:\n        return None\n\n    # Find the pair with the maximum LCM\n    max_lcm_pair = max(valid_pairs, key=lambda x: lcm(x[0], x[1]))\n\n    # Return the pair with the maximum LCM\n    return max_lcm_pair\n\n# Example usage\nL = 100\nR = 200\nprint(answer(L, R))"}
{"id": "167_0", "code": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for literals strings in a given text.\n\n    Args:\n        patterns (list): A list of literal strings to search for.\n        text (str): The text to search in.\n\n    Returns:\n        list: A list of indices where the literals are found in the text.\n    \"\"\"\n    # Initialize an empty list to store the indices of the literals\n    indices = []\n\n    # Iterate over each pattern\n    for pattern in patterns:\n        # Use the find method to search for the pattern in the text\n        # The find method returns the index of the first occurrence of the pattern\n        index = text.find(pattern)\n\n        # If the pattern is found, append its index to the list\n        if index != -1:\n            indices.append(index)\n\n    # Return the list of indices\n    return indices"}
{"id": "168_0", "code": "def is_num_keith(x):\n    \"\"\"\n    Checks if the given number is a Keith number.\n\n    A Keith number is a number that can be represented as the sum of two squares.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Keith number, False otherwise.\n    \"\"\"\n    # Initialize the sum of squares\n    sum_squares = 0\n\n    # Iterate over all possible pairs of squares\n    for i in range(int(x**0.5) + 1):\n        for j in range(int(x**0.5) + 1):\n            # Check if the sum of the squares is equal to the number\n            if i**2 + j**2 == x:\n                # If it is, return True\n                return True\n\n    # If no pair of squares sums up to the number, return False\n    return False"}
{"id": "169_0", "code": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    \"\"\"\n    Calculate the distance between two points on the surface of the Earth using latitude and longitude.\n\n    Parameters:\n    slat (float): The latitude of the first point in degrees.\n    slon (float): The longitude of the first point in degrees.\n    elat (float): The latitude of the second point in degrees.\n    elon (float): The longitude of the second point in degrees.\n\n    Returns:\n    float: The distance between the two points in kilometers.\n    \"\"\"\n    # Convert the latitude and longitude from degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n\n    # Calculate the differences in latitude and longitude\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n\n    # Calculate the Haversine formula\n    a = math.sin(dlat / 2) ** 2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2) ** 2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n\n    # Calculate the radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate the distance\n    distance = R * c\n\n    return distance"}
{"id": "170_0", "code": "def common_prefix(arr, n):\n    # Check if the input array is empty\n    if not arr:\n        return \"\"\n\n    # Sort the array\n    arr.sort()\n\n    # Initialize the prefix as an empty string\n    prefix = \"\"\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is equal to the previous one, add it to the prefix\n        if i == 0 or arr[i] == arr[i - 1]:\n            prefix += arr[i]\n        # If the current element is not equal to the previous one, break the loop\n        else:\n            break\n\n    return prefix"}
{"id": "171_0", "code": "import re\n\ndef find_character(string):\n    # Find uppercase letters\n    uppercase = re.findall(r'[A-Z]', string)\n    \n    # Find lowercase letters\n    lowercase = re.findall(r'[a-z]', string)\n    \n    # Find special characters\n    special_chars = re.findall(r'[^A-Za-z0-9]', string)\n    \n    # Find numeric values\n    numeric = re.findall(r'\\d', string)\n    \n    return uppercase, lowercase, special_chars, numeric"}
{"id": "172_0", "code": "def count_pairs(arr, n, k):\n    \"\"\"\n    Counts all distinct pairs in the given array with a difference of k.\n\n    Args:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The difference between the pairs.\n\n    Returns:\n    int: The number of distinct pairs with a difference of k.\n    \"\"\"\n    # Sort the array\n    arr.sort()\n\n    # Initialize two pointers, one at the start and one at the end\n    left = 0\n    right = n - 1\n\n    # Initialize a set to store unique pairs\n    pairs = set()\n\n    # Traverse the array\n    while left < right:\n        # Calculate the difference between the current elements\n        diff = arr[right] - arr[left]\n\n        # If the difference is equal to k, add the pair to the set\n        if diff == k:\n            pairs.add((arr[left], arr[right]))\n        # If the difference is less than k, move the left pointer to the right\n        elif diff < k:\n            left += 1\n        # If the difference is greater than k, move the right pointer to the left\n        else:\n            right -= 1\n\n    # Return the number of distinct pairs\n    return len(pairs)"}
{"id": "173_0", "code": "def greater_specificnum(lst, num):\n    return [i for i in lst if i > num]"}
{"id": "174_0", "code": "def parabola_focus(a, b, c):\n    \"\"\"\n    Calculate the focus of a parabola given its equation in the form y = ax^2 + bx + c.\n\n    Parameters:\n    a (float): The coefficient of x^2 in the parabola equation.\n    b (float): The coefficient of x in the parabola equation.\n    c (float): The constant term in the parabola equation.\n\n    Returns:\n    tuple: A tuple containing the x-coordinate and y-coordinate of the focus of the parabola.\n    \"\"\"\n    # Calculate the x-coordinate of the focus\n    x_focus = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the focus\n    y_focus = a * x_focus**2 + b * x_focus + c\n    \n    return x_focus, y_focus"}
{"id": "175_0", "code": "import re\n\ndef check_literals(text, patterns):\n    \"\"\"\n    Searches for literals strings in a given text by using regex.\n\n    Args:\n        text (str): The input text to search in.\n        patterns (list of str): A list of literal strings to search for.\n\n    Returns:\n        list of str: A list of literal strings found in the text.\n    \"\"\"\n    # Compile regex patterns\n    regex_patterns = [re.compile(pattern) for pattern in patterns]\n\n    # Find all matches\n    matches = [pattern.group() for pattern in regex_patterns if re.search(pattern, text)]\n\n    return matches"}
{"id": "176_0", "code": "def longest_common_subsequence(X, Y, m, n):\n    # Initialize a 2D array to store the lengths of common subsequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the longest common subsequence from the dp array\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if X[i - 1] == Y[j - 1]:\n            lcs.append(X[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Return the longest common subsequence in the correct order\n    return \"\".join(reversed(lcs))"}
{"id": "177_0", "code": "def prod_Square(n):\n    \"\"\"\n    Checks whether the given number can be represented by product of two squares or not.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        bool: True if the number can be represented by product of two squares, False otherwise.\n    \"\"\"\n    # Initialize a flag to True\n    flag = True\n\n    # Iterate over all possible values of a and b\n    for a in range(1, int(n**0.5) + 1):\n        for b in range(a, int(n**0.5) + 1):\n            # Check if a^2 * b^2 equals to n\n            if a**2 * b**2 == n:\n                # If it does, set the flag to False\n                flag = False\n                # Break the loop as we have found a pair of squares\n                break\n\n    # Return the result\n    return flag"}
{"id": "178_0", "code": "def first_Missing_Positive(arr, n):\n    \"\"\"\n    This function finds the first missing positive number in the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The number of elements in the array.\n\n    Returns:\n    int: The first missing positive number.\n    \"\"\"\n    # Create a set to store the numbers in the array\n    num_set = set(arr)\n    \n    # Initialize the first missing number to 1\n    first_missing = 1\n    \n    # Iterate through the range from 1 to n\n    for i in range(1, n + 1):\n        # If the current number is not in the set, return it\n        if i not in num_set:\n            return i\n        # If the current number is in the set, increment the first missing number\n        first_missing += 1\n    \n    # If the loop completes without finding a missing number, return the first missing number\n    return first_missing"}
{"id": "179_0", "code": "def count_Intgral_Points(x1, y1, x2, y2):\n    \"\"\"\n    Counts the number of integral points inside a square.\n\n    Args:\n        x1 (float): The x-coordinate of the top-left corner of the square.\n        y1 (float): The y-coordinate of the top-left corner of the square.\n        x2 (float): The x-coordinate of the bottom-right corner of the square.\n        y2 (float): The y-coordinate of the bottom-right corner of the square.\n\n    Returns:\n        int: The number of integral points inside the square.\n    \"\"\"\n    # Calculate the side length of the square\n    side_length = max(abs(x1 - x2), abs(y1 - y2))\n\n    # Initialize a counter for integral points\n    integral_points = 0\n\n    # Iterate over all integral points in the square\n    for x in range(int(side_length + 1)):\n        for y in range(int(side_length + 1)):\n            # Check if the point is inside the square\n            if (x1 <= x <= x2 and y1 <= y <= y2) or (x1 <= x <= x2 and y1 <= y <= y2) or (x1 <= x <= x2 and y1 <= y <= y2) or (x1 <= x <= x2 and y1 <= y <= y2):\n                integral_points += 1\n\n    return integral_points"}
{"id": "180_0", "code": "def check_monthnumber(monthname3):\n    monthdays = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return monthdays.get(monthname3, 'Invalid month name')"}
{"id": "181_0", "code": "def check_String(str):\n    # Check if the string has at least one letter and one number\n    if not any(char.isalpha() for char in str) or not any(char.isdigit() for char in str):\n        return False\n    return True"}
{"id": "182_0", "code": "def remove_tuple(test_tup):\n    return tuple(set(test_tup))"}
{"id": "183_0", "code": "def octal_to_decimal(n):\n    # Convert octal to decimal\n    decimal = 0\n    power = 0\n    while n > 0:\n        decimal += (n % 10) * (8 ** power)\n        n = n // 10\n        power += 1\n    return decimal"}
{"id": "184_0", "code": "def first(arr,x,n):\n    if n == 0:\n        return -1\n    if x < 0 or x > n:\n        return -1\n    if x == 0:\n        return 0\n    if x == n:\n        return n-1\n    if arr[x] == x:\n        return x\n    return first(arr,x+1,n)"}
{"id": "185_0", "code": "def remove_tuples(test_list, K):\n    \"\"\"\n    Removes all tuples with length K from the given list.\n\n    Args:\n        test_list (list): The input list of tuples.\n        K (int): The length of the tuples to be removed.\n\n    Returns:\n        list: The modified list with tuples of length K removed.\n    \"\"\"\n    return [t for t in test_list if len(t) != K]"}
{"id": "186_0", "code": "def find_exponentio(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the exponentiation of two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple for exponentiation.\n        test_tup2 (tuple): The second tuple for exponentiation.\n\n    Returns:\n        tuple: The result of the exponentiation of the two tuples.\n    \"\"\"\n    # Initialize the result tuple with the first tuple\n    result = test_tup1[:]\n    \n    # Iterate over the second tuple\n    for i, val in enumerate(test_tup2):\n        # Multiply the current element with the corresponding element in the result tuple\n        result[i] = result[i] * val\n    \n    # Return the result tuple\n    return result"}
{"id": "187_0", "code": "import math\n\ndef largest_triangle(a, b):\n    # Define the ellipse equation\n    ellipse_equation = lambda x: a * x**2 + b * x + b**2 - a**2\n\n    # Find the maximum x value of the ellipse\n    max_x = -b / (2 * a)\n\n    # Find the maximum y value of the ellipse\n    max_y = a * max_x**2 / (2 * a)\n\n    # Find the maximum x value of the triangle\n    max_x_triangle = max_x\n\n    # Find the maximum y value of the triangle\n    max_y_triangle = max_y\n\n    # Check if the triangle is valid\n    if max_x_triangle < max_x and max_y_triangle < max_y:\n        return max_x_triangle, max_y_triangle\n    else:\n        return None\n\n# Example usage\na = 5\nb = 3\nresult = largest_triangle(a, b)\nif result:\n    print(f\"The largest triangle that can be inscribed in the ellipse with semi-axes {a} and {b} is ({result[0]}, {result[1]})\")\nelse:\n    print(\"No valid triangle found\")"}
{"id": "188_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 less than or equal to the given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The highest power of 2 less than or equal to the given number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2"}
{"id": "189_0", "code": "def position_max(list1):\n    \"\"\"\n    Find all index positions of the maximum values in a given list.\n\n    Args:\n        list1 (list): The input list.\n\n    Returns:\n        list: A list of index positions of the maximum values.\n    \"\"\"\n    max_val = max(list1)\n    max_pos = [i for i, val in enumerate(list1) if val == max_val]\n    return max_pos"}
{"id": "190_0", "code": "def chkList(lst):\n    return len(set(lst)) == 1"}
{"id": "191_0", "code": "def remove_even(str1):\n    return ''.join([c for c in str1 if c not in 'aeiou'])"}
{"id": "192_0", "code": "def hamming_Distance(n1, n2):\n    \"\"\"\n    Calculate the Hamming distance between two integers.\n\n    Args:\n        n1 (int): The first integer.\n        n2 (int): The second integer.\n\n    Returns:\n        int: The Hamming distance between n1 and n2.\n    \"\"\"\n    # Convert the integers to binary strings\n    bin_str1 = bin(n1)[2:]\n    bin_str2 = bin(n2)[2:]\n\n    # Pad the shorter string with zeros\n    max_len = max(len(bin_str1), len(bin_str2))\n    bin_str1 = bin_str1.zfill(max_len)\n    bin_str2 = bin_str2.zfill(max_len)\n\n    # Calculate the Hamming distance\n    distance = 0\n    for i in range(max_len):\n        if bin_str1[i] != bin_str2[i]:\n            distance += 1\n\n    return distance"}
{"id": "193_0", "code": "def count(s, c):\n    \"\"\"\n    Counts the occurrence of a given character in a string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to be searched.\n\n    Returns:\n        int: The number of occurrences of the character in the string.\n    \"\"\"\n    return s.count(c)"}
{"id": "194_0", "code": "def inversion_elements(test_tup):\n    inversions = 0\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i] > test_tup[j]:\n                inversions += 1\n    return inversions"}
{"id": "195_0", "code": "def concatenate_elements(test_tup):\n    \"\"\"\n    This function concatenates adjacent elements in a tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        tuple: The concatenated tuple.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    # Check if the tuple has at least two elements\n    if len(test_tup) < 2:\n        raise ValueError(\"Tuple must have at least two elements.\")\n\n    # Initialize an empty list to store the concatenated elements\n    concatenated_list = []\n\n    # Iterate over the tuple\n    for i in range(len(test_tup)):\n        # Append the current element to the list\n        concatenated_list.append(test_tup[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(concatenated_list)"}
{"id": "196_0", "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if str[i - 1] == str[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[i][j] > max_len:\n                max_len = dp[i][j]\n    return str[max_len:]"}
{"id": "197_0", "code": "import re\n\ndef is_decimal(num):\n    # Check if the number is a decimal\n    if re.match(r'^\\d+(\\.\\d+)?$', num):\n        # Check if the number has a precision of 2\n        if len(num.split('.')[1]) == 2:\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"id": "198_0", "code": "import heapq\n\ndef heap_replace(heap, a):\n    # Check if the heap is empty\n    if not heap:\n        return a\n    \n    # Get the smallest element from the heap\n    smallest = heapq.heappop(heap)\n    \n    # Insert the new item into the heap\n    heapq.heappush(heap, a)\n    \n    return smallest"}
{"id": "199_0", "code": "import re\n\ndef is_allowed_specific_char(string):\n    # Define the allowed characters\n    allowed_chars = set('abcdefghijklmnopqrstuvwxyz0123456789')\n    \n    # Check if the string contains only allowed characters\n    if not re.match(r'^[a-zA-Z0-9]+$', string):\n        return False\n    else:\n        return True"}
{"id": "200_0", "code": "def count_Num(n):\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if (i & j) == 0 and (i != j):\n                count += 1\n    return count"}
{"id": "201_0", "code": "def fourth_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of fourth power of n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers.\n\n    Returns:\n        int: The sum of fourth power of n natural numbers.\n    \"\"\"\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Loop through each natural number from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the fourth power of the current number\n        fourth_power = i ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum\n    return total_sum"}
{"id": "202_0", "code": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenates two string tuples into a single string.\n\n    Args:\n        test_tup1 (tuple): The first string tuple.\n        test_tup2 (tuple): The second string tuple.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n\n    # Concatenate the lists\n    concatenated_list = list1 + list2\n\n    # Convert the concatenated list back to a tuple\n    concatenated_tuple = tuple(concatenated_list)\n\n    # Convert the tuple to a string\n    concatenated_str = ''.join(concatenated_tuple)\n\n    return concatenated_str"}
{"id": "203_0", "code": "def degree_radian(radian):\n    \"\"\"\n    Converts radians to degrees.\n\n    Args:\n        radian (float): The angle in radians.\n\n    Returns:\n        float: The angle in degrees.\n    \"\"\"\n    return radian * 180 / math.pi"}
{"id": "204_0", "code": "def decode_list(alist):\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        if alist[i] == 0:\n            decoded_list.append(alist[i+1])\n            i += 1\n        else:\n            decoded_list.append(alist[i])\n            i += 2\n    return decoded_list"}
{"id": "205_0", "code": "def check_subset_list(list1, list2):\n    \"\"\"\n    Checks if list1 is a subset of list2.\n\n    Args:\n        list1 (list): The list to check.\n        list2 (list): The list to check against.\n\n    Returns:\n        bool: True if list1 is a subset of list2, False otherwise.\n    \"\"\"\n    # Check if list1 is a subset of list2\n    return all(item in list2 for item in list1)"}
{"id": "206_0", "code": "def first_Repeated_Char(str):\n    seen = set()\n    for char in str:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"id": "207_0", "code": "def min_Operations(A, B):\n    \"\"\"\n    This function calculates the minimum number of operations required to make two numbers equal.\n    The operations allowed are addition and subtraction.\n\n    Parameters:\n    A (int): The first number.\n    B (int): The second number.\n\n    Returns:\n    int: The minimum number of operations required to make two numbers equal.\n    \"\"\"\n    # Calculate the absolute difference between A and B\n    diff = abs(A - B)\n    \n    # The minimum number of operations is the minimum of the absolute difference and the sum of the absolute differences of A and B\n    return min(diff, sum(abs(A - B)))\n\n# Example usage:\nprint(min_Operations(10, 20))  # Output: 6"}
{"id": "208_0", "code": "def extract_min_max(test_tup, K):\n    \"\"\"\n    Extract the maximum and minimum k elements from a tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n        K (int): The number of elements to extract.\n\n    Returns:\n        tuple: A tuple containing the maximum and minimum k elements.\n    \"\"\"\n    # Check if K is greater than the length of the tuple\n    if K > len(test_tup):\n        raise ValueError(\"K cannot be greater than the length of the tuple\")\n\n    # Extract the k elements\n    k_elements = test_tup[:K]\n\n    # Extract the maximum and minimum k elements\n    max_k_element = max(k_elements)\n    min_k_element = min(k_elements)\n\n    return max_k_element, min_k_element"}
{"id": "209_0", "code": "def replace_max_specialchar(text, n):\n    \"\"\"\n    Replace maximum n occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        text (str): The input text.\n        n (int): The maximum number of replacements.\n\n    Returns:\n        str: The modified text with maximum n replacements.\n    \"\"\"\n    # Initialize counters for spaces, commas, and dots\n    space_count = 0\n    comma_count = 0\n    dot_count = 0\n\n    # Initialize the result string\n    result = \"\"\n\n    # Iterate over each character in the input text\n    for char in text:\n        # Check if the character is a space, comma, or dot\n        if char in [' ', ',', '.']:\n            # If it is, increment the corresponding counter\n            if char == ' ':\n                space_count += 1\n            elif char == ',':\n                comma_count += 1\n            elif char == '.':\n                dot_count += 1\n            # If the counter exceeds n, replace the character with a colon\n            if space_count > n or comma_count > n or dot_count > n:\n                result += ':'\n                space_count = 0\n                comma_count = 0\n                dot_count = 0\n        # If the character is not a space, comma, or dot, add it to the result string\n        else:\n            result += char\n\n    # If the result string is not empty, add a colon at the end\n    if result:\n        result += ':'\n\n    return result"}
{"id": "210_0", "code": "def first_even(nums):\n    \"\"\"\n    This function finds the first even number in a given list of numbers.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The first even number in the list. If no even number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"id": "211_0", "code": "def check_type(test_tuple):\n    \"\"\"\n    Checks if all elements in the tuple have the same data type.\n\n    Args:\n        test_tuple (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    # Get the data type of the first element\n    data_type = type(test_tuple[0])\n    \n    # Iterate over the rest of the elements\n    for element in test_tuple[1:]:\n        # If the data type of the current element is different from the first element, return False\n        if type(element) != data_type:\n            return False\n    \n    # If the function hasn't returned False, all elements have the same data type\n    return True"}
{"id": "212_0", "code": "def is_majority(arr, n, x):\n    # Check if the array is empty\n    if n == 0:\n        return False\n\n    # Check if the array is sorted\n    if arr != sorted(arr):\n        return False\n\n    # Find the majority element\n    count = 0\n    for i in range(n):\n        if arr[i] == x:\n            count += 1\n        if count > n // 2:\n            break\n\n    # Check if the majority element is the actual majority element\n    return arr.count(x) == n // 2"}
{"id": "213_0", "code": "def count_Set_Bits(n):\n    \"\"\"\n    Counts the number of set bits in a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number of set bits in the input number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"id": "214_0", "code": "def find_Min(arr, low, high):\n    if low == high:\n        return arr[low]\n    else:\n        mid = (low + high) // 2\n        if arr[mid] > arr[high]:\n            return find_Min(arr, low, mid - 1)\n        else:\n            return find_Min(arr, mid + 1, high)"}
{"id": "215_0", "code": "def odd_values_string(str):\n    \"\"\"\n    This function removes the characters which have odd index values of a given string.\n\n    Parameters:\n    str (str): The input string.\n\n    Returns:\n    str: The string with characters having odd index values removed.\n    \"\"\"\n    return ''.join([c for i, c in enumerate(str) if i % 2 == 0])"}
{"id": "216_0", "code": "def min_of_three(a, b, c):\n    return min(a, b, c)"}
{"id": "217_0", "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    \"\"\"\n    Checks whether all bits are set in the given range.\n\n    Args:\n        n (int): The number of bits.\n        l (int): The lower bound of the range (inclusive).\n        r (int): The upper bound of the range (inclusive).\n\n    Returns:\n        bool: True if all bits are set in the given range, False otherwise.\n    \"\"\"\n    # Calculate the number of bits in the range\n    num_bits_in_range = r - l + 1\n\n    # Check if all bits are set in the range\n    return (num_bits_in_range & (num_bits_in_range - 1) == 0)"}
{"id": "218_0", "code": "def re_arrange_array(arr, n):\n    # Separate negative and positive numbers\n    negative = [x for x in arr if x < 0]\n    positive = [x for x in arr if x >= 0]\n    \n    # Combine the two lists\n    result = negative + positive\n    \n    # Return the result\n    return result"}
{"id": "219_0", "code": "def replace_blank(str1, char):\n    \"\"\"\n    Replace blank spaces in a string with any character.\n\n    Args:\n        str1 (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return str1.replace(' ', char)"}
{"id": "220_0", "code": "def max_sum(tri, n):\n    \"\"\"\n    This function calculates the maximum sum of a right triangle with n sides.\n\n    Parameters:\n    tri (list): A list of integers representing the sides of the right triangle.\n    n (int): The number of sides of the right triangle.\n\n    Returns:\n    int: The maximum sum of the right triangle.\n    \"\"\"\n    # Sort the sides of the triangle in ascending order\n    tri.sort()\n\n    # Initialize the maximum sum and the current sum\n    max_sum = tri[0]\n    current_sum = tri[0]\n\n    # Iterate over the sides of the triangle\n    for i in range(1, n):\n        # Calculate the sum of the current side and the previous side\n        current_sum += tri[i]\n\n        # Update the maximum sum if the current sum is greater\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"}
{"id": "221_0", "code": "def larg_nnum(list1, n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n\n    Args:\n        list1 (list): The input list.\n        n (int): The number of largest items to return.\n\n    Returns:\n        list: A list of the n largest items in the input list.\n    \"\"\"\n    # Sort the list in descending order\n    sorted_list = sorted(list1, reverse=True)\n    \n    # Return the n largest items\n    return sorted_list[:n]"}
{"id": "222_0", "code": "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    # Calculate the lateral surface area using the formula: 2 * pi * r * h\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n\n# Example usage:\nr = 5  # radius of the cylinder\nh = 10  # height of the cylinder\nprint(lateralsuface_cylinder(r, h))  # Output: 314.1592653589793"}
{"id": "223_0", "code": "def volume_cube(length):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Parameters:\n    length (float): The length of the cube.\n\n    Returns:\n    float: The volume of the cube.\n    \"\"\"\n    return length ** 3"}
{"id": "224_0", "code": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The number with all even bits set.\n    \"\"\"\n    # Initialize the result with the input number\n    result = n\n\n    # Loop through each bit in the number\n    while n:\n        # Check if the current bit is even\n        if n & 1:\n            # If the bit is even, set it to 1\n            result |= 1\n        else:\n            # If the bit is odd, set it to 0\n            result &= ~1\n        # Right shift the number by 1 bit\n        n >>= 1\n\n    return result"}
{"id": "225_0", "code": "def No_of_Triangle(N,K):\n    # Initialize a list to store the number of triangles for each sub-triangle\n    dp = [0]*(N+1)\n    dp[0] = 1\n    for i in range(1,N+1):\n        for j in range(1,i):\n            dp[i] += dp[i-j]*dp[j]\n    return dp[N]"}
{"id": "226_0", "code": "def check_occurences(test_list):\n    \"\"\"\n    This function checks the occurrences of records which occur similar times in the given tuples.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains a record and its occurrence time.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a record and its most frequent occurrence time.\n    \"\"\"\n    # Create a dictionary to store the occurrence count of each record\n    occurrence_count = {}\n    # Create a dictionary to store the most frequent occurrence time of each record\n    most_frequent_occurrence = {}\n\n    # Iterate over each tuple in the test list\n    for record, occurrence_time in test_list:\n        # If the record is not in the occurrence_count dictionary, add it with a count of 1\n        if record not in occurrence_count:\n            occurrence_count[record] = 1\n        # If the record is already in the occurrence_count dictionary, increment its count\n        else:\n            occurrence_count[record] += 1\n\n        # If the record is not in the most_frequent_occurrence dictionary, add it with its current occurrence time\n        if record not in most_frequent_occurrence:\n            most_frequent_occurrence[record] = occurrence_time\n        # If the record is already in the most_frequent_occurrence dictionary, update its occurrence time if the current time is more frequent\n        else:\n            if occurrence_time > most_frequent_occurrence[record]:\n                most_frequent_occurrence[record] = occurrence_time\n\n    # Create a list to store the tuples with the most frequent occurrence time\n    result = []\n    # Iterate over each record in the most_frequent_occurrence dictionary\n    for record, occurrence_time in most_frequent_occurrence.items():\n        # Append a tuple containing the record and its most frequent occurrence time to the result list\n        result.append((record, occurrence_time))\n\n    # Return the result list\n    return result"}
{"id": "227_0", "code": "def number_of_substrings(str):\n    n = len(str)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        if str[i] == str[i - 1]:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = 1\n    return sum(dp)"}
{"id": "228_0", "code": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function generates all possible sequences of length n\n    where each element is greater than or equal to twice of the previous element\n    but less than or equal to m.\n\n    Args:\n        m (int): The upper limit of the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n    # Initialize a list to store the number of sequences for each length\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: there is one way to have a sequence of length 0 (i.e., an empty sequence)\n\n    # Iterate over each length from 1 to n\n    for i in range(1, n + 1):\n        # For each length, iterate over each possible value of the current element\n        for j in range(1, min(i, m) + 1):\n            # If the current element is greater than or equal to twice of the previous element\n            if j * 2 <= i:\n                # Add the number of sequences for the previous length to the current length\n                dp[i] += dp[i - j]\n\n    # Return the total number of sequences\n    return dp[n]"}
{"id": "229_0", "code": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the list with another list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element with.\n\n    Returns:\n        list: The modified list with the last element replaced.\n    \"\"\"\n    # Check if list1 is empty\n    if not list1:\n        return list2\n    # Check if list2 is empty\n    if not list2:\n        return list1\n    # Get the last element of list1\n    last_element = list1[-1]\n    # Replace the last element with the last element of list2\n    modified_list = list1[:-1] + [last_element] + list2\n    return modified_list"}
{"id": "230_0", "code": "import numpy as np\n\ndef array_3d(m,n,o):\n    # Create a 3D array with zeros\n    arr = np.zeros((m,n,o))\n    \n    # Fill the array with '*'\n    arr[:] = '*'\n    \n    return arr"}
{"id": "231_0", "code": "def count_charac(str1):\n    return len(str1)"}
{"id": "232_0", "code": "def sort_on_occurence(lst):\n    # Sort the list based on the occurrence of first element of tuples\n    return sorted(lst, key=lambda x: x[0], reverse=True)"}
{"id": "233_0", "code": "import math\n\ndef next_Perfect_Square(N):\n    \"\"\"\n    Find the next perfect square greater than a given number.\n\n    Args:\n        N (int): The given number.\n\n    Returns:\n        int: The next perfect square greater than N.\n    \"\"\"\n    # Calculate the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # Calculate the next perfect square\n    next_perfect_square = int(sqrt_N + 1) ** 2\n    \n    return next_perfect_square\n\n# Example usage:\nN = 16\nprint(next_Perfect_Square(N))  # Output: 25"}
{"id": "234_0", "code": "def max_sum(arr, n):\n    \"\"\"\n    This function calculates the maximum sum of bi-tonic sub-sequence for the given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The maximum sum of bi-tonic sub-sequence.\n    \"\"\"\n    # Initialize a 2D array to store the maximum sum of bi-tonic sub-sequence.\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first row and column of the 2D array.\n    for i in range(n):\n        dp[i][i] = arr[i]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + arr[j]\n\n    # Fill the rest of the 2D array.\n    for length in range(1, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = max(dp[i][j-1], dp[i+1][j], dp[i][j-1] + arr[j])\n\n    # The maximum sum of bi-tonic sub-sequence is stored in the last cell of the 2D array.\n    return dp[n-1][n-1]"}
{"id": "235_0", "code": "import math\n\ndef babylonian_squareroot(number):\n    \"\"\"\n    Compute the square root of a number using the Babylonian method.\n\n    Args:\n        number (float): The number for which to compute the square root.\n\n    Returns:\n        float: The square root of the input number.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot compute square root of negative number\")\n\n    # Initialize the first guess\n    guess = number / 2.0\n\n    # Repeat the process until the guess is good enough\n    while True:\n        better_guess = (guess + number / guess) / 2.0\n        if abs(guess - better_guess) < 1e-9:\n            return better_guess\n        guess = better_guess\n\n# Example usage:\nprint(babylonian_squareroot(16))  # Output: 4.0\nprint(babylonian_squareroot(25))  # Output: 5.0"}
{"id": "236_0", "code": "def lps(str):\n    n = len(str)\n    lps = [0] * n\n    i, j = 0, 1\n\n    while i < n:\n        if str[i] == str[j]:\n            lps[i] = j + 1\n            i += 1\n            j += 1\n        elif j == 0:\n            i += 1\n        else:\n            j = lps[j - 1]\n    return lps"}
{"id": "237_0", "code": "def harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1.\n\n    Args:\n        n (int): The number of terms in the harmonic series.\n\n    Returns:\n        float: The harmonic sum of n-1.\n    \"\"\"\n    harmonic_sum = 0\n    for i in range(1, n):\n        harmonic_sum += 1 / i\n    return harmonic_sum"}
{"id": "238_0", "code": "def intersection_array(array_nums1, array_nums2):\n    return list(set(array_nums1) & set(array_nums2))"}
{"id": "239_0", "code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        x (any): The element to be searched.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(x)"}
{"id": "240_0", "code": "def insert_element(list, element):\n    \"\"\"\n    Inserts an element before each element of a list.\n\n    Args:\n        list (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The modified list with the element inserted before each element.\n    \"\"\"\n    # Check if the input list is empty\n    if not list:\n        return [element]  # Return a list containing the element\n    # Check if the input list is not empty\n    else:\n        # Create a new list with the element inserted before each element\n        new_list = [element] + list\n        return new_list"}
{"id": "241_0", "code": "import cmath\nimport math\n\ndef convert(numbers):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Parameters:\n    numbers (list): A list of complex numbers.\n\n    Returns:\n    list: A list of tuples containing the magnitude and angle of each complex number in polar coordinates.\n    \"\"\"\n    polar_coordinates = []\n    for num in numbers:\n        # Calculate the magnitude (r) and angle (theta) of the complex number\n        r = math.sqrt(num.real**2 + num.imag**2)\n        theta = math.atan2(num.imag, num.real)\n        \n        # Append the polar coordinates to the list\n        polar_coordinates.append((r, theta))\n    \n    return polar_coordinates\n\n# Example usage:\nnumbers = [1+2j, 3-4j, 5+6j]\npolar_coords = convert(numbers)\nprint(polar_coords)"}
{"id": "242_0", "code": "def count_integer(list1):\n    count = 0\n    for num in list1:\n        if isinstance(num, int):\n            count += 1\n    return count"}
{"id": "243_0", "code": "def words_ae(text):\n    \"\"\"\n    Find all words starting with 'a' or 'e' in a given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of words starting with 'a' or 'e'.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if word.lower().startswith(('a', 'e'))]"}
{"id": "244_0", "code": "import itertools\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Generate all combinations of colours with repetitions.\n\n    Parameters:\n    l (list): List of colours.\n    n (int): Number of colours to choose.\n\n    Returns:\n    list: List of combinations with repetitions.\n    \"\"\"\n    # Check if the number of colours to choose is greater than the number of colours\n    if n > len(l):\n        raise ValueError(\"Number of colours to choose cannot be greater than the number of colours\")\n\n    # Generate all combinations with repetitions\n    combinations = list(itertools.product(l, repeat=n))\n\n    return combinations\n\n# Example usage:\nl = [\"red\", \"green\", \"blue\"]\nn = 2\ncombinations = combinations_colors(l, n)\nprint(combinations)"}
{"id": "245_0", "code": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n (int): The upper limit for the prime numbers.\n\n    Returns:\n        int: The number of prime numbers less than n.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Checks if a number is prime.\n\n        Args:\n            num (int): The number to check.\n\n        Returns:\n            bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count"}
{"id": "246_0", "code": "def swap_numbers(a, b):\n    \"\"\"\n    Swap two numbers.\n\n    Args:\n        a (int): The first number.\n        b (int): The second number.\n\n    Returns:\n        tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    # Swap the values of a and b\n    a, b = b, a\n    return a, b"}
{"id": "247_0", "code": "def count_odd(array_nums):\n    return sum(1 for num in array_nums if num % 2 != 0)"}
{"id": "248_0", "code": "def maximize_elements(test_tup1, test_tup2):\n    # Sort the tuples in descending order\n    test_tup1 = sorted(test_tup1, reverse=True)\n    test_tup2 = sorted(test_tup2, reverse=True)\n\n    # Combine the tuples\n    combined_tup = test_tup1 + test_tup2\n\n    # Find the maximum value\n    max_val = max(combined_tup)\n\n    # Return the maximum value\n    return max_val"}
{"id": "249_0", "code": "import random\nimport math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n\n# Example usage:\nprint(newman_prime(10))  # Output: 541"}
{"id": "250_0", "code": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function performs mathematical division operation across the given tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple for the division operation.\n        test_tup2 (tuple): The second tuple for the division operation.\n\n    Returns:\n        tuple: A tuple containing the result of the division operation and the remainder.\n    \"\"\"\n    # Perform the division operation\n    result = test_tup1[0] / test_tup2[0]\n    \n    # Calculate the remainder\n    remainder = result % test_tup2[0]\n    \n    # Return the result and the remainder as a tuple\n    return result, remainder"}
{"id": "251_0", "code": "def split_two_parts(list1, L):\n    \"\"\"\n    Splits a given list into two parts where the length of the first part of the list is given.\n\n    Args:\n        list1 (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing two lists. The first list contains the first part of the input list,\n               and the second list contains the second part of the input list.\n    \"\"\"\n    # Check if L is greater than the length of the list\n    if L > len(list1):\n        raise ValueError(\"L cannot be greater than the length of the list\")\n\n    # Calculate the length of the first part\n    first_part_length = len(list1) - L\n\n    # Split the list into two parts\n    first_part = list1[:first_part_length]\n    second_part = list1[first_part_length:]\n\n    return first_part, second_part"}
{"id": "252_0", "code": "def merge_dict(d1, d2):\n    \"\"\"\n    Merge two dictionaries into one.\n\n    Args:\n        d1 (dict): The first dictionary to merge.\n        d2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from both input dictionaries.\n    \"\"\"\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n\n    # Iterate over the key-value pairs in the first dictionary\n    for key, value in d1.items():\n        # Add each key-value pair to the merged dictionary\n        merged_dict[key] = value\n\n    # Iterate over the key-value pairs in the second dictionary\n    for key, value in d2.items():\n        # Add each key-value pair to the merged dictionary, overwriting any existing key\n        merged_dict[key] = value\n\n    # Return the merged dictionary\n    return merged_dict"}
{"id": "253_0", "code": "def dog_age(h_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Args:\n        h_age (int): The dog's height in inches.\n\n    Returns:\n        int: The dog's age in dog's years.\n    \"\"\"\n    # Convert height from inches to feet\n    h_feet = h_age / 12\n\n    # Calculate dog's age in years\n    h_years = h_feet / 5\n\n    return h_years"}
{"id": "254_0", "code": "def list_split(S, step):\n    \"\"\"\n    Splits a list into chunks of size step.\n\n    Args:\n        S (list): The input list to be split.\n        step (int): The size of each chunk.\n\n    Returns:\n        list: A list of chunks.\n    \"\"\"\n    return [S[i:i+step] for i in range(0, len(S), step)]"}
{"id": "255_0", "code": "def lateralsurface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): The length of the cube's edge.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # Calculate the lateral surface area of the cube\n    lateral_surface_area = 4 * (l ** 2)\n    return lateral_surface_area"}
{"id": "256_0", "code": "def square_Sum(n):\n    \"\"\"\n    Calculate the sum of squares of the first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to sum.\n\n    Returns:\n        int: The sum of squares of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum of squares\n    sum_of_squares = 0\n\n    # Loop through the first n odd natural numbers\n    for i in range(1, n + 1):\n        # Check if the number is odd\n        if i % 2 != 0:\n            # Add the square of the number to the sum\n            sum_of_squares += i ** 2\n\n    # Return the sum of squares\n    return sum_of_squares"}
{"id": "257_0", "code": "def find_star_num(n):\n    \"\"\"\n    This function generates the nth star number.\n    \n    Parameters:\n    n (int): The position of the star number to be generated.\n    \n    Returns:\n    int: The nth star number.\n    \"\"\"\n    # Initialize a list to store the star numbers\n    star_numbers = [1]\n    \n    # Generate the star numbers\n    while len(star_numbers) < n:\n        # Calculate the next star number\n        next_star = star_numbers[-1] * 2\n        # Append the next star number to the list\n        star_numbers.append(next_star)\n    \n    # Return the nth star number\n    return star_numbers[-1]"}
{"id": "258_0", "code": "def ascii_value(k):\n    return ord(k)"}
{"id": "259_0", "code": "def sum_even_and_even_index(arr, n):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in a given array.\n\n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The length of the input list.\n\n    Returns:\n    int: The sum of even numbers at even positions.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the array with index and value\n    for i, num in enumerate(arr):\n        # Check if the index is even and the number is even\n        if i % 2 == 0 and num % 2 == 0:\n            # Add the number to the sum\n            total_sum += num\n    \n    # Return the sum\n    return total_sum"}
{"id": "260_0", "code": "def even_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of fifth power of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers.\n\n    Returns:\n        int: The sum of fifth power of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable\n    total_sum = 0\n\n    # Loop through the first n even natural numbers\n    for i in range(2, n + 1, 2):\n        # Calculate the fifth power of the current number\n        fifth_power = i ** 5\n        # Add the fifth power to the total sum\n        total_sum += fifth_power\n\n    # Return the total sum\n    return total_sum"}
{"id": "261_0", "code": "def rear_extract(test_list):\n    \"\"\"\n    This function extracts the rear element from a list of tuples.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        tuple: The rear element of the list of tuples.\n    \"\"\"\n    # Check if the list is empty\n    if not test_list:\n        return None\n\n    # Check if the list has only one element\n    if len(test_list) == 1:\n        return test_list[0]\n\n    # Extract the last element of the list\n    last_element = test_list[-1]\n\n    # Return the last element\n    return last_element"}
{"id": "262_0", "code": "def substract_elements(test_tup1, test_tup2):\n    \"\"\"\n    This function subtracts the contents of one tuple with corresponding index of other tuple.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: The result of subtraction.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the tuples\n    for i in range(len(test_tup1)):\n        # Subtract the corresponding elements and append to the result list\n        result.append(test_tup1[i] - test_tup2[i])\n\n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "263_0", "code": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculate the sum of even index binomial coefficients.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The sum of even index binomial coefficients.\n    \"\"\"\n    # Initialize the sum\n    total = 0\n\n    # Iterate over the range from 0 to n\n    for i in range(n + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Calculate the binomial coefficient\n            total += math.comb(i, i // 2)\n\n    return total"}
{"id": "264_0", "code": "def get_Position(a,n,m):\n    # Check if the array is empty\n    if n == 0:\n        return 0\n    # Check if the array is not empty and m is greater than n\n    if m > n:\n        return n\n    # Check if the array is not empty and m is equal to n\n    if m == n:\n        return n - 1\n    # Check if the array is not empty and m is less than n\n    if m < n:\n        return n - m\n    # Check if the array is empty\n    if n == 0:\n        return 0\n    # Check if the array is not empty and m is equal to n\n    if m == n:\n        return n - 1\n    # Check if the array is not empty and m is less than n\n    if m < n:\n        return n - m\n    # Check if the array is not empty and m is greater than n\n    if m > n:\n        return n\n    # If none of the above conditions are met, return -1\n    return -1"}
{"id": "265_0", "code": "import math\n\ndef volume_cylinder(r, h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Check if the radius is negative\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    # Check if the height is negative\n    if h < 0:\n        raise ValueError(\"Height cannot be negative\")\n\n    # Calculate the volume using the formula pi * r^2 * h\n    volume = math.pi * (r ** 2) * h\n\n    return volume\n\n# Example usage:\nprint(volume_cylinder(5, 10))  # Output: 785.3981633974483"}
{"id": "266_0", "code": "def dict_filter(dict, n):\n    \"\"\"\n    Filter a dictionary based on values.\n\n    Parameters:\n    dict (dict): The dictionary to be filtered.\n    n (int): The value to filter by.\n\n    Returns:\n    dict: The filtered dictionary.\n    \"\"\"\n    # Check if the input is a dictionary\n    if not isinstance(dict, dict):\n        raise TypeError(\"Input must be a dictionary\")\n\n    # Check if the value to filter by is an integer\n    if not isinstance(n, int):\n        raise TypeError(\"Value to filter by must be an integer\")\n\n    # Filter the dictionary based on the value\n    filtered_dict = {key: value for key, value in dict.items() if value == n}\n\n    return filtered_dict"}
{"id": "267_0", "code": "def count_first_elements(test_tup):\n    \"\"\"\n    Counts the number of elements before the first occurrence of a given element in a tuple.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        int: The number of elements before the first occurrence of the given element.\n    \"\"\"\n    # Initialize the count and the index of the first occurrence\n    count = 0\n    first_occurrence_index = float('inf')\n\n    # Iterate over the tuple\n    for i, element in enumerate(test_tup):\n        # If the current element is the first occurrence, update the count and index\n        if element == test_tup[0]:\n            count = i\n            first_occurrence_index = i\n        # If the current element is not the first occurrence, break the loop\n        else:\n            break\n\n    # Return the count of elements before the first occurrence\n    return count"}
{"id": "268_0", "code": "def is_num_decagonal(n):\n    return n**2 == 6*n + 1"}
{"id": "269_0", "code": "def sequential_search(dlist, item):\n    \"\"\"\n    Searches for an element in a given list using sequential search.\n\n    Args:\n        dlist (list): The list to search in.\n        item: The element to search for.\n\n    Returns:\n        int: The index of the item if found, -1 otherwise.\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1"}
{"id": "270_0", "code": "def all_unique(test_list):\n    \"\"\"\n    Checks if the elements of a given list are unique or not.\n\n    Args:\n        test_list (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(test_list) == len(set(test_list))"}
{"id": "271_0", "code": "def sub_list(nums1, nums2):\n    return list(map(lambda x: x if x < 0 else x if x > 0 else 0, nums1 + nums2))"}
{"id": "272_0", "code": "def validate(n):\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a dictionary to store the frequency of each digit\n    freq_dict = {}\n    \n    # Iterate over each character (digit) in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[digit] = 1\n    \n    # Iterate over the dictionary to check if each frequency is less than or equal to the digit itself\n    for digit, freq in freq_dict.items():\n        if freq > digit:\n            return False\n    \n    # If no invalid frequencies are found, return True\n    return True"}
{"id": "273_0", "code": "def check_element(list, element):\n    \"\"\"\n    Checks whether all items of a list are equal to a given string.\n\n    Args:\n        list (list): The list to be checked.\n        element (str): The string to be compared with the list items.\n\n    Returns:\n        bool: True if all items of the list are equal to the given string, False otherwise.\n    \"\"\"\n    return all(item == element for item in list)"}
{"id": "274_0", "code": "def text_match_two_three(text):\n    \"\"\"\n    Generate a string that matches a given text.\n\n    Args:\n        text (str): The input text.\n\n    Returns:\n        str: A generated string that matches the input text.\n    \"\"\"\n    # Check if the input text has an 'a' followed by two to three 'b's\n    if text.startswith('ab') and len(text) > 2 and len(text) > 3:\n        # Generate the matched string\n        matched_text = 'a' * 2 + 'b' * 2 + 'b' * 3\n        return matched_text\n    else:\n        return 'Invalid input text'"}
{"id": "275_0", "code": "def max_sub_array_sum_repeated(a, n, k):\n    \"\"\"\n    This function finds the largest sum of contiguous array in the modified array \n    which is formed by repeating the given array k times.\n\n    Parameters:\n    a (list): The input array\n    n (int): The length of the input array\n    k (int): The number of times the array is repeated\n\n    Returns:\n    int: The largest sum of contiguous array in the modified array\n    \"\"\"\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Repeat the array k times\n    for i in range(k):\n        # Initialize the current sum\n        current_sum = 0\n        # Add the elements of the array to the current sum\n        for j in range(n):\n            current_sum += a[j]\n\n        # Update the maximum sum\n        max_sum = max(max_sum, current_sum)\n\n    # Return the maximum sum\n    return max_sum"}
{"id": "276_0", "code": "def square_Sum(n):\n    \"\"\"\n    Calculate the sum of squares of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to sum.\n\n    Returns:\n        int: The sum of squares of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum of squares\n    total = 0\n\n    # Loop through the first n even numbers\n    for i in range(2, n + 1, 2):\n        # Calculate the square of the current number\n        square = i ** 2\n        # Add the square to the total\n        total += square\n\n    # Return the total sum of squares\n    return total"}
{"id": "277_0", "code": "def modular_inverse(arr, N, P):\n    \"\"\"\n    This function calculates the modular inverse of each element in the array under the given prime number P.\n\n    Parameters:\n    arr (list): The input array of integers.\n    N (int): The modulus.\n    P (int): The prime number.\n\n    Returns:\n    list: A list of integers representing the modular inverses of the input array elements under the given prime number P.\n    \"\"\"\n    # Initialize an empty list to store the modular inverses\n    inverses = []\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # Calculate the modular inverse using the extended Euclidean algorithm\n        # The extended Euclidean algorithm returns the gcd of the two numbers and the coefficients of BÃ©zout's identity\n        # We use the coefficients to calculate the modular inverse\n        inverse = pow(num, -1, P)\n        \n        # Append the modular inverse to the list\n        inverses.append(inverse)\n    \n    # Return the list of modular inverses\n    return inverses"}
{"id": "278_0", "code": "def odd_Days(N):\n    # Define the number of days in a week\n    days_in_week = 7\n    \n    # Initialize the count of odd days\n    odd_days_count = 0\n    \n    # Iterate over each month in the year\n    for month in range(1, N + 1):\n        # Get the number of days in the current month\n        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1]\n        \n        # Check if the month is a leap year\n        if month in [4, 6, 9, 11]:\n            days_in_month[1] = 29\n        \n        # Calculate the number of odd days in the current month\n        odd_days_in_month = sum(1 for day in days_in_month if day % 2 != 0)\n        \n        # Add the number of odd days in the current month to the total count\n        odd_days_count += odd_days_in_month\n    \n    # Return the total count of odd days\n    return odd_days_count"}
{"id": "279_0", "code": "def max_length(list1):\n    \"\"\"\n    This function generates a list of lists with maximum length.\n    \n    Parameters:\n    list1 (list): The input list of lists.\n    \n    Returns:\n    list: A list of lists with maximum length.\n    \"\"\"\n    # Get the maximum length of the input list\n    max_len = max(len(sublist) for sublist in list1)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in list1:\n        # Append the sublist with the maximum length to the result\n        result.append(sublist[:max_len])\n    \n    return result"}
{"id": "280_0", "code": "def count_no_of_ways(n, k):\n    \"\"\"\n    This function calculates the number of ways of painting the fence with at most 2 adjacent posts having the same color.\n\n    Parameters:\n    n (int): The number of posts on the fence.\n    k (int): The number of colors available.\n\n    Returns:\n    int: The number of ways of painting the fence.\n    \"\"\"\n    # Base cases\n    if n == 1:\n        return k\n    if n == 2:\n        return k + 1\n\n    # Initialize a list to store the number of ways for each number of posts\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k + 1\n\n    # Fill up the dp table\n    for i in range(3, n + 1):\n        # If the current post is the same color as the previous post, \n        # the number of ways is the same as the previous post\n        if i == 3:\n            dp[i] = dp[i - 1]\n        # If the current post is the same color as the previous post, \n        # the number of ways is the same as the previous post\n        elif i == 4:\n            dp[i] = dp[i - 1] + dp[i - 2]\n        # If the current post is different from the previous post, \n        # the number of ways is the sum of the number of ways for the previous post and the previous post minus one\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n    # The number of ways for n posts is stored in dp[n]\n    return dp[n]"}
{"id": "281_0", "code": "def find(n, m):\n    if n == 0:\n        return \"Error: Division by zero is not allowed\"\n    elif m == 0:\n        return \"Error: Division by zero is not allowed\"\n    elif n < 0 and m > 0:\n        return \"Error: Division by zero is not allowed\"\n    elif n > 0 and m < 0:\n        return \"Error: Division by zero is not allowed\"\n    elif n == 0 and m == 0:\n        return 0\n    elif n == 0 and m != 0:\n        return float('inf')\n    elif n != 0 and m == 0:\n        return float('-inf')\n    elif n == 0 and m != 0:\n        return 0\n    elif n > 0 and m > 0:\n        return n / m\n    elif n > 0 and m < 0:\n        return n / m\n    elif n < 0 and m > 0:\n        return -n / m\n    elif n < 0 and m < 0:\n        return -n / m\n    elif n == 0 and m == 0:\n        return 0\n    elif n == 0 and m != 0:\n        return float('inf')\n    elif n != 0 and m == 0:\n        return float('-inf')\n    elif n == 0 and m != 0:\n        return 0\n    elif n > 0 and m > 0:\n        return n / m\n    elif n > 0 and m < 0:\n        return n / m\n    elif n < 0 and m > 0:\n        return -n / m\n    elif n < 0 and m < 0:\n        return -n / m"}
{"id": "282_0", "code": "def otherside_rightangle(w,h):\n    # Calculate the third side of a right angled triangle\n    # using the Pythagorean theorem\n    a = w**2 + h**2\n    b = 2 * w * h\n    c = w**2 + h**2\n    return a,b,c"}
{"id": "283_0", "code": "def max_val(listval):\n    \"\"\"\n    This function finds the maximum value in a given heterogeneous list.\n\n    Args:\n        listval (list): A heterogeneous list containing different data types.\n\n    Returns:\n        The maximum value in the list.\n    \"\"\"\n    # Initialize max_val with the first element of the list\n    max_val = listval[0]\n    \n    # Iterate over the rest of the list\n    for val in listval[1:]:\n        # If the current value is greater than max_val, update max_val\n        if val > max_val:\n            max_val = val\n    \n    # Return the maximum value\n    return max_val"}
{"id": "284_0", "code": "def sum_div(number):\n    \"\"\"\n    Returns the sum of all divisors of a number.\n\n    Args:\n        number (int): The number for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of all divisors of the number.\n    \"\"\"\n    # Initialize the sum of divisors to 0\n    sum_divisors = 0\n\n    # Check if the number is less than 2\n    if number < 2:\n        return sum_divisors\n\n    # Iterate over all numbers from 1 to the square root of the number\n    for i in range(1, int(number ** 0.5) + 1):\n        # Check if the current number is a divisor of the number\n        if number % i == 0:\n            # If it is, add it to the sum of divisors\n            sum_divisors += i\n            # If it's not the square root, add the corresponding divisor as well\n            if i != number // i:\n                sum_divisors += number // i\n\n    return sum_divisors"}
{"id": "285_0", "code": "def get_Inv_Count(arr, n):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    Args:\n        arr (list): The input array.\n        n (int): The size of the input array.\n\n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    # Initialize the inversion count to 0\n    inv_count = 0\n\n    # Iterate over the array from the first element to the second last element\n    for i in range(n - 1):\n        # Iterate over the array from the first element to the second last element\n        for j in range(i + 1, n):\n            # Check if the current element is greater than the next element\n            if arr[i] > arr[j]:\n                # Increment the inversion count\n                inv_count += 1\n\n    # Return the inversion count\n    return inv_count"}
{"id": "286_0", "code": "def flatten_list(list1):\n    \"\"\"\n    This function takes a nested list as input and returns a flattened list.\n\n    Args:\n        list1 (list): The input list to be flattened.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    flattened_list = []\n    for item in list1:\n        if isinstance(item, list):\n            # If the item is a list, recursively call the function on it\n            flattened_list.extend(flatten_list(item))\n        else:\n            # If the item is not a list, append it to the flattened list\n            flattened_list.append(item)\n    return flattened_list"}
{"id": "287_0", "code": "def intersection_nested_lists(l1, l2):\n    \"\"\"\n    This function finds the nested list elements which are present in another list.\n\n    Args:\n        l1 (list): The list to search for nested elements.\n        l2 (list): The list to search in.\n\n    Returns:\n        list: A list of nested list elements present in l2.\n    \"\"\"\n    result = []\n    for elem in l2:\n        if isinstance(elem, list) and isinstance(l1[0], list):\n            result.extend(intersection_nested_lists(elem, l1[0]))\n        elif elem in l1:\n            result.append(elem)\n    return result"}
{"id": "288_0", "code": "def max_aggregate(stdata):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n        stdata (list): A list of tuples.\n\n    Returns:\n        int: The maximum aggregate.\n    \"\"\"\n    # Initialize the maximum aggregate to negative infinity\n    max_ag = float('-inf')\n\n    # Iterate over each tuple in the list\n    for tup in stdata:\n        # Calculate the aggregate for the current tuple\n        aggregate = sum(tup)\n\n        # Update the maximum aggregate if the current aggregate is larger\n        max_ag = max(max_ag, aggregate)\n\n    # Return the maximum aggregate\n    return max_ag"}
{"id": "289_0", "code": "def count_binary_seq(n):\n    \"\"\"\n    This function generates all binary sequences of length 2n and counts the number of sequences \n    where the sum of the first n bits is the same as the sum of the last n bits.\n\n    Parameters:\n    n (int): The length of the binary sequence.\n\n    Returns:\n    int: The count of binary sequences where the sum of the first n bits is the same as the sum of the last n bits.\n    \"\"\"\n    # Initialize a dictionary to store the count of sequences for each sum\n    count_dict = {0: 1}  # Base case: there is one sequence with sum 0 (the empty sequence)\n\n    # Iterate over all possible binary sequences of length 2n\n    for i in range(2**n):\n        # Convert the current sequence to a binary string\n        bin_str = bin(i)[2:].zfill(n)\n\n        # Calculate the sum of the first n bits\n        first_sum = sum(int(bit) for bit in bin_str[:n])\n\n        # Calculate the sum of the last n bits\n        last_sum = sum(int(bit) for bit in bin_str[n:])\n\n        # If the sums are equal, increment the count in the dictionary\n        if first_sum == last_sum:\n            count_dict[first_sum] = count_dict.get(first_sum, 0) + 1\n\n    # Return the count of sequences where the sum of the first n bits is the same as the sum of the last n bits\n    return count_dict.get(0, 0)"}
{"id": "290_0", "code": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n        d (dict): The dictionary to calculate the depth for.\n\n    Returns:\n        int: The depth of the dictionary.\n    \"\"\"\n    if not d:\n        return 0\n    else:\n        return 1 + max(dict_depth(v) for v in d.values())"}
{"id": "291_0", "code": "def set_Bit_Number(n):\n    \"\"\"\n    This function generates the most significant bit number which is also a set bit.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    int: The most significant bit number which is also a set bit.\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    \n    # Loop through each bit in the input integer\n    while n:\n        # Check if the least significant bit is set\n        if n & 1:\n            # If set, add the corresponding bit to the result\n            result |= 1 << (n - 1)\n        # Right shift the input integer by 1\n        n >>= 1\n    \n    # Return the result\n    return result"}
{"id": "292_0", "code": "def solve(a, n):\n    # Initialize a dictionary to store the inversion count of each number\n    inversion_count = {}\n    \n    # Iterate over the array and count the inversion\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                if a[i] in inversion_count:\n                    inversion_count[a[i]] += 1\n                else:\n                    inversion_count[a[i]] = 1\n                if a[j] in inversion_count:\n                    inversion_count[a[j]] += 1\n                else:\n                    inversion_count[a[j]] = 1\n    \n    # Check if the inversion count of two types are same\n    inversion_type1 = inversion_count.get(a[0], 0)\n    inversion_type2 = inversion_count.get(a[1], 0)\n    \n    if inversion_type1 == inversion_type2:\n        return True\n    else:\n        return False"}
{"id": "293_0", "code": "def find_Element(arr, ranges, rotations, index):\n    \"\"\"\n    Find the element at a given index after number of rotations.\n\n    Parameters:\n    arr (list): The input list of elements.\n    ranges (list): The list of ranges to rotate the array.\n    rotations (int): The number of rotations.\n    index (int): The index of the element to find.\n\n    Returns:\n    int: The element at the given index after rotations.\n    \"\"\"\n    # Calculate the effective rotations\n    effective_rotations = rotations % len(arr)\n    \n    # Rotate the array\n    rotated_arr = arr[-effective_rotations:] + arr[:-effective_rotations]\n    \n    # Find the element at the given index\n    element = rotated_arr[index]\n    \n    return element"}
{"id": "294_0", "code": "def start_withp(words):\n    \"\"\"\n    Returns a list of words that start with the letter 'p'.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        list: A list of words that start with the letter 'p'.\n    \"\"\"\n    return [word for word in words if word[0].lower() == 'p']"}
{"id": "295_0", "code": "def max_sum_increasing_subseq(a, n, index, k):\n    \"\"\"\n    This function finds the maximum sum of increasing subsequence from prefix till ith index \n    and also including a given kth element which is after i, i.e., k > i.\n\n    Parameters:\n    a (list): The input list of numbers.\n    n (int): The size of the input list.\n    index (int): The index of the given kth element.\n    k (int): The given kth element.\n\n    Returns:\n    int: The maximum sum of increasing subsequence.\n    \"\"\"\n    # Initialize a list to store the maximum sum of increasing subsequence ending at each index\n    dp = [0] * n\n    dp[0] = a[0]\n    \n    # Initialize the maximum sum of increasing subsequence ending at the first index\n    max_sum = a[0]\n    \n    # Iterate over the list from the second element to the nth element\n    for i in range(1, n):\n        # Initialize the maximum sum of increasing subsequence ending at the current index\n        max_sum = max(max_sum, dp[i - 1] + a[i])\n        \n        # Update the maximum sum of increasing subsequence ending at the current index\n        dp[i] = max_sum\n        \n        # Update the maximum sum of increasing subsequence ending at the previous index\n        max_sum = max(max_sum, dp[i - 1] + a[i])\n    \n    # Return the maximum sum of increasing subsequence ending at the nth index\n    return dp[n - 1]"}
{"id": "296_0", "code": "def colon_tuplex(tuplex,m,n):\n    return tuplex[:m] + \":\" + tuplex[m:n]"}
{"id": "297_0", "code": "def large_product(nums1, nums2, N):\n    \"\"\"\n    Find the specified number of largest products from two given lists.\n\n    Args:\n    nums1 (list): The first list of numbers.\n    nums2 (list): The second list of numbers.\n    N (int): The number of largest products to find.\n\n    Returns:\n    list: A list of the N largest products from the two input lists.\n    \"\"\"\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize an empty list to store the products\n    products = []\n\n    # Iterate over the two lists\n    for num1 in nums1:\n        for num2 in nums2:\n            # Calculate the product and append it to the products list\n            products.append(num1 * num2)\n\n    # Sort the products list in descending order\n    products.sort(reverse=True)\n\n    # Return the N largest products\n    return products[:N]"}
{"id": "298_0", "code": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"id": "299_0", "code": "def string_to_tuple(str1):\n    return tuple(str1)"}
{"id": "300_0", "code": "def set_left_most_unset_bit(n):\n    \"\"\"\n    Sets the left most unset bit in the binary representation of a given integer.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The integer with the left most unset bit set.\n    \"\"\"\n    # Convert the integer to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize the result with the first bit set to 1\n    result = '1' + bin_n\n    \n    # Iterate over the bits from right to left\n    for i in range(len(bin_n) - 1, -1, -1):\n        # If the current bit is 0, set it to 1\n        if bin_n[i] == '0':\n            result = '1' + result\n        # Otherwise, keep the current bit as it is\n        else:\n            result = result[1:]\n    \n    # Convert the result back to an integer\n    return int(result, 2)"}
{"id": "301_0", "code": "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    r (float): The radius of the cone's base.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    # Calculate the volume using the formula V = (1/3)Ï€r^2h\n    volume = (1/3) * math.pi * (r ** 2) * h\n    return volume"}
{"id": "302_0", "code": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i)"}
{"id": "303_0", "code": "def max_sum_rectangular_grid(grid, n):\n    \"\"\"\n    This function calculates the maximum sum of a rectangular grid of dimension 2 x n\n    such that no two chosen numbers are adjacent.\n\n    Parameters:\n    grid (list): A 2D list representing the rectangular grid.\n    n (int): The number of rows in the grid.\n\n    Returns:\n    int: The maximum sum of the rectangular grid.\n    \"\"\"\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n\n    # Iterate over all possible sub-grids of the given grid\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            # Initialize the sum of the current sub-grid as 0\n            sub_sum = 0\n\n            # Iterate over all possible sub-grids of the current sub-grid\n            for k in range(len(grid)):\n                for m in range(len(grid[0])):\n                    # Check if the current sub-grid is not adjacent to the previous sub-grid\n                    if k != i and m != j:\n                        # Add the value of the current sub-grid to the sum\n                        sub_sum += grid[i][j]\n\n            # Update the maximum sum if the sum of the current sub-grid is greater\n            max_sum = max(max_sum, sub_sum)\n\n    # Return the maximum sum\n    return max_sum"}
{"id": "304_0", "code": "def find_Max_Len_Even(str):\n    words = str.split()\n    max_len = 0\n    for word in words:\n        if word[0].lower() in 'aeiou':\n            if len(word) > max_len:\n                max_len = len(word)\n    return max_len"}
{"id": "305_0", "code": "def find_last_occurrence(A, x):\n    \"\"\"\n    Find the index of the last occurrence of a given number in a sorted array.\n\n    Args:\n        A (list): A sorted list of numbers.\n        x (int): The number to find the last occurrence of.\n\n    Returns:\n        int: The index of the last occurrence of x in A. If x is not found, returns -1.\n    \"\"\"\n    low, high = 0, len(A) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            # If x is found, check if it's the last occurrence\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            # If x is not the last occurrence, move the search space to the left half\n            else:\n                high = mid - 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"id": "306_0", "code": "def modified_encode(alist):\n    encoded_list = []\n    for i in range(len(alist)):\n        if alist[i] != 0:\n            encoded_list.append(alist[i])\n            if i < len(alist) - 1:\n                encoded_list.append(alist[i + 1])\n    return encoded_list"}
{"id": "307_0", "code": "def max_volume(s):\n    \"\"\"\n    Calculate the maximum volume of a cuboid with given sum of sides.\n\n    Parameters:\n    s (list): A list of three integers representing the sides of the cuboid.\n\n    Returns:\n    int: The maximum volume of the cuboid.\n    \"\"\"\n    # Sort the sides in descending order\n    s.sort(reverse=True)\n\n    # Calculate the volume\n    volume = s[0] * s[1] * s[2]\n\n    return volume"}
{"id": "308_0", "code": "import re\n\ndef find_long_word(text):\n    # Define the regex pattern\n    pattern = r'\\b\\w{5}\\b'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    # Return the matches\n    return matches"}
{"id": "309_0", "code": "def sum_difference(n):\n    \"\"\"\n    Calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers.\n\n    Returns:\n        int: The difference between the two sums.\n    \"\"\"\n    # Calculate the sum of squared first n natural numbers\n    sum_squared = sum(i**2 for i in range(1, n+1))\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum = sum(i**2 for i in range(1, n+1))\n    \n    # Return the difference between the two sums\n    return squared_sum - sum_squared"}
{"id": "310_0", "code": "def find_demlo(s):\n    \"\"\"\n    This function generates a random number between 1 and 1000.\n    The number is then converted to a string and the first 5 characters are removed.\n    The remaining 5 characters are then converted to an integer and returned.\n    \"\"\"\n    import random\n    num = random.randint(1, 1000)\n    num_str = str(num)\n    return int(num_str[:5])"}
{"id": "311_0", "code": "def position_min(list1):\n    min_val = min(list1)\n    min_index = list1.index(min_val)\n    return [min_index]"}
{"id": "312_0", "code": "def re_arrange(arr, n):\n    \"\"\"\n    Re-arrange the given array in alternating positive and negative items.\n\n    Args:\n        arr (list): The input array.\n        n (int): The number of positive and negative items to alternate.\n\n    Returns:\n        list: The rearranged array.\n    \"\"\"\n    result = []\n    count = 0\n    for i in range(len(arr)):\n        if count < n:\n            result.append(arr[i])\n            count += 1\n        else:\n            result.append(-arr[i])\n    return result"}
{"id": "313_0", "code": "def sum_of_alternates(test_tuple):\n    \"\"\"\n    Extract the sum of alternate chains of tuples.\n\n    Args:\n        test_tuple (tuple): The input tuple to process.\n\n    Returns:\n        int: The sum of alternate chains of tuples.\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n\n    # Iterate over the tuple with index\n    for i, (a, b, c) in enumerate(test_tuple):\n        # If the index is even, add the tuple to the sum\n        if i % 2 == 0:\n            total_sum += (a, b, c)\n\n    return total_sum"}
{"id": "314_0", "code": "def get_Min_Squares(n):\n    \"\"\"\n    Find the minimum number of squares whose sum is equal to a given number.\n\n    Args:\n        n (int): The target sum.\n\n    Returns:\n        int: The minimum number of squares.\n    \"\"\"\n    # Initialize a list to store the minimum number of squares for each sum from 1 to n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0  # Base case: 0 squares needed to get sum 0\n\n    # Iterate over each possible sum from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each possible square size from 1 to the square root of i\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current square size is less than or equal to i\n            if j * j <= i:\n                # Update the minimum number of squares for the current sum\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n\n    # Return the minimum number of squares for the target sum\n    return dp[n]"}
{"id": "315_0", "code": "def most_occurrences(test_list):\n    \"\"\"\n    Returns the word with most occurrences in the given list of strings.\n\n    Args:\n        test_list (list): A list of strings.\n\n    Returns:\n        str: The word with most occurrences.\n    \"\"\"\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    for string in test_list:\n        # Convert the string to lowercase and split it into words\n        words = string.lower().split()\n        # Update the frequency of each word\n        for word in words:\n            if word in word_freq:\n                word_freq[word] += 1\n            else:\n                word_freq[word] = 1\n\n    # Find the word with most occurrences\n    max_freq = max(word_freq.values())\n    most_common_word = [word for word, freq in word_freq.items() if freq == max_freq]\n\n    # Return the word with most occurrences\n    return most_common_word[0]"}
{"id": "316_0", "code": "def check_isosceles(x, y, z):\n    # Check if the triangle is isosceles\n    if x == y or y == z or z == x:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"id": "317_0", "code": "def rotate_left(list1,m,n):\n    # Check if the number of items to be rotated is greater than the length of the list\n    if m > len(list1):\n        return list1\n    # Check if the number of items to be rotated is greater than the length of the list\n    if n > len(list1):\n        return list1\n    # Check if the number of items to be rotated is greater than 0\n    if m < 0 or n < 0:\n        return list1\n    # Rotate the list to the left\n    rotated_list = list1[-m:] + list1[:-m]\n    return rotated_list"}
{"id": "318_0", "code": "def neg_count(lst):\n    \"\"\"\n    Counts the number of negative numbers in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The number of negative numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num < 0)"}
{"id": "319_0", "code": "import re\n\ndef find_char(text):\n    # Define the regex pattern\n    pattern = r'\\b\\w{3,5}\\b'\n    # Find all matches\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "320_0", "code": "def count_unset_bits(n):\n    \"\"\"\n    Counts the number of unset bits in a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number of unset bits in the input number.\n    \"\"\"\n    # Initialize count to 0\n    count = 0\n\n    # Loop through each bit in the number\n    while n:\n        # Check if the least significant bit is 0\n        if n & 1:\n            # If it is, increment the count\n            count += 1\n        # Right shift the number by 1 bit\n        n >>= 1\n\n    # Return the count\n    return count"}
{"id": "321_0", "code": "def char_frequency(str1):\n    \"\"\"\n    This function counts the frequency of each character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    dict: A dictionary where keys are characters and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency"}
{"id": "322_0", "code": "def Sort(sub_li):\n    # Sort the list based on the second element of each sublist\n    return sorted(sub_li, key=lambda x: x[1])"}
{"id": "323_0", "code": "def check_Validity(a, b, c):\n    \"\"\"\n    Checks whether a triangle is valid or not.\n\n    Args:\n        a (float): The length of the first side of the triangle.\n        b (float): The length of the second side of the triangle.\n        c (float): The length of the third side of the triangle.\n\n    Returns:\n        bool: True if the triangle is valid, False otherwise.\n    \"\"\"\n    # Check if the input values are valid (greater than 0)\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n\n    # Check if the square of the longest side is less than the sum of the squares of the other two sides\n    if a**2 + b**2 <= c**2 or b**2 + c**2 <= a**2 or c**2 + a**2 <= b**2:\n        return False\n\n    # If all conditions are met, the triangle is valid\n    return True"}
{"id": "324_0", "code": "def ap_sum(a, n, d):\n    \"\"\"\n    Calculate the sum of an arithmetic progression.\n\n    Parameters:\n    a (float): The first term of the progression.\n    n (int): The number of terms in the progression.\n    d (float): The common difference of the progression.\n\n    Returns:\n    float: The sum of the arithmetic progression.\n    \"\"\"\n    # Check if the number of terms is positive\n    if n <= 0:\n        raise ValueError(\"The number of terms must be positive.\")\n\n    # Check if the common difference is positive\n    if d <= 0:\n        raise ValueError(\"The common difference must be positive.\")\n\n    # Calculate the sum using the formula\n    sum_of_progression = (n / 2) * (2 * a + (n - 1) * d)\n\n    return sum_of_progression"}
{"id": "325_0", "code": "def check_monthnum(monthname1):\n    monthdays = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return monthdays.get(monthname1, 'Invalid month name')"}
{"id": "326_0", "code": "import re\n\ndef text_match_word(text):\n    \"\"\"\n    Matches a word at the end of a string, with optional punctuation.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        str: The matched word.\n    \"\"\"\n    # Remove leading and trailing whitespace\n    text = text.strip()\n\n    # Remove punctuation\n    text = re.sub(r'[^\\w\\s]', '', text)\n\n    # Find the last word\n    last_word = text.rsplit(' ', 1)[-1]\n\n    return last_word"}
{"id": "327_0", "code": "def count_Substring_With_Equal_Ends(s):\n    \"\"\"\n    Counts the number of substrings with same first and last characters.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of substrings with same first and last characters.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                count += 1\n    return count"}
{"id": "328_0", "code": "def find_Divisor(x, y):\n    \"\"\"\n    This function finds the maximum occurring divisor in an interval.\n\n    Parameters:\n    x (int): The start of the interval.\n    y (int): The end of the interval.\n\n    Returns:\n    int: The maximum occurring divisor in the interval.\n    \"\"\"\n    # Initialize the maximum divisor and the current divisor\n    max_divisor = 0\n    current_divisor = 1\n\n    # Iterate over all numbers from 1 to y\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # Update the maximum divisor if i is greater\n            max_divisor = max(max_divisor, i)\n            # Update the current divisor\n            current_divisor = i\n\n    # Return the maximum divisor\n    return max_divisor"}
{"id": "329_0", "code": "def sum_three_smallest_nums(lst):\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # Return the sum of the three smallest numbers\n    return sum(sorted_lst[:3])"}
{"id": "330_0", "code": "def set_to_tuple(s):\n    \"\"\"\n    Convert a set into an ordered tuple.\n\n    Args:\n        s (set): The input set.\n\n    Returns:\n        tuple: An ordered tuple representation of the input set.\n    \"\"\"\n    return tuple(sorted(s))"}
{"id": "331_0", "code": "def find_minimum_range(list1, list2, list3):\n    # Sort the lists\n    list1.sort()\n    list2.sort()\n    list3.sort()\n\n    # Initialize the minimum range\n    min_range = float('inf')\n    min_range_start = 0\n    min_range_end = 0\n\n    # Iterate over the lists\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                # Check if the current elements are in the correct order\n                if list1[i] <= list2[j] and list2[j] <= list3[k]:\n                    # Update the minimum range\n                    min_range = min(min_range, list1[i] - list2[j] - list3[k])\n                    min_range_start = max(min_range_start, list1[i])\n                    min_range_end = min(min_range_end, list2[j] + list3[k])\n\n    return min_range_start, min_range_end"}
{"id": "332_0", "code": "def dig_let(s):\n    \"\"\"\n    Calculate the number of digits and letters in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        tuple: A tuple containing the number of digits and letters in the string.\n    \"\"\"\n    # Initialize counters for digits and letters\n    digits = 0\n    letters = 0\n\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digits += 1\n        # Check if the character is a letter\n        elif char.isalpha():\n            letters += 1\n\n    # Return the counts as a tuple\n    return digits, letters"}
{"id": "333_0", "code": "def count_Odd_Squares(n, m):\n    \"\"\"\n    This function counts the number of odd perfect squares in a given range.\n\n    Parameters:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n\n    Returns:\n    int: The number of odd perfect squares in the given range.\n    \"\"\"\n    count = 0\n    for i in range(n, m + 1):\n        # Check if the square root is an integer\n        if i ** 0.5 == int(i ** 0.5):\n            # Check if the square root is odd\n            if i ** 0.5 % 2 != 0:\n                count += 1\n    return count"}
{"id": "334_0", "code": "def diff_consecutivenums(nums):\n    \"\"\"\n    This function calculates the difference between two consecutive numbers in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of differences between consecutive numbers.\n    \"\"\"\n    # Check if the list has less than two elements\n    if len(nums) < 2:\n        return []\n\n    # Initialize an empty list to store the differences\n    differences = []\n\n    # Iterate over the list, starting from the second element\n    for i in range(1, len(nums)):\n        # Calculate the difference between the current element and the previous one\n        difference = nums[i] - nums[i - 1]\n        # Append the difference to the list\n        differences.append(difference)\n\n    # Return the list of differences\n    return differences"}
{"id": "335_0", "code": "def zigzag(n, k):\n    \"\"\"\n    Generate a zigzag pattern of n rows with k columns.\n\n    Args:\n    n (int): The number of rows.\n    k (int): The number of columns.\n\n    Returns:\n    list: A list of lists representing the zigzag pattern.\n    \"\"\"\n    # Initialize the result matrix with zeros\n    result = [[0] * k for _ in range(n)]\n\n    # Fill the first row and column with values from 1 to n\n    for i in range(n):\n        result[i][0] = i + 1\n        result[0][i] = i + 1\n\n    # Fill the rest of the matrix in a zigzag pattern\n    for i in range(1, n):\n        for j in range(1, k):\n            result[i][j] = result[i - 1][j - 1] + result[i - 1][j] + result[i][j - 1] - result[i - 1][j + 1]\n\n    return result"}
{"id": "336_0", "code": "def count_Squares(m,n):\n    # Check if the input is valid\n    if m <= 0 or n <= 0:\n        return 0\n\n    # Initialize count\n    count = 0\n\n    # Calculate the number of squares\n    for i in range(m):\n        for j in range(n):\n            if i * i + j * j == i ** 2 + j ** 2:\n                count += 1\n\n    return count"}
{"id": "337_0", "code": "def find_ways(M):\n    dp = [0] * (M + 1)\n    dp[0] = 1\n    for i in range(1, M + 1):\n        for j in range(i):\n            dp[i] += dp[i - j]\n    return dp[M]"}
{"id": "338_0", "code": "def check(string):\n    \"\"\"\n    Checks whether the given string is a binary string or not.\n\n    Args:\n        string (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string is binary, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    string = string.strip()\n    \n    # Check if the string is empty\n    if not string:\n        return False\n    \n    # Check if the string starts with '0b' or '0B'\n    if string.startswith(('0b', '0B')):\n        return True\n    \n    # Check if the string starts with '0x' or '0X'\n    if string.startswith(('0x', '0X')):\n        return True\n    \n    # If none of the above conditions are met, the string is not binary\n    return False"}
{"id": "339_0", "code": "def minimum_Length(s):\n    \"\"\"\n    This function minimizes the length of the string by removing occurrence of only one character.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The minimized string.\n    \"\"\"\n    # Initialize the minimum length and the character to be removed\n    min_len = float('inf')\n    char_to_remove = None\n\n    # Iterate over all possible characters\n    for char in set(s):\n        # Initialize the length of the string with the current character removed\n        new_len = len(s.replace(char, ''))\n\n        # Update the minimum length and the character to be removed if necessary\n        if new_len < min_len:\n            min_len = new_len\n            char_to_remove = char\n\n    # Return the minimized string\n    return s.replace(char_to_remove, '', min_len)\n\n# Example usage\nprint(minimum_Length(\"aaabbbccc\"))  # Output: \"abc\""}
{"id": "340_0", "code": "def first_Element(arr, n, k):\n    \"\"\"\n    This function finds the first element occurring k times in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n    k (int): The number of times the element should occur.\n\n    Returns:\n    int: The first element occurring k times in the array.\n    \"\"\"\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for i in range(n):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n\n    # Find the first element occurring k times\n    for i in range(n):\n        if count_dict[arr[i]] == k:\n            return arr[i]\n\n    # If no element occurs k times, return None\n    return None"}
{"id": "341_0", "code": "def unique_Characters(str):\n    \"\"\"\n    Checks whether all characters in a given string are unique.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        bool: True if all characters are unique, False otherwise.\n    \"\"\"\n    return len(str) == len(set(str))"}
{"id": "342_0", "code": "def remove_column(list1, n):\n    \"\"\"\n    Removes the specified column from a given nested list.\n\n    Args:\n        list1 (list): The input list.\n        n (int): The column index to be removed.\n\n    Returns:\n        list: The modified list with the specified column removed.\n    \"\"\"\n    # Check if the input list is empty\n    if not list1:\n        return list1\n\n    # Check if the input list is a list\n    if not isinstance(list1, list):\n        raise ValueError(\"Input must be a list\")\n\n    # Check if the column index is within the valid range\n    if n < 0 or n >= len(list1):\n        raise ValueError(\"Column index is out of range\")\n\n    # Use list slicing to remove the specified column\n    return list1[:n] + list1[n+1:]"}
{"id": "343_0", "code": "def tn_ap(a, n, d):\n    \"\"\"\n    Calculate the nth term of an arithmetic progression.\n\n    Parameters:\n    a (float): The first term of the progression.\n    n (int): The term number to calculate.\n    d (float): The common difference of the progression.\n\n    Returns:\n    float: The nth term of the progression.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    if d == 0:\n        raise ValueError(\"d cannot be zero.\")\n    if n == 1:\n        return a\n    else:\n        return a + (n - 1) * d"}
{"id": "344_0", "code": "import math\n\ndef count_Rectangles(radius):\n    \"\"\"\n    Counts the number of rectangles in a circle of radius r.\n\n    Args:\n        radius (float): The radius of the circle.\n\n    Returns:\n        int: The number of rectangles in the circle.\n    \"\"\"\n    # Calculate the number of rectangles\n    num_rectangles = 0\n    for x in range(-radius, radius + 1):\n        for y in range(-radius, radius + 1):\n            # Check if the point (x, y) is inside the circle\n            if x**2 + y**2 <= radius**2:\n                num_rectangles += 1\n    return num_rectangles"}
{"id": "345_0", "code": "import math\n\ndef find_angle(a, b):\n    \"\"\"\n    Calculate the third angle of a triangle given two angles.\n\n    Args:\n        a (float): The first angle in degrees.\n        b (float): The second angle in degrees.\n\n    Returns:\n        float: The third angle in degrees.\n    \"\"\"\n    # Convert angles from degrees to radians\n    a_rad = math.radians(a)\n    b_rad = math.radians(b)\n\n    # Calculate the third angle using the sum of angles in a triangle\n    c_rad = math.pi - a_rad - b_rad\n\n    # Convert the third angle back to degrees\n    c_deg = math.degrees(c_rad)\n\n    return c_deg\n\n# Example usage:\nprint(find_angle(60, 30))  # Output: 90.0"}
{"id": "346_0", "code": "def find_max(test_list):\n    \"\"\"\n    This function finds the maximum element of all the given tuple records.\n\n    Args:\n        test_list (list): A list of tuples, where each tuple contains two integers.\n\n    Returns:\n        int: The maximum element of all the given tuple records.\n    \"\"\"\n    # Initialize max_element variable with the first element of the first tuple\n    max_element = test_list[0][0]\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Check if the current tuple has more elements than the max_element\n        if len(tup) > 1:\n            # Update max_element if the current tuple's first element is greater\n            max_element = max(max_element, tup[0])\n    \n    # Return the maximum element\n    return max_element"}
{"id": "347_0", "code": "def moddiv_list(nums1, nums2):\n    # Calculate the modulo of each element in nums1 and nums2\n    mod1 = map(lambda x: x % nums2[0], nums1)\n    mod2 = map(lambda x: x % nums2[0], nums2)\n    # Calculate the modulo of the result of mod1 and mod2\n    mod_result = map(lambda x, y: x * y % nums2[0], mod1, mod2)\n    # Return the result\n    return list(mod_result)"}
{"id": "348_0", "code": "import math\n\ndef Check_Solution(a, b, c):\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is positive, zero or negative\n    if discriminant > 0:\n        # Two distinct real roots\n        if b == 0:\n            return \"The equation has two distinct real roots.\"\n        else:\n            return \"The equation has two distinct real roots.\"\n    elif discriminant == 0:\n        # One real root\n        if b == 0:\n            return \"The equation has one real root.\"\n        else:\n            return \"The equation has one real root.\"\n    else:\n        # Two complex roots\n        return \"The equation has two complex roots.\"\n\n# Example usage\nprint(Check_Solution(1, -3, 2))  # Output: The equation has two complex roots.\nprint(Check_Solution(1, 2, 1))   # Output: The equation has one real root.\nprint(Check_Solution(1, 2, 3))   # Output: The equation has two distinct real roots."}
{"id": "349_0", "code": "def get_carol(n):\n    \"\"\"\n    Returns the nth Carol number.\n\n    The Carol numbers are a sequence of numbers that are one less than the sum of all the positive integers up to n.\n    For example, the 1st Carol number is 1, the 2nd is 3, the 3rd is 6, and so on.\n\n    Args:\n        n (int): The position of the Carol number to generate.\n\n    Returns:\n        int: The nth Carol number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1) // 2"}
{"id": "350_0", "code": "def remove_empty(list1):\n    \"\"\"\n    Removes empty lists from a given list of lists.\n\n    Args:\n        list1 (list): The input list of lists.\n\n    Returns:\n        list: The input list with empty lists removed.\n    \"\"\"\n    return [sublist for sublist in list1 if sublist]"}
{"id": "351_0", "code": "def max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum occurrences in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The item with maximum occurrences.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum occurrences\n    max_item = max(count_dict, key=count_dict.get)\n\n    return max_item"}
{"id": "352_0", "code": "def add_K_element(test_list, K):\n    \"\"\"\n    Adds k elements to each element in the tuple.\n\n    Args:\n        test_list (list): The input list.\n        K (int): The number of elements to add.\n\n    Returns:\n        list: The modified list with k elements added to each element.\n    \"\"\"\n    return [x + K for x in test_list]"}
{"id": "353_0", "code": "def min_flip_to_make_string_alternate(s):\n    flips = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            flips += 1\n    return flips"}
{"id": "354_0", "code": "def count_Digit(n):\n    count = 0\n    while n > 0:\n        count += 1\n        n //= 10\n    return count"}
{"id": "355_0", "code": "def adjacent_num_product(list_nums):\n    \"\"\"\n    This function calculates the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        list_nums (list): A list of integers.\n\n    Returns:\n        int: The largest product of the pair of adjacent elements.\n    \"\"\"\n    if len(list_nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(list_nums) - 1):\n        # Calculate the product of the current element and the next element\n        product = list_nums[i] * list_nums[i + 1]\n        # Update the maximum product if the current product is larger\n        max_product = max(max_product, product)\n\n    return max_product"}
{"id": "356_0", "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_tree_balanced(root):\n    \"\"\"\n    Checks if a binary tree is balanced or not.\n\n    Args:\n    root (Node): The root of the binary tree.\n\n    Returns:\n    bool: True if the tree is balanced, False otherwise.\n    \"\"\"\n    def check_balance(node):\n        # Base case: An empty tree is balanced\n        if node is None:\n            return True\n\n        # Recursively check the left and right subtrees\n        left_balanced = check_balance(node.left)\n        right_balanced = check_balance(node.right)\n\n        # A tree is balanced if both subtrees are balanced\n        return left_balanced and right_balanced and abs(node.left.value - node.right.value) <= 1\n\n    return check_balance(root)"}
{"id": "357_0", "code": "def repeat_tuples(test_tup, N):\n    \"\"\"\n    Repeats a given tuple N times.\n\n    Args:\n        test_tup (tuple): The tuple to be repeated.\n        N (int): The number of times to repeat the tuple.\n\n    Returns:\n        tuple: The repeated tuple.\n    \"\"\"\n    return tuple(test_tup for _ in range(N))"}
{"id": "358_0", "code": "def lateralsurface_cuboid(l, w, h):\n    \"\"\"\n    Calculate the lateral surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: lateral surface area of the cuboid\n    \"\"\"\n    # Calculate the lateral surface area\n    lateral_surface_area = 2 * (l * w + w * h + h * l)\n    return lateral_surface_area"}
{"id": "359_0", "code": "def float_sort(price):\n    \"\"\"\n    Sort a tuple by its float element.\n\n    Args:\n        price (tuple): A tuple containing a float and a string.\n\n    Returns:\n        tuple: A sorted tuple with the float element first.\n    \"\"\"\n    # Separate the float and string elements\n    float_val, string_val = price\n\n    # Sort the float element first\n    sorted_float = sorted([float_val], reverse=True)\n\n    # Combine the sorted float element with the string element\n    sorted_price = (sorted_float, string_val)\n\n    return sorted_price"}
{"id": "360_0", "code": "def smallest_missing(A, left_element, right_element):\n    \"\"\"\n    Find the smallest missing element in a sorted array.\n\n    Args:\n    A (list): A sorted list of elements.\n    left_element (int): The smallest element in the array.\n    right_element (int): The largest element in the array.\n\n    Returns:\n    int: The smallest missing element in the array.\n    \"\"\"\n    # Initialize the left and right pointers\n    left = 0\n    right = len(A) - 1\n\n    # Traverse the array from both ends\n    while left <= right:\n        # If the current element is equal to the left element, move the left pointer\n        if A[left] == left_element:\n            left += 1\n        # If the current element is equal to the right element, move the right pointer\n        elif A[right] == right_element:\n            right -= 1\n        # If the current element is greater than the left element, the smallest missing element is the right element\n        elif A[right] < A[left]:\n            return right_element\n        # If the current element is less than the left element, the smallest missing element is the right element\n        else:\n            return right_element\n\n    # If the right pointer is still pointing to the right element, it means there is no missing element\n    return right_element"}
{"id": "361_0", "code": "import heapq\n\ndef heap_assending(nums):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n\n    Args:\n        nums (list): A list of elements to be sorted.\n\n    Returns:\n        list: A sorted list of elements in ascending order.\n    \"\"\"\n    # Convert the list into a heap\n    heapq.heapify(nums)\n\n    # Initialize an empty list to store the sorted elements\n    sorted_nums = []\n\n    # While the heap is not empty\n    while nums:\n        # Extract the smallest element from the heap\n        smallest = heapq.heappop(nums)\n\n        # Append the extracted element to the sorted list\n        sorted_nums.append(smallest)\n\n    # Return the sorted list\n    return sorted_nums"}
{"id": "362_0", "code": "def volume_cuboid(l, w, h):\n    \"\"\"\n    Calculate the volume of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: volume of the cuboid\n    \"\"\"\n    return l * w * h"}
{"id": "363_0", "code": "import itertools\n\ndef permute_string(str):\n    # Convert the string to a list of characters\n    chars = list(str)\n    \n    # Use itertools.permutations to generate all permutations\n    perms = itertools.permutations(chars)\n    \n    # Convert the permutations back to a string\n    perms_str = ''.join(perms)\n    \n    # Print the result\n    print(perms_str)"}
{"id": "364_0", "code": "def round_num(n, m):\n    \"\"\"\n    Rounds the given number to the nearest multiple of a specific number.\n\n    Args:\n        n (int): The number to be rounded.\n        m (int): The multiple to which the number should be rounded.\n\n    Returns:\n        int: The rounded number.\n    \"\"\"\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is 0, the number is already a multiple of m\n    if remainder == 0:\n        return n\n    \n    # Otherwise, round the number up to the nearest multiple of m\n    else:\n        return n + (m - remainder)"}
{"id": "365_0", "code": "def remove_replica(test_tup):\n    \"\"\"\n    Removes duplicate elements from a tuple and replaces them with a custom value.\n\n    Args:\n        test_tup (tuple): The input tuple to process.\n\n    Returns:\n        tuple: The modified tuple with duplicates replaced.\n    \"\"\"\n    seen = set()\n    result = []\n    for item in test_tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n        else:\n            result.append(\"Custom Value\")\n    return tuple(result)"}
{"id": "366_0", "code": "def remove_char(s, c):\n    \"\"\"\n    Removes all occurrences of a character from a given string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to be removed.\n\n    Returns:\n        str: The modified string with all occurrences of the character removed.\n    \"\"\"\n    return s.replace(c, '')"}
{"id": "367_0", "code": "def move_first(test_list):\n    if len(test_list) == 0:\n        return test_list\n    elif len(test_list) == 1:\n        return test_list\n    else:\n        return test_list[1:] + [test_list[0]]"}
{"id": "368_0", "code": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    Calculate the surface area of a cuboid.\n\n    Parameters:\n    l (float): length of the cuboid\n    w (float): width of the cuboid\n    h (float): height of the cuboid\n\n    Returns:\n    float: surface area of the cuboid\n    \"\"\"\n    # Calculate the surface area of the cuboid\n    surface_area = 2 * (l * w + w * h + l * h)\n    return surface_area"}
{"id": "369_0", "code": "import numpy as np\n\ndef multi_list(rownum, colnum):\n    # Create a 2D array with zeros\n    arr = np.zeros((rownum, colnum))\n    return arr"}
{"id": "370_0", "code": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists by a given index of the inner list.\n\n    Args:\n        list_data (list): The input list of lists.\n        index_no (int): The index of the inner list to sort by.\n\n    Returns:\n        list: The sorted list of lists.\n    \"\"\"\n    # Check if the input list is empty\n    if not list_data:\n        return list_data\n\n    # Check if the index is within the bounds of the inner list\n    if index_no < 0 or index_no >= len(list_data[0]):\n        raise ValueError(\"Index out of range\")\n\n    # Use the built-in sorted function with a custom key function\n    # The key function returns the inner list at the given index\n    sorted_list = sorted(list_data, key=lambda x: x[index_no])\n\n    return sorted_list"}
{"id": "371_0", "code": "def find_rotation_count(A):\n    \"\"\"\n    This function calculates the number of rotations in a circularly sorted array.\n\n    Args:\n        A (list): A list of integers representing a circularly sorted array.\n\n    Returns:\n        int: The number of rotations in the array.\n    \"\"\"\n    n = len(A)\n    # Find the index of the minimum element in the array\n    min_idx = A.index(min(A))\n    # The number of rotations is the index of the minimum element\n    return min_idx"}
{"id": "372_0", "code": "def even_bit_toggle_number(n):\n    \"\"\"\n    Toggles all odd bits of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with all odd bits toggled.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    bin_n = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the binary string\n    for bit in bin_n:\n        # If the bit is '1', toggle it\n        if bit == '1':\n            result += '1'\n        # If the bit is '0', keep it as is\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer\n    result = int(result, 2)\n    \n    return result"}
{"id": "373_0", "code": "def frequency_Of_Smallest(n,arr):\n    # Sort the array in ascending order\n    arr.sort()\n    # Find the index of the smallest value\n    idx = arr.index(min(arr))\n    # Return the frequency of the smallest value\n    return arr.count(min(arr))"}
{"id": "374_0", "code": "def get_perrin(n):\n    \"\"\"\n    Returns the nth Pernin number.\n\n    Args:\n        n (int): The position of the Pernin number to be found.\n\n    Returns:\n        int: The nth Pernin number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return 2 * get_perrin(n - 1) + get_perrin(n - 2)"}
{"id": "375_0", "code": "def swap_count(s):\n    \"\"\"\n    Calculate the minimum number of swaps required for bracket balancing in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of swaps required for bracket balancing.\n    \"\"\"\n    stack = []\n    count = 0\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                count += 1\n    return count"}
{"id": "376_0", "code": "def even_or_odd(N):\n    if N % 2 == 0:\n        return \"The hexadecimal number is even.\"\n    else:\n        return \"The hexadecimal number is odd.\""}
{"id": "377_0", "code": "def highest_Power_of_2(n):\n    \"\"\"\n    Returns the highest power of 2 that is less than or equal to n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2"}
{"id": "378_0", "code": "def find_lucas(n):\n    \"\"\"\n    Returns the nth Lucas number.\n\n    Args:\n        n (int): The position of the Lucas number to find.\n\n    Returns:\n        int: The nth Lucas number.\n    \"\"\"\n    if n <= 1:\n        return n\n    a, b = 2, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b"}
{"id": "379_0", "code": "def add_string(list, string):\n    \"\"\"\n    Inserts a given string at the beginning of all items in a list.\n\n    Args:\n        list (list): The input list.\n        string (str): The string to be inserted.\n\n    Returns:\n        list: The modified list with the string inserted at the beginning.\n    \"\"\"\n    # Check if the input list is empty\n    if not list:\n        return list\n\n    # Use list comprehension to create a new list with the string inserted at the beginning\n    return [string] + list"}
{"id": "380_0", "code": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    Convert more than one list to nested dictionary.\n\n    Args:\n        l1 (list): The first list to convert.\n        l2 (list): The second list to convert.\n        l3 (list): The third list to convert.\n\n    Returns:\n        dict: A nested dictionary containing the converted lists.\n    \"\"\"\n    # Initialize an empty dictionary to store the result\n    result = {}\n\n    # Iterate over the elements of the first list\n    for i, element in enumerate(l1):\n        # If the element is a list, recursively call the function\n        if isinstance(element, list):\n            result[i] = convert_list_dictionary(element, l2, l3)\n        # If the element is not a list, add it to the result dictionary\n        else:\n            result[i] = element\n\n    # Return the result dictionary\n    return result"}
{"id": "381_0", "code": "def get_max_sum(n):\n    \"\"\"\n    This function calculates the maximum sum possible by using the given equation f(n) = max( \n    (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Base case: If n is 1, return 1\n    if n == 1:\n        return 1\n    \n    # Initialize the maximum sum\n    max_sum = 1\n    \n    # Calculate the maximum sum for n/2, n/3, n/4, and n/5\n    max_sum = get_max_sum(n // 2)\n    max_sum = max(max_sum, get_max_sum(n // 3))\n    max_sum = max(max_sum, get_max_sum(n // 4))\n    max_sum = max(max_sum, get_max_sum(n // 5))\n    \n    # Return the maximum sum for n\n    return max_sum + get_max_sum(n - 1)"}
{"id": "382_0", "code": "def max_length_list(input_list):\n    return max(input_list, key=len)"}
{"id": "383_0", "code": "def check_distinct(test_tup):\n    \"\"\"\n    Checks if the given tuple is distinct or not.\n\n    Args:\n        test_tup (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))"}
{"id": "384_0", "code": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    for char in str1:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Find the first non-repeating character\n    for char in str1:\n        if char_frequency[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None"}
{"id": "385_0", "code": "import re\n\ndef check_char(string):\n    # Check if the string starts and ends with the same character\n    if re.match(r'^[a-zA-Z]+$', string):\n        return True\n    else:\n        return False"}
{"id": "386_0", "code": "def median_numbers(a, b, c):\n    # Sort the numbers in ascending order\n    numbers = sorted([a, b, c])\n    \n    # Find the median\n    if len(numbers) % 2 == 0:\n        # If the number of elements is even, the median is the average of the two middle numbers\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        # If the number of elements is odd, the median is the middle number\n        median = numbers[len(numbers) // 2]\n    \n    return median"}
{"id": "387_0", "code": "def sum_of_digits(nums):\n    \"\"\"\n    Compute the sum of digits of each number in the given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list of sums of digits of each number in the input list.\n    \"\"\"\n    return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"id": "388_0", "code": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    This function performs the bitwise XOR operation across two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple for the XOR operation.\n        test_tup2 (tuple): The second tuple for the XOR operation.\n\n    Returns:\n        tuple: A tuple containing the result of the XOR operation.\n    \"\"\"\n    # Initialize an empty list to store the XOR results\n    xor_results = []\n    \n    # Iterate over the elements of the tuples\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        # Perform the XOR operation on the current elements\n        xor_result = elem1 ^ elem2\n        \n        # Append the XOR result to the list\n        xor_results.append(xor_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(xor_results)"}
{"id": "389_0", "code": "def extract_freq(test_list):\n    # Convert the list to a set to remove duplicates\n    unique_tuples = set(tuple(sorted(t)) for t in test_list)\n    \n    # Use a dictionary to store the frequency of each tuple\n    freq_dict = {}\n    \n    # Iterate over the unique tuples and update their frequency in the dictionary\n    for t in unique_tuples:\n        freq_dict[t] = freq_dict.get(t, 0) + 1\n    \n    # Convert the dictionary back to a list of tuples\n    freq_list = list(freq_dict.items())\n    \n    return freq_list"}
{"id": "390_0", "code": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function adds elements of two nested tuples element-wise.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: The result of the element-wise addition of the two input tuples.\n    \"\"\"\n    # Check if both inputs are tuples\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples.\")\n\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length.\")\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Add the elements of the current tuple elements-wise\n        result.append(test_tup1[i] + test_tup2[i])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"id": "391_0", "code": "import math\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p using the formula: ncr%p = n! / (r! * (n-r)!)\n    \"\"\"\n    # Initialize the result\n    result = 1\n    # Initialize the factorial of r\n    r_factorial = 1\n    # Initialize the factorial of (n-r)\n    n_r_factorial = 1\n    # Iterate over the range from 1 to n\n    for i in range(1, n+1):\n        # Update the result\n        result = (result * i) % p\n        # Update the factorial of r\n        r_factorial = (r_factorial * r) % p\n        # Update the factorial of (n-r)\n        n_r_factorial = (n_r_factorial * (n-i)) % p\n    # Return the result\n    return result"}
{"id": "392_0", "code": "import re\n\ndef is_valid_URL(str):\n    pattern = r\"^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$\"\n    return bool(re.match(pattern, str))"}
{"id": "393_0", "code": "def minimum(a, b):\n    if a > b:\n        return b\n    else:\n        return a"}
{"id": "394_0", "code": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be checked.\n        tuple1 (tuple): The tuple to be searched in.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return tuplex in tuple1"}
{"id": "395_0", "code": "def find_Parity(x):\n    if x == 0:\n        return 0\n    elif x % 2 == 0:\n        return 1\n    else:\n        return 0"}
{"id": "396_0", "code": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n    \n    # Join the sorted digits to form a string\n    bigger = ''.join(map(str, digits))\n    \n    # Convert the string back to an integer\n    bigger = int(bigger)\n    \n    return bigger"}
{"id": "397_0", "code": "def k_smallest_pairs(nums1, nums2, k):\n    \"\"\"\n    Find k number of pairs which consist of one element from the first array and one element from the second array.\n\n    Args:\n    nums1 (list): The first array.\n    nums2 (list): The second array.\n    k (int): The number of pairs to generate.\n\n    Returns:\n    list: A list of tuples, where each tuple contains a pair of elements from the two arrays.\n    \"\"\"\n    # Sort both arrays\n    nums1.sort()\n    nums2.sort()\n\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate over the first array\n    for num1 in nums1:\n        # Iterate over the second array\n        for num2 in nums2:\n            # Check if the current pair is valid (i.e., num1 < num2)\n            if num1 < num2:\n                # Add the pair to the list\n                pairs.append((num1, num2))\n\n    # Return the list of pairs\n    return pairs"}
{"id": "398_0", "code": "def min_product_tuple(lst1):\n    # Initialize the minimum product\n    min_product = float('inf')\n\n    # Iterate over the list\n    for i in range(len(lst1)):\n        for j in range(i + 1, len(lst1)):\n            # Calculate the product of the current pair\n            product = lst1[i] * lst1[j]\n\n            # Update the minimum product if necessary\n            min_product = min(min_product, product)\n\n    return min_product"}
{"id": "399_0", "code": "def min_val(lstval):\n    \"\"\"\n    This function finds the minimum value in a given heterogeneous list.\n\n    Args:\n        lstval (list): A list containing heterogeneous elements.\n\n    Returns:\n        The minimum value in the list.\n    \"\"\"\n    return min(lstval)"}
{"id": "400_0", "code": "import re\n\ndef snake_to_camel(word):\n    # Define the regex pattern to match snake case\n    pattern = r'^[a-z]+(?=[A-Z])'\n    # Use regex to replace snake case with camel case\n    camel_case_word = re.sub(pattern, lambda x: x.group(0).upper(), word)\n    return camel_case_word"}
{"id": "401_0", "code": "def remove_odd(l):\n    return [x for x in l if x % 2 == 0]"}
{"id": "402_0", "code": "def extract_nth_element(list1, n):\n    \"\"\"\n    Extract the nth element from a given list of tuples.\n\n    Args:\n        list1 (list): A list of tuples.\n        n (int): The index of the element to extract.\n\n    Returns:\n        tuple: The nth element of the list.\n    \"\"\"\n    # Check if the input list is empty\n    if not list1:\n        raise ValueError(\"Input list is empty\")\n\n    # Check if n is within the valid range\n    if n < 1 or n > len(list1):\n        raise ValueError(\"n is out of range\")\n\n    # Extract the nth element\n    nth_element = list1[n - 1]\n\n    return nth_element"}
{"id": "403_0", "code": "def overlapping(list1, list2):\n    \"\"\"\n    Checks whether the value exists in a sequence or not.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        bool: True if the value exists in list1, False otherwise.\n    \"\"\"\n    # Check if list1 is a list\n    if not isinstance(list1, list):\n        raise TypeError(\"The first argument must be a list.\")\n\n    # Check if list2 is a list\n    if not isinstance(list2, list):\n        raise TypeError(\"The second argument must be a list.\")\n\n    # Check if both lists are not empty\n    if len(list1) == 0 or len(list2) == 0:\n        return False\n\n    # Check if list1 is empty\n    if len(list1) == 0:\n        return False\n\n    # Check if list2 is empty\n    if len(list2) == 0:\n        return True\n\n    # Check if the value exists in list1\n    for i in range(len(list1)):\n        if list1[i] == list2[0]:\n            return True\n\n    # Check if the value exists in list2\n    for i in range(len(list2)):\n        if list2[i] == list1[0]:\n            return True\n\n    # If the value does not exist in either list, return False\n    return False"}
{"id": "404_0", "code": "def max_product(arr):\n    \"\"\"\n    This function finds the pair with the highest product from a given array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    tuple: A tuple containing the pair with the highest product and the product itself.\n    \"\"\"\n    if len(arr) < 2:\n        return None, None\n\n    max_product = float('-inf')\n    min_product = float('inf')\n    max_pair = None\n    min_pair = None\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (arr[i], arr[j])\n            if product < min_product:\n                min_product = product\n                min_pair = (arr[i], arr[j])\n\n    return max_pair, max_product"}
{"id": "405_0", "code": "def breakSum(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    else:\n        return n + breakSum(n-1) + breakSum(n-2)"}
{"id": "406_0", "code": "def group_tuples(Input):\n    # Initialize an empty list to store the tuples\n    result = []\n    \n    # Iterate over the input list\n    for i in Input:\n        # Check if the tuple is not empty\n        if i:\n            # Append the tuple to the result list\n            result.append(i)\n    \n    # Return the result list\n    return result"}
{"id": "407_0", "code": "def Find_Max(lst):\n    \"\"\"\n    This function finds the sublist with the maximum length in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: The sublist with the maximum length.\n\n    \"\"\"\n    # Initialize the maximum length and the corresponding sublist\n    max_len = 0\n    max_sublist = []\n\n    # Iterate over the list to find the sublist with the maximum length\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check if the current sublist is longer than the maximum length\n            if len(lst[i:j+1]) > max_len:\n                # Update the maximum length and the corresponding sublist\n                max_len = len(lst[i:j+1])\n                max_sublist = lst[i:j+1]\n\n    # Return the sublist with the maximum length\n    return max_sublist"}
{"id": "408_0", "code": "def round_and_sum(list1):\n    total = 0\n    for num in list1:\n        total += round(num)\n    print(\"Total sum: \", total)\n    print(\"Length of the list: \", len(list1))\n    print(\"Total sum multiplied by the length of the list: \", total * len(list1))"}
{"id": "409_0", "code": "def cube_Sum(n):\n    \"\"\"\n    Calculate the sum of cubes of first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to sum.\n\n    Returns:\n        int: The sum of cubes of first n even natural numbers.\n    \"\"\"\n    # Initialize the sum variable\n    total = 0\n\n    # Loop through the range from 2 to n (inclusive)\n    for i in range(2, n + 1):\n        # Check if the number is even\n        if i % 2 == 0:\n            # Add the cube of the number to the total\n            total += i ** 3\n\n    # Return the total sum\n    return total"}
{"id": "410_0", "code": "def concatenate_tuple(test_tup):\n    \"\"\"\n    Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        test_tup (tuple): The input tuple.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return ''.join(map(str, test_tup)) + ' ' + test_tup[0] + ' ' + test_tup[-1]"}
{"id": "411_0", "code": "def find_Average_Of_Cube(n):\n    \"\"\"\n    Calculate the average of cubes of the first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        float: The average of the cubes of the first n natural numbers.\n    \"\"\"\n    # Initialize the sum of cubes\n    sum_of_cubes = 0\n\n    # Calculate the sum of cubes of the first n natural numbers\n    for i in range(1, n + 1):\n        sum_of_cubes += i ** 3\n\n    # Calculate the average of the sum of cubes\n    average_of_cubes = sum_of_cubes / n\n\n    return average_of_cubes"}
{"id": "412_0", "code": "def get_maxgold(gold, m, n):\n    \"\"\"\n    This function calculates the maximum gold that can be obtained from a gold mine.\n    \n    Parameters:\n    gold (int): The initial amount of gold in the mine.\n    m (int): The number of gold bars in the mine.\n    n (int): The number of gold coins in the mine.\n    \n    Returns:\n    int: The maximum gold that can be obtained.\n    \"\"\"\n    # Calculate the maximum gold that can be obtained from gold bars\n    max_gold_from_bars = gold * m\n    \n    # Calculate the maximum gold that can be obtained from gold coins\n    max_gold_from_coins = gold * n\n    \n    # Return the maximum of the two values\n    return max(max_gold_from_bars, max_gold_from_coins)"}
{"id": "413_0", "code": "def extract_rear(test_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n        test_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of rear index elements of the strings in the tuple.\n    \"\"\"\n    return [s[-1] for s in test_tuple]"}
{"id": "414_0", "code": "def count_element_in_list(list1, x):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list1 (list): The input list.\n        x (any): The element to search for.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == x:\n            count += 1\n    return count"}
{"id": "415_0", "code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"id": "416_0", "code": "import re\nfrom datetime import datetime\n\ndef change_date_format(dt):\n    # Define the regex pattern\n    pattern = r'\\d{4}-\\d{2}-\\d{2}'\n    \n    # Replace the regex pattern with the desired format\n    new_date = re.sub(pattern, lambda x: x.group(0).zfill(2), dt.strftime('%d-%m-%Y'))\n    \n    return new_date"}
{"id": "417_0", "code": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list"}
{"id": "418_0", "code": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple containing the elementwise and tuples from the input tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the elementwise and tuples from the input tuples.\n    \"\"\"\n    # Extract the elementwise and tuples from the input tuples\n    elementwise = tuple(test_tup1[i] for i in range(len(test_tup1)))\n    tuples = tuple(test_tup2[i] for i in range(len(test_tup2)))\n\n    # Combine the elementwise and tuples into a new tuple\n    result = elementwise + tuples\n\n    return result"}
{"id": "419_0", "code": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its vertex and focal length.\n\n    Parameters:\n    a (float): The coefficient of the squared term in the parabola's equation.\n    b (float): The coefficient of the linear term in the parabola's equation.\n    c (float): The focal length of the parabola.\n\n    Returns:\n    str: The equation of the directrix of the parabola.\n    \"\"\"\n    # Calculate the focal length squared\n    focal_length_squared = c ** 2\n\n    # Calculate the directrix equation\n    if a == 0:\n        # If a is zero, the parabola is a vertical line\n        directrix = f\"x = {focal_length_squared / (4 * b)}\"\n    else:\n        # If a is not zero, the directrix is a horizontal line\n        directrix = f\"y = -{focal_length_squared / (4 * a)}\"\n\n    return directrix"}
{"id": "420_0", "code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2))"}
{"id": "421_0", "code": "def median_trapezium(base1, base2, height):\n    \"\"\"\n    Calculate the median of a trapezium.\n\n    Parameters:\n    base1 (float): The length of the first base of the trapezium.\n    base2 (float): The length of the second base of the trapezium.\n    height (float): The height of the trapezium.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    # Calculate the average of the bases\n    avg_bases = (base1 + base2) / 2\n\n    # Calculate the median of the trapezium\n    median = (avg_bases + height) / 2\n\n    return median"}
{"id": "422_0", "code": "def check_greater(arr, number):\n    # Check if the number is greater than all elements in the array\n    if all(num > number for num in arr):\n        return True\n    else:\n        return False"}
{"id": "423_0", "code": "def text_match_one(text):\n    \"\"\"\n    Generate a string that matches a string that has an a followed by one or more b's.\n    \n    Args:\n        text (str): The input string.\n    \n    Returns:\n        str: A generated string that matches the input string.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Initialize a counter to count the number of 'a's\n    a_count = 0\n    \n    # Iterate over each character in the input string\n    for char in text:\n        # If the character is 'a', increment the counter\n        if char == 'a':\n            a_count += 1\n        # If the character is 'b', append the corresponding number of 'a's to the result\n        elif char == 'b':\n            result += \"a\" * a_count\n        # If the character is not 'a' or 'b', append it to the result as is\n        else:\n            result += char\n    \n    # Return the generated string\n    return result"}
{"id": "424_0", "code": "def last_Digit(n):\n    \"\"\"\n    This function finds the last digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The last digit of the input number.\n    \"\"\"\n    return n % 10"}
{"id": "425_0", "code": "def neg_nos(list1):\n    for i in list1:\n        if i < 0:\n            print(i)"}
{"id": "426_0", "code": "def remove_odd(str1):\n    return ''.join([c for c in str1 if c.isalnum()])"}
{"id": "427_0", "code": "def count_bidirectional(test_list):\n    \"\"\"\n    Counts bidirectional tuple pairs in a given list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        int: The number of bidirectional tuple pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            # Check if the tuple is bidirectional\n            if (test_list[i] == test_list[j]) and (test_list[j] == test_list[i]):\n                count += 1\n    return count"}
{"id": "428_0", "code": "def multiple_to_single(L):\n    result = 0\n    for num in L:\n        result += num\n    return result"}
{"id": "429_0", "code": "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    Find all adverbs and their positions in a given sentence.\n\n    Args:\n        text (str): The input sentence.\n\n    Returns:\n        dict: A dictionary containing the adverbs and their positions.\n    \"\"\"\n    # Define a list of common adverbs\n    adverbs = ['fast', 'slow', 'loud', 'quiet', 'high', 'low', 'big', 'small', 'long', 'short', 'well', 'bad', 'good', 'good', 'bad', 'well', 'very', 'not', 'very', 'not', 'very', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', 'not', '"}
{"id": "430_0", "code": "def surfacearea_cube(length):\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Args:\n        length (float): The length of the cube.\n\n    Returns:\n        float: The surface area of the cube.\n    \"\"\"\n    # Calculate the surface area of the cube\n    surface_area = 6 * (length ** 2)\n    return surface_area"}
{"id": "431_0", "code": "def positive_count(nums):\n    \"\"\"\n    This function calculates the ratio of positive numbers in a given array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The ratio of positive numbers in the list.\n    \"\"\"\n    positive_nums = [num for num in nums if num > 0]\n    return len(positive_nums) / len(nums) if nums else 0"}
{"id": "432_0", "code": "def largest_neg(list1):\n    # Check if the list is empty\n    if not list1:\n        return None\n\n    # Find the largest negative number\n    largest = float('-inf')\n    for num in list1:\n        if num < 0 and num > largest:\n            largest = num\n\n    # Return the largest negative number\n    return largest"}
{"id": "433_0", "code": "def trim_tuple(test_list, K):\n    \"\"\"\n    Trim each tuple in the given list by K.\n\n    Args:\n        test_list (list): A list of tuples.\n        K (int): The number of elements to trim from the beginning of each tuple.\n\n    Returns:\n        list: The list of tuples with trimmed content.\n    \"\"\"\n    return [tuple(t[:K]) for t in test_list]"}
{"id": "434_0", "code": "def index_multiplication(test_tup1, test_tup2):\n    \"\"\"\n    This function performs index-wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        test_tup1 (tuple): The first tuple.\n        test_tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of index-wise multiplication.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices and elements of the first tuple\n    for i, elem1 in enumerate(test_tup1):\n        # Iterate over the indices and elements of the second tuple\n        for j, elem2 in enumerate(test_tup2):\n            # Perform index-wise multiplication and append to the result list\n            result.append(elem1 * elem2)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"id": "435_0", "code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements of list in a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        lst (list): The list to search for.\n\n    Returns:\n        dict: A dictionary where keys are elements of the list and values are their occurrences in the tuple.\n    \"\"\"\n    count_dict = {}\n    for elem in lst:\n        if elem in tup:\n            count_dict[elem] = tup.count(elem)\n    return count_dict"}
{"id": "436_0", "code": "def cube_nums(nums):\n    return [lambda x: x**3 for x in nums]"}
{"id": "437_0", "code": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of perrin numbers.\n\n    Args:\n        n (int): The number of perrin numbers to calculate.\n\n    Returns:\n        int: The sum of perrin numbers.\n    \"\"\"\n    # Initialize the sum\n    total = 0\n\n    # Calculate the sum of perrin numbers\n    for i in range(n):\n        # Initialize the sum of perrin numbers for the current iteration\n        perrin_sum = 0\n\n        # Calculate the sum of perrin numbers for the current iteration\n        for j in range(i + 1):\n            # Calculate the perrin number\n            perrin_num = (2 * j + 1) ** i + (2 * j) ** i\n\n            # Add the perrin number to the sum\n            perrin_sum += perrin_num\n\n        # Add the sum of perrin numbers for the current iteration to the total\n        total += perrin_sum\n\n    # Return the total sum\n    return total"}
{"id": "438_0", "code": "import math\n\ndef check_Triangle(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Check if a triangle is valid given 3 points.\n\n    Args:\n        x1 (float): x-coordinate of the first point.\n        y1 (float): y-coordinate of the first point.\n        x2 (float): x-coordinate of the second point.\n        y2 (float): y-coordinate of the second point.\n        x3 (float): x-coordinate of the third point.\n        y3 (float): y-coordinate of the third point.\n\n    Returns:\n        bool: True if the triangle is valid, False otherwise.\n    \"\"\"\n\n    # Calculate the lengths of the sides\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the sides are valid\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n\n    # Check if the points are collinear\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are collinear and coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return True\n\n    # Check if the points are collinear\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are collinear and coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return True\n\n    # Check if the points are collinear\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return False\n\n    # Check if the points are collinear and coplanar\n    if (x1 - x2) * (y3 - y2) == (x2 - x3) * (y1 - y2) and \\\n       (x1 - x3) * (y2 - y1) == (x3 - x2) * (y1 - y2):\n        return True\n\n    # Check if the points are collinear\n    if (x1 - x2) * (y3 - y2) == (x2"}
{"id": "439_0", "code": "def extract_string(str, l):\n    \"\"\"\n    Extract specified size of strings from a given list of string values.\n\n    Args:\n        str (str): The string to extract from.\n        l (list): The list of string values.\n\n    Returns:\n        list: A list of extracted strings.\n    \"\"\"\n    # Check if the input string is in the list\n    if str in l:\n        # Extract the specified size of strings from the list\n        return [s for s in l if s.startswith(str)]\n    else:\n        # Return an empty list if the string is not found\n        return []"}
{"id": "440_0", "code": "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)"}
{"id": "441_0", "code": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost < sale_amount:\n        return None\n    else:\n        return actual_cost - sale_amount"}
{"id": "442_0", "code": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The sum of even factors of the input number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    even_sum = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if i is even\n            if i % 2 == 0:\n                # Add i to the sum of even factors\n                even_sum += i\n    \n    # Return the sum of even factors\n    return even_sum"}
{"id": "443_0", "code": "def text_match_wordz(text):\n    \"\"\"\n    This function generates a text that matches a word containing 'z'.\n    \n    Parameters:\n    text (str): The input text.\n    \n    Returns:\n    str: The generated text.\n    \"\"\"\n    # Initialize an empty string to store the generated text\n    generated_text = \"\"\n    \n    # Initialize a counter to keep track of the number of 'z' characters\n    z_count = 0\n    \n    # Iterate over each character in the input text\n    for char in text:\n        # If the character is 'z', increment the counter\n        if char == 'z':\n            z_count += 1\n        # If the character is not 'z', add it to the generated text\n        else:\n            generated_text += char\n    \n    # If the counter is greater than 1, add 'z' to the generated text\n    if z_count > 1:\n        generated_text += 'z'\n    \n    # Return the generated text\n    return generated_text"}
{"id": "444_0", "code": "def check_monthnumb_number(monthnum2):\n    if monthnum2 < 1 or monthnum2 > 12:\n        return False\n    if monthnum2 == 2:\n        return 28 in [1, 3, 5, 7, 8, 10, 12]\n    elif monthnum2 == 4:\n        return 30 in [1, 3, 5, 7, 8, 10, 12]\n    elif monthnum2 == 6:\n        return 30 in [1, 3, 5, 7, 8, 10, 12]\n    elif monthnum2 == 9:\n        return 30 in [1, 5, 7, 10, 12]\n    elif monthnum2 == 11:\n        return 30 in [1, 5, 9, 13, 15, 17, 19, 21, 23, 25, 27, 29]\n    else:\n        return 31 in [1, 3, 5, 7, 8, 10, 12]"}
{"id": "445_0", "code": "def reverse_string_list(stringlist):\n    \"\"\"\n    Reverses the order of the strings in the given list.\n\n    Args:\n        stringlist (list): A list of strings.\n\n    Returns:\n        list: A new list with the strings in reverse order.\n    \"\"\"\n    return [s[::-1] for s in stringlist]"}
{"id": "446_0", "code": "def Find_Min(lst):\n    \"\"\"\n    This function finds the sublist with the minimum length in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The sublist with the minimum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    min_length = float('inf')\n    min_sublist = None\n\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_sublist = sublist\n\n    return min_sublist"}
{"id": "447_0", "code": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The area of the rectangle.\n    \"\"\"\n    return length * width"}
{"id": "448_0", "code": "import re\n\ndef remove_uppercase(str1):\n    # Remove uppercase substrings from a given string\n    return re.sub(r'([A-Z])', r' \\1', str1)"}
{"id": "449_0", "code": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"id": "450_0", "code": "def upper_ctr(str):\n    \"\"\"\n    Counts the number of upper case characters in a given string.\n\n    Args:\n        str (str): The input string.\n\n    Returns:\n        int: The number of upper case characters in the string.\n    \"\"\"\n    return sum(1 for c in str if c.isupper())"}
{"id": "451_0", "code": "def combinations_list(list1):\n    \"\"\"\n    Generate all possible combinations of the elements of a given list.\n\n    Args:\n        list1 (list): The input list.\n\n    Returns:\n        list: A list of lists, where each sublist is a combination of the elements of the input list.\n    \"\"\"\n    # Base case: if the list is empty or contains only one element, return a list containing the list itself\n    if len(list1) <= 1:\n        return [list1]\n\n    # Initialize an empty list to store the combinations\n    combinations = []\n\n    # Iterate over each element in the list\n    for i, element in enumerate(list1):\n        # Recursively generate combinations for the rest of the list\n        rest_combinations = combinations_list(list1[:i] + list1[i+1:])\n\n        # Add the current element to each combination generated by the recursive call\n        for combination in rest_combinations:\n            combinations.append([element] + combination)\n\n    return combinations"}
{"id": "452_0", "code": "def max_subarray_product(arr):\n    \"\"\"\n    This function finds the maximum product subarray of the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum product subarray.\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            # If the current element is negative, swap max_product and min_product\n            # because multiplying a negative number swaps the max and min product\n            if min_product < 0:\n                min_product, max_product = max_product, min_product\n            # Update max_product and min_product\n            max_product = max(arr[i], max_product * arr[i])\n            min_product = min(arr[i], min_product * arr[i])\n        else:\n            # Update max_product and min_product\n            max_product = max(arr[i], max_product * arr[i])\n            min_product = min(arr[i], min_product * arr[i])\n\n        # Update the result\n        result = max(result, max_product)\n\n    return result"}
{"id": "453_0", "code": "def check_value(dict, n):\n    \"\"\"\n    This function checks if all values in a dictionary are the same.\n\n    Args:\n        dict (dict): The input dictionary.\n        n (int): The number of values to check.\n\n    Returns:\n        bool: True if all values are the same, False otherwise.\n    \"\"\"\n    # Check if the input is a dictionary\n    if not isinstance(dict, dict):\n        raise TypeError(\"Input must be a dictionary\")\n\n    # Check if the number of values to check is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Number of values to check must be a positive integer\")\n\n    # Get the values from the dictionary\n    values = dict.values()\n\n    # Check if all values are the same\n    return len(set(values)) == 1"}
{"id": "454_0", "code": "def drop_empty(dict1):\n    \"\"\"\n    Drops empty items from a given dictionary.\n\n    Args:\n        dict1 (dict): The input dictionary.\n\n    Returns:\n        dict: The dictionary with empty items removed.\n    \"\"\"\n    # Create a copy of the input dictionary\n    dict_copy = dict1.copy()\n    \n    # Iterate over the dictionary items\n    for key, value in dict_copy.items():\n        # Check if the value is empty\n        if not value:\n            # If the value is empty, remove the key-value pair\n            del dict_copy[key]\n    \n    # Return the modified dictionary\n    return dict_copy"}
{"id": "455_0", "code": "def find_peak(arr, n):\n    \"\"\"\n    This function finds the peak element in the given array.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the input array.\n    \n    Returns:\n    int: The index of the peak element in the array.\n    \"\"\"\n    # Initialize the low and high pointers for binary search\n    low = 0\n    high = n - 1\n    \n    # Continue the search until the low and high pointers meet\n    while low < high:\n        # Calculate the mid index\n        mid = (low + high) // 2\n        \n        # If the middle element is greater than the next element, the peak is on the left side\n        if arr[mid] > arr[mid + 1]:\n            # Update the high pointer to the left of the mid index\n            high = mid\n        # If the middle element is less than or equal to the next element, the peak is on the right side\n        else:\n            # Update the low pointer to the right of the mid index\n            low = mid + 1\n    \n    # Return the index of the peak element\n    return low"}
{"id": "456_0", "code": "def decimal_to_Octal(deciNum):\n    octal = oct(deciNum)[2:]  # Remove '0o' prefix\n    return octal"}
{"id": "457_0", "code": "def max_product(arr, n):\n    \"\"\"\n    This function finds the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The length of the array.\n\n    Returns:\n    int: The maximum product of an increasing subsequence.\n    \"\"\"\n    # Initialize the maximum product and the current product\n    max_product = 1\n    current_product = 1\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is greater than the current product, update the current product\n        if arr[i] > current_product:\n            current_product = arr[i]\n        # If the current element is less than the current product, update the maximum product\n        elif arr[i] < current_product:\n            max_product = max(max_product, current_product)\n            current_product = arr[i]\n\n    # Update the maximum product one last time\n    max_product = max(max_product, current_product)\n\n    return max_product"}
{"id": "458_0", "code": "def max_profit(price, k):\n    \"\"\"\n    This function calculates the maximum profit that can be earned from a maximum of k stock transactions.\n\n    Parameters:\n    price (list): A list of stock prices\n    k (int): The maximum number of stock transactions\n\n    Returns:\n    int: The maximum profit that can be earned\n    \"\"\"\n    if not price or k <= 0:\n        return 0\n\n    # Initialize a 2D array to store the maximum profit for each subproblem\n    dp = [[0] * (k + 1) for _ in range(len(price))]\n\n    # Iterate over each stock price\n    for i in range(1, len(price)):\n        # Iterate over each possible number of transactions\n        for j in range(1, min(i, k) + 1):\n            # Update the maximum profit for the current subproblem\n            dp[i][j] = max(dp[i - 1][j], price[i] - dp[i - 1][j - 1])\n\n    # Return the maximum profit for the last stock price and the maximum number of transactions\n    return max(dp[-1][-1], price[-1] - dp[-1][-2])"}
{"id": "459_0", "code": "def add_pairwise(test_tup):\n    \"\"\"\n    This function adds the elements of the given tuples pairwise.\n\n    Args:\n        test_tup (tuple): A tuple of tuples.\n\n    Returns:\n        tuple: A tuple of tuples where each inner tuple contains the sum of the corresponding elements of the input tuples.\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the input tuples\n    for tup in test_tup:\n        # Initialize an empty list to store the elements of the current tuple\n        current_elements = []\n        \n        # Iterate over the elements of the current tuple\n        for element in tup:\n            # Append the current element to the list of current elements\n            current_elements.append(element)\n        \n        # Calculate the sum of the current elements\n        current_sum = sum(current_elements)\n        \n        # Append the sum to the result list\n        result.append((current_sum, current_elements))\n    \n    # Return the result list\n    return result"}
{"id": "460_0", "code": "def find_remainder(arr, lens, n):\n    \"\"\"\n    This function calculates the remainder of array multiplication divided by n.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    lens (int): The length of the input array.\n    n (int): The divisor.\n\n    Returns:\n    int: The remainder of the array multiplication divided by n.\n    \"\"\"\n    # Calculate the product of the array\n    product = 1\n    for num in arr:\n        product *= num\n\n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n\n    return remainder"}
{"id": "461_0", "code": "def check_Consecutive(lst):\n    \"\"\"\n    Checks if the given list contains consecutive numbers.\n\n    Args:\n        lst (list): The input list to be checked.\n\n    Returns:\n        bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    if len(lst) < 2:\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] + 1 != lst[i + 1]:\n            return False\n    return True"}
{"id": "462_0", "code": "def tuple_intersection(test_list1, test_list2):\n    \"\"\"\n    This function finds the tuple intersection of elements in the given tuple list \n    irrespective of their order.\n\n    Args:\n        test_list1 (list): The first tuple list.\n        test_list2 (list): The second tuple list.\n\n    Returns:\n        list: A list of tuples that are common to both input lists.\n    \"\"\"\n    # Convert the input lists to sets for efficient lookup\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the intersection back to a list of tuples\n    intersection_list = list(intersection)\n\n    return intersection_list"}
{"id": "463_0", "code": "def replace_char(str1,ch,newch):\n    \"\"\"\n    Replace characters in a string.\n\n    Args:\n        str1 (str): The original string.\n        ch (str): The character to be replaced.\n        newch (str): The character to replace with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return str1.replace(ch, newch)"}
{"id": "464_0", "code": "def sort_counter(dict1):\n    # Sort the dictionary by value\n    sorted_dict = dict1.copy()\n    sorted_dict = dict(sorted(sorted_dict.items(), key=lambda item: item[1], reverse=True))\n    return sorted_dict"}
{"id": "465_0", "code": "def big_sum(nums):\n    \"\"\"\n    This function calculates the sum of the largest and smallest value in a given array.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    return max(nums) + min(nums)"}
{"id": "466_0", "code": "def is_lower(string):\n    return string.lower()"}
{"id": "467_0", "code": "def remove_lowercase(str1):\n    \"\"\"\n    This function removes all lowercase substrings from a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with all lowercase substrings removed.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over the input string\n    for i in range(len(str1)):\n        # Check if the current character is not lowercase\n        if str1[i].isupper():\n            # If it's not lowercase, append it to the result\n            result += str1[i]\n\n    # Return the result\n    return result"}
{"id": "468_0", "code": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    # Convert the number to a string\n    str_n = str(n)\n    \n    # Check if the number is less than 10\n    if n < 10:\n        # Return the first character of the string\n        return str_n[0]\n    else:\n        # Return the first digit of the number\n        return int(str_n[0])"}
{"id": "469_0", "code": "def get_max_occuring_char(str1):\n    \"\"\"\n    This function finds the maximum occurring character in a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The maximum occurring character in the string.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the maximum frequency\n    max_frequency = max(char_frequency.values())\n    \n    # Find the character with the maximum frequency\n    max_char = [char for char, freq in char_frequency.items() if freq == max_frequency]\n    \n    # Return the character with the maximum frequency\n    return max_char[0]"}
{"id": "470_0", "code": "def is_subset_sum(set, n, sum):\n    dp = [False] * (sum + 1)\n    dp[0] = True\n    for num in set:\n        for i in range(sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[sum]"}
{"id": "471_0", "code": "import re\n\ndef match(text):\n    pattern = r\"([A-Z])([a-z]+)\"\n    matches = re.findall(pattern, text)\n    return matches"}
{"id": "472_0", "code": "import math\n\ndef first_Factorial_Divisible_Number(x):\n    \"\"\"\n    Find the first natural number whose factorial is divisible by x.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        int: The first natural number whose factorial is divisible by x.\n    \"\"\"\n    i = 1\n    while True:\n        factorial = math.factorial(i)\n        if factorial % x == 0:\n            return i\n        i += 1"}
{"id": "473_0", "code": "def remove_matching_tuple(test_list1, test_list2):\n    \"\"\"\n    Removes matching tuples from two lists.\n\n    Args:\n        test_list1 (list): The first list.\n        test_list2 (list): The second list.\n\n    Returns:\n        list: The modified list with matching tuples removed.\n    \"\"\"\n    # Convert the lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n\n    # Use set difference to remove matching tuples\n    result = set1 - set2\n\n    # Convert the result back to a list\n    result = list(result)\n\n    return result"}
{"id": "474_0", "code": "def largest_palindrome(A, n):\n    \"\"\"\n    This function generates the largest palindromic number in the given array.\n\n    Parameters:\n    A (list): The input list of numbers.\n    n (int): The length of the input list.\n\n    Returns:\n    int: The largest palindromic number in the given array.\n    \"\"\"\n    # Initialize the maximum palindromic number\n    max_palindrome = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Check if the current number is a palindrome\n        if is_palindrome(A[i]):\n            # Update the maximum palindromic number\n            max_palindrome = max(max_palindrome, A[i])\n\n    # Return the maximum palindromic number\n    return max_palindrome\n\ndef is_palindrome(num):\n    \"\"\"\n    This function checks if a given number is a palindrome.\n\n    Parameters:\n    num (int): The input number.\n\n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    # Convert the number to a string\n    str_num = str(num)\n\n    # Compare the string with its reverse\n    return str_num == str_num[::-1]\n\n# Example usage\nA = [1, 2, 3, 4, 5]\nn = len(A)\nprint(largest_palindrome(A, n))  # Output: 5"}
{"id": "475_0", "code": "import math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Compute the binomial probability for the given number.\n\n    Parameters:\n    n (int): The total number of trials.\n    k (int): The number of successful trials.\n    p (float): The probability of success in each trial.\n\n    Returns:\n    float: The binomial probability.\n    \"\"\"\n    # Check if n is greater than k\n    if n < k:\n        raise ValueError(\"n must be greater than or equal to k\")\n\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n\n    # Calculate the probability\n    probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))\n\n    return probability"}
{"id": "476_0", "code": "def sort_tuple(tup):\n    return tuple(sorted(tup, key=lambda x: x[-1]))"}
{"id": "477_0", "code": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The area of the pentagon.\n    \"\"\"\n    # Calculate the area using the Shoelace formula\n    area = 0.5 * abs(a * (4 * math.sin(math.pi / 5) + 4 * math.sin(2 * math.pi / 5) + 4 * math.sin(3 * math.pi / 5) + math.sin(4 * math.pi / 5)))\n    return area"}
{"id": "478_0", "code": "def frequency_Of_Largest(n,arr):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Initialize the maximum frequency and the largest value\n    max_freq = 0\n    max_val = arr[0]\n    \n    # Iterate through the array to find the frequency of the largest value\n    for i in range(1, n):\n        if arr[i] == max_val:\n            max_freq += 1\n        else:\n            max_val = arr[i]\n            max_freq = 1\n    \n    return max_freq, max_val"}
{"id": "479_0", "code": "def extract_symmetric(test_list):\n    \"\"\"\n    Extract all symmetric pairs from a given tuple list.\n\n    Args:\n        test_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples containing symmetric pairs.\n    \"\"\"\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs"}
{"id": "480_0", "code": "def sum_gp(a, n, r):\n    \"\"\"\n    Calculate the sum of a geometric progression series.\n\n    Parameters:\n    a (float): The first term of the series.\n    n (int): The number of terms in the series.\n    r (float): The common ratio of the series.\n\n    Returns:\n    float: The sum of the geometric progression series.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"}
{"id": "481_0", "code": "def binary_search(item_list, item):\n    low = 0\n    high = len(item_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"id": "482_0", "code": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    \"\"\"\n    Calculate a grid of hexagon coordinates.\n\n    Args:\n        startx (float): The x-coordinate of the starting point.\n        starty (float): The y-coordinate of the starting point.\n        endx (float): The x-coordinate of the ending point.\n        endy (float): The y-coordinate of the ending point.\n        radius (float): The radius of the hexagon.\n\n    Returns:\n        list of lists: A list of lists containing 6 tuples of x, y point coordinates.\n    \"\"\"\n    # Calculate the angle between the start and end points\n    angle = math.atan2(endy - starty, endx - startx)\n\n    # Calculate the number of hexagons\n    num_hexagons = int((endx - startx) / radius)\n\n    # Initialize the list of hexagons\n    hexagons = []\n\n    # Loop through the number of hexagons\n    for i in range(num_hexagons):\n        # Calculate the x and y coordinates of the current hexagon\n        x = startx + i * radius * math.cos(angle + i * math.pi / 3)\n        y = starty + i * radius * math.sin(angle + i * math.pi / 3)\n\n        # Add the hexagon coordinates to the list\n        hexagons.append([x, y])\n\n    return hexagons"}
{"id": "483_0", "code": "def binary_to_integer(test_tup):\n    \"\"\"\n    Convert a binary tuple to an integer.\n\n    Args:\n        test_tup (tuple): A binary tuple.\n\n    Returns:\n        int: The integer equivalent of the binary tuple.\n\n    Raises:\n        ValueError: If the input tuple is not a binary tuple.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        raise ValueError(\"Input must be a tuple\")\n\n    # Check if the tuple contains only binary digits\n    if not all(bit in '01' for bit in test_tup):\n        raise ValueError(\"Input tuple must contain only binary digits\")\n\n    # Convert the tuple to an integer\n    return int(''.join(test_tup), 2)"}
{"id": "484_0", "code": "import re\n\ndef remove_lowercase(str1):\n    # Define the regex pattern to match lowercase substrings\n    pattern = r'(?:[a-z]+)'\n    # Use the regex to replace all occurrences of lowercase substrings\n    result = re.sub(pattern, '', str1)\n    return result"}
{"id": "485_0", "code": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    This function generates the smallest integers from a given list of numbers using heap queue algorithm.\n\n    Args:\n    nums (list): A list of integers.\n    n (int): The number of smallest integers to generate.\n\n    Returns:\n    list: A list of the smallest integers from the input list.\n    \"\"\"\n    # Check if the input list is empty\n    if not nums:\n        return []\n\n    # Create a min heap\n    min_heap = []\n\n    # Push the first 'n' elements of the list into the min heap\n    for i in range(n):\n        heapq.heappush(min_heap, nums[i])\n\n    # Pop the smallest element from the min heap 'n' times\n    smallest = []\n    for _ in range(n):\n        smallest.append(heapq.heappop(min_heap))\n\n    return smallest"}
{"id": "486_0", "code": "import math\n\ndef surfacearea_cone(r, h):\n    \"\"\"\n    Calculate the surface area of a cone.\n\n    Parameters:\n    r (float): The radius of the base of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The surface area of the cone.\n    \"\"\"\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r**2 + h**2)\n\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n\n    return surface_area\n\n# Example usage:\nprint(surfacearea_cone(5, 10))"}
{"id": "487_0", "code": "import math\n\ndef gcd(x, y):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two positive integers.\n\n    Args:\n        x (int): The first positive integer.\n        y (int): The second positive integer.\n\n    Returns:\n        int: The greatest common divisor of x and y.\n    \"\"\"\n    # Ensure x is greater than y\n    if x > y:\n        x, y = y, x\n\n    # Use the Euclidean algorithm to find the GCD\n    while y:\n        x, y = y, x % y\n\n    return x"}
{"id": "488_0", "code": "import math\n\ndef diameter_circle(r):\n    \"\"\"\n    Calculate the diameter of a circle given its radius.\n\n    Args:\n        r (float): The radius of the circle.\n\n    Returns:\n        float: The diameter of the circle.\n    \"\"\"\n    # Check if the radius is negative\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    # Calculate the diameter using the formula: diameter = 2 * radius\n    diameter = 2 * r\n\n    return diameter"}
{"id": "489_0", "code": "def concatenate_elements(lst):\n    \"\"\"\n    Concatenates all elements of the given list into a string.\n\n    Args:\n        lst (list): The list of elements to be concatenated.\n\n    Returns:\n        str: A string containing all elements of the input list.\n    \"\"\"\n    return ''.join(map(str, lst))"}
{"id": "490_0", "code": "def num_comm_div(x,y):\n    def gcd(a,b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n    return gcd(x,y)"}
{"id": "491_0", "code": "def find(n, m):\n    \"\"\"\n    This function calculates the remainder of two numbers.\n\n    Args:\n        n (int): The dividend.\n        m (int): The divisor.\n\n    Returns:\n        int: The remainder of n divided by m.\n    \"\"\"\n    if m == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return n % m"}
{"id": "492_0", "code": "def add_consecutive_nums(nums):\n    \"\"\"\n    This function adds consecutive numbers of a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of numbers with consecutive additions.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(nums[i] + nums[i-1])\n    return result"}
{"id": "493_0", "code": "def sum_of_series(n):\n    \"\"\"\n    Calculate the sum of the first n natural numbers cubed.\n\n    Args:\n        n (int): The number of natural numbers to sum.\n\n    Returns:\n        int: The sum of the first n natural numbers cubed.\n    \"\"\"\n    return sum(i**3 for i in range(1, n+1))"}
{"id": "494_0", "code": "def re_order(A):\n    \"\"\"\n    Reorders the array A such that all zeroes are moved to the end.\n\n    Args:\n        A (list): The input array.\n\n    Returns:\n        list: The reordered array.\n    \"\"\"\n    # Separate non-zero elements from zeroes\n    non_zero = [x for x in A if x != 0]\n    zeroes = [x for x in A if x == 0]\n\n    # Combine non-zero elements and zeroes\n    result = non_zero + zeroes\n\n    return result"}
{"id": "495_0", "code": "import math\n\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient of given p(n, k)\n    \n    Parameters:\n    n (int): The total number of items\n    k (int): The number of items to choose\n    \n    Returns:\n    float: The permutation coefficient\n    \"\"\"\n    # Calculate the permutation coefficient using the formula\n    coefficient = math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n    return coefficient\n\n# Example usage:\nn = 10  # Total number of items\nk = 3   # Number of items to choose\nprint(permutation_coefficient(n, k))"}
{"id": "496_0", "code": "def remove_words(list1, removewords):\n    \"\"\"\n    Removes specific words from a given list.\n\n    Args:\n        list1 (list): The original list of words.\n        removewords (list): The list of words to be removed.\n\n    Returns:\n        list: The modified list with the specified words removed.\n    \"\"\"\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    # Convert the removewords list to a set for efficient lookups\n    set2 = set(removewords)\n    # Use set difference to remove words from the original list\n    modified_list = [word for word in list1 if word not in set2]\n    return modified_list"}
{"id": "497_0", "code": "def same_order(l1, l2):\n    \"\"\"\n    Checks if the common elements between two lists are in the same order.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n\n    Returns:\n        bool: True if the common elements are in the same order, False otherwise.\n    \"\"\"\n    # Convert the lists to sets for efficient lookups\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Check if the sets are equal\n    return set1 == set2"}
{"id": "498_0", "code": "def average_Odd(n):\n    \"\"\"\n    Calculate the average of odd numbers till a given odd number.\n\n    Args:\n        n (int): The given odd number.\n\n    Returns:\n        float: The average of odd numbers till n.\n    \"\"\"\n    # Initialize the sum of odd numbers\n    sum_odd = 0\n\n    # Initialize the count of odd numbers\n    count_odd = 0\n\n    # Loop till n\n    while n > 0:\n        # Check if n is odd\n        if n % 2 != 0:\n            # Add n to the sum of odd numbers\n            sum_odd += n\n            # Increment the count of odd numbers\n            count_odd += 1\n        # Decrement n\n        n -= 1\n\n    # Check if there are any odd numbers\n    if count_odd == 0:\n        # Return 0 if there are no odd numbers\n        return 0\n    else:\n        # Return the average of odd numbers\n        return sum_odd / count_odd"}
{"id": "499_0", "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            if arr[j] * arr[i] < k:\n                dp[i] += dp[j]\n    return dp[n]"}
